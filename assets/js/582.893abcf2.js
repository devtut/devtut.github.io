(window.webpackJsonp=window.webpackJsonp||[]).push([[582],{990:function(e,t,a){"use strict";a.r(t);var r=a(31),v=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"literals-for-numbers-characters-and-strings"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#literals-for-numbers-characters-and-strings"}},[e._v("#")]),e._v(" Literals for numbers, characters and strings")]),e._v(" "),a("h2",{attrs:{id:"floating-point-literals"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#floating-point-literals"}},[e._v("#")]),e._v(" Floating point literals")]),e._v(" "),a("p",[e._v("Floating point literals are used to represent signed real numbers. The following suffixes can be used to specify type of a literal:")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("Suffix")]),e._v(" "),a("th",[e._v("Type")]),e._v(" "),a("th",[e._v("Examples")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("none")]),e._v(" "),a("td",[a("code",[e._v("double")])]),e._v(" "),a("td",[a("code",[e._v("3.1415926")]),e._v(" "),a("code",[e._v("-3E6")])])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("f")]),e._v(", "),a("code",[e._v("F")])]),e._v(" "),a("td",[a("code",[e._v("float")])]),e._v(" "),a("td",[a("code",[e._v("3.1415926f")]),e._v(" "),a("code",[e._v("2.1E-6F")])])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("l")]),e._v(", "),a("code",[e._v("L")])]),e._v(" "),a("td",[a("code",[e._v("long double")])]),e._v(" "),a("td",[a("code",[e._v("3.1415926L")]),e._v(" "),a("code",[e._v("1E126L")])])])])]),e._v(" "),a("p",[e._v("In order to use these suffixes, the literal "),a("strong",[e._v("must")]),e._v(" be a floating point literal. For example, "),a("code",[e._v("3f")]),e._v(" is an error, since "),a("code",[e._v("3")]),e._v(" is an integer literal, while "),a("code",[e._v("3.f")]),e._v(" or "),a("code",[e._v("3.0f")]),e._v(" are correct. For "),a("code",[e._v("long double")]),e._v(", the recommendation is to always use capital "),a("code",[e._v("L")]),e._v(" for the sake of readability.")]),e._v(" "),a("h2",{attrs:{id:"integer-literals"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#integer-literals"}},[e._v("#")]),e._v(" Integer literals")]),e._v(" "),a("p",[e._v("Integer literals are used to provide integral values. Three numerical bases are supported, indicated by prefixes:")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("Base")]),e._v(" "),a("th",[e._v("Prefix")]),e._v(" "),a("th",[e._v("Example")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("Decimal")]),e._v(" "),a("td",[e._v("None")]),e._v(" "),a("td",[a("code",[e._v("5")])])]),e._v(" "),a("tr",[a("td",[e._v("Octal")]),e._v(" "),a("td",[a("code",[e._v("0")])]),e._v(" "),a("td",[a("code",[e._v("0345")])])]),e._v(" "),a("tr",[a("td",[e._v("Hexadecimal")]),e._v(" "),a("td",[a("code",[e._v("0x")]),e._v(" or "),a("code",[e._v("0X")])]),e._v(" "),a("td",[a("code",[e._v("0x12AB")]),e._v(", "),a("code",[e._v("0X12AB")]),e._v(", "),a("code",[e._v("0x12ab")]),e._v(", "),a("code",[e._v("0x12Ab")])])])])]),e._v(" "),a("p",[e._v("Note that this writing doesn't include any sign, so integer literals are always positive. Something like "),a("code",[e._v("-1")]),e._v(" is treated as an expression that has one integer literal ("),a("code",[e._v("1")]),e._v(") that is negated with a "),a("code",[e._v("-")])]),e._v(" "),a("p",[e._v("The type of a decimal integer literal is the first data type that can fit the value from "),a("code",[e._v("int")]),e._v(" and "),a("code",[e._v("long")]),e._v(". Since C99, "),a("code",[e._v("long long")]),e._v(" is also supported for very large literals.")]),e._v(" "),a("p",[e._v("The type of an octal or hexadecimal integer literal is the first data type that can fit the value from "),a("code",[e._v("int")]),e._v(", "),a("code",[e._v("unsigned")]),e._v(", "),a("code",[e._v("long")]),e._v(", and "),a("code",[e._v("unsigned long")]),e._v(". Since C99, "),a("code",[e._v("long long")]),e._v(" and "),a("code",[e._v("unsigned long long")]),e._v(" are also supported for very large literals.")]),e._v(" "),a("p",[e._v("Using various suffixes, the default type of a literal can be changed.")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("Suffix")]),e._v(" "),a("th",[e._v("Explanation")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[a("code",[e._v("L")]),e._v(", "),a("code",[e._v("l")])]),e._v(" "),a("td",[a("code",[e._v("long int")])])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("LL")]),e._v(", "),a("code",[e._v("ll")]),e._v(" (since C99)")]),e._v(" "),a("td",[a("code",[e._v("long long int")])])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("U")]),e._v(", "),a("code",[e._v("u")])]),e._v(" "),a("td",[a("code",[e._v("unsigned")])])])])]),e._v(" "),a("p",[e._v("The U and L/LL suffixes can be combined in any order and case. It is an error to duplicate suffixes (e.g. provide two "),a("code",[e._v("U")]),e._v(" suffixes) even if they have different cases.")]),e._v(" "),a("h2",{attrs:{id:"string-literals"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string-literals"}},[e._v("#")]),e._v(" String literals")]),e._v(" "),a("p",[e._v("String literals are used to specify arrays of characters. They are sequences of characters enclosed within double quotes (e.g. "),a("code",[e._v('"abcd"')]),e._v(" and have the type "),a("code",[e._v("char*")]),e._v(").")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("L")]),e._v(" prefix makes the literal a wide character array, of type "),a("code",[e._v("wchar_t*")]),e._v(". For example, "),a("code",[e._v('L"abcd"')]),e._v(".")]),e._v(" "),a("p",[e._v("Since C11, there are other encoding prefixes, similar to "),a("code",[e._v("L")]),e._v(":")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("prefix")]),e._v(" "),a("th",[e._v("base type")]),e._v(" "),a("th",[e._v("encoding")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("none")]),e._v(" "),a("td",[a("code",[e._v("char")])]),e._v(" "),a("td",[e._v("platform dependent")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("L")])]),e._v(" "),a("td",[a("code",[e._v("wchar_t")])]),e._v(" "),a("td",[e._v("platform dependent")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("u8")])]),e._v(" "),a("td",[a("code",[e._v("char")])]),e._v(" "),a("td",[e._v("UTF-8")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("u")])]),e._v(" "),a("td",[a("code",[e._v("char16_t")])]),e._v(" "),a("td",[e._v("usually UTF-16")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("U")])]),e._v(" "),a("td",[a("code",[e._v("char32_t")])]),e._v(" "),a("td",[e._v("usually UTF-32")])])])]),e._v(" "),a("p",[e._v("For the latter two, it can be queried with feature test macros if the encoding is effectively the corresponding UTF encoding.")]),e._v(" "),a("h2",{attrs:{id:"character-literals"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#character-literals"}},[e._v("#")]),e._v(" Character literals")]),e._v(" "),a("p",[e._v("Character literals are a special type of integer literals that are used to represent one character. They are enclosed in single quotes, e.g. "),a("code",[e._v("'a'")]),e._v(" and have the type "),a("code",[e._v("int")]),e._v(". The value of the literal is an integer value according to the machine's character set. They do not allow suffixes.")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("L")]),e._v(" prefix before a character literal makes it a wide character of type "),a("code",[e._v("wchar_t")]),e._v(". Likewise since C11 "),a("code",[e._v("u")]),e._v(" and "),a("code",[e._v("U")]),e._v(" prefixes make it wide characters of type "),a("code",[e._v("char16_t")]),e._v(" and "),a("code",[e._v("char32_t")]),e._v(", respectively.")]),e._v(" "),a("p",[e._v("When intending to represent certain special characters, such as a character that is non-printing, escape sequences are used. Escape sequences use a sequence of characters that are translated into another character. All escape sequences consist of two or more characters, the first of which is a backslash "),a("code",[e._v("\\")]),e._v(". The characters immediately following the backslash determine what character literal the sequence is interpreted as.")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("Escape Sequence")]),e._v(" "),a("th",[e._v("Represented Character")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[a("code",[e._v("\\b")])]),e._v(" "),a("td",[e._v("Backspace")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("\\f")])]),e._v(" "),a("td",[e._v("Form feed")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("\\n")])]),e._v(" "),a("td",[e._v("Line feed (new line)")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("\\r")])]),e._v(" "),a("td",[e._v("Carriage return")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("\\t")])]),e._v(" "),a("td",[e._v("Horizontal tab")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("\\v")])]),e._v(" "),a("td",[e._v("Vertical tab")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("\\\\")])]),e._v(" "),a("td",[e._v("Backslash")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("\\'")])]),e._v(" "),a("td",[e._v("Single quotation mark")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v('\\"')])]),e._v(" "),a("td",[e._v("Double quotation mark")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("\\?")])]),e._v(" "),a("td",[e._v("Question mark")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("\\nnn")])]),e._v(" "),a("td",[e._v("Octal value")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("\\xnn")]),e._v("...")]),e._v(" "),a("td",[e._v("Hexadecimal value")])])])]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("Escape Sequence")]),e._v(" "),a("th",[e._v("Represented Character")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[a("code",[e._v("\\a")])]),e._v(" "),a("td",[e._v("Alert (beep, bell)")])])])]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("Escape Sequence")]),e._v(" "),a("th",[e._v("Represented Character")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[a("code",[e._v("\\unnnn")])]),e._v(" "),a("td",[e._v("Universal character name")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("\\Unnnnnnnn")])]),e._v(" "),a("td",[e._v("Universal character name")])])])]),e._v(" "),a("p",[e._v("A universal character name is a Unicode code point. A universal character name may map to more than one character. The digits "),a("code",[e._v("n")]),e._v(" are interpreted as hexadecimal digits. Depending on the UTF encoding in use, a universal character name sequence may result in a code point that consists of multiple characters, instead of a single normal "),a("code",[e._v("char")]),e._v(" character.")]),e._v(" "),a("p",[e._v("When using the line feed escape sequence in text mode I/O, it is converted to the OS-specific newline byte or byte sequence.")]),e._v(" "),a("p",[e._v("The question mark escape sequence is used to avoid "),a("a",{attrs:{href:"http://stackoverflow.com/documentation/c/7111/multi-character-character-sequence/23858/trigraphs#t=201701231206445520346",target:"_blank",rel:"noopener noreferrer"}},[e._v("trigraphs"),a("OutboundLink")],1),e._v(". For example, "),a("code",[e._v("??/")]),e._v(" is compiled as the trigraph representing a backslash character "),a("code",[e._v("'\\'")]),e._v(", but using "),a("code",[e._v("?\\?/")]),e._v(" would result in the "),a("strong",[a("a",{attrs:{href:"http://stackoverflow.com/documentation/c/1990/strings#t=201701231207186587708",target:"_blank",rel:"noopener noreferrer"}},[e._v("string"),a("OutboundLink")],1)]),e._v(" "),a("code",[e._v('"??/"')]),e._v(".")]),e._v(" "),a("p",[e._v("There may be  one, two or three octal numerals "),a("code",[e._v("n")]),e._v(" in the octal value escape sequence.")]),e._v(" "),a("h4",{attrs:{id:"remarks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#remarks"}},[e._v("#")]),e._v(" Remarks")]),e._v(" "),a("p",[e._v("The term "),a("strong",[e._v("literal")]),e._v(" is commonly used to describe a sequence of characters in a C code that designates a constant value such as a number (e.g. "),a("code",[e._v("0")]),e._v(") or a string (e.g. "),a("code",[e._v('"C"')]),e._v(").  Strictly speaking, the standard uses the term "),a("strong",[e._v("constant")]),e._v(" for integer constants, floating constants, enumeration constants and character constants, reserving the term 'literal' for string literals, but this is not common usage.")]),e._v(" "),a("p",[e._v("Literals can have "),a("strong",[e._v("prefixes")]),e._v(" or "),a("strong",[e._v("suffixes")]),e._v(" (but not both) which are extra characters that can start or end a literal to change its default type or its representation.")])])}),[],!1,null,null,null);t.default=v.exports}}]);