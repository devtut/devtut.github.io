(window.webpackJsonp=window.webpackJsonp||[]).push([[592],{938:function(t,a,n){"use strict";n.r(a);var s=n(19),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"signal-handling"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#signal-handling"}},[t._v("#")]),t._v(" Signal handling")]),t._v(" "),n("h2",{attrs:{id:"signal-handling-with-signal"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#signal-handling-with-signal"}},[t._v("#")]),t._v(" Signal Handling with “signal()”")]),t._v(" "),n("p",[n("a",{attrs:{href:"https://en.wikipedia.org/wiki/C_signal_handling#Standard_signals",target:"_blank",rel:"noopener noreferrer"}},[t._v("Signal numbers"),n("OutboundLink")],1),t._v(" can be synchronous (like "),n("code",[t._v("SIGSEGV")]),t._v(" – segmentation fault) when they are triggered by a malfunctioning of the program itself or asynchronous (like "),n("code",[t._v("SIGINT")]),t._v(" - interactive attention) when they are initiated from outside the program, e.g by a keypress as "),n("code",[t._v("Cntrl-C")]),t._v(".")]),t._v(" "),n("p",[t._v("The "),n("code",[t._v("signal()")]),t._v(" function is part of the ISO C standard and can be used to assign a function to handle a specific signal")]),t._v(" "),n("div",{staticClass:"language-c extra-class"},[n("pre",{pre:!0,attrs:{class:"language-c"}},[n("code",[n("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),n("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdio.h>")]),t._v("  ")]),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* printf() */")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),n("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdlib.h>")]),t._v(" ")]),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* abort()  */")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),n("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v("<signal.h>")]),t._v(" ")]),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* signal() */")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("handler_nonportable")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" sig"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* undefined behavior, maybe fine on specific platform */")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Catched: %d\\n"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" sig"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    \n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* abort is safe to call */")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("abort")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\nsig_atomic_t "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" finished "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("handler")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" sig"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("switch")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("sig"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* hardware interrupts should not return */")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("case")]),t._v(" SIGSEGV"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("case")]),t._v(" SIGFPE"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("case")]),t._v(" SIGILL"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n\n")])])]),n("div",{staticClass:"language-c extra-class"},[n("pre",{pre:!0,attrs:{class:"language-c"}},[n("code",[t._v("      "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* quick_exit is safe to call */")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("quick_exit")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("EXIT_FAILURE"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),n("div",{staticClass:"language-c extra-class"},[n("pre",{pre:!0,attrs:{class:"language-c"}},[n("code",[t._v("      "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* use _Exit in pre-C11 */")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("_Exit")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("EXIT_FAILURE"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),n("div",{staticClass:"language-c extra-class"},[n("pre",{pre:!0,attrs:{class:"language-c"}},[n("code",[t._v("    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n       "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Reset the signal to the default handler, \n          so we will not be called again if things go\n          wrong on return. */")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("signal")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("sig"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" SIG_DFL"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* let everybody know that we are finished */")]),t._v("\n      finished "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" sig"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n   "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Catch the SIGSEGV signal, raised on segmentation faults (i.e NULL ptr access */")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("signal")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("SIGSEGV"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("handler"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" SIG_ERR"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("perror")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"could not establish handler for SIGSEGV"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" EXIT_FAILURE"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Catch the SIGTERM signal, termination request */")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("signal")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("SIGTERM"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("handler"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" SIG_ERR"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("perror")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"could not establish handler for SIGTERM"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" EXIT_FAILURE"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Ignore the SIGINT signal, by setting the handler to `SIG_IGN`. */")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("signal")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("SIGINT"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" SIG_IGN"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Do something that takes some time here, and leaves\n       the time to terminate the program from the keyboard. */")]),t._v("\n\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Then: */")]),t._v("\n\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("finished"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n       "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("fprintf")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token constant"}},[t._v("stderr")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"we have been terminated by signal %d\\n"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("finished"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" EXIT_FAILURE"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Try to force a segmentation fault, and raise a SIGSEGV */")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" ptr "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n      "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("ptr "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* This should never be executed */")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" EXIT_SUCCESS"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),n("p",[t._v("Using "),n("code",[t._v("signal()")]),t._v(" imposes important limitations what you are allowed to do inside the signal handlers, see the remarks for further information.")]),t._v(" "),n("p",[n("a",{attrs:{href:"http://stackoverflow.com/documentation/posix/4532/signals#t=201608081940432865722",target:"_blank",rel:"noopener noreferrer"}},[t._v("POSIX"),n("OutboundLink")],1),t._v(" recommends the usage of "),n("code",[t._v("sigaction()")]),t._v(" instead of "),n("code",[t._v("signal()")]),t._v(", due to its underspecified behavior and significant implementation variations. POSIX also defines "),n("a",{attrs:{href:"https://en.wikipedia.org/wiki/Unix_signal#POSIX_signals",target:"_blank",rel:"noopener noreferrer"}},[t._v("many more signals"),n("OutboundLink")],1),t._v(" than ISO C standard, including "),n("code",[t._v("SIGUSR1")]),t._v(" and "),n("code",[t._v("SIGUSR2")]),t._v(", which can be used freely by the programmer for any purpose.")]),t._v(" "),n("h4",{attrs:{id:"syntax"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#syntax"}},[t._v("#")]),t._v(" Syntax")]),t._v(" "),n("ul",[n("li",[t._v("void (*signal(int sig, void (*func)(int)))(int);")])]),t._v(" "),n("h4",{attrs:{id:"parameters"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#parameters"}},[t._v("#")]),t._v(" Parameters")]),t._v(" "),n("table",[n("thead",[n("tr",[n("th",[t._v("Parameter")]),t._v(" "),n("th",[t._v("Details")])])]),t._v(" "),n("tbody",[n("tr",[n("td",[t._v("sig")]),t._v(" "),n("td",[t._v("The signal to set the signal handler to, one of "),n("code",[t._v("SIGABRT")]),t._v(", "),n("code",[t._v("SIGFPE")]),t._v(", "),n("code",[t._v("SIGILL")]),t._v(", "),n("code",[t._v("SIGTERM")]),t._v(", "),n("code",[t._v("SIGINT")]),t._v(", "),n("code",[t._v("SIGSEGV")]),t._v(" or some implementation defined value")])]),t._v(" "),n("tr",[n("td",[t._v("func")]),t._v(" "),n("td",[t._v("The signal handler, which is either of the following: "),n("code",[t._v("SIG_DFL")]),t._v(", for the default handler, "),n("code",[t._v("SIG_IGN")]),t._v(" to ignore the signal, or a function pointer with the signature "),n("code",[t._v("void foo(int sig);")]),t._v(".")])])])]),t._v(" "),n("h4",{attrs:{id:"remarks"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#remarks"}},[t._v("#")]),t._v(" Remarks")]),t._v(" "),n("p",[t._v("The usage of signal handlers with only the guarantees from the C standard imposes various limitations what can, or can't be done in the user defined signal handler.")]),t._v(" "),n("li",[t._v("\nIf the user defined function returns while handling `SIGSEGV`, `SIGFPE`, `SIGILL` or any other implementation-defined hardware interrupt, the behavior is undefined by the C standard. This is because C's interface doesn't give means to change the faulty state (e.g after a division by `0`) and thus when returning the program is in exactly the same erroneous state than before the hardware interrupt occurred.\n")]),t._v(" "),n("li",[t._v("\nIf the user defined function was called as the result of a call to `abort`, or `raise`, the signal handler is not allowed to call `raise`, again.\n")]),t._v(" "),n("li",[t._v("\nSignals can arrive in the middle of any operation, and therefore the indivisibility of operations can in generally not be guaranteed nor does signal handling work well with optimization. Therefore all modifications to data in a signal handler must be to variables\n"),n("ul",[t._v("\n- of type `sig_atomic_t` (all versions) or a lock-free atomic type (since C11, optional)\n- that are `volatile` qualified.\n"),n("p",[t._v("Other functions from the C standard library will usually not respect these restrictions, because they may change variables in the global state of the program. The C standard only makes guarantees for "),n("code",[t._v("abort")]),t._v(", "),n("code",[t._v("_Exit")]),t._v(" (since C99), "),n("code",[t._v("quick_exit")]),t._v(" (since C11), "),n("code",[t._v("signal")]),t._v(" (for the same signal number), and some atomic operations (since C11).")]),t._v(" "),n("p",[t._v("Behavior is undefined by the C standard if any of the rules above are violated. Platforms may have specific extensions, but these are generally not portable beyond that platform.")]),t._v(" "),n("li",[t._v("\nUsually systems have their own list of functions that are **asynchronous signal safe**, that is of C library functions that can be used from a signal handler. E.g often `printf` is among these function.\n")]),t._v(" "),n("li",[t._v("\nIn particular the C standard doesn't define much about the interaction with its threads interface (since C11) or any platform specific thread libraries such as POSIX threads. Such platforms have to specify the interaction of such thread libraries with signals by themselves.\n")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);