(window.webpackJsonp=window.webpackJsonp||[]).push([[1135],{1543:function(e,t,s){"use strict";s.r(t);var a=s(31),o=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"hooks"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hooks"}},[e._v("#")]),e._v(" Hooks")]),e._v(" "),s("h2",{attrs:{id:"pre-push"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pre-push"}},[e._v("#")]),e._v(" Pre-push")]),e._v(" "),s("p",[s("strong",[e._v("Available in "),s("a",{attrs:{href:"https://github.com/git/git/blob/master/Documentation/RelNotes/1.8.2.txt",target:"_blank",rel:"noopener noreferrer"}},[e._v("Git 1.8.2"),s("OutboundLink")],1),e._v(" and above.")])]),e._v(" "),s("p",[e._v("Pre-push hooks can be used to prevent a push from going though. Reasons this is helpful include: blocking accidental manual pushes to specific branches, or blocking pushes if an established check fails (unit tests, syntax).")]),e._v(" "),s("p",[e._v("A pre-push hook is created by simply creating a file named "),s("code",[e._v("pre-push")]),e._v(" under "),s("code",[e._v(".git/hooks/")]),e._v(", and ("),s("strong",[e._v("gotcha alert")]),e._v("), making sure the file is executable: "),s("code",[e._v("chmod +x ./git/hooks/pre-push")]),e._v(".")]),e._v(" "),s("p",[e._v("Here's an example from "),s("a",{attrs:{href:"https://dev.ghost.org/prevent-master-push/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Hannah Wolfe"),s("OutboundLink")],1),e._v(" that blocks a push to master:")]),e._v(" "),s("div",{staticClass:"language-git extra-class"},[s("pre",{pre:!0,attrs:{class:"language-git"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#!/bin/bash")]),e._v("\n\nprotected_branch="),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'master'")]),e._v("  \ncurrent_branch=$(git symbolic-ref HEAD | sed -e "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'s,.*/\\(.*\\),\\1,'")]),e._v(")\n\nif [ $protected_branch = $current_branch ]  \nthen  \n    read -p "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"You\'re about to push master, is that what you intended? [y|n] "')]),e._v(" -n 1 -r < /dev/tty\n    echo\n    if echo $REPLY | grep -E "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'^[Yy]$'")]),e._v(" > /dev/null\n    then\n        exit 0 # push will execute\n    fi\n    exit 1 # push will not execute\nelse  \n    exit 0 # push will execute\nfi  \n\n")])])]),s("p",[e._v("Here's an example from "),s("a",{attrs:{href:"https://coderwall.com/p/k1hbyw/how-to-run-rspec-tests-before-pushing-with-a-git-pre-push-hook",target:"_blank",rel:"noopener noreferrer"}},[e._v("Volkan Unsal"),s("OutboundLink")],1),e._v(" which makes sure RSpec tests pass before allowing the push:")]),e._v(" "),s("div",{staticClass:"language-git extra-class"},[s("pre",{pre:!0,attrs:{class:"language-git"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#!/usr/bin/env ruby")]),e._v("\nrequire "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'pty'")]),e._v("\nhtml_path = "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"rspec_results.html"')]),e._v("\nbegin\n  PTY.spawn( "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"rspec spec --format h > rspec_results.html"')]),e._v(" ) do |stdin, stdout, pid|\n  begin\n    stdin.each { |line| print line }\n  rescue Errno::EIO\n  end\nend\nrescue PTY::ChildExited\n  puts "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Child process exit!"')]),e._v("\nend\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# find out if there were any errors  ")]),e._v("\nhtml = open(html_path).read\nexamples = html.match(/(\\d+) examples/)[0].to_i rescue 0\nerrors = html.match(/(\\d+) errors/)[0].to_i rescue 0\nif errors == 0 then\n  errors = html.match(/(\\d+) failure/)[0].to_i rescue 0\nend\npending = html.match(/(\\d+) pending/)[0].to_i rescue 0\n\nif errors.zero?\n  puts "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"0 failed! #{examples} run, #{pending} pending"')]),e._v("\n  # HTML Output when tests ran successfully:\n  # puts "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"View spec results at #{File.expand_path(html_path)}"')]),e._v("\n  sleep 1\n  exit 0\nelse\n  puts "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"\\aCOMMIT FAILED!!"')]),e._v("\n  puts "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"View your rspec results at #{File.expand_path(html_path)}"')]),e._v("\n  puts\n  puts "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"#{errors} failed! #{examples} run, #{pending} pending"')]),e._v("\n  # Open HTML Ooutput when tests failed\n  # `open #{html_path}`\n  exit 1\nend\n\n")])])]),s("p",[e._v("As you can see, there are lots of possibilities, but the core piece is to "),s("code",[e._v("exit 0")]),e._v(" if good things happened, and "),s("code",[e._v("exit 1")]),e._v(" if bad things happened. Anytime you "),s("code",[e._v("exit 1")]),e._v(" the push will be prevented and your code will be in the state it was before running "),s("code",[e._v("git push...")]),e._v(".")]),e._v(" "),s("p",[e._v('When using client side hooks, keep in mind that users can skip all client side hooks by using the option "--no-verify" on a push.  If you\'re relying on the hook to enforce process, you can get burned.')]),e._v(" "),s("p",[e._v("Documentation: "),s("a",{attrs:{href:"https://git-scm.com/docs/githooks#_pre_push",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://git-scm.com/docs/githooks#_pre_push"),s("OutboundLink")],1),s("br"),e._v("\nOfficial Sample: "),s("a",{attrs:{href:"https://github.com/git/git/blob/87c86dd14abe8db7d00b0df5661ef8cf147a72a3/templates/hooks--pre-push.sample",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/git/git/blob/87c86dd14abe8db7d00b0df5661ef8cf147a72a3/templates/hooks--pre-push.sample"),s("OutboundLink")],1)]),e._v(" "),s("h2",{attrs:{id:"verify-maven-build-or-other-build-system-before-committing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#verify-maven-build-or-other-build-system-before-committing"}},[e._v("#")]),e._v(" Verify Maven build (or other build system) before committing")]),e._v(" "),s("p",[s("code",[e._v(".git/hooks/pre-commit")])]),e._v(" "),s("div",{staticClass:"language-git extra-class"},[s("pre",{pre:!0,attrs:{class:"language-git"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#!/bin/sh")]),e._v("\nif [ -s pom.xml ]; then\n    echo "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Running mvn verify"')]),e._v("\n    mvn clean verify\n    if [ $? -ne 0 ]; then\n        echo "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Maven build failed"')]),e._v("\n        exit 1\n    fi\nfi\n\n")])])]),s("h2",{attrs:{id:"automatically-forward-certain-pushes-to-other-repositories"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#automatically-forward-certain-pushes-to-other-repositories"}},[e._v("#")]),e._v(" Automatically forward certain pushes to other repositories")]),e._v(" "),s("p",[s("code",[e._v("post-receive")]),e._v(" hooks can be used to automatically forward incoming pushes to another repository.")]),e._v(" "),s("div",{staticClass:"language-git extra-class"},[s("pre",{pre:!0,attrs:{class:"language-git"}},[s("code",[e._v("$ cat .git/hooks/post-receive\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#!/bin/bash")]),e._v("\n\nIFS="),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("' '")]),e._v("\nwhile read local_ref local_sha remote_ref remote_sha\ndo\n\n  echo "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"$remote_ref"')]),e._v(" | egrep "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'^refs\\/heads\\/[A-Z]+-[0-9]+$'")]),e._v(" >/dev/null && {\n    ref=`echo $remote_ref | sed -e "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'s/^refs\\/heads\\///'")]),e._v("`\n    echo Forwarding feature branch to other repository: $ref\n    git push -q --force other_repos $ref\n  }\n\ndone\n\n")])])]),s("p",[e._v("In this example, the "),s("code",[e._v("egrep")]),e._v(" regexp looks for a specific branch format (here: JIRA-12345 as used to name Jira issues). You can leave this part off if you want to forward all branches, of course.")]),e._v(" "),s("h2",{attrs:{id:"commit-msg"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#commit-msg"}},[e._v("#")]),e._v(" Commit-msg")]),e._v(" "),s("p",[e._v("This hook is similar to the "),s("code",[e._v("prepare-commit-msg")]),e._v(" hook, but it's called after the user enters a commit message rather than before. This is usually used to warn developers if their commit message is in an incorrect format.")]),e._v(" "),s("p",[e._v("The only argument passed to this hook is the name of the file that contains the message. If you don't like the message that the user has entered, you can either alter this file in-place (same as "),s("code",[e._v("prepare-commit-msg")]),e._v(") or you can abort the commit entirely by exiting with a non-zero status.")]),e._v(" "),s("p",[e._v("The following example is used to check if the word ticket followed by a number is present on the commit message")]),e._v(" "),s("div",{staticClass:"language-git extra-class"},[s("pre",{pre:!0,attrs:{class:"language-git"}},[s("code",[e._v("word="),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"ticket [0-9]"')]),e._v("\nisPresent=$(grep -Eoh "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"$word"')]),e._v(" $1)\n\nif [[ -z $isPresent ]]\n  then echo "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Commit message KO, $word is missing"')]),e._v("; exit 1;\n  else echo "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Commit message OK"')]),e._v("; exit 0;\nfi\n\n")])])]),s("h2",{attrs:{id:"local-hooks"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#local-hooks"}},[e._v("#")]),e._v(" Local hooks")]),e._v(" "),s("p",[e._v("Local hooks affect only the local repositories in which they reside. Each developer can alter their own local hooks, so they can't be used reliably as a way to enforce a commit policy. They are designed to make it easier for developers to adhere to certain guidelines and avoid potential problems down the road.")]),e._v(" "),s("p",[e._v("There are six types of local hooks: pre-commit, prepare-commit-msg, commit-msg, post-commit, post-checkout, and pre-rebase.")]),e._v(" "),s("p",[e._v("The first four hooks relate to commits and allow you to have some control over each part in a commit's life cycle. The final two let you perform some extra actions or safety checks for the git checkout and git rebase commands.")]),e._v(" "),s("p",[e._v('All of the "pre-" hooks let you alter the action that’s about to take place, while the "post-" hooks are used primarily for notifications.')]),e._v(" "),s("h2",{attrs:{id:"post-checkout"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#post-checkout"}},[e._v("#")]),e._v(" Post-checkout")]),e._v(" "),s("p",[e._v("This hook works similarly to the "),s("code",[e._v("post-commit")]),e._v(" hook, but it's called whenever you successfully check out a reference with "),s("code",[e._v("git checkout")]),e._v(". This could be a useful tool for clearing out your working directory of auto-generated files that would otherwise cause confusion.")]),e._v(" "),s("p",[e._v("This hook accepts three parameters:")]),e._v(" "),s("ol",[s("li",[e._v("the ref of the previous HEAD,")]),e._v(" "),s("li",[e._v("the ref of the new HEAD, and")]),e._v(" "),s("li",[e._v("a flag indicating if it was a branch checkout or a file checkout ("),s("code",[e._v("1")]),e._v(" or "),s("code",[e._v("0")]),e._v(", respectively).")])]),e._v(" "),s("p",[e._v("Its exit status has no affect on the "),s("code",[e._v("git checkout")]),e._v(" command.")]),e._v(" "),s("h2",{attrs:{id:"post-commit"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#post-commit"}},[e._v("#")]),e._v(" Post-commit")]),e._v(" "),s("p",[e._v("This hook is called immediately after the "),s("code",[e._v("commit-msg")]),e._v(" hook. It cannot alter the outcome of the "),s("code",[e._v("git commit")]),e._v(" operation, therefore it's used primarily for notification purposes.")]),e._v(" "),s("p",[e._v("The script takes no parameters, and its exit status does not affect the commit in any way.")]),e._v(" "),s("h2",{attrs:{id:"post-receive"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#post-receive"}},[e._v("#")]),e._v(" Post-receive")]),e._v(" "),s("p",[e._v("This hook is called after a successful push operation. It is typically used for notification purposes.")]),e._v(" "),s("p",[e._v("The script takes no parameters, but is sent the same information as "),s("code",[e._v("pre-receive")]),e._v(" via standard input:")]),e._v(" "),s("div",{staticClass:"language-git extra-class"},[s("pre",{pre:!0,attrs:{class:"language-git"}},[s("code",[e._v("<old-value> <new-value> <ref-name>\n\n")])])]),s("h2",{attrs:{id:"pre-commit"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pre-commit"}},[e._v("#")]),e._v(" Pre-commit")]),e._v(" "),s("p",[e._v("This hook is executed every time you run "),s("code",[e._v("git commit")]),e._v(", to verify what is about to be committed. You can use this hook to inspect the snapshot that is about to be committed.")]),e._v(" "),s("p",[e._v("This type of hook is useful for running automated tests to make sure the incoming commit doesn't break existing functionality of your project. This type of hook may also check for whitespace or EOL errors.")]),e._v(" "),s("p",[e._v("No arguments are passed to the pre-commit script, and exiting with a non-zero status aborts the entire commit.")]),e._v(" "),s("h2",{attrs:{id:"prepare-commit-msg"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#prepare-commit-msg"}},[e._v("#")]),e._v(" Prepare-commit-msg")]),e._v(" "),s("p",[e._v("This hook is called after the "),s("code",[e._v("pre-commit")]),e._v(" hook to populate the text editor with a commit message. This is typically used to alter the automatically generated commit messages for squashed or merged commits.")]),e._v(" "),s("p",[e._v("One to three arguments are passed to this hook:")]),e._v(" "),s("ul",[s("li",[e._v("The name of a temporary file that contains the message.\n")]),s("li",[e._v("The type of commit, either\n"),s("ul")]),e._v(" "),s("li",[e._v("message ("),s("code",[e._v("-m")]),e._v(" or "),s("code",[e._v("-F")]),e._v(" option),")]),e._v(" "),s("li",[e._v("template ("),s("code",[e._v("-t")]),e._v(" option),")]),e._v(" "),s("li",[e._v("merge (if it's a merge commit), or")]),e._v(" "),s("li",[e._v("squash (if it's squashing other commits).")])]),e._v(" "),s("p",[e._v("Similar to "),s("code",[e._v("pre-commit")]),e._v(", exiting with a non-zero status aborts the commit.")]),e._v(" "),s("h2",{attrs:{id:"pre-rebase"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pre-rebase"}},[e._v("#")]),e._v(" Pre-rebase")]),e._v(" "),s("p",[e._v("This hook is called before "),s("code",[e._v("git rebase")]),e._v(" begins to alter code structure. This hook is typically used for making sure a rebase operation is appropriate.")]),e._v(" "),s("p",[e._v("This hook takes 2 parameters:")]),e._v(" "),s("ol",[s("li",[e._v("the upstream branch that the series was forked from, and")]),e._v(" "),s("li",[e._v("the branch being rebased (empty when rebasing the current branch).")])]),e._v(" "),s("p",[e._v("You can abort the rebase operation by exiting with a non-zero status.")]),e._v(" "),s("h2",{attrs:{id:"pre-receive"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pre-receive"}},[e._v("#")]),e._v(" Pre-receive")]),e._v(" "),s("p",[e._v("This hook is executed every time somebody uses "),s("code",[e._v("git push")]),e._v(" to push commits to the repository. It always resides in the remote repository that is the destination of the push and not in the originating (local) repository.")]),e._v(" "),s("p",[e._v("The hook runs before any references are updated. It is typically used to enforce any kind of development policy.")]),e._v(" "),s("p",[e._v("The script takes no parameters, but each ref that is being pushed is passed to the script on a separate line on standard input in the following format:")]),e._v(" "),s("div",{staticClass:"language-git extra-class"},[s("pre",{pre:!0,attrs:{class:"language-git"}},[s("code",[e._v("<old-value> <new-value> <ref-name>\n\n")])])]),s("h2",{attrs:{id:"update"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#update"}},[e._v("#")]),e._v(" Update")]),e._v(" "),s("p",[e._v("This hook is called after "),s("code",[e._v("pre-receive")]),e._v(", and it works the same way. It's called before anything is actually updated, but is called separately for each ref that was pushed rather than all of the refs at once.")]),e._v(" "),s("p",[e._v("This hook accepts the following 3 arguments:")]),e._v(" "),s("ul",[s("li",[e._v("name of the ref being updated,")]),e._v(" "),s("li",[e._v("old object name stored in the ref, and")]),e._v(" "),s("li",[e._v("new object name stored in the ref.")])]),e._v(" "),s("p",[e._v("This is the same information passed to "),s("code",[e._v("pre-receive")]),e._v(", but since "),s("code",[e._v("update")]),e._v(" is invoked separately for each ref, you can reject some refs while allowing others.")]),e._v(" "),s("h4",{attrs:{id:"syntax"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#syntax"}},[e._v("#")]),e._v(" Syntax")]),e._v(" "),s("ul",[s("li",[e._v(".git/hooks/applypatch-msg")]),e._v(" "),s("li",[e._v(".git/hooks/commit-msg")]),e._v(" "),s("li",[e._v(".git/hooks/post-update")]),e._v(" "),s("li",[e._v(".git/hooks/pre-applypatch")]),e._v(" "),s("li",[e._v(".git/hooks/pre-commit")]),e._v(" "),s("li",[e._v(".git/hooks/prepare-commit-msg")]),e._v(" "),s("li",[e._v(".git/hooks/pre-push")]),e._v(" "),s("li",[e._v(".git/hooks/pre-rebase")]),e._v(" "),s("li",[e._v(".git/hooks/update")])]),e._v(" "),s("h4",{attrs:{id:"remarks"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#remarks"}},[e._v("#")]),e._v(" Remarks")]),e._v(" "),s("p",[s("code",[e._v("--no-verify")]),e._v(" or "),s("code",[e._v("-n")]),e._v(" to skip all local hooks on the given git command."),s("br"),e._v("\nEg: "),s("code",[e._v("git commit -n")])]),e._v(" "),s("p",[e._v("Information on this page was gathered from the "),s("a",{attrs:{href:"https://git-scm.com/doc",target:"_blank",rel:"noopener noreferrer"}},[e._v("official Git docs"),s("OutboundLink")],1),e._v(" and "),s("a",{attrs:{href:"https://www.atlassian.com/git/tutorials/git-hooks",target:"_blank",rel:"noopener noreferrer"}},[e._v("Atlassian"),s("OutboundLink")],1),e._v(".")])])}),[],!1,null,null,null);t.default=o.exports}}]);