(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{438:function(t,e,a){"use strict";a.r(e);var r=a(31),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"depth-first-search"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#depth-first-search"}},[t._v("#")]),t._v(" Depth First Search")]),t._v(" "),a("h2",{attrs:{id:"introduction-to-depth-first-search"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#introduction-to-depth-first-search"}},[t._v("#")]),t._v(" Introduction To Depth-First Search")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Depth-first_search",target:"_blank",rel:"noopener noreferrer"}},[t._v("Depth-first search"),a("OutboundLink")],1),t._v(" is an algorithm for traversing or searching tree or graph data structures. One starts at the root and explores as far as possible along each branch before backtracking. A version of depth-first search was investigated in the 19th century French mathematician Charles Pierre Tr√©maux as a strategy for solving mazes.")]),t._v(" "),a("p",[t._v("Depth-first search is a systematic way to find all the vertices reachable from a source vertex. Like breadth-first search, DFS traverse a connected component of a given graph and defines a spanning tree. The basic idea of depth-first search is methodically exploring every edge. We start over from a different vertices as necessary. As soon as we discover a vertex, DFS starts exploring from it (unlike BFS, which puts a vertex on a queue so that it explores from it later).")]),t._v(" "),a("p",[t._v("Let's look at an example. We'll traverse this graph:")]),t._v(" "),a("p",[a("a",{attrs:{href:"http://i.stack.imgur.com/JJkTC.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:"http://i.stack.imgur.com/JJkTC.png",alt:"Example Graph"}}),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("We'll traverse the graph following these rules:")]),t._v(" "),a("ul",[a("li",[t._v("We'll start from the source.")]),t._v(" "),a("li",[t._v("No node will be visited twice.")]),t._v(" "),a("li",[t._v("The nodes we didn't visit yet, will be colored white.")]),t._v(" "),a("li",[t._v("The node we visited, but didn't visit all of its child nodes, will be colored grey.")]),t._v(" "),a("li",[t._v("Completely traversed nodes will be colored black.")])]),t._v(" "),a("p",[t._v("Let's look at it step by step:"),a("a",{attrs:{href:"http://i.stack.imgur.com/AI6W0.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:"http://i.stack.imgur.com/AI6W0.png",alt:"Step 1 and 2"}}),a("OutboundLink")],1),a("a",{attrs:{href:"http://i.stack.imgur.com/f3T4C.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:"http://i.stack.imgur.com/f3T4C.png",alt:"Step 3 and 4"}}),a("OutboundLink")],1),a("a",{attrs:{href:"http://i.stack.imgur.com/MXRDH.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:"http://i.stack.imgur.com/MXRDH.png",alt:"Step 5 and 6"}}),a("OutboundLink")],1),a("a",{attrs:{href:"http://i.stack.imgur.com/Piasa.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:"http://i.stack.imgur.com/Piasa.png",alt:"Step 7 and 8"}}),a("OutboundLink")],1),a("a",{attrs:{href:"http://i.stack.imgur.com/RJ76g.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:"http://i.stack.imgur.com/RJ76g.png",alt:"Step 9 and 10"}}),a("OutboundLink")],1),a("a",{attrs:{href:"http://i.stack.imgur.com/4W5Bz.png",target:"_blank",rel:"noopener noreferrer"}},[a("img",{attrs:{src:"http://i.stack.imgur.com/4W5Bz.png",alt:"Step 11"}}),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("We can see one important keyword. That is "),a("strong",[t._v("backedge")]),t._v(". You can see. "),a("strong",[t._v("5-1")]),t._v(" is called backedge. This is because, we're not yet done with "),a("strong",[t._v("node-1")]),t._v(", so going from another node to "),a("strong",[t._v("node-1")]),t._v(" means there's a cycle in the graph. In DFS, if we can go from one gray node to another, we can be certain that the graph has a cycle. This is one of the ways of detecting cycle in a graph. Depending on "),a("strong",[t._v("source")]),t._v(" node and the order of the nodes we visit, we can find out any edge in a cycle as "),a("strong",[t._v("backedge")]),t._v(". For example: if we went to "),a("strong",[t._v("5")]),t._v(" from "),a("strong",[t._v("1")]),t._v(" first, we'd have found out "),a("strong",[t._v("2-1")]),t._v(" as backedge.")]),t._v(" "),a("p",[t._v("The edge that we take to go from gray node to white node are called "),a("strong",[t._v("tree edge")]),t._v(". If we only keep the "),a("strong",[t._v("tree edge")]),t._v("'s and remove others, we'll get "),a("strong",[t._v("DFS tree")]),t._v(".")]),t._v(" "),a("p",[t._v("In undirected graph, if we can visit a already visited node, that must be a "),a("strong",[t._v("backedge")]),t._v(". But for directed graphs, we must check the colors. "),a("strong",[t._v("If and only if we can go from one gray node to another gray node, that is called a backedge")]),t._v(".")]),t._v(" "),a("p",[t._v("In DFS, we can also keep timestamps for each node, which can be used in many ways (e.g.: Topological Sort).")]),t._v(" "),a("ol",[a("li",[t._v("When a node "),a("strong",[t._v("v")]),t._v(" is changed from white to gray the time is recorded in "),a("strong",[t._v("d[v]")]),t._v(".")]),t._v(" "),a("li",[t._v("When a node "),a("strong",[t._v("v")]),t._v(" is changed from gray to black the time is recorded in "),a("strong",[t._v("f[v]")]),t._v(".")])]),t._v(" "),a("p",[t._v("Here "),a("strong",[t._v("d[]")]),t._v(" means "),a("strong",[t._v("discovery time")]),t._v(" and "),a("strong",[t._v("f[]")]),t._v(" means "),a("strong",[t._v("finishing time")]),t._v(". Our pesudo-code will look like:")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[t._v("Procedure "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("DFS")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("G"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" each node u in V"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("G"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    color"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("u"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" white\n    parent"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("u"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),t._v("\nend "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v("\ntime "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" each node u in V"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("G"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" color"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("u"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" white\n        DFS"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Visit")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("u"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    end "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v("\nend "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v("\n\nProcedure DFS"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Visit")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("u"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\ncolor"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("u"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" gray\ntime "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" time "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\nd"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("u"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" time\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" each node v adjacent to u\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" color"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" white\n        parent"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" u\n        DFS"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Visit")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    end "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v("\nend "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v("\ncolor"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("u"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" black\ntime "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" time "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\nf"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("u"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" time\n\n")])])]),a("p",[a("strong",[t._v("Complexity:")])]),t._v(" "),a("p",[t._v("Each nodes and edges are visited once. So the complexity of DFS is "),a("strong",[t._v("O(V+E)")]),t._v(", where "),a("strong",[t._v("V")]),t._v(" denotes the number of nodes and "),a("strong",[t._v("E")]),t._v(" denotes the number of edges.")]),t._v(" "),a("p",[a("strong",[t._v("Applications of Depth First Search:")])]),t._v(" "),a("ul",[a("li",[t._v("Finding all pair shortest path in an undirected graph.")]),t._v(" "),a("li",[t._v("Detecting cycle in a graph.")]),t._v(" "),a("li",[t._v("Path finding.")]),t._v(" "),a("li",[t._v("Topological Sort.")]),t._v(" "),a("li",[t._v("Testing if a graph is bipartite.")]),t._v(" "),a("li",[t._v("Finding Strongly Connected Component.")]),t._v(" "),a("li",[t._v("Solving puzzles with one solution.")])])])}),[],!1,null,null,null);e.default=s.exports}}]);