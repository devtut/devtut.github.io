(window.webpackJsonp=window.webpackJsonp||[]).push([[1204],{1612:function(t,a,s){"use strict";s.r(a);var n=s(31),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"monad-transformers"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#monad-transformers"}},[t._v("#")]),t._v(" Monad Transformers")]),t._v(" "),s("h2",{attrs:{id:"a-monadic-counter"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#a-monadic-counter"}},[t._v("#")]),t._v(" A monadic counter")]),t._v(" "),s("p",[t._v("An example on how to compose the reader, writer, and state\nmonad using monad transformers. The source code can be found "),s("a",{attrs:{href:"https://github.com/capitanbatata/sandbox/tree/master/monadic-counter",target:"_blank",rel:"noopener noreferrer"}},[t._v("in this repository"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("We want to implement a counter, that increments its value by a given\nconstant.")]),t._v(" "),s("p",[t._v("We start by defining some types, and functions:")]),t._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("newtype")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Counter")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("MkCounter")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("cValue")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("deriving")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Show")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- | 'inc c n' increments the counter by 'n' units.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("inc")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Counter")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Counter")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("inc")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("MkCounter")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("c")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("n")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("MkCounter")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("c")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("n")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n")])])]),s("p",[t._v("Assume we want to carry out the following computation using the counter:")]),t._v(" "),s("ul",[s("li",[t._v("set the counter to 0")]),t._v(" "),s("li",[t._v("set the increment constant to 3")]),t._v(" "),s("li",[t._v("increment the counter 3 times")]),t._v(" "),s("li",[t._v("set the increment constant to 5")]),t._v(" "),s("li",[t._v("increment the counter 2 times")])]),t._v(" "),s("p",[t._v("The "),s("a",{attrs:{href:"https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-State-Lazy.html#t:StateT",target:"_blank",rel:"noopener noreferrer"}},[t._v("state monad"),s("OutboundLink")],1),t._v(" provides abstractions for passing state around. We can make\nuse of the state monad, and define our increment function as a state\ntransformer.")]),t._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- | CounterS is a monad.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CounterS")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("State")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Counter")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- | Increment the counter by 'n' units.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("incS")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Int")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CounterS")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("incS")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("n")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("modify")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("\\")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("c")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("inc")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("c")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("n")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n")])])]),s("p",[t._v("This already enables us to express a computation in a more clear and\nsuccinct way:")]),t._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- | The computation we want to run, with the state monad.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("mComputationS")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CounterS")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("mComputationS")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("do")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("incS")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("incS")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("incS")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("incS")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("incS")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v("\n\n")])])]),s("p",[t._v("But we still have to pass the increment constant at each invocation. We would\nlike to avoid this.")]),t._v(" "),s("h3",{attrs:{id:"adding-an-environment"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#adding-an-environment"}},[t._v("#")]),t._v(" Adding an environment")]),t._v(" "),s("p",[t._v("The "),s("a",{attrs:{href:"https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Reader.html#v:runReaderT",target:"_blank",rel:"noopener noreferrer"}},[t._v("reader monad"),s("OutboundLink")],1),t._v(" provides a convenient way to pass an environment around.\nThis monad is used in functional programming to perform what in the\nOO world is known as "),s("strong",[t._v("dependency injection")]),t._v(".")]),t._v(" "),s("p",[t._v("In its simplest version, the reader monad requires two types:")]),t._v(" "),s("li",[t._v("\nthe type of the value being read (i.e. our environment, `r` below),\n")]),t._v(" "),s("li",[t._v("\nthe value returned by the reader monad (`a` below).\nReader r a\n")]),t._v(" "),s("p",[t._v("However, we need to make use of the state monad as well. Thus, we need to use\nthe "),s("code",[t._v("ReaderT")]),t._v(" transformer:")]),t._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("newtype")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("ReaderT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("r")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("m")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("a")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("\n\n")])])]),s("p",[t._v("Using "),s("code",[t._v("ReaderT")]),t._v(", we can define our counter with environment and state as\nfollows:")]),t._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CounterRS")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("ReaderT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CounterS")]),t._v("\n\n")])])]),s("p",[t._v("We define an "),s("code",[t._v("incR")]),t._v(" function that takes the increment constant from the\nenvironment (using "),s("code",[t._v("ask")]),t._v("), and to define our increment function in terms of\nour "),s("code",[t._v("CounterS")]),t._v(" monad we make use of the "),s("code",[t._v("lift")]),t._v(" function (which belongs to the\n"),s("a",{attrs:{href:"https://hackage.haskell.org/package/transformers-0.1.3.0/docs/Control-Monad-Trans.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("monad transformer"),s("OutboundLink")],1),t._v(" class).")]),t._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- | Increment the counter by the amount of units specified by the environment.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("incR")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CounterRS")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("incR")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("ask")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("lift")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("incS")]),t._v("\n\n")])])]),s("p",[t._v("Using the reader monad we can define our computation as follows:")]),t._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("-- | The computation we want to run, using reader and state monads.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("mComputationRS")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CounterRS")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("mComputationRS")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("do")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("local")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("$")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("do")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("incR")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("incR")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("incR")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("local")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("$")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("do")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("incR")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("incR")]),t._v("\n\n")])])]),s("h3",{attrs:{id:"the-requirements-changed-we-need-logging"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#the-requirements-changed-we-need-logging"}},[t._v("#")]),t._v(" The requirements changed: we need logging!")]),t._v(" "),s("p",[t._v("Now assume that we want to add logging to our computation, so that we can see\nthe evolution of our counter in time.")]),t._v(" "),s("p",[t._v("We also have a monad to perform this task, the "),s("a",{attrs:{href:"https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Writer-Strict.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("writer monad"),s("OutboundLink")],1),t._v(". As with the\nreader monad, since we are composing them, we need to make use of the reader\nmonad transformer:")]),t._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("newtype")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("WriterT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("w")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("m")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("a")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("\n\n")])])]),s("p",[t._v("Here "),s("code",[t._v("w")]),t._v(" represents the type of the output to accumulate (which has to be a\nmonoid, which allow us to accumulate this value), "),s("code",[t._v("m")]),t._v(" is the inner monad, and\n"),s("code",[t._v("a")]),t._v(" the type of the computation.")]),t._v(" "),s("p",[t._v("We can then define our counter with logging, environment, and state as\nfollows:")]),t._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CounterWRS")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("WriterT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CounterRS")]),t._v("\n\n")])])]),s("p",[t._v("And making use of "),s("code",[t._v("lift")]),t._v(" we can define the version of the increment function\nwhich logs the value of the counter after each increment:")]),t._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("incW")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CounterWRS")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("incW")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("lift")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("incR")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("get")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("tell")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("cValue")]),t._v("\n\n")])])]),s("p",[t._v("Now the computation that contains logging can be written as follows:")]),t._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("mComputationWRS")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("CounterWRS")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("mComputationWRS")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("do")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("local")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("$")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("do")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("incW")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("incW")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("incW")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("local")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("$")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("do")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("incW")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("incW")]),t._v("\n\n")])])]),s("h3",{attrs:{id:"doing-everything-in-one-go"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#doing-everything-in-one-go"}},[t._v("#")]),t._v(" Doing everything in one go")]),t._v(" "),s("p",[t._v("This example intended to show monad transformers at work. However, we can\nachieve the same effect by composing all the aspects (environment, state, and\nlogging) in a single increment operation.")]),t._v(" "),s("p",[t._v("To do this we make use of type-constraints:")]),t._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("inc'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("MonadReader")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("m")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("MonadState")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Counter")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("m")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("MonadWriter")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("m")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("m")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("inc'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("ask")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("modify")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("flip")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("inc")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("get")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("tell")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(".")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("cValue")]),t._v("\n\n")])])]),s("p",[t._v("Here we arrive at a solution that will work for any monad that satisfies the\nconstraints above. The computation function is defined thus with type:")]),t._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("mComputation'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("::")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("MonadReader")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("m")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("MonadState")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Counter")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("m")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("MonadWriter")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("m")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("m")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n")])])]),s("p",[t._v("since in its body we make use of inc'.")]),t._v(" "),s("p",[t._v("We could run this computation, in the "),s("code",[t._v("ghci")]),t._v(" REPL for instance, as follows:")]),t._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("runState")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("runReaderT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("runWriterT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("mComputation'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("15")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("MkCounter")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);