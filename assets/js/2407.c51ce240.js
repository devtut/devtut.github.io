(window.webpackJsonp=window.webpackJsonp||[]).push([[2407],{2815:function(t,s,a){"use strict";a.r(s);var e=a(31),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"sorting"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sorting"}},[t._v("#")]),t._v(" Sorting")]),t._v(" "),a("p",[t._v("For sorting lists of things, Perl has only a single function, unsurprisingly called "),a("code",[t._v("sort")]),t._v(". It is flexible enough to sort all kinds of items: numbers, strings in any number of encodings, nested data structures or objects. However, due to its flexibility, there are quite a few tricks and idioms to be learned for its use.")]),t._v(" "),a("h2",{attrs:{id:"basic-lexical-sort"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#basic-lexical-sort"}},[t._v("#")]),t._v(" Basic Lexical Sort")]),t._v(" "),a("div",{staticClass:"language-perl extra-class"},[a("pre",{pre:!0,attrs:{class:"language-perl"}},[a("code",[a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@sorted")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" sort "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@list")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@sorted")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" sort "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$a")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("cmp")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$b")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@list")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("sub")]),t._v(" compare")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$a")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("cmp")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$b")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@sorted")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" sort compare "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@list")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),a("p",[t._v("The three examples above do exactly the same thing. If you don't supply any comparator function or block, "),a("code",[t._v("sort")]),t._v(" assumes you want the list on its right sorted lexically. This is usually the form you want if you just need your data in some predictable order and don't care about linguistic correctness.")]),t._v(" "),a("p",[a("code",[t._v("sort")]),t._v(" passes pairs of items in "),a("code",[t._v("@list")]),t._v(" to the comparator function, which tells "),a("code",[t._v("sort")]),t._v(" which item is larger. The "),a("code",[t._v("cmp")]),t._v(" operator does this for strings while "),a("code",[t._v("<=>")]),t._v(" does the same thing for numbers. The comparator is called quite often, on average "),a("strong",[t._v("n")]),t._v(" * log("),a("strong",[t._v("n")]),t._v(") times with "),a("strong",[t._v("n")]),t._v(" being the number of elements to be sorted, so it's important it be fast. This is the reason "),a("code",[t._v("sort")]),t._v(" uses predefined package global variables ("),a("code",[t._v("$a")]),t._v(" and "),a("code",[t._v("$b")]),t._v(") to pass the elements to be compared to the block or function, instead of proper function parameters.")]),t._v(" "),a("p",[t._v("If you "),a("code",[t._v("use locale")]),t._v(", "),a("code",[t._v("cmp")]),t._v(" takes locale specific collation order into account, e.g. it will sort "),a("code",[t._v("Å")]),t._v(" like "),a("code",[t._v("A")]),t._v(" under a Danish locale but after "),a("code",[t._v("Z")]),t._v(" under an English or German one. However, it doesn't take the more complex Unicode sorting rules into account nor does it offer any control over the order—for example phone books are often sorted differently from dictionaries. For those cases, the "),a("code",[t._v("Unicode::Collate")]),t._v(" and particularly "),a("code",[t._v("Unicode::Collate::Locale")]),t._v(" modules are recommended.")]),t._v(" "),a("h2",{attrs:{id:"the-schwartzian-transform"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#the-schwartzian-transform"}},[t._v("#")]),t._v(" The Schwartzian Transform")]),t._v(" "),a("p",[t._v("This is probably the most famous example of a sort optimization making use of Perl's functional programming facilities, to be used where the sort order of items depend on an expensive function.")]),t._v(" "),a("div",{staticClass:"language-perl extra-class"},[a("pre",{pre:!0,attrs:{class:"language-perl"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# What you would usually do")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@sorted")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" sort "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" slow"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$a")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=>")]),t._v(" slow"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$b")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@list")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# What you do to make it faster")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@sorted")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("\nmap "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$_")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\nsort "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$a")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$b")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\nmap "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$_")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" slow"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$_")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@list")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),a("p",[t._v("The trouble with the first example is that the comparator is called very often and keeps recalculating values using a slow function over and over. A typical example would be sorting file names by their file size:")]),t._v(" "),a("div",{staticClass:"language-perl extra-class"},[a("pre",{pre:!0,attrs:{class:"language-perl"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("use")]),t._v(" File"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("stat"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@sorted")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" sort "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" stat"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$a")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("size "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=>")]),t._v(" stat"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$b")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("size "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" glob "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"*"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),a("p",[t._v("This works, but at best it incurs the overhead of two system calls per comparison, at worst it has to go to the disk, twice, for every single comparison, and that disk may be in an overloaded file server on the other side of the planet.")]),t._v(" "),a("p",[t._v("Enter Randall Schwartz's trick.")]),t._v(" "),a("p",[t._v("The Schwartzian Transform basically shoves "),a("code",[t._v("@list")]),t._v(" through three functions, bottom-to-top. The first "),a("code",[t._v("map")]),t._v(" turns each entry into a two-element list of the original item and the result of the slow function as a sort key, so at the end of this we have called "),a("code",[t._v("slow()")]),t._v(" exactly once for each element. The following "),a("code",[t._v("sort")]),t._v(" can then simply access the sort key by looking in the list. As we don't care about the sort keys but only need the original elements in sorted order, the final "),a("code",[t._v("map")]),t._v(" throws away the two-element lists from the already-sorted list it receives from "),a("code",[t._v("@sort")]),t._v(" and returns a list of only their first members.")]),t._v(" "),a("h2",{attrs:{id:"case-insensitive-sort"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#case-insensitive-sort"}},[t._v("#")]),t._v(" Case Insensitive Sort")]),t._v(" "),a("p",[t._v("The traditional technique to make "),a("code",[t._v("sort")]),t._v(" ignore case is to pass strings to "),a("code",[t._v("lc")]),t._v(" or "),a("code",[t._v("uc")]),t._v(" for comparison:")]),t._v(" "),a("div",{staticClass:"language-perl extra-class"},[a("pre",{pre:!0,attrs:{class:"language-perl"}},[a("code",[a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@sorted")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" sort "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" lc"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$a")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("cmp")]),t._v(" lc"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$b")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@list")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),a("p",[t._v("This works on all versions of Perl 5 and is completely sufficient for English; it doesn't matter whether you use "),a("code",[t._v("uc")]),t._v(" or "),a("code",[t._v("lc")]),t._v(". However, it presents a problem for languages like Greek or Turkish where there is no 1:1 correspondence between upper- and lowercase letters so you get different results depending on whether you use "),a("code",[t._v("uc")]),t._v(" or "),a("code",[t._v("lc")]),t._v(". Therefore, Perl 5.16 and higher have a "),a("strong",[t._v("case folding")]),t._v(" function called "),a("code",[t._v("fc")]),t._v(" that avoids this problem, so modern multi-lingual sorting should use this:")]),t._v(" "),a("div",{staticClass:"language-perl extra-class"},[a("pre",{pre:!0,attrs:{class:"language-perl"}},[a("code",[a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@sorted")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" sort "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" fc"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$a")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("cmp")]),t._v(" fc"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$b")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@list")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),a("h2",{attrs:{id:"numeric-sort"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#numeric-sort"}},[t._v("#")]),t._v(" Numeric Sort")]),t._v(" "),a("div",{staticClass:"language-perl extra-class"},[a("pre",{pre:!0,attrs:{class:"language-perl"}},[a("code",[a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@sorted")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" sort "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$a")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$b")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@list")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),a("p",[t._v("Comparing "),a("code",[t._v("$a")]),t._v(" and "),a("code",[t._v("$b")]),t._v(" with the "),a("code",[t._v("<=>")]),t._v(" operator ensures they are compared numerically and not textually as per default.")]),t._v(" "),a("h2",{attrs:{id:"reverse-sort"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reverse-sort"}},[t._v("#")]),t._v(" Reverse Sort")]),t._v(" "),a("div",{staticClass:"language-perl extra-class"},[a("pre",{pre:!0,attrs:{class:"language-perl"}},[a("code",[a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@sorted")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" sort "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$b")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$a")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@list")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@sorted")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" reverse sort "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$a")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$b")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@list")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),a("p",[t._v("Sorting items in descending order can simply be achieved by swapping "),a("code",[t._v("$a")]),t._v(" and "),a("code",[t._v("$b")]),t._v(" in the comparator block. However, some people prefer the clarity of a separate "),a("code",[t._v("reverse")]),t._v(" even though it is slightly slower.")]),t._v(" "),a("h4",{attrs:{id:"syntax"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#syntax"}},[t._v("#")]),t._v(" Syntax")]),t._v(" "),a("ul",[a("li",[t._v("sort SUBNAME LIST")]),t._v(" "),a("li",[t._v("sort BLOCK LIST")]),t._v(" "),a("li",[t._v("sort LIST")])])])}),[],!1,null,null,null);s.default=r.exports}}]);