(window.webpackJsonp=window.webpackJsonp||[]).push([[604],{1013:function(t,e,a){"use strict";a.r(e);var s=a(31),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"undefined-behavior"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#undefined-behavior"}},[t._v("#")]),t._v(" Undefined behavior")]),t._v(" "),a("p",[t._v("In C, some expressions yield "),a("strong",[t._v("undefined behavior")]),t._v(". The standard explicitly chooses to not define how a compiler should behave if it encounters such an expression. As a result, a compiler is free to do whatever it sees fit and may produce useful results, unexpected  results, or even crash.")]),t._v(" "),a("p",[t._v("Code that invokes UB may work as intended on a specific system with a specific compiler, but will likely not work on another system, or with a different compiler, compiler version or compiler settings.")]),t._v(" "),a("h2",{attrs:{id:"dereferencing-a-pointer-to-variable-beyond-its-lifetime"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dereferencing-a-pointer-to-variable-beyond-its-lifetime"}},[t._v("#")]),t._v(" Dereferencing a pointer to variable beyond its lifetime")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" bar"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" baz "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    baz "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" bar"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("baz"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* (&baz) copied to new memory location outside of foo. */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* (1) The lifetime of baz and bar end here as they have automatic storage   \n   * duration (local variables), thus the returned pointer is not valid! */")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" p"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* (2) this expression's behavior is undefined */")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* (3) Undefined behaviour here */")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[t._v("Some compilers helpfully point this out. For example, "),a("code",[t._v("gcc")]),t._v(" warns with:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[t._v("warning"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" function returns address of local variable "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Wreturn"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("local"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("addr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n")])])]),a("p",[t._v("and "),a("code",[t._v("clang")]),t._v(" warns with:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[t._v("warning"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" address of stack memory associated with local variable "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'baz'")]),t._v(" returned \n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Wreturn"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("stack"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("address"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n")])])]),a("p",[t._v("for the above code. But compilers may not be able to help in complex code.")]),t._v(" "),a("p",[t._v("(1) Returning reference to variable declared "),a("code",[t._v("static")]),t._v(" is defined behaviour, as the variable is not destroyed after leaving current scope.")]),t._v(" "),a("p",[t._v('(2) According to ISO/IEC 9899:2011 6.2.4 §2, "The value of a pointer becomes indeterminate when the object it points to reaches the end of its lifetime."')]),t._v(" "),a("p",[t._v("(3) Dereferencing the pointer returned by the function "),a("code",[t._v("foo")]),t._v(" is undefined behaviour as the memory it references holds an indeterminate value.")]),t._v(" "),a("h2",{attrs:{id:"copying-overlapping-memory"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copying-overlapping-memory"}},[t._v("#")]),t._v(" Copying overlapping memory")]),t._v(" "),a("p",[t._v("A wide variety of standard library functions have among their effects copying byte sequences from one memory region to another.  Most of these functions have undefined behavior when the source and destination regions overlap.")]),t._v(" "),a("p",[t._v("For example, this ...")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<string.h>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* for memcpy() */")])]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" str"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("19")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"This is an example"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("memcpy")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("str "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" str"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),a("p",[t._v("... attempts to copy 10 bytes where the source and destination memory areas overlap by three bytes. To visualize:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\n              overlapping area\n               |\n               _ _\n              |   |\n              v   v\nT h i s   i s   a n   e x a m p l e \\0\n^             ^\n|             |\n|             destination\n|\nsource\n\n")])])]),a("p",[t._v("Because of the overlap, the resulting behavior is undefined.")]),t._v(" "),a("p",[t._v("Among the standard library functions with a limitation of this kind are "),a("code",[t._v("memcpy()")]),t._v(", "),a("code",[t._v("strcpy()")]),t._v(", "),a("code",[t._v("strcat()")]),t._v(", "),a("code",[t._v("sprintf()")]),t._v(", and "),a("code",[t._v("sscanf()")]),t._v(".  The standard says of these and several other functions:")]),t._v(" "),a("blockquote"),t._v(" "),a("p",[t._v("If copying takes place between objects that overlap, the behavior\nis undefined.")]),t._v(" "),a("p",[t._v("The "),a("code",[t._v("memmove()")]),t._v(" function is the principal exception to this rule.  Its definition specifies that the function behaves as if the source data were first copied into a temporary buffer and then written to the destination address.  There is no exception for overlapping source and destination regions, nor any need for one, so "),a("code",[t._v("memmove()")]),t._v(" has well-defined behavior in such cases.")]),t._v(" "),a("p",[t._v("The distinction reflects an efficiency "),a("strong",[t._v("vs")]),t._v(". generality tradeoff.  Copying such as these functions perform usually occurs between disjoint regions of memory, and often it is possible to know at development time whether a particular instance of memory copying will be in that category.  Assuming non-overlap affords comparatively more efficient implementations that do not reliably produce correct results when the assumption does not hold.  Most C library functions are allowed the more efficient implementations, and "),a("code",[t._v("memmove()")]),t._v(" fills in the gaps, serving the cases where the source and destination may or do overlap.  To produce the correct effect in all cases, however, it must perform additional tests and / or employ a comparatively less efficient implementation.")]),t._v(" "),a("h2",{attrs:{id:"signed-integer-overflow"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#signed-integer-overflow"}},[t._v("#")]),t._v(" Signed integer overflow")]),t._v(" "),a("p",[t._v("Per paragraph 6.5/5 of both C99 and C11, evaluation of an expression produces undefined behavior if the result is not a representable value of the expression's type.  For arithmetic types, that's called an "),a("strong",[t._v("overflow")]),t._v(".  Unsigned integer arithmetic does not overflow because paragraph 6.2.5/9 applies, causing any unsigned result that otherwise would be out of range to be reduced to an in-range value.  There is no analogous provision for "),a("strong",[t._v("signed")]),t._v(" integer types, however; these can and do overflow, producing undefined behavior.  For example,")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<limits.h>")]),t._v("      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* to get INT_MAX */")])]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" INT_MAX "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Overflow happens here */")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[t._v("Most instances of this type of undefined behavior are more difficult to recognize or predict.  Overflow can in principle arise from any addition, subtraction, or multiplication operation on signed integers (subject to the usual arithmetic conversions) where there are not effective bounds on or a relationship between the operands to prevent it.  For example, this function:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("square")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* overflows for some values of x */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[t._v("is reasonable, and it does the right thing for small enough argument values, but its behavior is undefined for larger argument values.  You cannot judge from the function alone whether programs that call it exhibit undefined behavior as a result.  It depends on what arguments they pass to it.")]),t._v(" "),a("p",[t._v("On the other hand, consider this trivial example of overflow-safe signed integer arithmetic:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("zero")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Cannot overflow */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[t._v("The relationship between the operands of the subtraction operator ensures that the subtraction never overflows.  Or consider this somewhat more practical example:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("sizeDelta")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("FILE "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("f1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" FILE "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("f2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" count1 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" count2 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("fgetc")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("f1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("EOF")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" count1"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* might overflow */")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("fgetc")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("f2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("EOF")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" count2"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* might overflow */")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" count1 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" count2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* provided no UB to this point, will not overflow */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[t._v("As long as that the counters do not overflow individually, the operands of the final subtraction will both be non-negative.  All differences between any two such values are representable as "),a("code",[t._v("int")]),t._v(".")]),t._v(" "),a("h2",{attrs:{id:"use-of-an-uninitialized-variable"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#use-of-an-uninitialized-variable"}},[t._v("#")]),t._v(" Use of an uninitialized variable")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"%d"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),a("p",[t._v("The variable "),a("code",[t._v("a")]),t._v(" is an "),a("code",[t._v("int")]),t._v(" with automatic storage duration. The example code above is trying to print the value of an uninitialized variable ("),a("code",[t._v("a")]),t._v(" was never initialized). Automatic variables which are not initialized have indeterminate values; accessing these can lead to undefined behavior.")]),t._v(" "),a("p",[a("strong",[t._v("Note:")]),t._v(" Variables with static or thread local storage, including "),a("a",{attrs:{href:"http://stackoverflow.com/a/16016164",target:"_blank",rel:"noopener noreferrer"}},[t._v("global variables"),a("OutboundLink")],1),t._v(" without the "),a("code",[t._v("static")]),t._v(" keyword, are initialized to either zero, or their initialized value. Hence the following is legal.")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"%d"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),a("p",[t._v("A very common mistake is to not initialize the variables that serve as counters to 0. You add values to them, but since the initial value is garbage, you will invoke "),a("strong",[t._v("Undefined Behavior")]),t._v(", such as in the question "),a("a",{attrs:{href:"http://stackoverflow.com/questions/38881622/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Compilation on terminal gives off pointer warning and strange symbols"),a("OutboundLink")],1),t._v(".")]),t._v(" "),a("p",[t._v("Example:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdio.h>")])]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" counter"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        counter "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"%d\\n"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" counter"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[t._v("Output:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[t._v("C02QT2UBFVH6"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("lm"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),t._v(" gsamaras$ gcc main"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("c "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Wall "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("o main\nmain"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("c"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" warning"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" variable "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'counter'")]),t._v(" is uninitialized when used here "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Wuninitialized"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n        counter "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),t._v("\nmain"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("c"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("19")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" note"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" initialize the variable "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'counter'")]),t._v(" to silence this warning\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" counter"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                  "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),t._v("\n                   "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" warning generated"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\nC02QT2UBFVH6"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("lm"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),t._v(" gsamaras$ "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("main\n"),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("32812")]),t._v("\n\n")])])]),a("p",[t._v("The above rules are applicable for pointers as well. For example, the following results in undefined behavior")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("p"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    p"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Trying to increment an uninitialized pointer.")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[t._v("Note that the above code on its own might not cause an error or segmentation fault, but trying to dereference this pointer later would cause the undefined behavior.")]),t._v(" "),a("h2",{attrs:{id:"data-race"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#data-race"}},[t._v("#")]),t._v(" Data race")]),t._v(" "),a("p",[t._v("C11 introduced support for multiple threads of execution, which affords the possibility of data races.  A program contains a data race if an object in it is  accessed"),a("sup",[t._v("1")]),t._v(" by two different threads, where at least one of the accesses is non-atomic, at least one modifies the object, and program semantics fail to ensure that the two accesses cannot overlap temporally."),a("sup",[t._v("2")]),t._v("  Note well that actual concurrency of the accesses involved is not a condition for a data race; data races cover a broader class of issues arising from (allowed) inconsistencies in different threads' views of memory.")]),t._v(" "),a("p",[t._v("Consider this example:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<threads.h>")])]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" ignore "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("thrd_t")]),t._v(" id"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("thrd_create")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("id "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" Function "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" b "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("thrd_join")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" id "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[t._v("The main thread calls "),a("code",[t._v("thrd_create")]),t._v(" to start a new thread running function "),a("code",[t._v("Function")]),t._v(".  The second thread modifies "),a("code",[t._v("a")]),t._v(", and the main thread reads "),a("code",[t._v("a")]),t._v(". Neither of those access is atomic, and the two threads do nothing either individually or jointly to ensure that they do not overlap, so there is a data race.")]),t._v(" "),a("p",[t._v("Among the ways this program could avoid the data race are")]),t._v(" "),a("ul",[a("li",[t._v("the main thread could perform its read of "),a("code",[t._v("a")]),t._v(" before starting the other thread;")]),t._v(" "),a("li",[t._v("the main thread could perform its read of "),a("code",[t._v("a")]),t._v(" after ensuring via "),a("code",[t._v("thrd_join")]),t._v(" that the other has terminated;")]),t._v(" "),a("li",[t._v("the threads could synchronize their accesses via a mutex, each one locking that mutex before accessing "),a("code",[t._v("a")]),t._v(" and unlocking it afterward.")])]),t._v(" "),a("p",[t._v("As the mutex option demonstrates, avoiding a data race does not require ensuring a specific order of operations, such as the child thread modifying "),a("code",[t._v("a")]),t._v(" before the main thread reads it; it is sufficient (for avoiding a data race) to ensure that  for a given execution, one access will happen before the other.")]),t._v(" "),a("p",[a("sup",[t._v("1")]),t._v(" Modifying or reading an object.")]),t._v(" "),a("p",[a("sup",[t._v("2")]),t._v(' (Quoted from ISO:IEC 9889:201x, section 5.1.2.4 "Multi-threaded executions and data races")'),a("br"),t._v("\nThe execution of a program contains a data race if it contains two conflicting actions in different threads, at least one of which is not atomic, and neither happens before the other. Any such data race results in undefined behavior.")]),t._v(" "),a("h2",{attrs:{id:"read-value-of-pointer-that-was-freed"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#read-value-of-pointer-that-was-freed"}},[t._v("#")]),t._v(" Read value of pointer that was freed")]),t._v(" "),a("p",[t._v("Even just "),a("strong",[t._v("reading")]),t._v(" the value of a pointer that was freed (i.e. without trying to dereference the pointer) is undefined behavior(UB), e.g.")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("malloc")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("free")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* NOTE: even without dereferencing, this may have UB */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[t._v("Quoting "),a("strong",[t._v("ISO/IEC 9899:2011")]),t._v(", section 6.2.4 §2:")]),t._v(" "),a("blockquote"),t._v(" "),a("p",[t._v("[…] The value of a pointer becomes indeterminate when the object it points\nto (or just past) reaches the end of its lifetime.")]),t._v(" "),a("p",[t._v("The use of indeterminate memory for anything, including apparently harmless comparison or arithmetic, can have undefined behavior if the value can be a trap representation for the type.")]),t._v(" "),a("h2",{attrs:{id:"modify-string-literal"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#modify-string-literal"}},[t._v("#")]),t._v(" Modify string literal")]),t._v(" "),a("p",[t._v("In this code example, the char pointer "),a("code",[t._v("p")]),t._v(" is initialized to the address of a string literal. Attempting to modify the string literal has undefined behavior.")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hello world"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\np"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'H'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Undefined behavior")]),t._v("\n\n")])])]),a("p",[t._v("However, modifying a mutable array of "),a("code",[t._v("char")]),t._v(" directly, or through a pointer is naturally not undefined behavior, even if its initializer is a literal string. The following is fine:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hello, world"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("p "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\na"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'H'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\np"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'W'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),a("p",[t._v("That's because the string literal is effectively copied to the array each time the array is initialized (once for variables with static duration, each time the array is created for variables with automatic or thread duration — variables with allocated duration aren't initialized), and it is fine to modify array contents.")]),t._v(" "),a("h2",{attrs:{id:"using-incorrect-format-specifier-in-printf"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#using-incorrect-format-specifier-in-printf"}},[t._v("#")]),t._v(" Using incorrect format specifier in printf")]),t._v(" "),a("p",[t._v("Using an incorrect format specifier in the first argument to "),a("code",[t._v("printf")]),t._v(" invokes undefined behavior.\nFor example, the code below invokes undefined behavior:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" z "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'B'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"%c\\n"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" z"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),a("p",[t._v("Here is another example")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"%f\\n"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),a("p",[t._v("Above line of code is undefined behavior. "),a("code",[t._v("%f")]),t._v(" expects double. However 0 is of type "),a("code",[t._v("int")]),t._v(".")]),t._v(" "),a("p",[t._v("Note that your compiler usually can help you avoid cases like these, if you turn on the proper flags during compiling ("),a("code",[t._v("-Wformat")]),t._v(" in "),a("code",[t._v("clang")]),t._v(" and "),a("code",[t._v("gcc")]),t._v("). From the last example:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[t._v("warning"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" format specifies type "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'double'")]),t._v(" but the argument has type\n      "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'int'")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Wformat"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"%f\\n"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("~")]),t._v("    "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("d\n\n")])])]),a("h2",{attrs:{id:"modifying-any-object-more-than-once-between-two-sequence-points"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#modifying-any-object-more-than-once-between-two-sequence-points"}},[t._v("#")]),t._v(" Modifying any object more than once between two sequence points")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("42")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ni "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Assignment changes variable, post-increment as well */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),a("p",[t._v('Code like this often leads to speculations about the "resulting value" of '),a("code",[t._v("i")]),t._v(".  Rather than specifying an outcome, however, the C standards specify that evaluating such an expression produces "),a("strong",[t._v("undefined behavior")]),t._v(".  Prior to C2011, the standard formalized these rules in terms of so-called "),a("strong",[t._v("sequence points")]),t._v(":")]),t._v(" "),a("blockquote"),t._v(" "),a("p",[t._v("Between the previous and next sequence point a scalar object shall have its stored value modified at most once by the evaluation of an expression. Furthermore, the prior value shall be read only to determine the value to be stored.")]),t._v(" "),a("p",[t._v("(C99 standard, section 6.5, paragraph 2)")]),t._v(" "),a("p",[t._v("That scheme proved to be a little too coarse, resulting in some expressions exhibiting undefined behavior with respect to C99 that plausibly should not do.  C2011 retains sequence points, but introduces a more nuanced approach to this area based on "),a("strong",[t._v("sequencing")]),t._v(' and a relationship it calls "sequenced before":')]),t._v(" "),a("blockquote"),t._v(" "),a("p",[t._v("If  a  side  effect  on  a  scalar  object  is  unsequenced  relative  to either  a  different  side  effect on  the  same  scalar  object  or  a  value  computation  using  the  value  of  the  same  scalar object,  the  behavior  is  undefined.   If  there  are  multiple  allowable  orderings  of  the subexpressions  of  an  expression,  the  behavior  is  undefined  if  such  an  unsequenced  side effect occurs in any of the orderings.")]),t._v(" "),a("p",[t._v("(C2011 standard, section 6.5, paragraph 2)")]),t._v(" "),a("p",[t._v('The full details of the "sequenced before" relation are too long to describe here, but they supplement sequence points rather than supplanting them, so they have the effect of defining behavior for some evaluations whose behavior previously was undefined.  In particular, if there is a sequence point between two evaluations, then the one before the sequence point is "sequenced before" the one after.')]),t._v(" "),a("p",[t._v("The following example has well-defined behaviour:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("42")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ni "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("42")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* The comma-operator creates a sequence point */")]),t._v("\n\n")])])]),a("p",[t._v("The following example has undefined behaviour:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("42")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"%d %d\\n"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* commas as separator of function arguments are not comma-operators */")]),t._v("\n\n")])])]),a("p",[t._v("As with any form of undefined behavior, observing the actual behavior of evaluating expressions that violate the sequencing rules is not informative, except in a retrospective sense.  The language standard provides no basis for expecting such observations to be predictive even of the future behavior of the same program.")]),t._v(" "),a("h2",{attrs:{id:"passing-a-null-pointer-to-printf-s-conversion"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#passing-a-null-pointer-to-printf-s-conversion"}},[t._v("#")]),t._v(" Passing a null pointer to printf %s conversion")]),t._v(" "),a("p",[t._v("The "),a("code",[t._v("%s")]),t._v(" conversion of "),a("code",[t._v("printf")]),t._v(" states that the corresponding argument "),a("strong",[t._v("a pointer to the initial element of an array of character type")]),t._v(". A null pointer does not point to the initial element of any array of character type, and thus the behavior of the following is undefined:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("foo "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"%s"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" foo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* undefined behavior */")]),t._v("\n\n")])])]),a("p",[t._v("However, the undefined behavior does not always mean that the program crashes — some systems take steps to avoid the crash that normally happens when a null pointer is dereferenced. For example Glibc is known to print")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("null"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n")])])]),a("p",[t._v("for the code above. However, add (just) a newline to the format string and you will get a crash:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("foo "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"%s\\n"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" foo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* undefined behavior */")]),t._v("\n\n")])])]),a("p",[t._v("In this case, it happens because GCC has an optimization that turns "),a("code",[t._v('printf("%s\\n", argument);')]),t._v(" into a call to "),a("code",[t._v("puts")]),t._v(" with "),a("code",[t._v("puts(argument)")]),t._v(", and "),a("code",[t._v("puts")]),t._v(" in Glibc does not handle null pointers. All this behavior is standard conforming.")]),t._v(" "),a("p",[t._v("Note that "),a("strong",[t._v("null pointer")]),t._v(" is different from an "),a("strong",[t._v("empty string")]),t._v(". So, the following is valid and has no undefined behaviour. It'll just print a "),a("strong",[t._v("newline")]),t._v(":")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("foo "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('""')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"%s\\n"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" foo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),a("h2",{attrs:{id:"freeing-memory-twice"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#freeing-memory-twice"}},[t._v("#")]),t._v(" Freeing memory twice")]),t._v(" "),a("p",[t._v("Freeing memory twice is undefined behavior, e.g.")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("malloc")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("sizeof")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("free")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("free")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),a("p",[t._v("Quote from standard(7.20.3.2. The free function of C99 ):")]),t._v(" "),a("blockquote"),t._v(" "),a("p",[t._v("Otherwise, if the argument does not match a pointer earlier returned\nby the calloc, malloc, or realloc function, or if the space has been\ndeallocated by a call to free or realloc, the behavior is undefined.")]),t._v(" "),a("h2",{attrs:{id:"bit-shifting-using-negative-counts-or-beyond-the-width-of-the-type"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bit-shifting-using-negative-counts-or-beyond-the-width-of-the-type"}},[t._v("#")]),t._v(" Bit shifting using negative counts or beyond the width of the type")]),t._v(" "),a("p",[t._v("If the "),a("strong",[t._v("shift count")]),t._v(" value is a "),a("strong",[t._v("negative value")]),t._v(" then both "),a("strong",[t._v("left shift")]),t._v(" and "),a("strong",[t._v("right shift")]),t._v(" operations are undefined"),a("sup",[t._v("1")]),t._v(":")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* undefined */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* undefined */")]),t._v("\n\n")])])]),a("p",[t._v("If "),a("strong",[t._v("left shift")]),t._v(" is performed on a "),a("strong",[t._v("negative value")]),t._v(", it's undefined:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* undefined */")]),t._v("\n\n")])])]),a("p",[t._v("If "),a("strong",[t._v("left shift")]),t._v(" is performed on a "),a("strong",[t._v("positive value")]),t._v(" and result of the mathematical value is "),a("strong",[t._v("not")]),t._v(" representable in the type, it's undefined"),a("sup",[t._v("1")]),t._v(":")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Assuming an int is 32-bits wide, the value '5 * 2^72' doesn't fit \n * in an int. So, this is undefined. */")]),t._v("\n       \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("72")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),a("p",[t._v("Note that "),a("strong",[t._v("right shift")]),t._v(" on a "),a("strong",[t._v("negative value")]),t._v("  (.e.g "),a("code",[t._v("-5 >> 3")]),t._v(") is "),a("strong",[t._v("not")]),t._v(" undefined but "),a("strong",[t._v("implementation-defined")]),t._v(".")]),t._v(" "),a("p",[a("sup",[t._v("1")]),t._v(" Quoting "),a("strong",[t._v("ISO/IEC 9899:201x")]),t._v(", section 6.5.7:")]),t._v(" "),a("blockquote"),t._v(" "),a("p",[t._v("If the value of the right operand is negative or is greater than or equal to the width of the promoted left operand, the behavior is undefined.")]),t._v(" "),a("h2",{attrs:{id:"accessing-memory-beyond-allocated-chunk"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#accessing-memory-beyond-allocated-chunk"}},[t._v("#")]),t._v(" Accessing memory beyond allocated chunk")]),t._v(" "),a("p",[t._v("A a pointer to a piece of memory containing "),a("code",[t._v("n")]),t._v(" elements may only be dereferenced if it is in the range "),a("code",[t._v("memory")]),t._v(" and "),a("code",[t._v("memory + (n - 1)")]),t._v(". Dereferencing a pointer outside of that range results in undefined behavior. As an example, consider the following code:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" array"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("beyond_array "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" array "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("beyond_array "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Accesses memory that has not been allocated. */")]),t._v("\n\n")])])]),a("p",[t._v("The third line accesses the 4th element in an array that is only 3 elements long, leading to undefined behavior. Similarly, the behavior of the second line in the following code fragment is also not well defined:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" array"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\narray"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),a("p",[t._v("Note that pointing past the last element of an array is not undefined behavior ("),a("code",[t._v("beyond_array = array + 3")]),t._v(" is well defined here), but dereferencing it is ("),a("code",[t._v("*beyond_array")]),t._v(" is undefined behavior). This rule also holds for dynamically allocated memory (such as buffers created through "),a("code",[t._v("malloc")]),t._v(").")]),t._v(" "),a("h2",{attrs:{id:"returning-from-a-function-that-s-declared-with-noreturn-or-noreturn-function-specifier"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#returning-from-a-function-that-s-declared-with-noreturn-or-noreturn-function-specifier"}},[t._v("#")]),t._v(" Returning from a function that's declared with "),a("code",[t._v("_Noreturn")]),t._v(" or "),a("code",[t._v("noreturn")]),t._v(" function specifier")]),t._v(" "),a("p",[t._v("The function specifier "),a("code",[t._v("_Noreturn")]),t._v(" was introduced in C11. The header "),a("code",[t._v("<stdnoreturn.h>")]),t._v(" provides a macro "),a("code",[t._v("noreturn")]),t._v(" which expands to "),a("code",[t._v("_Noreturn")]),t._v(". So using "),a("code",[t._v("_Noreturn")]),t._v(" or "),a("code",[t._v("noreturn")]),t._v(" from "),a("code",[t._v("<stdnoreturn.h>")]),t._v(" is fine and equivalent.")]),t._v(" "),a("p",[t._v("A function that's declared with "),a("code",[t._v("_Noreturn")]),t._v(" (or "),a("code",[t._v("noreturn")]),t._v(") is not allowed to return to its caller. If such a function "),a("strong",[t._v("does")]),t._v(" return to its caller, the behavior is undefined.")]),t._v(" "),a("p",[t._v("In the following example, "),a("code",[t._v("func()")]),t._v(" is declared with "),a("code",[t._v("noreturn")]),t._v(" specifier but it returns to its caller.")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdio.h>")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdlib.h>")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdnoreturn.h>")])]),t._v("\n\nnoreturn "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("func")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("func")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"In func()...\\n"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Undefined behavior as func() returns */")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("func")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[a("code",[t._v("gcc")]),t._v(" and "),a("code",[t._v("clang")]),t._v(" produce warnings for the above program:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[t._v("$ gcc test"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("c\ntest"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("c"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" In function ‘func’"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\ntest"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("c"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" warning"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" ‘noreturn’ function does "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v("\n "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),t._v("\n$ clang test"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("c\ntest"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("c"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("9")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" warning"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" function declared "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'noreturn'")]),t._v(" should not "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Winvalid"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("noreturn"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("^")]),t._v("\n\n")])])]),a("p",[t._v("An example using "),a("code",[t._v("noreturn")]),t._v(" that has well-defined behavior:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdio.h>")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdlib.h>")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdnoreturn.h>")])]),t._v("\n\nnoreturn "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("my_exit")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* calls exit() and doesn't return to its caller. */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("my_exit")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Exiting...\\n"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("exit")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("my_exit")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("h2",{attrs:{id:"dereferencing-a-null-pointer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dereferencing-a-null-pointer"}},[t._v("#")]),t._v(" Dereferencing a null pointer")]),t._v(" "),a("p",[t._v("This is an example of dereferencing a NULL pointer, causing undefined behavior.")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" pointer "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" value "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("pointer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Dereferencing happens here */")]),t._v("\n\n")])])]),a("p",[t._v("A "),a("code",[t._v("NULL")]),t._v(" pointer is guaranteed by the C standard to compare unequal to any pointer to a valid object, and dereferencing it invokes undefined behavior.")]),t._v(" "),a("h2",{attrs:{id:"reading-an-uninitialized-object-that-is-not-backed-by-memory"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reading-an-uninitialized-object-that-is-not-backed-by-memory"}},[t._v("#")]),t._v(" Reading an uninitialized object  that is not backed by memory")]),t._v(" "),a("p",[t._v("Reading an object will cause undefined behavior, if the object is"),a("sup",[t._v("1")]),t._v(":")]),t._v(" "),a("ul",[a("li",[t._v("uninitialized")]),t._v(" "),a("li",[t._v("defined with automatic storage duration")]),t._v(" "),a("li",[t._v("it's address is never taken")])]),t._v(" "),a("p",[t._v("The variable a in the below example satisfies all those conditions:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" b "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n\n")])])]),a("p",[a("sup",[t._v("1")]),t._v(" (Quoted from: ISO:IEC 9899:201X 6.3.2.1 Lvalues, arrays, and function designators 2)"),a("br"),t._v("\nIf the lvalue designates an object of automatic storage duration that could have been declared with the register storage class (never had its address taken), and that object is uninitialized (not declared with an initializer and no assignment to it has been performed prior to use), the behavior is undefined.")]),t._v(" "),a("h2",{attrs:{id:"addition-or-subtraction-of-pointer-not-properly-bounded"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#addition-or-subtraction-of-pointer-not-properly-bounded"}},[t._v("#")]),t._v(" Addition or subtraction of pointer not properly bounded")]),t._v(" "),a("p",[t._v("The following code has undefined behavior:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" buffer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hello"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("ptr1 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" buffer "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* undefined behavior */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("ptr2 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" buffer "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* OK, pointing to the '\\0' inside the array */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("ptr3 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" buffer "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* OK, pointing to just beyond */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("ptr4 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" buffer "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* undefined behavior */")]),t._v("\n\n")])])]),a("p",[t._v("According to C11, if addition or subtraction of a pointer into, or just beyond, an array object and an integer type produces a result that does not point into, or just beyond, the same array object, the behavior is undefined (6.5.6).")]),t._v(" "),a("p",[t._v("Additionally it is naturally undefined behavior to "),a("strong",[t._v("dereference")]),t._v(" a pointer that points to just beyond the array:")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" buffer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"hello"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("ptr3 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" buffer "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* OK, pointing to just beyond */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" value "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("ptr3"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("       "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* undefined behavior */")]),t._v("\n\n")])])]),a("h2",{attrs:{id:"modifying-a-const-variable-using-a-pointer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#modifying-a-const-variable-using-a-pointer"}},[t._v("#")]),t._v(" Modifying a const variable using a pointer")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" foo_readonly "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("foo_ptr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    foo_ptr "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("foo_readonly"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* (1) This casts away the const qualifier */")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("foo_ptr "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* This is undefined behavior */")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[t._v("Quoting "),a("strong",[t._v("ISO/IEC 9899:201x")]),t._v(", section 6.7.3 §2:")]),t._v(" "),a("blockquote"),t._v(" "),a("p",[t._v("If an attempt is made to modify an object defined with a const-qualified type through use\nof  an  lvalue  with  non-const-qualified  type,  the  behavior  is  undefined. [...]")]),t._v(" "),a("p",[a("sup",[t._v("(1)")]),t._v(" In GCC this can throw the following warning: "),a("code",[t._v("warning: assignment discards ‘const’ qualifier from pointer target type [-Wdiscarded-qualifiers]")])]),t._v(" "),a("h2",{attrs:{id:"using-fflush-on-an-input-stream"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#using-fflush-on-an-input-stream"}},[t._v("#")]),t._v(" Using fflush on an input stream")]),t._v(" "),a("p",[t._v("The POSIX and C standards explicitly state that using "),a("code",[t._v("fflush")]),t._v(" on an input stream is undefined behavior. The "),a("code",[t._v("fflush")]),t._v(" is defined only for output streams.")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdio.h>")])]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" input"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("4096")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("scanf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"%i"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("fflush")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("stdin")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// <-- undefined behavior")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("gets")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("input"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[t._v("There is no standard way to discard unread characters from an input stream. On the other hand, some implementations uses "),a("code",[t._v("fflush")]),t._v(" to clear "),a("code",[t._v("stdin")]),t._v(" buffer. Microsoft defines the behavior of "),a("code",[t._v("fflush")]),t._v(" on an input stream: If the stream is open for input, "),a("code",[t._v("fflush")]),t._v(" clears the contents of the buffer. According to POSIX.1-2008, the behavior of "),a("code",[t._v("fflush")]),t._v(" is undefined unless the input file is seekable.")]),t._v(" "),a("p",[t._v("See "),a("a",{attrs:{href:"http://stackoverflow.com/questions/2979209/using-fflushstdin",target:"_blank",rel:"noopener noreferrer"}},[t._v("Using "),a("code",[t._v("fflush(stdin)")]),a("OutboundLink")],1),t._v(" for many more details.")]),t._v(" "),a("h2",{attrs:{id:"missing-return-statement-in-value-returning-function"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#missing-return-statement-in-value-returning-function"}},[t._v("#")]),t._v(" Missing return statement in value returning function")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* do stuff */")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* no return here */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Trying to use the (not) returned value causes UB */")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" value "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[t._v("When a function is declared to return a value then it has to do so on every possible code path through it. Undefined behavior occurs as soon as the caller (which is expecting a return value) tries to use the return value"),a("sup",[t._v("1")]),t._v(".")]),t._v(" "),a("p",[t._v("Note that the undefined behaviour happens "),a("strong",[t._v("only if")]),t._v(" the caller attempts to use/access the value from the function. For example,")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* do stuff */")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* no return here */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* The value (not) returned from foo() is unused. So, this program\n   * doesn't cause *undefined behaviour*. */")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[t._v("The "),a("code",[t._v("main()")]),t._v(" function is an exception to this rule in that it is possible for it to be terminated without a return statement because an assumed return value of "),a("code",[t._v("0")]),t._v(" will automatically be used in this case"),a("sup",[t._v("2")]),t._v(".")]),t._v(" "),a("p",[a("sup",[t._v("1")]),t._v(" ("),a("strong",[t._v("ISO/IEC 9899:201x")]),t._v(", 6.9.1/12)")]),t._v(" "),a("blockquote"),t._v(" "),a("p",[t._v("If the } that terminates a function is reached, and the value of the function call is used by the caller, the behavior is undefined.")]),t._v(" "),a("p",[a("sup",[t._v("2")]),t._v(" ("),a("strong",[t._v("ISO/IEC 9899:201x")]),t._v(", 5.1.2.2.3/1)")]),t._v(" "),a("blockquote"),t._v(" "),a("p",[t._v("reaching the } that terminates the main function returns a value of 0.")]),t._v(" "),a("h2",{attrs:{id:"division-by-zero"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#division-by-zero"}},[t._v("#")]),t._v(" Division by zero")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" y "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* integer division */")]),t._v("\n\n")])])]),a("p",[t._v("or")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),t._v(" y "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5.0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* floating point division */")]),t._v("\n\n")])])]),a("p",[t._v("or")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" y "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v(" x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* modulo operation */")]),t._v("\n\n")])])]),a("p",[t._v("For the second line in each example, where the value of the second operand (x) is zero, the behaviour is undefined.")]),t._v(" "),a("p",[t._v("Note that most "),a("a",{attrs:{href:"http://stackoverflow.com/documentation/c/4832/implementation-defined-behaviour#t=201609301837209070127&a=remarks-overview-0",target:"_blank",rel:"noopener noreferrer"}},[t._v("implementations"),a("OutboundLink")],1),t._v(" of floating point math will "),a("a",{attrs:{href:"http://stackoverflow.com/a/12617974/1462295",target:"_blank",rel:"noopener noreferrer"}},[t._v("follow a standard"),a("OutboundLink")],1),t._v(" (e.g. IEEE 754), in which case operations like divide-by-zero will have consistent results (e.g., "),a("code",[t._v("INFINITY")]),t._v(") even though the C standard says the operation is undefined.")]),t._v(" "),a("h2",{attrs:{id:"inconsistent-linkage-of-identifiers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#inconsistent-linkage-of-identifiers"}},[t._v("#")]),t._v(" Inconsistent linkage of identifiers")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extern")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" var"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" var"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Undefined behaviour */")]),t._v("\n\n")])])]),a("p",[a("strong",[t._v("C11, §6.2.2, 7")]),t._v(" says:")]),t._v(" "),a("blockquote"),t._v(" "),a("p",[t._v("If, within a translation unit, the same identiﬁer appears with both\ninternal and external linkage, the behavior is undeﬁned.")]),t._v(" "),a("p",[t._v("Note that if an prior declaration of an identifier is visible then it'll have the prior declaration's linkage. "),a("strong",[t._v("C11, §6.2.2, 4")]),t._v(" allows it:")]),t._v(" "),a("blockquote"),t._v(" "),a("p",[t._v("For an identiﬁer declared with the storage-class speciﬁer extern in a\nscope in which a prior declaration of that identiﬁer is visible,31) if\nthe prior declaration speciﬁes internal or external linkage, the\nlinkage of the identiﬁer at the later declaration is the same as the\nlinkage speciﬁed at the prior declaration. If no prior declaration is\nvisible, or if the prior declaration speciﬁes no linkage, then the\nidentiﬁer has external linkage.")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 1. This is NOT undefined */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" var"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extern")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" var"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 2. This is NOT undefined */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" var"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" var"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 3. This is NOT undefined */")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extern")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" var"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extern")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" var"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n\n")])])]),a("h2",{attrs:{id:"conversion-between-pointer-types-produces-incorrectly-aligned-result"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#conversion-between-pointer-types-produces-incorrectly-aligned-result"}},[t._v("#")]),t._v(" Conversion between pointer types produces incorrectly aligned result")]),t._v(" "),a("p",[t._v("The following "),a("strong",[t._v("might")]),t._v(" have undefined behavior due to incorrect pointer alignment:")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("\nchar *memory_block = calloc(sizeof(uint32_t) + 1, 1);\n uint32_t *intptr = (uint32_t*)(memory_block + 1);  /* possible undefined behavior */\n uint32_t mvalue = *intptr;\n\n")])])]),a("p",[t._v("The undefined behavior happens as the pointer is converted. According to C11, if a "),a("strong",[t._v("conversion between two pointer types produces a result that is incorrectly aligned (6.3.2.3), the behavior is undefined")]),t._v(". Here an "),a("code",[t._v("uint32_t")]),t._v(" could require alignment of 2 or 4 for example.")]),t._v(" "),a("p",[a("code",[t._v("calloc")]),t._v(" on the other hand is required to return a pointer that is suitably aligned for any object type; thus "),a("code",[t._v("memory_block")]),t._v(" is properly aligned to contain an "),a("code",[t._v("uint32_t")]),t._v(" in its initial part.  Then, on a system where "),a("code",[t._v("uint32_t")]),t._v(" has required alignment of 2 or 4, "),a("code",[t._v("memory_block + 1")]),t._v(" will be an "),a("strong",[t._v("odd")]),t._v(" address and thus not properly aligned.")]),t._v(" "),a("p",[t._v("Observe that the C standard requests that already the cast operation is undefined. This is imposed because on platforms where addresses are segmented, the byte address "),a("code",[t._v("memory_block + 1")]),t._v(" may not even have a proper representation as an integer pointer.")]),t._v(" "),a("p",[t._v("Casting "),a("code",[t._v("char *")]),t._v(" to pointers to other types without any concern to alignment requirements is sometimes incorrectly used for decoding packed structures such as file headers or network packets.")]),t._v(" "),a("p",[t._v("You can avoid the undefined behavior arising from misaligned pointer conversion by using "),a("code",[t._v("memcpy")]),t._v(":")]),t._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("memcpy")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("mvalue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" memory_block "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("sizeof")]),t._v(" mvalue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),a("p",[t._v("Here no pointer conversion to "),a("code",[t._v("uint32_t*")]),t._v(" takes place and the bytes are copied one by one.")]),t._v(" "),a("p",[t._v("This copy operation for our example only leads to valid value of "),a("code",[t._v("mvalue")]),t._v(" because:")]),t._v(" "),a("ul",[a("li",[t._v("We used "),a("code",[t._v("calloc")]),t._v(", so the bytes are properly initialized. In our case all bytes have value "),a("code",[t._v("0")]),t._v(", but any other proper initialization would do.")]),t._v(" "),a("li",[a("code",[t._v("uint32_t")]),t._v(" is an exact width type and has no padding bits")]),t._v(" "),a("li",[t._v("Any arbitrary bit pattern is a valid representation for any unsigned type.")])]),t._v(" "),a("h2",{attrs:{id:"modifying-the-string-returned-by-getenv-strerror-and-setlocale-functions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#modifying-the-string-returned-by-getenv-strerror-and-setlocale-functions"}},[t._v("#")]),t._v(" Modifying the string returned by getenv, strerror, and setlocale functions")]),t._v(" "),a("p",[t._v("Modifying the strings returned by the standard functions "),a("code",[t._v("getenv()")]),t._v(", "),a("code",[t._v("strerror()")]),t._v(" and "),a("code",[t._v("setlocale()")]),t._v(" is undefined. So, implementations may use static storage for these strings.")]),t._v(" "),a("p",[a("strong",[t._v("The getenv() function, C11, §7.22.4.7, 4")]),t._v(", says:")]),t._v(" "),a("blockquote"),t._v(" "),a("p",[t._v("The getenv function returns a pointer to a string associated with the\nmatched list member. The string pointed to shall not be modified by the\nprogram, but may be overwritten by a subsequent call to the getenv\nfunction.")]),t._v(" "),a("p",[a("strong",[t._v("The strerror() function, C11, §7.23.6.3, 4")]),t._v(" says:")]),t._v(" "),a("blockquote"),t._v(" "),a("p",[t._v("The strerror function returns a pointer to the string, the contents of\nwhich are localespeciﬁc. The array pointed to shall not be modified by\nthe program, but may be overwritten by a subsequent call to the\nstrerror function.")]),t._v(" "),a("p",[a("strong",[t._v("The setlocale() function, C11, §7.11.1.1, 8")]),t._v(" says:")]),t._v(" "),a("blockquote"),t._v(" "),a("p",[t._v("The pointer to string returned by the setlocale function is such that\na subsequent call with that string value and its associated category\nwill restore that part of the program’s locale. The string pointed to\nshall not be modified by the program, but may be overwritten by a\nsubsequent call to the setlocale function.")]),t._v(" "),a("p",[t._v("Similarly the "),a("code",[t._v("localeconv()")]),t._v(" function returns a pointer to "),a("code",[t._v("struct lconv")]),t._v(" which shall not be modified.")]),t._v(" "),a("p",[a("strong",[t._v("The localeconv() function, C11, §7.11.2.1, 8")]),t._v(" says:")]),t._v(" "),a("blockquote"),t._v(" "),a("p",[t._v("The localeconv function returns a pointer to the filled-in object. The\nstructure pointed to by the return value shall not be modified by the\nprogram, but may be overwritten by a subsequent call to the localeconv\nfunction.")]),t._v(" "),a("h4",{attrs:{id:"remarks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#remarks"}},[t._v("#")]),t._v(" Remarks")]),t._v(" "),a("p",[a("strong",[t._v("What is Undefined Behavior (UB)?")])]),t._v(" "),a("p",[a("strong",[t._v("Undefined behavior")]),t._v(" is a term used in the C standard. The C11 standard (ISO/IEC 9899:2011) defines the term undefined behavior as")]),t._v(" "),a("blockquote"),t._v(" "),a("p",[t._v("behavior, upon use of a nonportable or erroneous program construct or of erroneous data, for which this International Standard imposes no requirements")]),t._v(" "),a("p",[a("strong",[t._v("What happens if there is UB in my code?")])]),t._v(" "),a("p",[t._v("These are the results which can happen due to undefined behavior according to standard:")]),t._v(" "),a("blockquote"),t._v(" "),a("p",[t._v("NOTE Possible undefined behavior ranges from ignoring the situation\ncompletely with unpredictable results, to behaving during translation\nor program execution in a documented manner characteristic of the\nenvironment (with or without the issuance of a diagnostic message), to\nterminating a translation or execution (with the issuance of a\ndiagnostic message).")]),t._v(" "),a("p",[t._v("The following quote is often used to describe (less formally though) results happening from undefined behavior:")]),t._v(" "),a("blockquote"),t._v(" "),a("p",[t._v("“When the compiler encounters [a given undefined construct] it is\nlegal for it to make demons fly out of your nose” (the implication is\nthat the compiler may choose any arbitrarily bizarre way to interpret\nthe code without violating the ANSI C standard)")]),t._v(" "),a("p",[a("strong",[t._v("Why does UB exist?")])]),t._v(" "),a("p",[t._v("If it's so bad, why didn't they just define it or make it implementation-defined?")]),t._v(" "),a("p",[t._v("Undefined behavior allows more opportunities for optimization; The compiler can justifiably assume that any code does not contain undefined behaviour, which can allow it to avoid run-time checks and perform optimizations whose validity would be costly or impossible to prove otherwise.")]),t._v(" "),a("p",[a("strong",[t._v("Why is UB hard to track down?")])]),t._v(" "),a("p",[t._v("There are at least two reasons why undefined behavior creates bugs that are difficult to detect:")]),t._v(" "),a("ul",[a("li",[t._v("The compiler is not required to - and generally can't reliably - warn you about undefined behavior. In fact requiring it to do so would go directly against the reason for the existence of undefined behaviour.")]),t._v(" "),a("li",[t._v("The unpredictable results might not start unfolding at the exact point of the operation where the construct whose behavior is undefined occurs; Undefined behaviour taints the whole execution and its effects may happen at any time: During, after, or even "),a("strong",[t._v("before")]),t._v(" the undefined construct.")])]),t._v(" "),a("p",[t._v("Consider null-pointer dereference: the compiler is not required to diagnose null-pointer dereference, and even could not, as at run-time any pointer passed into a function, or in a global variable might be null. "),a("strong",[t._v("And when the null-pointer dereference occurs, the standard does not mandate that the program needs to crash.")]),t._v(" Rather, the program might crash earlier, later, or not crash at all; it could even behave as if the null pointer pointed to a valid object, and behave completely normally, only to crash under other circumstances.")]),t._v(" "),a("p",[t._v("In the case of null-pointer dereference, C language differs from managed languages such as Java or C#, where the behavior of null-pointer dereference is "),a("strong",[t._v("defined")]),t._v(": an exception is thrown, at the exact time ("),a("code",[t._v("NullPointerException")]),t._v(" in Java, "),a("code",[t._v("NullReferenceException")]),t._v(" in C#), thus those coming from Java or C# might "),a("strong",[t._v("incorrectly believe that in such a case, a C program must crash, with or without the issuance of a diagnostic message")]),t._v(".")]),t._v(" "),a("p",[a("strong",[t._v("Additional information")])]),t._v(" "),a("p",[t._v("There are several such situations that should be clearly distinguished:")]),t._v(" "),a("ul",[a("li",[t._v("Explicitly undefined behavior, that is where the C standard explicitly tells you that you are off limits.")]),t._v(" "),a("li",[t._v("Implicitly undefined behavior, where there is simply no text in the standard that foresees a behavior for the situation you brought your program in.")])]),t._v(" "),a("p",[t._v("Also have in mind that in many places the behavior of certain constructs is deliberately undefined by the C standard to leave room for compiler and library implementors to come up with their own definitions. A good example are signals and signal handlers, where extensions to C, such as the POSIX operating system standard, define much more elaborated rules. In such cases you just have to check the documentation of your platform; the C standard can't tell you anything.")]),t._v(" "),a("p",[t._v("Also note that if undefined behavior occurs in program it doesn't mean that just the point where undefined behavior occurred is problematic, rather entire program becomes meaningless.")]),t._v(" "),a("p",[t._v("Because of such concerns it is important (especially since compilers don't always warn us about UB) for person programming in C to be at least familiar with the kind of things that trigger undefined behavior.")]),t._v(" "),a("p",[t._v("It should be noted there are some tools (e.g. static analysis tools such as PC-Lint) which aid in detecting undefined behavior, but again, they can't detect all occurrences of undefined behavior.")])])}),[],!1,null,null,null);e.default=n.exports}}]);