(window.webpackJsonp=window.webpackJsonp||[]).push([[1235],{1643:function(a,t,e){"use strict";e.r(t);var s=e(31),r=Object(s.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"type-classes"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#type-classes"}},[a._v("#")]),a._v(" Type Classes")]),a._v(" "),e("p",[a._v("Typeclasses in Haskell are a means of defining the behaviour associated with a type separately from that type's definition. Whereas, say, in Java, you'd define the behaviour as part of the type's definition -- i.e. in an interface, abstract class or concrete class -- Haskell keeps these two things separate.")]),a._v(" "),e("p",[a._v("There are a number of typeclasses already defined in Haskell's "),e("code",[a._v("base")]),a._v(" package. The relationship between these is illustrated in the Remarks section below.")]),a._v(" "),e("h2",{attrs:{id:"eq"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#eq"}},[a._v("#")]),a._v(" Eq")]),a._v(" "),e("p",[a._v("All basic datatypes (like "),e("code",[a._v("Int")]),a._v(", "),e("code",[a._v("String")]),a._v(", "),e("code",[a._v("Eq a => [a]")]),a._v(") from Prelude except for functions and "),e("code",[a._v("IO")]),a._v(" have instances of "),e("code",[a._v("Eq")]),a._v(". If a type instantiates "),e("code",[a._v("Eq")]),a._v(" it means that we know how to compare two values for "),e("strong",[a._v("value")]),a._v(" or "),e("strong",[a._v("structural")]),a._v(" equality.")]),a._v(" "),e("div",{staticClass:"language-hs extra-class"},[e("pre",{pre:!0,attrs:{class:"language-hs"}},[e("code",[e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),a._v(" \n"),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("False")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("True")]),a._v("\n\n")])])]),e("h3",{attrs:{id:"required-methods"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#required-methods"}},[a._v("#")]),a._v(" Required methods")]),a._v(" "),e("ul",[e("li",[e("code",[a._v("(==) :: Eq a => a -> a -> Boolean")]),a._v(" or "),e("code",[a._v("(/=) :: Eq a => a -> a -> Boolean")]),a._v(" (if only one is implemented, the other defaults to the negation of the defined one)")])]),a._v(" "),e("h3",{attrs:{id:"defines"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#defines"}},[a._v("#")]),a._v(" Defines")]),a._v(" "),e("ul",[e("li",[e("code",[a._v("(==) :: Eq a => a -> a -> Boolean")])]),a._v(" "),e("li",[e("code",[a._v("(/=) :: Eq a => a -> a -> Boolean")])])]),a._v(" "),e("h3",{attrs:{id:"direct-superclasses"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#direct-superclasses"}},[a._v("#")]),a._v(" Direct superclasses")]),a._v(" "),e("p",[a._v("None")]),a._v(" "),e("h3",{attrs:{id:"notable-subclasses"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#notable-subclasses"}},[a._v("#")]),a._v(" Notable subclasses")]),a._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://stackoverflow.com/documentation/haskell/1879/type-classes/7440/ord",target:"_blank",rel:"noopener noreferrer"}},[e("code",[a._v("Ord")]),e("OutboundLink")],1)])]),a._v(" "),e("h2",{attrs:{id:"ord"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ord"}},[a._v("#")]),a._v(" Ord")]),a._v(" "),e("p",[a._v("Types instantiating "),e("code",[a._v("Ord")]),a._v(" include, e.g., "),e("code",[a._v("Int")]),a._v(", "),e("code",[a._v("String")]),a._v(", and "),e("code",[a._v("[a]")]),a._v(" (for types "),e("code",[a._v("a")]),a._v(" where there's an "),e("code",[a._v("Ord a")]),a._v(" instance). If a type instantiates "),e("code",[a._v("Ord")]),a._v(" it means that we know a “natural” ordering of values of that type. Note, there are often many possible choices of the “natural” ordering of a type and "),e("code",[a._v("Ord")]),a._v(" forces us to favor one.")]),a._v(" "),e("p",[e("code",[a._v("Ord")]),a._v(" provides the standard "),e("code",[a._v("(<=)")]),a._v(", "),e("code",[a._v("(<)")]),a._v(", "),e("code",[a._v("(>)")]),a._v(", "),e("code",[a._v("(>=)")]),a._v(" operators but interestingly defines them all using a custom algebraic data type")]),a._v(" "),e("div",{staticClass:"language-hs extra-class"},[e("pre",{pre:!0,attrs:{class:"language-hs"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("data")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Ordering")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("LT")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("EQ")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("GT")]),a._v("\n\n"),e("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("compare")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Ord")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Ordering")]),a._v("\n\n")])])]),e("h3",{attrs:{id:"required-methods-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#required-methods-2"}},[a._v("#")]),a._v(" Required methods")]),a._v(" "),e("ul",[e("li",[e("code",[a._v("compare :: Ord a => a -> a -> Ordering")]),a._v(" or "),e("code",[a._v("(<=) :: Ord a => a -> a -> Boolean")]),a._v(" (the standard’s default "),e("code",[a._v("compare")]),a._v(" method uses "),e("code",[a._v("(<=)")]),a._v(" in its implementation)")])]),a._v(" "),e("h3",{attrs:{id:"defines-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#defines-2"}},[a._v("#")]),a._v(" Defines")]),a._v(" "),e("ul",[e("li",[e("code",[a._v("compare :: Ord a => a -> a -> Ordering")])]),a._v(" "),e("li",[e("code",[a._v("(<=) :: Ord a => a -> a -> Boolean")])]),a._v(" "),e("li",[e("code",[a._v("(<) :: Ord a => a -> a -> Boolean")])]),a._v(" "),e("li",[e("code",[a._v("(>=) :: Ord a => a -> a -> Boolean")])]),a._v(" "),e("li",[e("code",[a._v("(>) :: Ord a => a -> a -> Boolean")])]),a._v(" "),e("li",[e("code",[a._v("min :: Ord a => a -> a -> a")])]),a._v(" "),e("li",[e("code",[a._v("max :: Ord a => a -> a -> a")])])]),a._v(" "),e("h3",{attrs:{id:"direct-superclasses-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#direct-superclasses-2"}},[a._v("#")]),a._v(" Direct superclasses")]),a._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://stackoverflow.com/documentation/haskell/1879/type-classes/7439/eq",target:"_blank",rel:"noopener noreferrer"}},[e("code",[a._v("Eq")]),e("OutboundLink")],1)])]),a._v(" "),e("h2",{attrs:{id:"monoid"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#monoid"}},[a._v("#")]),a._v(" Monoid")]),a._v(" "),e("p",[a._v("Types instantiating "),e("a",{attrs:{href:"http://stackoverflow.com/documentation/haskell/2211/monoid#t=201607241111111418916",target:"_blank",rel:"noopener noreferrer"}},[e("code",[a._v("Monoid")]),e("OutboundLink")],1),a._v(" include lists, numbers, and functions with "),e("code",[a._v("Monoid")]),a._v(" return values, among others. To instantiate "),e("code",[a._v("Monoid")]),a._v(" a type must support an associative binary operation ("),e("code",[a._v("mappend")]),a._v(" or "),e("code",[a._v("(<>)")]),a._v(') which combines its values, and have  a special "zero" value ('),e("code",[a._v("mempty")]),a._v(") such that combining a value with it does not change that value:")]),a._v(" "),e("div",{staticClass:"language-hs extra-class"},[e("pre",{pre:!0,attrs:{class:"language-hs"}},[e("code",[e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("mempty")]),a._v("  "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<>")]),a._v("  "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<>")]),a._v("  "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("mempty")]),a._v("  "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v("\n\n"),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<>")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("y")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<>")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("z")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<>")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("y")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<>")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("z")]),a._v("\n\n")])])]),e("p",[a._v("Intuitively, "),e("code",[a._v("Monoid")]),a._v(' types are "list-like" in that they support appending values together. Alternatively, '),e("code",[a._v("Monoid")]),a._v(" types can be thought of as sequences of values for which we care about the order but not the grouping. For instance, a binary tree is a "),e("code",[a._v("Monoid")]),a._v(", but using the "),e("code",[a._v("Monoid")]),a._v(" operations we cannot witness its branching structure, only a traversal of its values (see "),e("code",[a._v("Foldable")]),a._v(" and "),e("code",[a._v("Traversable")]),a._v(").")]),a._v(" "),e("h3",{attrs:{id:"required-methods-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#required-methods-3"}},[a._v("#")]),a._v(" Required methods")]),a._v(" "),e("ul",[e("li",[e("code",[a._v("mempty :: Monoid m => m")])]),a._v(" "),e("li",[e("code",[a._v("mappend :: Monoid m => m -> m -> m")])])]),a._v(" "),e("h3",{attrs:{id:"direct-superclasses-3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#direct-superclasses-3"}},[a._v("#")]),a._v(" Direct superclasses")]),a._v(" "),e("p",[a._v("None")]),a._v(" "),e("h2",{attrs:{id:"num"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#num"}},[a._v("#")]),a._v(" Num")]),a._v(" "),e("p",[a._v("The most general class for number types, more precisely for "),e("a",{attrs:{href:"https://en.wikipedia.org/wiki/Ring_(mathematics)",target:"_blank",rel:"noopener noreferrer"}},[a._v("rings"),e("OutboundLink")],1),a._v(", i.e. numbers that can be added and subtracted and multiplied in the usual sense, but not necessarily divided.")]),a._v(" "),e("p",[a._v("This class contains both integral types ("),e("code",[a._v("Int")]),a._v(", "),e("code",[a._v("Integer")]),a._v(", "),e("code",[a._v("Word32")]),a._v(" etc.) and fractional types ("),e("code",[a._v("Double")]),a._v(", "),e("code",[a._v("Rational")]),a._v(", also complex numbers etc.). In case of finite types, the semantics are generally understood as "),e("strong",[a._v("modular arithmetic")]),a._v(", i.e. with over- and underflow"),e("sup",[a._v("†")]),a._v(".")]),a._v(" "),e("p",[a._v("Note that the rules for the numerical classes are much less strictly obeyed than the "),e("a",{attrs:{href:"http://stackoverflow.com/documentation/haskell/2968/monads/6144/monad-laws-and-the-maybe-monad#t=201610010024186706477",target:"_blank",rel:"noopener noreferrer"}},[a._v("monad"),e("OutboundLink")],1),a._v(" or monoid laws, or those for "),e("a",{attrs:{href:"http://stackoverflow.com/documentation/haskell/2264/standard-and-popular-type-classes/7439/eq",target:"_blank",rel:"noopener noreferrer"}},[a._v("equality comparison"),e("OutboundLink")],1),a._v(". In particular, floating-point numbers generally obey laws only in a approximate sense.")]),a._v(" "),e("h3",{attrs:{id:"the-methods"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#the-methods"}},[a._v("#")]),a._v(" The methods")]),a._v(" "),e("li",[a._v("\n`fromInteger :: Num a => Integer -> a`. convert an integer to the general number type (wrapping around the range, if necessary). Haskell [number literals](http://stackoverflow.com/documentation/haskell/369/overloaded-literals/1243/integer-numeral) can be understood as a monomorphic `Integer` literal with the general conversion around it, so you can use the literal `5` in both an `Int` context and a `Complex Double` setting.\n")]),a._v(" "),e("li",[a._v("\n`(+) :: Num a => a -> a -> a`. Standard addition, generally understood as associative and commutative, i.e.,\n"),e("div",{staticClass:"language-hs extra-class"},[e("pre",{pre:!0,attrs:{class:"language-hs"}},[e("code",[a._v("  "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" ≡ "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c")]),a._v("\n  "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v(" ≡ "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v("\n\n")])])])]),a._v(" "),e("li",[a._v("\n`(-) :: Num a => a -> a -> a`. Subtraction, which is the inverse of addition:\n"),e("div",{staticClass:"language-hs extra-class"},[e("pre",{pre:!0,attrs:{class:"language-hs"}},[e("code",[a._v("  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v(" ≡ "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v(" ≡ "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v("\n\n")])])])]),a._v(" "),e("li",[a._v("\n`(*) :: Num a => a -> a -> a`. Multiplication, an associative operation that's distributive over addition:\n"),e("div",{staticClass:"language-hs extra-class"},[e("pre",{pre:!0,attrs:{class:"language-hs"}},[e("code",[a._v("  "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" ≡ "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c")]),a._v("\n  "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" ≡ "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c")]),a._v("\n\n")])])]),e("p",[a._v("for the most common instances, multiplication is also commutative, but this is definitely not a requirement.\n")])]),a._v(" "),e("li",[e("code",[a._v("negate :: Num a => a -> a")]),a._v(". The full name of the unary negation operator. "),e("code",[a._v("-1")]),a._v(" is syntactic sugar for "),e("code",[a._v("negate 1")]),a._v("."),e("p"),a._v(" "),e("div",{staticClass:"language-hs extra-class"},[e("pre",{pre:!0,attrs:{class:"language-hs"}},[e("code",[a._v("  "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" ≡ "),e("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("negate")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" ≡ "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v("\n\n")])])])]),a._v(" "),e("li",[a._v("\n`abs :: Num a => a -> a`. The absolute-value function always gives a non-negative result of the same magnitude\n"),e("div",{staticClass:"language-hs extra-class"},[e("pre",{pre:!0,attrs:{class:"language-hs"}},[e("code",[a._v("  "),e("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("abs")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" ≡ "),e("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("abs")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v("\n  "),e("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("abs")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("abs")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" ≡ "),e("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("abs")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v("\n\n")])])]),e("p",[e("code",[a._v("abs a ≡ 0")]),a._v(" should only happen if "),e("code",[a._v("a ≡ 0")]),a._v(".\nFor "),e("a",{attrs:{href:"http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Real",target:"_blank",rel:"noopener noreferrer"}},[a._v("real"),e("OutboundLink")],1),a._v(" types it's clear what non-negative means: you always have "),e("code",[a._v("abs a >= 0")]),a._v(". Complex etc. types don't have a well-defined ordering, however the result of "),e("code",[a._v("abs")]),a._v(" should always lie in the real subset"),e("sup",[a._v("‡")]),a._v(" (i.e. give a number that could also be written as a single number literal without negation).\n")])]),a._v(" "),e("li",[e("code",[a._v("signum :: Num a => a -> a")]),a._v(". The sign function, according to the name, yields only "),e("code",[a._v("-1")]),a._v(" or "),e("code",[a._v("1")]),a._v(", depending on the sign of the argument. Actually, that's only true for nonzero real numbers; in general "),e("code",[a._v("signum")]),a._v(" is better understood as the "),e("strong",[a._v("normalising")]),a._v(" function:"),e("p"),a._v(" "),e("div",{staticClass:"language-hs extra-class"},[e("pre",{pre:!0,attrs:{class:"language-hs"}},[e("code",[a._v("  "),e("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("abs")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("signum")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" ≡ "),e("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v("   "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("-- unless a≡0")]),a._v("\n  "),e("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("signum")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("abs")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" ≡ "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("-- This is required to be true for all Num instances")]),a._v("\n\n")])])]),e("p",[a._v("Note that "),e("a",{attrs:{href:"https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1390006.4.4",target:"_blank",rel:"noopener noreferrer"}},[a._v("section 6.4.4 of the Haskell 2010 Report"),e("OutboundLink")],1),a._v(" explicitly requires this last equality to hold for any valid "),e("code",[a._v("Num")]),a._v(" instance.\n")])]),e("p"),a._v(" "),e("p",[a._v("Some libraries, notably "),e("a",{attrs:{href:"http://hackage.haskell.org/package/linear",target:"_blank",rel:"noopener noreferrer"}},[a._v("linear"),e("OutboundLink")],1),a._v(" and "),e("a",{attrs:{href:"http://hackage.haskell.org/package/hmatrix",target:"_blank",rel:"noopener noreferrer"}},[a._v("hmatrix"),e("OutboundLink")],1),a._v(", have a much laxer understanding of what the "),e("code",[a._v("Num")]),a._v(" class is for: they treat it just as "),e("strong",[a._v("a way to overload the arithmetic operators")]),a._v(". While this is pretty straightforward for "),e("code",[a._v("+")]),a._v(" and "),e("code",[a._v("-")]),a._v(", it already becomes troublesome with "),e("code",[a._v("*")]),a._v(" and more so with the other methods. For instance, "),e("strong",[a._v("should "),e("code",[a._v("*")]),a._v(" mean matrix multiplication or element-wise multiplication?")]),a._v(" "),e("br"),a._v("\nIt is arguably a bad idea to define such non-number instances; please consider dedicated classes such as "),e("a",{attrs:{href:"http://hackage.haskell.org/package/vector-space-0.10.2/docs/Data-VectorSpace.html",target:"_blank",rel:"noopener noreferrer"}},[e("code",[a._v("VectorSpace")]),e("OutboundLink")],1),a._v(".")]),a._v(" "),e("p",[e("sup",[a._v("†")]),a._v(" "),e("sub",[a._v("In particular, the “negatives” of unsigned types are wrapped around to large positive, e.g. "),e("code",[a._v("(-4 :: Word32) == 4294967292")]),a._v(".")])]),a._v(" "),e("p",[e("sup",[a._v("‡")]),a._v(" "),e("sub",[a._v("This is widely "),e("strong",[a._v("not")]),a._v(" fulfilled: vector types do not have a real subset. The controversial "),e("code",[a._v("Num")]),a._v("-instances for such types generally define "),e("code",[a._v("abs")]),a._v(" and "),e("code",[a._v("signum")]),a._v(" element-wise, which mathematically speaking doesn't really make sense.")])]),a._v(" "),e("h2",{attrs:{id:"maybe-and-the-functor-class"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#maybe-and-the-functor-class"}},[a._v("#")]),a._v(" Maybe and the Functor Class")]),a._v(" "),e("p",[a._v("In Haskell, data types can have arguments just like functions. Take the "),e("code",[a._v("Maybe")]),a._v(" type for example.")]),a._v(" "),e("p",[e("code",[a._v("Maybe")]),a._v(" is a very useful type which allows us to represent the idea of failure, or the possiblity thereof. In other words, if there is a possibility that a computation will fail, we use the "),e("code",[a._v("Maybe")]),a._v(" type there. "),e("code",[a._v("Maybe")]),a._v(" acts kind of like a wrapper for other types, giving them additional functionality.")]),a._v(" "),e("p",[a._v("Its actual declaration is fairly simple.")]),a._v(" "),e("div",{staticClass:"language-hs extra-class"},[e("pre",{pre:!0,attrs:{class:"language-hs"}},[e("code",[e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Maybe")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Just")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Nothing")]),a._v("\n\n")])])]),e("p",[a._v("What this tells is that a "),e("code",[a._v("Maybe")]),a._v(" comes in two forms, a "),e("code",[a._v("Just")]),a._v(", which represents success, and a "),e("code",[a._v("Nothing")]),a._v(", which represents failure. "),e("code",[a._v("Just")]),a._v(" takes one argument which determines the type of the "),e("code",[a._v("Maybe")]),a._v(", and "),e("code",[a._v("Nothing")]),a._v(" takes none. For example, the value "),e("code",[a._v('Just "foo"')]),a._v(" will have type "),e("code",[a._v("Maybe String")]),a._v(", which is a string type wrapped with the additional "),e("code",[a._v("Maybe")]),a._v(" functionality. The value "),e("code",[a._v("Nothing")]),a._v(" has type "),e("code",[a._v("Maybe a")]),a._v(" where "),e("code",[a._v("a")]),a._v(" can be any type.")]),a._v(" "),e("p",[a._v("This idea of wrapping types to give them additional functionality is a very useful one, and is applicable to more than just "),e("code",[a._v("Maybe")]),a._v(". Other examples include the "),e("code",[a._v("Either")]),a._v(", "),e("code",[a._v("IO")]),a._v(" and list types, each providing different functionality.  However, there are some actions and abilities which are common to all of these wrapper types. The most notable of these is the ability to modify the encapsulated value.")]),a._v(" "),e("p",[a._v("It is common to think of these kinds of types as boxes which can have values placed in them. Different boxes hold different values and do different things, but none are useful without being able to access the contents within.")]),a._v(" "),e("p",[a._v("To encapsulate this idea, Haskell comes with a standard typeclass, named "),e("code",[a._v("Functor")]),a._v(". It is defined as follows.")]),a._v(" "),e("div",{staticClass:"language-hs extra-class"},[e("pre",{pre:!0,attrs:{class:"language-hs"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Functor")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("f")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v("\n  "),e("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("fmap")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("f")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("f")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v("\n\n")])])]),e("p",[a._v("As can be seen, the class has a single function, "),e("code",[a._v("fmap")]),a._v(", of two arguments. The first argument is a function from one type, "),e("code",[a._v("a")]),a._v(", to another, "),e("code",[a._v("b")]),a._v(". The second argument is a functor (wrapper type) containing a value of type "),e("code",[a._v("a")]),a._v(". It returns a functor (wrapper type) containing a value of type "),e("code",[a._v("b")]),a._v(".")]),a._v(" "),e("p",[a._v("In simple terms, "),e("code",[a._v("fmap")]),a._v(" takes a function and applies to the value inside of a functor. It is the only function necessary for a type to be a member of the "),e("code",[a._v("Functor")]),a._v(" class, but it is extremely useful. Functions operating on functors that have more specific applications can be found in the "),e("code",[a._v("Applicative")]),a._v(" and "),e("code",[a._v("Monad")]),a._v(" typeclasses.")]),a._v(" "),e("h2",{attrs:{id:"type-class-inheritance-ord-type-class"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#type-class-inheritance-ord-type-class"}},[a._v("#")]),a._v(" Type class inheritance: Ord type class")]),a._v(" "),e("p",[a._v("Haskell supports a notion of class extension. For example, the class "),e("code",[a._v("Ord")]),a._v(" inherits all of the operations in "),e("code",[a._v("Eq")]),a._v(", but in addition has a "),e("code",[a._v("compare")]),a._v(" function that returns an "),e("code",[a._v("Ordering")]),a._v(" between values. "),e("code",[a._v("Ord")]),a._v(" may also contain the common order comparison operators, as well as a "),e("code",[a._v("min")]),a._v(" method and a "),e("code",[a._v("max")]),a._v(" method.")]),a._v(" "),e("p",[a._v("The "),e("code",[a._v("=>")]),a._v(" notation has the same meaning as it does in a function signature and requires type "),e("code",[a._v("a")]),a._v(" to implement "),e("code",[a._v("Eq")]),a._v(", in order to implement "),e("code",[a._v("Ord")]),a._v(".")]),a._v(" "),e("div",{staticClass:"language-hs extra-class"},[e("pre",{pre:!0,attrs:{class:"language-hs"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("data")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Ordering")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("EQ")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("LT")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("GT")]),a._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Eq")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Ord")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("compare")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Ord")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Ordering")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("     "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Ord")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Bool")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("    "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Ord")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Bool")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("     "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Ord")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Bool")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("    "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Ord")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Bool")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("min")]),a._v("     "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Ord")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("max")]),a._v("     "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Ord")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v("\n\n")])])]),e("p",[a._v("All of the methods following "),e("code",[a._v("compare")]),a._v(" can be derived from it in a number of ways:")]),a._v(" "),e("div",{staticClass:"language-hs extra-class"},[e("pre",{pre:!0,attrs:{class:"language-hs"}},[e("code",[e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("y")]),a._v("   "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("compare")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("y")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("LT")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("y")]),a._v("  "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("y")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("||")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("y")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("-- Note the use of (==) inherited from Eq")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("y")]),a._v("   "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("not")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("y")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("y")]),a._v("  "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("not")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("y")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n"),e("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("min")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("y")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("case")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("compare")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("y")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("of")]),a._v("\n               "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("EQ")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v("\n               "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("LT")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v("\n               "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("GT")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("y")]),a._v("\n\n"),e("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("max")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("y")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("case")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("compare")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("y")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("of")]),a._v("\n               "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("EQ")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v("\n               "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("LT")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("y")]),a._v("\n               "),e("span",{pre:!0,attrs:{class:"token constant"}},[a._v("GT")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v("\n\n")])])]),e("p",[a._v("Type classes that themselves extend "),e("code",[a._v("Ord")]),a._v(" must implement at least either the "),e("code",[a._v("compare")]),a._v(" method or the "),e("code",[a._v("(<=)")]),a._v("  method themselves, which builds up the directed inheritance lattice.")]),a._v(" "),e("h4",{attrs:{id:"remarks"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#remarks"}},[a._v("#")]),a._v(" Remarks")]),a._v(" "),e("p",[a._v("The following diagram taken from the "),e("a",{attrs:{href:"https://wiki.haskell.org/Typeclassopedia",target:"_blank",rel:"noopener noreferrer"}},[a._v("Typeclassopedia"),e("OutboundLink")],1),a._v(" article shows the relationship between the various typeclasses in Haskell.")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://i.stack.imgur.com/Fph6t.png",target:"_blank",rel:"noopener noreferrer"}},[e("img",{attrs:{src:"https://i.stack.imgur.com/Fph6t.png",alt:"Relationships among standard Haskell type classes, Figure 1 as published in Typeclassopedia."}}),e("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=r.exports}}]);