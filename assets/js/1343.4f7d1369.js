(window.webpackJsonp=window.webpackJsonp||[]).push([[1343],{1689:function(t,e,n){"use strict";n.r(e);var o=n(19),i=Object(o.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"content-hugging-content-compression-in-autolayout"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#content-hugging-content-compression-in-autolayout"}},[t._v("#")]),t._v(" Content Hugging/Content Compression in Autolayout")]),t._v(" "),n("h2",{attrs:{id:"definition-intrinsic-content-size"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#definition-intrinsic-content-size"}},[t._v("#")]),t._v(" Definition: Intrinsic Content Size")]),t._v(" "),n("p",[t._v("Before Auto Layout, you always had to tell buttons and other controls how big they should be, either by setting their frame or bounds properties or by resizing them in Interface Builder. But it turns out that most controls are perfectly capable of determining how much space they need, based on their content.")]),t._v(" "),n("p",[t._v("A "),n("strong",[t._v("label")]),t._v(" knows how wide and tall it is because it knows the length of the text that has been set on it, as well as the font size for that text. Likewise for a "),n("strong",[t._v("button")]),t._v(", which might combine the text with a background image and some padding.")]),t._v(" "),n("p",[t._v("The same is true for segmented controls, progress bars, and most other controls, although some may only have a predetermined height but an unknown width.")]),t._v(" "),n("p",[t._v("This is known as the intrinsic content size, and it is an important concept in Auto Layout.  Auto Layout asks your controls how big they need to be and lays out the screen based on that information.")]),t._v(" "),n("p",[t._v("Usually you want to use the "),n("code",[t._v("intrinsic content size")]),t._v(", but there are some cases where you may not want to do that. You can prevent this by setting an explicit Width or Height constraint on a control.")]),t._v(" "),n("p",[t._v("Imagine what happens when you set an image on a UIImageView if that image is much larger than the screen. You usually want to give image views a fixed width and height and scale the content, unless you want the view to resize to the dimensions of the image.")]),t._v(" "),n("p",[t._v("Reference: "),n("a",{attrs:{href:"https://www.raywenderlich.com/115444/auto-layout-tutorial-in-ios-9-part-2-constraints",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.raywenderlich.com/115444/auto-layout-tutorial-in-ios-9-part-2-constraints"),n("OutboundLink")],1)]),t._v(" "),n("h4",{attrs:{id:"remarks"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#remarks"}},[t._v("#")]),t._v(" Remarks")]),t._v(" "),n("p",[n("strong",[t._v("Content Compression Resistance Priority")])]),t._v(" "),n("blockquote"),t._v(" "),n("p",[t._v("This value determines how resistant a view is to being compressed, or\nshrunk. A higher value here means the view will be less likely to be\ncompressed and more likely to stay the same.")]),t._v(" "),n("p",[n("strong",[t._v("Content Hugging Priority")])]),t._v(" "),n("blockquote"),t._v(" "),n("p",[t._v("This value determines how resistant a view is to being expanded. You\ncan imagine “hugging” here to mean “size to fit” – the bounds of the\nview will “hug” or be close to the intrinsic content size. A higher\nvalue here means the view will be less likely to grow and more likely\nto stay the same.")])])}),[],!1,null,null,null);e.default=i.exports}}]);