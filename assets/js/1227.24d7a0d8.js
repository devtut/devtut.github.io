(window.webpackJsonp=window.webpackJsonp||[]).push([[1227],{1573:function(a,t,s){"use strict";s.r(t);var e=s(19),r=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"template-haskell-quasiquotes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#template-haskell-quasiquotes"}},[a._v("#")]),a._v(" Template Haskell & QuasiQuotes")]),a._v(" "),s("h2",{attrs:{id:"syntax-of-template-haskell-and-quasiquotes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#syntax-of-template-haskell-and-quasiquotes"}},[a._v("#")]),a._v(" Syntax of Template Haskell and Quasiquotes")]),a._v(" "),s("p",[a._v("Template Haskell is enabled by the "),s("code",[a._v("-XTemplateHaskell")]),a._v(" GHC extension. This extension enables all the syntactic features further detailed in this section. The full details on Template Haskell are given by the "),s("a",{attrs:{href:"https://downloads.haskell.org/%7Eghc/latest/docs/html/users_guide/glasgow_exts.html#template-haskell",target:"_blank",rel:"noopener noreferrer"}},[a._v("user guide"),s("OutboundLink")],1),a._v(".")]),a._v(" "),s("h3",{attrs:{id:"splices"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#splices"}},[a._v("#")]),a._v(" Splices")]),a._v(" "),s("li",[a._v("\nA splice is a new syntactic entity enabled by Template Haskell, written as `$(...)`, where `(...)` is some expression.\n")]),a._v(" "),s("li",[a._v("\nThere must not be a space between `$` and the first character of the expression; and Template Haskell overrides the parsing of the `$` operator - e.g. `f$g` is normally parsed as `($) f g` whereas with Template Haskell enabled, it is parsed as a splice.\n")]),a._v(" "),s("li",[a._v("\nWhen a splice appears at the top level, the `$` may be omitted. In this case, the spliced expression is the entire line.\n")]),a._v(" "),s("li",[a._v("\nA splice represents code which is run at compile time to produce a Haskell AST, and that AST is compiled as Haskell code and inserted into the program\n")]),a._v(" "),s("li",[a._v("\nSplices can appear in place of: expressions, patterns, types, and top-level declarations. The type of the spliced expression, in each case respectively, is `Q Exp`, `Q Pat`, `Q Type`, `Q [Decl]`. Note that declaration splices may **only** appear at the top level, whereas the others may be inside other expressions, patterns, or types, respectively.\n")]),a._v(" "),s("h3",{attrs:{id:"expression-quotations-note-not-a-quasiquotation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#expression-quotations-note-not-a-quasiquotation"}},[a._v("#")]),a._v(" Expression quotations (note: "),s("strong",[a._v("not")]),a._v(" a QuasiQuotation)")]),a._v(" "),s("li",[a._v("\nAn expression quotation is a new syntactic entity written as one of:\n"),s("ul",[a._v("\n- `[e|..|]` or `[|..|]` - `..` is an expression and the quotation has type `Q Exp`;\n- `[p|..|]` - `..` is a pattern and the quotation has type `Q Pat`;\n- `[t|..|]` - `..` is a type and the quotation has type `Q Type`;\n- `[d|..|]` - `..` is a list of declarations and the quotation has type `Q [Dec]`.\n"),s("p",[a._v("An expression quotation takes a compile time program and produces the AST represented by that program.")]),a._v(" "),s("p",[a._v("The use of a value in a quotation (e.g. "),s("code",[a._v("\\x -> [| x |]")]),a._v(") without a splice corresponds to syntactic sugar for "),s("code",[a._v("\\x -> [| $(lift x) |]")]),a._v(", where "),s("code",[a._v("lift :: Lift t => t -> Q Exp")]),a._v(" comes from the class")]),a._v(" "),s("h3",{attrs:{id:"typed-splices-and-quotations"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#typed-splices-and-quotations"}},[a._v("#")]),a._v(" Typed splices and quotations")]),a._v(" "),s("li",[a._v("\nTyped splices are similair to previously mentioned (untyped) splices, and are written as `$$(..)` where `(..)` is an expression.\n")]),a._v(" "),s("li",[a._v("\nIf `e` has type `Q (TExp a)` then `$$e` has type `a`.\n")]),a._v(" "),s("li",[a._v("\nTyped quotations take the form `[||..||]` where `..` is an expression of type `a`; the resulting quotation has type `Q (TExp a)`.\n")]),a._v(" "),s("li",[a._v("\nTyped expression can be converted to untyped ones: `unType :: TExp a -> Exp`.\n")]),a._v(" "),s("h3",{attrs:{id:"quasiquotes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#quasiquotes"}},[a._v("#")]),a._v(" QuasiQuotes")]),a._v(" "),s("li",[a._v("\nQuasiQuotes generalize expression quotations - previously, the parser used by the expression quotation is one of a fixed set (`e,p,t,d`), but QuasiQuotes allow a custom parser to be defined and used to produce code at compile time. Quasi-quotations can appear in all the same contexts as regular quotations.\n")]),a._v(" "),s("li",[a._v("\nA quasi-quotation is written as `[iden|...|]`, where `iden` is an identifier of type `Language.Haskell.TH.Quote.QuasiQuoter`.\n")]),a._v(" "),s("li",[a._v("\nA `QuasiQuoter` is simply composed of four parsers, one for each of the different contexts in which quotations can appear:\n")]),a._v(" "),s("h3",{attrs:{id:"names"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#names"}},[a._v("#")]),a._v(" Names")]),a._v(" "),s("li",[a._v("\nHaskell identifiers are represented by the type `Language.Haskell.TH.Syntax.Name`. Names form the leaves of abstract syntax trees representing Haskell programs in Template Haskell.\n")]),a._v(" "),s("li",[a._v("\nAn identifier which is currently in scope may be turned into a name with either: `'e` or `'T`. In the first case, `e` is interpreted in the expression scope, while in the second case `T` is in the type scope (recalling that types and value constructors may share the name without amiguity in Haskell).\n")]),a._v(" "),s("h2",{attrs:{id:"the-q-type"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#the-q-type"}},[a._v("#")]),a._v(" The Q type")]),a._v(" "),s("p",[a._v("The "),s("code",[a._v("Q :: * -> *")]),a._v(" type constructor defined in "),s("code",[a._v("Language.Haskell.TH.Syntax")]),a._v(" is an abstract type representing computations which have access to the compile-time environment of the module in which the computation is run. The "),s("code",[a._v("Q")]),a._v(" type also handles variable substituion, called "),s("strong",[a._v("name capture")]),a._v(" by TH (and discussed "),s("a",{attrs:{href:"https://hackage.haskell.org/package/template-haskell-2.10.0.0/docs/Language-Haskell-TH-Syntax.html#namecapture",target:"_blank",rel:"noopener noreferrer"}},[a._v("here"),s("OutboundLink")],1),a._v(".) All splices have type "),s("code",[a._v("Q X")]),a._v(" for some "),s("code",[a._v("X")]),a._v(".")]),a._v(" "),s("p",[a._v("The compile-time environment includes:")]),a._v(" "),s("li",[a._v("in-scope identifiers and information about said identifiers,\n"),s("ul",[a._v("\n- types of functions\n- types and source data types of constructors\n- full specification of type declarations (classes, type families)\n"),s("p",[a._v("The "),s("code",[a._v("Q")]),a._v(" type also has the ability to generate fresh names, with the function "),s("code",[a._v("newName :: String -> Q Name")]),a._v(". Note that the name is not bound anywhere implicitly, so the user must bind it themselves, and so making sure the resulting use of the name is well-scoped is the responsibility of the user.")]),a._v(" "),s("p",[s("code",[a._v("Q")]),a._v(" has instances for "),s("code",[a._v("Functor,Monad,Applicative")]),a._v(" and this is the main interface for manipulating "),s("code",[a._v("Q")]),a._v(" values, along with the combinators provided in "),s("code",[a._v("Language.Haskell.TH.Lib")]),a._v(", which define a helper function for every constructor of the TH ast of the form:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("LitE")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Lit")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Exp")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("litE")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Lit")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("ExpQ")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("AppE")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Exp")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Exp")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Exp")]),a._v(" \n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("appE")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("ExpQ")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("ExpQ")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("ExpQ")]),a._v("\n\n")])])]),s("p",[a._v("Note that "),s("code",[a._v("ExpQ")]),a._v(", "),s("code",[a._v("TypeQ")]),a._v(", "),s("code",[a._v("DecsQ")]),a._v(" and "),s("code",[a._v("PatQ")]),a._v(" are synonyms for the AST types which are typically stored inside the "),s("code",[a._v("Q")]),a._v(" type.")]),a._v(" "),s("p",[a._v("The TH library provides a function "),s("code",[a._v("runQ :: Quasi m => Q a -> m a")]),a._v(", and there is an instance "),s("code",[a._v("Quasi IO")]),a._v(", so it would seem that the "),s("code",[a._v("Q")]),a._v(" type is just a fancy "),s("code",[a._v("IO")]),a._v(". However, the use of "),s("code",[a._v("runQ :: Q a -> IO a")]),a._v(" produces an "),s("code",[a._v("IO")]),a._v(" action which does "),s("strong",[a._v("not")]),a._v(" have access to any compile-time environment - this is only available in the actual "),s("code",[a._v("Q")]),a._v(" type. Such "),s("code",[a._v("IO")]),a._v(" actions will fail at runtime if trying to access said environment.")]),a._v(" "),s("h2",{attrs:{id:"an-n-arity-curry"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#an-n-arity-curry"}},[a._v("#")]),a._v(" An n-arity curry")]),a._v(" "),s("p",[a._v("The familiar")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("curry")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("curry")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("\\")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("f")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("f")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n")])])]),s("p",[a._v("function can be generalized to tuples of arbitrary arity, for example:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("curry3")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("d")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("d")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("curry4")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("d")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("e")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("d")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("e")]),a._v(" \n\n")])])]),s("p",[a._v("However, writing such functions for tuples of arity 2 to (e.g.) 20 by hand would be tedious (and ignoring the fact that the presence of 20 tuples in your program almost certainly signal design issues which should be fixed with records).")]),a._v(" "),s("p",[a._v("We can use Template Haskell to produce such "),s("code",[a._v("curryN")]),a._v(" functions for arbitrary "),s("code",[a._v("n")]),a._v(":")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("{-# LANGUAGE TemplateHaskell #-}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token import_statement"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("import")]),a._v(" Control.Monad")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("replicateM")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" \n"),s("span",{pre:!0,attrs:{class:"token import_statement"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("import")]),a._v(" Language.Haskell.TH")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("ExpQ")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("newName")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Exp")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("..")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Pat")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("..")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token import_statement"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("import")]),a._v(" Numeric.Natural")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Natural")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" \n\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("curryN")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Natural")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Q")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Exp")]),a._v("\n\n")])])]),s("p",[a._v("The "),s("code",[a._v("curryN")]),a._v(" function takes a natural number, and produces the curry function of that arity, as a Haskell AST.")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("curryN")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("n")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("do")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("f")]),a._v("  "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<-")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("newName")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"f"')]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("xs")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<-")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("replicateM")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("fromIntegral")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("n")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("newName")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"x"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n")])])]),s("p",[a._v("First we produces "),s("strong",[a._v("fresh")]),a._v(" type variables for each of the arguments of the function - one for the input function, and one for each of the arguments to said function.")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("\n let args = map VarP (f:xs)\n\n")])])]),s("p",[a._v("The expression "),s("code",[a._v("args")]),a._v(" represents the pattern "),s("code",[a._v("f x1 x2 .. xn")]),a._v(". Note that a pattern is seperate syntactic entity - we could take this same pattern and place it in a lambda, or a function binding, or even the LHS of a let binding (which would be an error).")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("\n     ntup = TupE (map VarE xs)\n\n")])])]),s("p",[a._v("The function must build the argument tuple from the sequence of arguments, which is what\nwe've done here. Note the distinction between pattern variables ("),s("code",[a._v("VarP")]),a._v(") and expression variables ("),s("code",[a._v("VarE")]),a._v(").")]),a._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[a._v("\n return $ LamE args (AppE (VarE f) ntup)\n\n")])])]),s("p",[a._v("Finally, the value which we produce is the AST "),s("code",[a._v("\\f x1 x2 .. xn -> f (x1, x2, .. , xn)")]),a._v(".")]),a._v(" "),s("p",[a._v("We could have also written this function using quotations and 'lifted' constructors:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("...")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token import_statement"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("import")]),a._v(" Language.Haskell.TH.Lib")]),a._v("  \n\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("curryN")]),a._v("' "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Natural")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("ExpQ")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("curryN")]),a._v("' "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("n")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("do")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("f")]),a._v("  "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<-")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("newName")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"f"')]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("xs")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<-")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("replicateM")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("fromIntegral")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("n")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("newName")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"x"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("lamE")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("map")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("varP")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("f")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("xs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" \n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("varE")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("f")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("tupE")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("map")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("varE")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("xs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n\n")])])]),s("p",[a._v("Note that quotations must be syntactically valid, so "),s("code",[a._v("[| \\ $(map varP (f:xs)) -> .. |]")]),a._v(" is invalid, because there is no way in regular Haskell to declare a 'list' of patterns - the above is interpreted as "),s("code",[a._v("\\ var -> ..")]),a._v(" and the spliced expression is expected to have type "),s("code",[a._v("PatQ")]),a._v(", i.e. a single pattern, not a list of patterns.")]),a._v(" "),s("p",[a._v("Finally, we can load this TH function in GHCi:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">:")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("set")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("XTemplateHaskell")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">:")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("t")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("curryN")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("curryN")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("t1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("t2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("t3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("t4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("t5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("t")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("t1")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("t2")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("t3")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("t4")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("t5")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("t")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">$")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("curryN")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("\\")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("d")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("e")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("d")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("e")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("15")]),a._v("\n\n")])])]),s("p",[a._v("This example is adapted primarily from "),s("a",{attrs:{href:"https://wiki.haskell.org/A_practical_Template_Haskell_Tutorial",target:"_blank",rel:"noopener noreferrer"}},[a._v("here"),s("OutboundLink")],1),a._v(".")]),a._v(" "),s("h4",{attrs:{id:"remarks"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#remarks"}},[a._v("#")]),a._v(" Remarks")]),a._v(" "),s("h3",{attrs:{id:"what-is-template-haskell"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#what-is-template-haskell"}},[a._v("#")]),a._v(" What is Template Haskell?")]),a._v(" "),s("p",[a._v("Template Haskell refers to the template meta-programming facilities built into GHC Haskell. The paper describing the original implementation can be found "),s("a",{attrs:{href:"http://research.microsoft.com/en-us/um/people/simonpj/papers/meta-haskell/",target:"_blank",rel:"noopener noreferrer"}},[a._v("here"),s("OutboundLink")],1),a._v(".")]),a._v(" "),s("h3",{attrs:{id:"what-are-stages-or-what-is-the-stage-restriction"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#what-are-stages-or-what-is-the-stage-restriction"}},[a._v("#")]),a._v(" What are stages? (Or, what is the stage restriction?)")]),a._v(" "),s("p",[a._v("Stages refer to "),s("strong",[a._v("when")]),a._v(' code is executed. Normally, code is exectued only at runtime, but with Template Haskell, code can be executed at compile time. "Normal" code is stage 0 and compile-time code is stage 1.')]),a._v(" "),s("p",[a._v("The stage restriction refers to the fact that a stage 0 program may not be executed at stage 1 - this would be equivalent to being able to run any "),s("strong",[a._v("regular")]),a._v(" program (not just meta-program) at compile time.")]),a._v(" "),s("p",[a._v("By convention (and for the sake of implementation simplicity), code in the current module is always stage 0 and code imported from all other modules is stage 1. For this reason, only expressions from other modules may be spliced.")]),a._v(" "),s("p",[a._v("Note that a stage 1 program is a stage 0 expression of type "),s("code",[a._v("Q Exp")]),a._v(", "),s("code",[a._v("Q Type")]),a._v(", etc; but the converse is not true - not every value (stage 0 program) of type "),s("code",[a._v("Q Exp")]),a._v(" is a stage 1 program,")]),a._v(" "),s("p",[a._v("Futhermore, since splices can be nested, identifiers can have stages greater than 1. The stage restriction can then be generalized - a stage "),s("strong",[a._v("n")]),a._v(" program may not be executed in any stage "),s("strong",[a._v("m>n")]),a._v(". For example, one can see references to such stages greater than 1 in certain error messages:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">:")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("t")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("\\")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("interactive")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">:")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("error")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Stage")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("error")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" `"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v("' "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("is")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("bound")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("at")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("stage")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("but")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("used")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("at")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("stage")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("In")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("the")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("untyped")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("splice")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v("\n      "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("In")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("the")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Template")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Haskell")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("quotation")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("\\")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("$")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n\n")])])]),s("h3",{attrs:{id:"using-template-haskell-causes-not-in-scope-errors-from-unrelated-identifiers"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#using-template-haskell-causes-not-in-scope-errors-from-unrelated-identifiers"}},[a._v("#")]),a._v(" Using Template Haskell causes not-in-scope errors from unrelated identifiers?")]),a._v(" "),s("p",[a._v("Normally, all the declarations in a single Haskell module can be thought of as all being mutually recursive. In other words, every top-level declaration is in the scope of every other in a single module. When Template Haskell is enabled, the scoping rules change - the module is instead broken into groups of code seperated by TH splices, and each group is mutually recursive, and each group in the scope of all further groups.")])])])])])])}),[],!1,null,null,null);t.default=r.exports}}]);