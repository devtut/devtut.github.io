(window.webpackJsonp=window.webpackJsonp||[]).push([[548],{956:function(e,t,a){"use strict";a.r(t);var s=a(31),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"atomics"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#atomics"}},[e._v("#")]),e._v(" Atomics")]),e._v(" "),a("h2",{attrs:{id:"atomics-and-operators"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#atomics-and-operators"}},[e._v("#")]),e._v(" atomics and operators")]),e._v(" "),a("p",[e._v("Atomic variables can be accessed concurrently between different threads without creating race conditions.")]),e._v(" "),a("div",{staticClass:"language-c extra-class"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/* a global static variable that is visible by all threads */")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("static")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("unsigned")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("_Atomic")]),e._v(" active "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("ATOMIC_VAR_INIT")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("myThread")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("*")]),e._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("++")]),e._v("active"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("         "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// increment active race free")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// do something")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("--")]),e._v("active"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("         "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// decrement active race free")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n")])])]),a("p",[e._v("All lvalue operations (operations that modify the object) that are allowed for the base type are allowed and will not lead to race conditions between different threads that access them.")]),e._v(" "),a("ul",[a("li",[e._v("Operations on atomic objects are generally orders of magnitude slower than normal arithmetic operations. This also includes simple load or store operations. So you should only use them for critical tasks.")]),e._v(" "),a("li",[e._v("Usual arithmetic operations and assignment such as "),a("code",[e._v("a = a+1;")]),e._v(" are in fact three operations on "),a("code",[e._v("a")]),e._v(": first a load, then addition and finally a store. This is "),a("strong",[e._v("not")]),e._v(" race free. Only the operation "),a("code",[e._v("a += 1;")]),e._v(" and "),a("code",[e._v("a++;")]),e._v(" are.")])]),e._v(" "),a("h4",{attrs:{id:"syntax"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#syntax"}},[e._v("#")]),e._v(" Syntax")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("#ifdef __STDC_NO_ATOMICS__")])]),e._v(" "),a("li",[a("code",[e._v("# error this implementation needs atomics")])]),e._v(" "),a("li",[a("code",[e._v("#endif")])]),e._v(" "),a("li",[a("code",[e._v("#include <stdatomic.h>")])]),e._v(" "),a("li",[e._v("unsigned _Atomic counter = ATOMIC_VAR_INIT(0);")])]),e._v(" "),a("h4",{attrs:{id:"remarks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#remarks"}},[e._v("#")]),e._v(" Remarks")]),e._v(" "),a("p",[e._v("Atomics as part of the C language are an optional feature that is available since C11.")]),e._v(" "),a("p",[e._v("Their purpose is to ensure race-free access to variables that are shared between different threads. Without atomic qualification, the state of a shared variable would be undefined if two threads access it concurrently. Eg an increment operation ("),a("code",[e._v("++")]),e._v(") could be split into several assembler instructions, a read, the addition itself and a store instruction. If another thread would be doing the same operation their two instruction sequences could be intertwined and lead to an inconsistent result.")]),e._v(" "),a("li",[e._v("\n**Types:** All object types with the exception of array types can be qualified with `_Atomic`.\n")]),e._v(" "),a("li",[e._v("\n**Operators:** All read-modify-write operators (e.g `++` or `*=`) on these are guaranteed to be atomic.\n")]),e._v(" "),a("li",[e._v("\n**Operations:** There are some other operations that are specified as type generic functions, e.g `atomic_compare_exchange`.\n")]),e._v(" "),a("li",[e._v("\n**Threads:** Access to them is guaranteed not to produce data race when they are accessed by different threads.\n")]),e._v(" "),a("li",[e._v("\n**Signal handlers:** Atomic types are called **lock-free** if all operations on them are stateless. In that case they can also be used to deal state changes between normal control flow and a signal handler.\n")]),e._v(" "),a("li",[e._v("\nThere is only one data type that is guaranteed to be lock-free: `atomic_flag`. This is a minimal type who's operations are intended to map to efficient test-and-set hardware instructions.\n")]),e._v(" "),a("p",[e._v("Other means to avoid race conditions are available in C11's thread interface, in particular a mutex type "),a("code",[e._v("mtx_t")]),e._v(" to mutually exclude threads from accessing critical data or critical sections of code. If atomics are not available, these must be used to prevent races.")])])}),[],!1,null,null,null);t.default=n.exports}}]);