(window.webpackJsonp=window.webpackJsonp||[]).push([[1521],{1929:function(t,e,a){"use strict";a.r(e);var s=a(31),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"atomic-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#atomic-types"}},[t._v("#")]),t._v(" Atomic Types")]),t._v(" "),a("p",[t._v("Java Atomic Types are simple mutable types that provide basic operations that are thread-safe and atomic without resorting to locking.  They are intended for use in cases where locking would be a concurrency bottleneck, or where there is risk of deadlock or livelock.")]),t._v(" "),a("h2",{attrs:{id:"creating-atomic-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#creating-atomic-types"}},[t._v("#")]),t._v(" Creating Atomic Types")]),t._v(" "),a("p",[t._v("For simple multi-threaded code, using "),a("a",{attrs:{href:"http://stackoverflow.com/documentation/java/121/concurrent-programming-threads/7299/synchronization#t=201610211859175882372",target:"_blank",rel:"noopener noreferrer"}},[t._v("synchronization"),a("OutboundLink")],1),t._v(" is acceptable.  However, using synchronization does have a liveness impact, and as a codebase becomes more complex, the likelihood goes up that you will end up with "),a("a",{attrs:{href:"https://docs.oracle.com/javase/tutorial/essential/concurrency/deadlock.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Deadlock"),a("OutboundLink")],1),t._v(", "),a("a",{attrs:{href:"https://docs.oracle.com/javase/tutorial/essential/concurrency/starvelive.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Starvation, or Livelock"),a("OutboundLink")],1),t._v(".")]),t._v(" "),a("p",[t._v("In cases of more complex concurrency, using Atomic Variables is often a better alternative, as it allows an individual variable to be accessed in a thread-safe manner without the overhead of using synchronized methods or code blocks.")]),t._v(" "),a("p",[t._v("Creating an "),a("code",[t._v("AtomicInteger")]),t._v(" type:")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AtomicInteger")]),t._v(" aInt "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AtomicInteger")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Create with default value 0")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AtomicInteger")]),t._v(" aInt "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AtomicInteger")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Create with initial value 1")]),t._v("\n\n")])])]),a("p",[t._v("Similarly for other instance types.")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AtomicIntegerArray")]),t._v(" aIntArray "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AtomicIntegerArray")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Create array of specific length")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AtomicIntegerArray")]),t._v(" aIntArray "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AtomicIntegerArray")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Initialize array with another array")]),t._v("\n\n")])])]),a("p",[t._v("Similarly for other atomic types.")]),t._v(" "),a("p",[t._v("There is a notable exception that there is no "),a("code",[t._v("float")]),t._v(" and "),a("code",[t._v("double")]),t._v(" types. These can be simulated through the use of "),a("code",[t._v("Float.floatToIntBits(float)")]),t._v(" and "),a("code",[t._v("Float.intBitsToFloat(int)")]),t._v(" for "),a("code",[t._v("float")]),t._v(" as well as "),a("code",[t._v("Double.doubleToLongBits(double)")]),t._v(" and "),a("code",[t._v("Double.longBitsToDouble(long)")]),t._v(" for doubles.")]),t._v(" "),a("p",[t._v("If you are willing to use "),a("code",[t._v("sun.misc.Unsafe")]),t._v(" you can use any primitive variable as atomic by using the atomic operation in "),a("code",[t._v("sun.misc.Unsafe")]),t._v(". All primitive types should be converted or encoded in int or longs to so use it in this way. For more on this see: "),a("a",{attrs:{href:"http://stackoverflow.com/documentation/java/6771/sun-misc-unsafe",target:"_blank",rel:"noopener noreferrer"}},[t._v("sun.misc.Unsafe"),a("OutboundLink")],1),t._v(".")]),t._v(" "),a("h2",{attrs:{id:"motivation-for-atomic-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#motivation-for-atomic-types"}},[t._v("#")]),t._v(" Motivation for Atomic Types")]),t._v(" "),a("p",[t._v("The simple way to implement multi-threaded applications is to use Java's built-in synchronization and locking primitives; e.g. the "),a("code",[t._v("synchronized")]),t._v(" keyword.  The following example shows how we might use "),a("code",[t._v("synchronized")]),t._v(" to accumulate counts.")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Counters")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" counters"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Counters")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" nosCounters"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        counters "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("nosCounters"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n     * Increments the integer at the given index\n     */")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("count")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" number"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("number "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" number "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" counters"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            counters"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("number"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n     * Obtains the current count of the number at the given index,\n     * or if there is no number at that index, returns 0.\n     */")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getCount")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" number"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("number "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" number "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" counters"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" counters"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("number"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[t._v("This implementation will work correctly.  However, if you have a large number of threads making lots of simultaneous calls on the same "),a("code",[t._v("Counters")]),t._v(" object, the synchronization is liable to be a bottleneck.  Specifically:")]),t._v(" "),a("ol",[a("li",[t._v("Each "),a("code",[t._v("synchronized")]),t._v(" method call will start with the current thread acquiring the lock for the "),a("code",[t._v("Counters")]),t._v(" instance.")]),t._v(" "),a("li",[t._v("The thread will hold the lock while it checks "),a("code",[t._v("number")]),t._v(" value and updates the counter.")]),t._v(" "),a("li",[t._v("Finally, the it will release the lock, allowing other threads access.")])]),t._v(" "),a("p",[t._v("If one thread attempts to acquire the lock while another one holds it, the attempting thread will be blocked (stopped) at step 1 until the lock is released.  If multiple threads are waiting, one of them will get it, and the others will continue to be blocked.")]),t._v(" "),a("p",[t._v("This can lead to a couple of problems:")]),t._v(" "),a("li",[t._v("\nIf there is a lot of **contention** for the lock (i.e. lots of thread try to acquire it), then some threads can be blocked for a long time.\n")]),t._v(" "),a("li",[t._v("\nWhen a thread is blocked waiting for the lock, the operating system will typically try switch execution to a different thread. This **context switching** incurs a relatively large performance impact on the processor.\n")]),t._v(" "),a("li",[t._v('\nWhen there are multiple threads blocked on the same lock, there are no guarantees that any one of them will be treated "fairly" (i.e. each thread is guaranteed to be scheduled to run).  This can lead to **thread starvation**.\n')]),t._v(" "),a("h3",{attrs:{id:"how-does-one-implement-atomic-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#how-does-one-implement-atomic-types"}},[t._v("#")]),t._v(" How does one implement Atomic Types?")]),t._v(" "),a("p",[t._v("Let us start by rewriting the example above using "),a("code",[t._v("AtomicInteger")]),t._v(" counters:")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Counters")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AtomicInteger")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" counters"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Counters")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" nosCounters"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        counters "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AtomicInteger")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("nosCounters"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" nosCounters"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            counters"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AtomicInteger")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n     * Increments the integer at the given index\n     */")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("count")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" number"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("number "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" number "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" counters"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            counters"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("number"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("incrementAndGet")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n     * Obtains the current count of the object at the given index,\n     * or if there is no number at that index, returns 0.\n     */")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getCount")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" number"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("number "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" number "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" counters"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v(" \n                counters"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("number"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[t._v("We have replaced the "),a("code",[t._v("int[]")]),t._v(" with an "),a("code",[t._v("AtomicInteger[]")]),t._v(", and initialized it with an instance in each element.  We have also added calls to "),a("code",[t._v("incrementAndGet()")]),t._v(" and "),a("code",[t._v("get()")]),t._v(" in place of operations on "),a("code",[t._v("int")]),t._v(" values.")]),t._v(" "),a("p",[t._v("But the most important thing is that we can remove the "),a("code",[t._v("synchronized")]),t._v(" keyword because locking is no longer required.  This works because the "),a("code",[t._v("incrementAndGet()")]),t._v(" and "),a("code",[t._v("get()")]),t._v(" operations are "),a("strong",[t._v("atomic")]),t._v(" and "),a("strong",[t._v("thread-safe")]),t._v(".  In this context, it means that:")]),t._v(" "),a("li",[t._v('\nEach counter in the array will only be **observable** in the either the "before" state for an operation (like an "increment") or in the "after" state.\n')]),t._v(" "),a("li",[t._v('\nAssuming that the operation occurs at time `T`, no thread will be able to see the "before" state after time `T`.\n')]),t._v(" "),a("p",[t._v("Furthermore, while two threads might actually attempt to update the same "),a("code",[t._v("AtomicInteger")]),t._v(" instance at the same time, the implementations of the operations ensure that only one increment happens at a time on the given instance. This is done without locking, often resulting in better performance.")]),t._v(" "),a("h3",{attrs:{id:"how-do-atomic-types-work"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#how-do-atomic-types-work"}},[t._v("#")]),t._v(" How do Atomic Types work?")]),t._v(" "),a("p",[t._v("Atomic types typically rely on specialized hardware instructions in the instruction set of the target machine.  For example, Intel-based instruction sets provide a "),a("code",[t._v("CAS")]),t._v(" ("),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Compare-and-swap",target:"_blank",rel:"noopener noreferrer"}},[t._v("Compare and Swap"),a("OutboundLink")],1),t._v(") instruction that will perform a specific sequence of memory operations atomically.")]),t._v(" "),a("p",[t._v("These low-level instructions are are used to implement higher-level operations in the APIs of the respective "),a("code",[t._v("AtomicXxx")]),t._v(" classes.  For example, (again, in C-like pseudocode):")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" num"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("increment")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("TRUE"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" old "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" num"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" old "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("old "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("compare_and_swap")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("num"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" old"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("p",[t._v("If there is no contention on the "),a("code",[t._v("AtomicXxxx")]),t._v(", the "),a("code",[t._v("if")]),t._v(" test will succeed and the loop will end immediately.  If there is contention, then the "),a("code",[t._v("if")]),t._v(' will fail for all but one of the threads, and they will "spin" in the loop for a small number of cycles of the loop.  In practice, the spinning is orders of magnitude faster (except at '),a("strong",[t._v("unrealistically high")]),t._v(" levels of contention, where synchronized performs better than atomic classes because when the CAS operation fails, then the retry will only add more contention) than suspending the thread and switching to another one.")]),t._v(" "),a("p",[t._v("Incidentally, CAS instructions are typically used by the JVM to implement "),a("strong",[t._v("uncontended locking")]),t._v(".  If the JVM can see that a lock is not currently locked, it will attempt to use a CAS to acquire the lock.  If the CAS succeeds, then there is no need to do the expensive thread scheduling, context switching and so on.  For more information on the techniques used, see "),a("a",{attrs:{href:"https://blogs.oracle.com/dave/entry/biased_locking_in_hotspot",target:"_blank",rel:"noopener noreferrer"}},[t._v("Biased Locking in HotSpot"),a("OutboundLink")],1),t._v(".")]),t._v(" "),a("h4",{attrs:{id:"parameters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters"}},[t._v("#")]),t._v(" Parameters")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Parameter")]),t._v(" "),a("th",[t._v("Description")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("set")]),t._v(" "),a("td",[t._v("Volatile set of the field")])]),t._v(" "),a("tr",[a("td",[t._v("get")]),t._v(" "),a("td",[t._v("Volatile read of the field")])]),t._v(" "),a("tr",[a("td",[t._v("lazySet")]),t._v(" "),a("td",[t._v("This is a store ordered operation of the field")])]),t._v(" "),a("tr",[a("td",[t._v("compareAndSet")]),t._v(" "),a("td",[t._v("If the value is the expeed value then sent it to the new value")])]),t._v(" "),a("tr",[a("td",[t._v("getAndSet")]),t._v(" "),a("td",[t._v("get the current value and update")])])])]),t._v(" "),a("h4",{attrs:{id:"remarks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#remarks"}},[t._v("#")]),t._v(" Remarks")]),t._v(" "),a("p",[t._v("Many on essentially combinations of volatile reads or writes and "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Compare-and-swap",target:"_blank",rel:"noopener noreferrer"}},[t._v("CAS"),a("OutboundLink")],1),t._v(" operations. Best way to understand this is to look at the source code directly. E.g. "),a("a",{attrs:{href:"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/java/util/concurrent/atomic/AtomicInteger.java",target:"_blank",rel:"noopener noreferrer"}},[t._v("AtomicInteger"),a("OutboundLink")],1),t._v(", "),a("a",{attrs:{href:"http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/sun/misc/Unsafe.java#Unsafe.getAndSetInt%28java.lang.Object%2Clong%2Cint%29",target:"_blank",rel:"noopener noreferrer"}},[t._v("Unsafe.getAndSet"),a("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=n.exports}}]);