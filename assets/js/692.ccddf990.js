(window.webpackJsonp=window.webpackJsonp||[]).push([[692],{1100:function(t,a,s){"use strict";s.r(a);var e=s(31),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"pointers"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pointers"}},[t._v("#")]),t._v(" Pointers")]),t._v(" "),s("p",[t._v("A pointer is an address that refers to a location in memory. They're commonly used to allow functions or data structures to know of and modify memory without having to copy the memory referred to. Pointers are usable with both primitive (built-in) or user-defined types.")]),t._v(" "),s("p",[t._v('Pointers make use of the "dereference" '),s("code",[t._v("*")]),t._v(' , "address of" '),s("code",[t._v("&")]),t._v(' , and "arrow" '),s("code",[t._v("->")]),t._v(" operators. The '*' and '->' operators are used to access the memory being pointed at, and the "),s("code",[t._v("&")]),t._v(" operator is used to get an address in memory.")]),t._v(" "),s("h2",{attrs:{id:"pointer-basics"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pointer-basics"}},[t._v("#")]),t._v(" Pointer basics")]),t._v(" "),s("p",[s("strong",[t._v("Note:")]),t._v(" in all the following, the existence of the C++11 constant "),s("code",[t._v("nullptr")]),t._v(" is assumed. For earlier versions, replace "),s("code",[t._v("nullptr")]),t._v(" with "),s("code",[t._v("NULL")]),t._v(", the constant that used to play a similar role.")]),t._v(" "),s("h3",{attrs:{id:"creating-a-pointer-variable"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#creating-a-pointer-variable"}},[t._v("#")]),t._v(" Creating a pointer variable")]),t._v(" "),s("p",[t._v("A pointer variable can be created using the specific "),s("code",[t._v("*")]),t._v(" syntax, e.g. "),s("code",[t._v("int *pointer_to_int;")]),t._v("."),s("br"),t._v("\nWhen a variable is of a "),s("strong",[t._v("pointer type")]),t._v(" ("),s("code",[t._v("int *")]),t._v("), it just contains a memory address. The memory address is the location at which data of the "),s("strong",[t._v("underlying type")]),t._v(" ("),s("code",[t._v("int")]),t._v(") is stored.")]),t._v(" "),s("p",[t._v("The difference is clear when comparing the size of a variable with the size of a pointer to the same type:")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Declare a struct type `big_struct` that contains")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// three long long ints.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" foo1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" foo2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" foo3"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" big_struct"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Create a variable `bar` of type `big_struct`")]),t._v("\nbig_struct bar"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Create a variable `p_bar` of type `pointer to big_struct`.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Initialize it to `nullptr` (a null pointer).")]),t._v("\nbig_struct "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("p_bar0 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nullptr")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Print the size of `bar`")]),t._v("\nstd"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("cout "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"sizeof(bar) = "')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("sizeof")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("bar"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" std"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Print the size of `p_bar`.")]),t._v("\nstd"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("cout "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"sizeof(p_bar0) = "')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("sizeof")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("p_bar0"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" std"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Produces:\n    sizeof(bar) = 24\n    sizeof(p_bar0) = 8\n*/")]),t._v("\n\n")])])]),s("h3",{attrs:{id:"taking-the-address-of-another-variable"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#taking-the-address-of-another-variable"}},[t._v("#")]),t._v(" Taking the address of another variable")]),t._v(" "),s("p",[t._v("Pointers can be assigned between each other just as normal variables; in this case, it is the "),s("strong",[t._v("memory address")]),t._v(" that is copied from one pointer to another, "),s("strong",[t._v("not the actual data")]),t._v(" that a pointer points to."),s("br"),t._v("\nMoreover, they can take the value "),s("code",[t._v("nullptr")]),t._v(" which represents a null memory location. A pointer equal to "),s("code",[t._v("nullptr")]),t._v(" contains an invalid memory location and hence it does not refer to valid data.")]),t._v(" "),s("p",[t._v("You can get the memory address of a variable of a given type by prefixing the variable with the "),s("strong",[t._v("address of")]),t._v(" operator "),s("code",[t._v("&")]),t._v(". The value returned by "),s("code",[t._v("&")]),t._v(" is a pointer to the underlying type which contains the memory address of the variable (which is valid data "),s("strong",[t._v("as long as the variable does not go out of scope")]),t._v(").")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Copy `p_bar0` into `p_bar_1`.")]),t._v("\nbig_struct "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("p_bar1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" p_bar0"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Take the address of `bar` into `p_bar_2`")]),t._v("\nbig_struct "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("p_bar2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("bar"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// p_bar1 is now nullptr, p_bar2 is &bar.")]),t._v("\n\np_bar0 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" p_bar2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// p_bar0 is now &bar.")]),t._v("\n\np_bar2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nullptr")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// p_bar0 == &bar")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// p_bar1 == nullptr")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// p_bar2 == nullptr")]),t._v("\n\n")])])]),s("p",[t._v("In contrast with references:")]),t._v(" "),s("ul",[s("li",[t._v("assigning two pointers does not overwrite the memory that the assigned pointer refers to;")]),t._v(" "),s("li",[t._v("pointers can be null.")]),t._v(" "),s("li",[t._v("the "),s("strong",[t._v("address of")]),t._v(" operator is required explicitly.")])]),t._v(" "),s("h3",{attrs:{id:"accessing-the-content-of-a-pointer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#accessing-the-content-of-a-pointer"}},[t._v("#")]),t._v(" Accessing the content of a pointer")]),t._v(" "),s("p",[t._v("As taking an address requires "),s("code",[t._v("&")]),t._v(", as well accessing the content requires the usage of the "),s("strong",[t._v("dereference operator")]),t._v(" "),s("code",[t._v("*")]),t._v(", as a prefix. When a pointer is dereferenced, it becomes a variable of the underlying type (actually, a reference to it). It can then be read and modified, if not "),s("code",[t._v("const")]),t._v(".")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("p_bar0"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("foo1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// `p_bar0` points to `bar`. This prints 5.")]),t._v("\nstd"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("cout "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"bar.foo1 = "')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" bar"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("foo1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" std"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Assign the value pointed to by `p_bar0` to `baz`.")]),t._v("\nbig_struct baz"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nbaz "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("p_bar0"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Now `baz` contains a copy of the data pointed to by `p_bar0`.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Indeed, it contains a copy of `bar`.")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Prints 5 as well")]),t._v("\nstd"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("cout "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"baz.foo1 = "')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" baz"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("foo1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" std"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),s("p",[t._v("The combination of "),s("code",[t._v("*")]),t._v(" and the operator "),s("code",[t._v(".")]),t._v(" is abbreviated by "),s("code",[t._v("->")]),t._v(":")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[t._v("std"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("cout "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"bar.foo1 = "')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("p_bar0"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("foo1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" std"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Prints 5")]),t._v("\nstd"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("cout "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"bar.foo1 = "')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v("  p_bar0"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("foo1  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" std"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Prints 5")]),t._v("\n\n")])])]),s("h3",{attrs:{id:"dereferencing-invalid-pointers"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dereferencing-invalid-pointers"}},[t._v("#")]),t._v(" Dereferencing invalid pointers")]),t._v(" "),s("p",[t._v("When dereferencing a pointer, you should make sure it points to valid data. Dereferencing an invalid pointer (or a null pointer) can lead to memory access violation, or to read or write garbage data.")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[t._v("big_struct "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("never_do_this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// This is a local variable. Outside `never_do_this` it doesn't exist.")]),t._v("\n   big_struct retval"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n   retval"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("foo1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("11")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// This returns the address of `retval`.")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("retval"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// `retval` is destroyed and any code using the value returned")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// by `never_do_this` has a pointer to a memory location that")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// contains garbage data (or is inaccessible).")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),s("p",[t._v("In such scenario, "),s("code",[t._v("g++")]),t._v(" and "),s("code",[t._v("clang++")]),t._v(" correctly issue the warnings:")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Clang"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" warning"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" address of stack memory associated with local variable "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'retval'")]),t._v(" returned "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Wreturn"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("stack"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("address"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Gcc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("   warning"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" address of local variable ‘retval’ returned "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("Wreturn"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("local"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("addr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n")])])]),s("p",[t._v("Hence, care must be taken when pointers are arguments of functions, as they could be null:")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("naive_code")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("big_struct "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("ptr_big_struct"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ... some code which doesn't check if `ptr_big_struct` is valid.")]),t._v("\n    ptr_big_struct"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("foo1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("12")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Segmentation fault.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("naive_code")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nullptr")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),s("h2",{attrs:{id:"pointer-operations"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pointer-operations"}},[t._v("#")]),t._v(" Pointer Operations")]),t._v(" "),s("p",[t._v("There are two operators for pointers:\nAddress-of operator (&): Returns the memory address of its operand.\nContents-of (Dereference) operator(*): Returns the value of the variable located at the address specified by its operator.")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" var "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("20")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("ptr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nptr "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("var"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\ncout "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" var "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//Outputs 20 (The value of var)")]),t._v("\n\ncout "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" ptr "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//Outputs 0x234f119 (var's memory location)")]),t._v("\n\ncout "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("ptr "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<<")]),t._v(" endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//Outputs 20(The value of the variable stored in the pointer ptr")]),t._v("\n\n")])])]),s("p",[t._v("The asterisk (*) is used in declaring a pointer for simple purpose of indicating that it is a pointer. Don't confuse this with the "),s("strong",[t._v("dereference")]),t._v(" operator, which is used to obtain the value located at the specified address. They are simply two different things represented with the same sign.")]),t._v(" "),s("h2",{attrs:{id:"pointer-arithmetic"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pointer-arithmetic"}},[t._v("#")]),t._v(" Pointer Arithmetic")]),t._v(" "),s("h3",{attrs:{id:"increment-decrement"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#increment-decrement"}},[t._v("#")]),t._v(" Increment / Decrement")]),t._v(" "),s("p",[t._v("A pointer can be incremented or decremented (prefix and postfix). Incrementing a pointer advances the pointer value to the element in the array one element past the currently pointed to element. Decrementing a pointer moves it to the previous element in the array.")]),t._v(" "),s("p",[t._v("Pointer arithmetic is not permitted if the type that the pointer points to is not complete. "),s("code",[t._v("void")]),t._v(" is always an incomplete type.")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" str "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// str = 0x010")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("str"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// str = 0x011  in this case sizeof(char) = 1 byte")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" arr "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// arr = 0x00100")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("arr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("                    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// arr = 0x00104 if sizeof(int) = 4 bytes")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" ptr "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("ptr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// void is incomplete.")]),t._v("\n\n")])])]),s("p",[t._v("If a pointer to the end element is incremented, then the pointer points to one element past the end of the array. Such a pointer cannot be dereferenced, but it can be decremented.")]),t._v(" "),s("p",[t._v("Incrementing a pointer to the one-past-the-end element in the array, or decrementing a pointer to the first element in an array yields undefined behavior.")]),t._v(" "),s("p",[t._v("A pointer to a non-array object can be treated, for the purposes of pointer arithmetic, as though it were an array of size 1.")]),t._v(" "),s("h3",{attrs:{id:"addition-subtraction"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#addition-subtraction"}},[t._v("#")]),t._v(" Addition / Subtraction")]),t._v(" "),s("p",[t._v("Integer values can be added to pointers; they act as incrementing, but by a specific number rather than by 1. Integer values can be subtracted from pointers as well, acting as pointer decrementing. As with incrementing/decrementing, the pointer must point to a complete type.")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" str "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// str = 0x010")]),t._v("\nstr "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("                  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// str = 0x010 + 2 * sizeof(char) = 0x012")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" arr "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// arr = 0x100")]),t._v("\narr "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("                  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// arr = 0x100 + 2 * sizeof(int) = 0x108, assuming sizeof(int) == 4.")]),t._v("\n\n")])])]),s("h3",{attrs:{id:"pointer-differencing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pointer-differencing"}},[t._v("#")]),t._v(" Pointer Differencing")]),t._v(" "),s("p",[t._v("The difference between two pointers to the same type can be computed. The two pointers must be within the same array object; otherwise undefined behavior results.")]),t._v(" "),s("p",[t._v("Given two pointers "),s("code",[t._v("P")]),t._v(" and "),s("code",[t._v("Q")]),t._v(" in the same array, if "),s("code",[t._v("P")]),t._v(" is the "),s("code",[t._v("i")]),t._v("th element in the array, and "),s("code",[t._v("Q")]),t._v(" is the "),s("code",[t._v("j")]),t._v("th element, then "),s("code",[t._v("P - Q")]),t._v(" shall be "),s("code",[t._v("i - j")]),t._v(". The type of the result is "),s("code",[t._v("std::ptrdiff_t")]),t._v(", from "),s("code",[t._v("<cstddef>")]),t._v(".")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" start "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// str = 0x010")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" test "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("start"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nstd"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("ptrdiff_t diff "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" test "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" start"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//Equal to 5.")]),t._v("\nstd"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[t._v("::")]),t._v("ptrdiff_t diff "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" start "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" test"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//Equal to -5; ptrdiff_t is signed.")]),t._v("\n\n")])])]),s("h4",{attrs:{id:"syntax"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#syntax"}},[t._v("#")]),t._v(" Syntax")]),t._v(" "),s("ul",[s("li",[s("Data",{attrs:{type:""}},[t._v(" *"),s("Variable",{attrs:{name:""}},[t._v(";\n")])],1)],1),t._v(" "),s("li",[s("Data",{attrs:{type:""}},[t._v(" *"),s("Variable",{attrs:{name:""}},[t._v(" = &"),s("Variable",{attrs:{name:"",of:"",same:"",Data:"",type:""}},[t._v(";\n")])],1)],1)],1),t._v(" "),s("li",[s("Data",{attrs:{type:""}},[t._v(" *"),s("Variable",{attrs:{name:""}},[t._v(" = "),s("Value",{attrs:{of:"",same:"",Data:"",type:""}},[t._v(";\n")])],1)],1)],1),t._v(" "),s("li",[t._v("int *foo; //A pointer which would points to an integer value")]),t._v(" "),s("li",[t._v("int *bar = &myIntVar;")]),t._v(" "),s("li",[t._v("long *bar[2];")]),t._v(" "),s("li",[t._v("long *bar[] = {&myLongVar1, &myLongVar2}; //Equals to: long *bar[2]")])]),t._v(" "),s("h4",{attrs:{id:"remarks"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#remarks"}},[t._v("#")]),t._v(" Remarks")]),t._v(" "),s("p",[t._v("Be aware of problems when declaring multiple pointers on the same line.")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//Only a is a pointer, the others are regular ints.")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("b"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("c"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//These are three pointers!")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("foo"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//Both *foo[0] and *foo[1] are pointers.")]),t._v("\n\n")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);