(window.webpackJsonp=window.webpackJsonp||[]).push([[1214],{1622:function(a,t,r){"use strict";r.r(t);var e=r(31),n=Object(e.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"profunctor"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#profunctor"}},[a._v("#")]),a._v(" Profunctor")]),a._v(" "),r("p",[r("code",[a._v("Profunctor")]),a._v(" is a typeclass provided by the "),r("code",[a._v("profunctors")]),a._v(" package in "),r("a",{attrs:{href:"http://hackage.haskell.org/package/profunctors-5.2/docs/Data-Profunctor.html",target:"_blank",rel:"noopener noreferrer"}},[r("code",[a._v("Data.Profunctor")]),r("OutboundLink")],1),a._v(".")]),a._v(" "),r("p",[a._v('See the "Remarks" section for a full explanation.')]),a._v(" "),r("h2",{attrs:{id:"profunctor-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#profunctor-2"}},[a._v("#")]),a._v(" (->) Profunctor")]),a._v(" "),r("p",[a._v("(->) is a simple example of a profunctor: the left argument is the input to a function, and the right argument is the same as the reader functor instance.")]),a._v(" "),r("div",{staticClass:"language-hs extra-class"},[r("pre",{pre:!0,attrs:{class:"language-hs"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("instance")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Profunctor")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v("\n    "),r("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("lmap")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("f")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("g")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("g")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v(".")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("f")]),a._v("\n    "),r("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("rmap")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("f")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("g")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("g")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v(".")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("g")]),a._v("\n\n")])])]),r("h4",{attrs:{id:"syntax"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#syntax"}},[a._v("#")]),a._v(" Syntax")]),a._v(" "),r("ul",[r("li",[a._v("dimap :: Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d")]),a._v(" "),r("li",[a._v("lmap :: Profunctor p => (a -> b) -> p b c -> p a c")]),a._v(" "),r("li",[a._v("rmap :: Profunctor p => (b -> c) -> p a b -> p a c")]),a._v(" "),r("li",[a._v("dimap id id = id")]),a._v(" "),r("li",[a._v("lmap id = id")]),a._v(" "),r("li",[a._v("rmap id = id")]),a._v(" "),r("li",[a._v("dimap f g = lmap f . rmap g")]),a._v(" "),r("li",[a._v("lmap f = dimap f id")]),a._v(" "),r("li",[a._v("rmap f = dimap id f")])]),a._v(" "),r("h4",{attrs:{id:"remarks"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#remarks"}},[a._v("#")]),a._v(" Remarks")]),a._v(" "),r("p",[a._v('Profunctors are, as described by the docs on Hackage, "a bifunctor where the first argument is contravariant and the second argument is covariant."')]),a._v(" "),r("p",[a._v("So what does this mean? Well, a bifunctor is like a normal functor, except that it has two parameters instead of one, each with its own "),r("code",[a._v("fmap")]),a._v("-like function to map on it.")]),a._v(" "),r("p",[a._v('Being "covariant" means that the second argument to a profunctor is just like a normal functor: its mapping function ('),r("code",[a._v("rmap")]),a._v(") has a type signature of "),r("code",[a._v("Profunctor p => (b -> c) -> p a b -> p a c")]),a._v(".  It just maps the function on the second argument.")]),a._v(" "),r("p",[a._v('Being "contravariant" makes the first argument a little weirder.  Instead of mapping like a normal functor, its mapping function ('),r("code",[a._v("lmap")]),a._v(") has a type signature of "),r("code",[a._v("Profunctor p => (a -> b) -> p b c -> p a c")]),a._v(".  This seemingly backward mapping makes most sense for inputs to a function: you would run "),r("code",[a._v("a -> b")]),a._v(" on the input, and then your other function, leaving the new input as "),r("code",[a._v("a")]),a._v(".")]),a._v(" "),r("p",[r("strong",[a._v("Note:")]),a._v(" The naming for the normal, one argument functors is a little misleading: the "),r("a",{attrs:{href:"http://hackage.haskell.org/package/base-4.9.1.0/docs/Data-Functor.html#t:Functor",target:"_blank",rel:"noopener noreferrer"}},[r("code",[a._v("Functor")]),a._v(" typeclass"),r("OutboundLink")],1),a._v(' implements "covariant" functors, while "contravariant" functors are implemented in the '),r("a",{attrs:{href:"https://hackage.haskell.org/package/contravariant-1.4/docs/Data-Functor-Contravariant.html#t:Contravariant",target:"_blank",rel:"noopener noreferrer"}},[r("code",[a._v("Contravariant")]),a._v(" typeclass in "),r("code",[a._v("Data.Functor.Contravariant")]),r("OutboundLink")],1),a._v(", and previously the (misleadingly named) "),r("a",{attrs:{href:"https://hackage.haskell.org/package/cofunctor-0.1.0.1/docs/Data-Cofunctor.html#t:Cofunctor",target:"_blank",rel:"noopener noreferrer"}},[r("code",[a._v("Cofunctor")]),a._v(" typeclass in "),r("code",[a._v("Data.Cofunctor")]),r("OutboundLink")],1),a._v(".")])])}),[],!1,null,null,null);t.default=n.exports}}]);