(window.webpackJsonp=window.webpackJsonp||[]).push([[587],{933:function(t,s,e){"use strict";e.r(s);var a=e(19),n=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"preprocessor-and-macros"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#preprocessor-and-macros"}},[t._v("#")]),t._v(" Preprocessor and Macros")]),t._v(" "),e("p",[t._v("All preprocessor commands begins with the hash (pound) symbol "),e("code",[t._v("#")]),t._v(".\nA C macro is just a preprocessor command that is defined using the "),e("code",[t._v("#define")]),t._v(" preprocessor directive. During the preprocessing stage, the C preprocessor (a part of the C compiler) simply substitutes the body of the macro wherever its name appears.")]),t._v(" "),e("h2",{attrs:{id:"if-0-to-block-out-code-sections"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#if-0-to-block-out-code-sections"}},[t._v("#")]),t._v(" #if 0 to block out code sections")]),t._v(" "),e("p",[t._v("If there are sections of code that you are considering removing or want to temporarily disable, you can comment it out with a block comment.")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Block comment around whole function to keep it from getting used.\n * What's even the purpose of this function?\nint myUnusedFunction(void)\n{\n    int i = 5;\n    return i;\n}\n*/")]),t._v("\n\n")])])]),e("p",[t._v("However, if the source code you have surrounded with a block comment has block style comments in the source, the ending */ of the existing block comments can cause your new block comment to be invalid and cause compilation problems.")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Block comment around whole function to keep it from getting used.\n * What's even the purpose of this function?\nint myUnusedFunction(void)\n{\n    int i = 5;\n\n    /* Return 5 */")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" i"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" \n\n")])])]),e("p",[t._v("In the previous example, the last two lines of the function and the last '*/' are seen by the compiler, so it would compile with errors.  A safer method is to use an "),e("code",[t._v("#if 0")]),t._v(" directive around the code you want to block out.")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("if")]),t._v(" 0")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* #if 0 evaluates to false, so everything between here and the #endif are\n * removed by the preprocessor. */")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("myUnusedFunction")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" i"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n\n")])])]),e("p",[t._v('A benefit with this is that when you want to go back and find the code, it\'s much easier to do a search for "#if 0" than searching all your comments.')]),t._v(" "),e("p",[t._v("Another very important benefit is that you can nest commenting out code with "),e("code",[t._v("#if 0")]),t._v(". This cannot be done with comments.")]),t._v(" "),e("p",[t._v("An alternative to using "),e("code",[t._v("#if 0")]),t._v(" is to use a name that will not be "),e("code",[t._v("#defined")]),t._v(" but is more descriptive of why the code is being blocked out. For instance if there is a function that seems to be useless dead code you might use "),e("code",[t._v("#if defined(POSSIBLE_DEAD_CODE)")]),t._v(" or "),e("code",[t._v("#if defined(FUTURE_CODE_REL_020201)")]),t._v(" for code needed once other functionality is in place or something similar. Then when going back through to remove or enable that source, those sections of source are easy to find.")]),t._v(" "),e("h2",{attrs:{id:"header-include-guards"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#header-include-guards"}},[t._v("#")]),t._v(" Header Include Guards")]),t._v(" "),e("p",[t._v("Pretty much every header file should follow the "),e("a",{attrs:{href:"https://en.wikipedia.org/wiki/Include_guard",target:"_blank",rel:"noopener noreferrer"}},[t._v("include guard"),e("OutboundLink")],1),t._v(" idiom:")]),t._v(" "),e("p",[e("strong",[t._v("my-header-file.h")])]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("ifndef")]),t._v(" MY_HEADER_FILE_H")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" MY_HEADER_FILE_H")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Code body for header file")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n\n")])])]),e("p",[t._v("This ensures that when you "),e("code",[t._v('#include "my-header-file.h"')]),t._v(" in multiple places, you don't get duplicate declarations of functions, variables, etc. Imagine the following hierarchy of files:")]),t._v(" "),e("p",[e("strong",[t._v("header-1.h")])]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    …\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" MyStruct"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("myFunction")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("MyStruct "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("value"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),e("p",[e("strong",[t._v("header-2.h")])]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"header-1.h"')])]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("myFunction2")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("MyStruct "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("value"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),e("p",[e("strong",[t._v("main.c")])]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"header-1.h"')])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"header-2.h"')])]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// do something")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),e("p",[t._v("This code has a serious problem: the detailed contents of "),e("code",[t._v("MyStruct")]),t._v(" is defined twice, which is not allowed. This would result in a compilation error that can be difficult to track down, since one header file includes another. If you instead did it with header guards:")]),t._v(" "),e("p",[e("strong",[t._v("header-1.h")])]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("ifndef")]),t._v(" HEADER_1_H")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" HEADER_1_H")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    …\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" MyStruct"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("myFunction")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("MyStruct "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("value"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n\n")])])]),e("p",[e("strong",[t._v("header-2.h")])]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("ifndef")]),t._v(" HEADER_2_H")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" HEADER_2_H")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"header-1.h"')])]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("myFunction2")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("MyStruct "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("value"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n\n")])])]),e("p",[e("strong",[t._v("main.c")])]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"header-1.h"')])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"header-2.h"')])]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// do something")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),e("p",[t._v("This would then expand to:")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("ifndef")]),t._v(" HEADER_1_H")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" HEADER_1_H")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    …\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" MyStruct"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("myFunction")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("MyStruct "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("value"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("ifndef")]),t._v(" HEADER_2_H")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" HEADER_2_H")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("ifndef")]),t._v(" HEADER_1_H ")]),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Safe, since HEADER_1_H was #define'd before.")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" HEADER_1_H")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    …\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" MyStruct"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("myFunction")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("MyStruct "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("value"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("myFunction2")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("MyStruct "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("value"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// do something")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),e("p",[t._v("When the compiler reaches the second inclusion of "),e("strong",[t._v("header-1.h")]),t._v(", "),e("code",[t._v("HEADER_1_H")]),t._v(" was already defined by the previous inclusion. Ergo, it boils down to the following:")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" HEADER_1_H")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    …\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" MyStruct"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("myFunction")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("MyStruct "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("value"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" HEADER_2_H")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("myFunction2")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("MyStruct "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("value"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// do something")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),e("p",[t._v("And thus there is no compilation error.")]),t._v(" "),e("p",[t._v("Note: There are multiple different conventions for naming the header guards. Some people like to name it "),e("code",[t._v("HEADER_2_H_")]),t._v(", some include the project name like "),e("code",[t._v("MY_PROJECT_HEADER_2_H")]),t._v(". The important thing is to ensure that the convention you follow makes it so that each file in your project has a unique header guard.")]),t._v(" "),e("p",[t._v("If the structure details were not included in the header, the type declared would be incomplete or an "),e("a",{attrs:{href:"https://en.wikipedia.org/wiki/Opaque_data_type",target:"_blank",rel:"noopener noreferrer"}},[t._v("opaque type"),e("OutboundLink")],1),t._v(".  Such types can be useful, hiding implementation details from users of the functions.  For many purposes, the "),e("code",[t._v("FILE")]),t._v(" type in the standard C library can be regarded as an opaque type (though it usually isn't opaque so that macro implementations of the standard I/O functions can make use of the internals of the structure).  In that case, the "),e("code",[t._v("header-1.h")]),t._v(" could contain:")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("ifndef")]),t._v(" HEADER_1_H")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" HEADER_1_H")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MyStruct")]),t._v(" MyStruct"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("myFunction")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("MyStruct "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("value"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n\n")])])]),e("p",[t._v("Note that the structure must have a tag name (here "),e("code",[t._v("MyStruct")]),t._v(" — that's in the tags namespace, separate from the ordinary identifiers namespace of the typedef name "),e("code",[t._v("MyStruct")]),t._v("), and that the "),e("code",[t._v("{ … }")]),t._v(' is omitted.  This says "there is a structure type '),e("code",[t._v("struct MyStruct")]),t._v(" and there is an alias for it "),e("code",[t._v("MyStruct")]),t._v('".')]),t._v(" "),e("p",[t._v("In the implementation file, the details of the structure can be defined to make the type complete:")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MyStruct")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    …\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),e("p",[t._v("If you are using C11, you could repeat the "),e("code",[t._v("typedef struct MyStruct MyStruct;")]),t._v(" declaration without causing a compilation error, but earlier versions of C would complain.  Consequently, it is still best to use the include guard idiom, even though in this example, it would be optional if the code was only ever compiled with compilers that supported C11.")]),t._v(" "),e("p",[t._v("Many compilers support the "),e("code",[t._v("#pragma once")]),t._v(" directive, which has the same results:")]),t._v(" "),e("p",[e("strong",[t._v("my-header-file.h")])]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("pragma")]),t._v(" once")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Code for header file")]),t._v("\n\n")])])]),e("p",[t._v("However, "),e("code",[t._v("#pragma once")]),t._v(" is not part of the C standard, so the code is less portable if you use it.")]),t._v(" "),e("p",[t._v("A few headers do not use the include guard idiom.  One specific example is the standard "),e("code",[t._v("<assert.h>")]),t._v(" header.  It may be included multiple times in a single translation unit, and the effect of doing so depends on whether the macro "),e("code",[t._v("NDEBUG")]),t._v(" is defined each time the header is included.  You may occasionally have an analogous requirement; such cases will be few and far between.  Ordinarily, your headers should be protected by the include guard idiom.")]),t._v(" "),e("h2",{attrs:{id:"function-like-macros"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#function-like-macros"}},[t._v("#")]),t._v(" Function-like macros")]),t._v(" "),e("p",[t._v("Function-like macros are similar to "),e("code",[t._v("inline")]),t._v(" functions, these are useful in some cases, such as temporary debug log:")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("ifdef")]),t._v(" DEBUG")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("# "),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(' LOGFILENAME "/tmp/logfile.log"')]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("# "),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(' LOG(str) do {                            \\\n  FILE *fp = fopen(LOGFILENAME, "a");            \\\n  if (fp) {                                       \\\n    fprintf(fp, "%s:%d %s\\n", __FILE__, __LINE__, \\\n                 ')]),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* don't print null pointer */")]),t._v("   \\\n                 str "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v("str "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"<null>"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("             \\\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("fclose")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("fp"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("                                   \\\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("                                               \\\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("                                          \\\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("perror")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Opening \'"')]),t._v(" LOGFILENAME "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"\' failed"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   \\\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("                                               \\\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("else")])]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Make it a NOOP if DEBUG is not defined. */")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("# "),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" LOG(LINE) (void)0")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n\n\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdio.h>")])]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" argc"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" argv"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("argc "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("LOG")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"There are command line arguments"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("LOG")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"No command line arguments"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),e("p",[t._v("Here in both cases (with "),e("code",[t._v("DEBUG")]),t._v(" or not) the call behaves the same way\nas a function with "),e("code",[t._v("void")]),t._v(" return type. This ensures that the "),e("code",[t._v("if/else")]),t._v(" conditionals are interpreted as expected.")]),t._v(" "),e("p",[t._v("In the "),e("code",[t._v("DEBUG")]),t._v(" case this is implemented through a "),e("code",[t._v("do { ... } while(0)")]),t._v(" construct. In the other case, "),e("code",[t._v("(void)0")]),t._v(" is a statement with no side effect that is just ignored.")]),t._v(" "),e("p",[t._v("An alternative for the latter would be")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" LOG(LINE) do { ")]),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* empty */")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n")])])]),e("p",[t._v("such that it is in all cases syntactically equivalent to the first.")]),t._v(" "),e("p",[t._v("If you use GCC, you can also implement a function-like macro that returns result using a non-standard GNU extension — "),e("a",{attrs:{href:"https://gcc.gnu.org/onlinedocs/gcc-7.1.0/gcc/Statement-Exprs.html#Statement-Exprs",target:"_blank",rel:"noopener noreferrer"}},[t._v("statement expressions"),e("OutboundLink")],1),t._v(".  For example:")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdio.h>")])]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" POW(X, Y) \\\n({ \\\n        int i, r = 1; \\\n        for (i = 0; i < Y; ++i) \\\n                r *= X; \\\n        r; \\ ")]),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// returned value is result of last operation")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" result"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        result "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("POW")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" \n        "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Result: %d\\n"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" result"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),e("h2",{attrs:{id:"source-file-inclusion"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#source-file-inclusion"}},[t._v("#")]),t._v(" Source file inclusion")]),t._v(" "),e("p",[t._v("The most common uses of "),e("code",[t._v("#include")]),t._v(" preprocessing directives are as in the following:")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdio.h>")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"myheader.h"')])]),t._v("\n\n")])])]),e("p",[e("code",[t._v("#include")]),t._v(' replaces the statement with the contents of the file referred to. Angle brackets (<>) refer to header files installed on the system, while quotation marks ("") are for user-supplied files.')]),t._v(" "),e("p",[t._v("Macros themselves can expand other macros once, as this example illustrates:")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("if")]),t._v(" VERSION == 1")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(' INCFILE  "vers1.h"')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("elif")]),t._v(" VERSION == 2")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(' INCFILE  "vers2.h"')]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/*  and so on */")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("else")])]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(' INCFILE  "versN.h"')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* ... */")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" INCFILE")]),t._v("\n\n")])])]),e("h2",{attrs:{id:"conditional-inclusion-and-conditional-function-signature-modification"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#conditional-inclusion-and-conditional-function-signature-modification"}},[t._v("#")]),t._v(" Conditional inclusion and conditional function signature modification")]),t._v(" "),e("p",[t._v("To conditionally include a block of code, the preprocessor has several directives (e.g "),e("code",[t._v("#if")]),t._v(", "),e("code",[t._v("#ifdef")]),t._v(", "),e("code",[t._v("#else")]),t._v(", "),e("code",[t._v("#endif")]),t._v(", etc).")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Defines a conditional `printf` macro, which only prints if `DEBUG`\n * has been defined\n */")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("ifdef")]),t._v(" DEBUG")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" DLOG(x) (printf(x))")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("else")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" DLOG(x)")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n\n")])])]),e("p",[t._v("Normal C relational operators may be used for the "),e("code",[t._v("#if")]),t._v(" condition")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("if")]),t._v(" __STDC_VERSION__ >= 201112L")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Do stuff for C11 or higher */")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("elif")]),t._v(" __STDC_VERSION__ >= 199901L")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Do stuff for C99 */")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("else")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Do stuff for pre C99 */")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n\n")])])]),e("p",[t._v("The "),e("code",[t._v("#if")]),t._v(" directives behaves similar to the C "),e("code",[t._v("if")]),t._v(" statement, it shall only contain integral constant expressions, and no casts. It supports one additional unary operator, "),e("code",[t._v("defined( identifier )")]),t._v(", which returns "),e("code",[t._v("1")]),t._v(" if the identifier is defined, and "),e("code",[t._v("0")]),t._v(" otherwise.")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("if")]),t._v(" defined(DEBUG) && !defined(QUIET)")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" DLOG(x) (printf(x))")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("else")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" DLOG(x)")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n\n")])])]),e("p",[e("strong",[t._v("Conditional Function Signature Modification")])]),t._v(" "),e("p",[t._v("In most cases a release build of an application is expected to have as little overhead as possible. However during testing of an interim build, additional logs and information about problems found can be helpful.")]),t._v(" "),e("p",[t._v("For example assume there is some function "),e("code",[t._v("SHORT SerOpPluAllRead(PLUIF *pPif, USHORT usLockHnd)")]),t._v(" which when doing a test build it is desired will generate a log about its use. However this function is used in multiple places and it is desired that when generating the log, part of the information is to know where is the function being called from.")]),t._v(" "),e("p",[t._v("So using conditional compilation you can have something like the following in the include file declaring the function. This replaces the standard version of the function with a debug version of the function. The preprocessor is used to replace calls to the function "),e("code",[t._v("SerOpPluAllRead()")]),t._v(" with calls to the function "),e("code",[t._v("SerOpPluAllRead_Debug()")]),t._v(" with two additional arguments, the name of the file and the line number of where the function is used.")]),t._v(" "),e("p",[t._v("Conditional compilation is used to choose whether to override the standard function with a debug version or not.")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("if")]),t._v(" 0")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// function declaration and prototype for our debug version of the function.")]),t._v("\nSHORT   "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("SerOpPluAllRead_Debug")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("PLUIF "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("pPif"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" USHORT usLockHnd"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("aszFilePath"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" nLineNo"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// macro definition to replace function call using old name with debug function with additional arguments.")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" SerOpPluAllRead(pPif,usLock) SerOpPluAllRead_Debug(pPif,usLock,__FILE__,__LINE__)")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("else")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// standard function declaration that is normally used with builds.")]),t._v("\nSHORT   "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("SerOpPluAllRead")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("PLUIF "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("pPif"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" USHORT usLockHnd"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n\n")])])]),e("p",[t._v("This allows you to override the standard version of the function "),e("code",[t._v("SerOpPluAllRead()")]),t._v(" with a version that will provide the name of the file and line number in the file of where the function is called.")]),t._v(" "),e("p",[e("strong",[t._v("There is one important consideration:")]),t._v(" "),e("strong",[t._v("any file using this function must include the header file where this approach is used in order for the preprocessor to modify the function. Otherwise you will see a linker error.")])]),t._v(" "),e("p",[t._v("The definition of the function would look something like the following. What this source does is to request that the preprocessor rename the function "),e("code",[t._v("SerOpPluAllRead()")]),t._v(" to be "),e("code",[t._v("SerOpPluAllRead_Debug()")]),t._v(" and to modify the argument list to include two additional arguments, a pointer to the name of the file where the function was called and the line number in the file at which the function is used.")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("if")]),t._v(" defined(SerOpPluAllRead)")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// forward declare the replacement function which we will call once we create our log.")]),t._v("\nSHORT    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("SerOpPluAllRead_Special")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("PLUIF "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("pPif"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" USHORT usLockHnd"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\nSHORT    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("SerOpPluAllRead_Debug")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("PLUIF "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("pPif"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" USHORT usLockHnd"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("aszFilePath"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" nLineNo"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" iLen "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v("  xBuffer"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("256")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// only print the last 30 characters of the file name to shorten the logs.")]),t._v("\n    iLen "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("strlen")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("aszFilePath"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("iLen "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("30")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        iLen "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" iLen "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("30")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        iLen "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("sprintf")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("xBuffer"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"SerOpPluAllRead_Debug(): husHandle = %d, File %s, lineno = %d"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" pPif"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("husHandle"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" aszFilePath "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" iLen"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" nLineNo"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("IssueDebugLog")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("xBuffer"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// now that we have issued the log, continue with standard processing.")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("SerOpPluAllRead_Special")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pPif"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" usLockHnd"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// our special replacement function name for when we are generating logs.")]),t._v("\nSHORT    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("SerOpPluAllRead_Special")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("PLUIF "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("pPif"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" USHORT usLockHnd"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("else")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// standard, normal function name (signature) that is replaced with our debug version.")]),t._v("\nSHORT   "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("SerOpPluAllRead")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("PLUIF "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("pPif"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" USHORT usLockHnd"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("STUB_SELF "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("SstReadAsMaster")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("OpPluAllRead")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pPif"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" usLockHnd"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" OP_NOT_MASTER"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),e("h2",{attrs:{id:"token-pasting"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#token-pasting"}},[t._v("#")]),t._v(" Token pasting")]),t._v(" "),e("p",[t._v("Token pasting allows one to glue together two macro arguments. For example, "),e("code",[t._v("front##back")]),t._v(" yields "),e("code",[t._v("frontback")]),t._v(". A famous example is Win32's "),e("code",[t._v("<TCHAR.H>")]),t._v(" header. In standard C, one can write "),e("code",[t._v('L"string"')]),t._v(" to declare a wide character string. However, Windows API allows one to convert between wide character strings and narrow character strings simply by "),e("code",[t._v("#define")]),t._v("ing "),e("code",[t._v("UNICODE")]),t._v(". In order to implement the string literals, "),e("code",[t._v("TCHAR.H")]),t._v(" uses this")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("ifdef")]),t._v(" UNICODE")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" TEXT(x) L##x")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n\n")])])]),e("p",[t._v("Whenever a user writes "),e("code",[t._v('TEXT("hello, world")')]),t._v(", and UNICODE is defined, the C preprocessor concatenates "),e("code",[t._v("L")]),t._v(" and the macro argument. "),e("code",[t._v("L")]),t._v(" concatenated with "),e("code",[t._v('"hello, world"')]),t._v(" gives "),e("code",[t._v('L"hello, world"')]),t._v(".")]),t._v(" "),e("h2",{attrs:{id:"predefined-macros"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#predefined-macros"}},[t._v("#")]),t._v(" Predefined Macros")]),t._v(" "),e("p",[t._v("A predefined macro is a macro that is already understood by the C pre processor without the program needing to define it. Examples include")]),t._v(" "),e("h3",{attrs:{id:"mandatory-pre-defined-macros"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mandatory-pre-defined-macros"}},[t._v("#")]),t._v(" Mandatory Pre-Defined Macros")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("__FILE__")]),t._v(", which gives the file name of the current source file (a string literal),")]),t._v(" "),e("li",[e("code",[t._v("__LINE__")]),t._v(" for the current line number (an integer constant),")]),t._v(" "),e("li",[e("code",[t._v("__DATE__")]),t._v(" for the compilation date (a string literal),")]),t._v(" "),e("li",[e("code",[t._v("__TIME__")]),t._v(" for the compilation time (a string literal).")])]),t._v(" "),e("p",[t._v("There's also a related predefined identifier, "),e("code",[t._v("__func__")]),t._v(" (ISO/IEC 9899:2011 §6.4.2.2), which is "),e("strong",[t._v("not")]),t._v(" a macro:")]),t._v(" "),e("blockquote"),t._v(" "),e("p",[t._v("The identifier `__func__` shall be implicitly declared by the translator as if,\nimmediately following the opening brace of each function definition, the declaration:")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("__func__")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"function-name"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),e("p",[t._v("appeared, where "),e("strong",[t._v("function-name")]),t._v(" is the name of the lexically-enclosing function.")]),t._v(" "),e("p",[e("code",[t._v("__FILE__")]),t._v(", "),e("code",[t._v("__LINE__")]),t._v(" and "),e("code",[t._v("__func__")]),t._v(" are especially useful for debugging purposes. For example:")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[t._v("fprintf")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("stderr")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"%s: %s: %d: Denominator is 0"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("__FILE__")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("__func__")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("__LINE__")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),e("p",[t._v("Pre-C99 compilers, may or may not support "),e("code",[t._v("__func__")]),t._v(" or may have a macro that acts the same that is named differently.  For example, gcc used "),e("code",[t._v("__FUNCTION__")]),t._v(" in C89 mode.")]),t._v(" "),e("p",[t._v("The below macros allow to ask for detail on the implementation:")]),t._v(" "),e("ul",[e("li",[e("code",[t._v("__STDC_VERSION__")]),t._v(" The version of the C Standard implemented. This is a constant integer using the format "),e("code",[t._v("yyyymmL")]),t._v(" (the value "),e("code",[t._v("201112L")]),t._v(" for C11, the value "),e("code",[t._v("199901L")]),t._v(" for C99; it wasn't defined for C89/C90)")]),t._v(" "),e("li",[e("code",[t._v("__STDC_HOSTED__")]),t._v(" "),e("code",[t._v("1")]),t._v(" if it's a hosted implementation, else "),e("code",[t._v("0")]),t._v(".")]),t._v(" "),e("li",[e("code",[t._v("__STDC__")]),t._v(" If "),e("code",[t._v("1")]),t._v(", the implementation conforms to the C Standard.")])]),t._v(" "),e("h3",{attrs:{id:"other-pre-defined-macros-non-mandatory"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#other-pre-defined-macros-non-mandatory"}},[t._v("#")]),t._v(" Other Pre-Defined Macros (non mandatory)")]),t._v(" "),e("p",[t._v("ISO/IEC 9899:2011 §6.10.9.2 Environment macros:")]),t._v(" "),e("blockquote"),t._v(" "),e("ul",[e("li",[e("p",[t._v("`__STDC_ISO_10646__`\nAn integer constant of the form `yyyymmL` (for example,\n199712L). If this symbol is defined, then every character in the Unicode\nrequired set, when stored in an object of type `wchar_t`, has the same\nvalue as the short identifier of that character. The Unicode required set\nconsists of all the characters that are defined by ISO/IEC 10646, along with\nall amendments and technical corrigenda, as of the specified year and\nmonth. If some other encoding is used, the macro shall not be defined and\nthe actual encoding used is implementation-defined.")])]),t._v(" "),e("li",[e("p",[t._v("`__STDC_MB_MIGHT_NEQ_WC__`\nThe integer constant 1, intended to indicate that, in\nthe encoding for `wchar_t`, a member of the basic character set need not\nhave a code value equal to its value when used as the lone character in an\ninteger character constant.")])]),t._v(" "),e("li",[e("p",[t._v("`__STDC_UTF_16__`\nThe integer constant 1, intended to indicate that values of type\n`char16_t` are UTF−16 encoded. If some other encoding is used, the\nmacro shall not be defined and the actual encoding used is implementation-defined.")])]),t._v(" "),e("li",[e("p",[t._v("`__STDC_UTF_32__`\nThe integer constant 1, intended to indicate that values of type\n`char32_t` are UTF−32 encoded. If some other encoding is used, the\nmacro shall not be defined and the actual encoding used is implementation-defined.")])])]),t._v(" "),e("p",[t._v("ISO/IEC 9899:2011 §6.10.8.3 Conditional feature macros")]),t._v(" "),e("blockquote"),t._v(" "),e("ul",[e("li",[t._v("`__STDC_ANALYZABLE__`\nThe integer constant 1, intended to indicate conformance to\nthe specifications in annex L (Analyzability).")]),t._v(" "),e("li",[t._v("`__STDC_IEC_559__`\nThe integer constant 1, intended to indicate conformance to the\nspecifications in annex F (IEC 60559 floating-point arithmetic).")]),t._v(" "),e("li",[t._v("`__STDC_IEC_559_COMPLEX__` The integer constant 1, intended to indicate\nadherence to the specifications in annex G (IEC 60559 compatible complex\narithmetic).")]),t._v(" "),e("li",[t._v("`__STDC_LIB_EXT1__` The integer constant `201112L`, intended to indicate support\nfor the extensions defined in annex K (Bounds-checking interfaces).")]),t._v(" "),e("li",[t._v("`__STDC_NO_ATOMICS__`\nThe integer constant 1, intended to indicate that the\nimplementation does not support atomic types (including the `_Atomic`\ntype qualifier) and the `"),e("stdatomic.h",[t._v("` header.")])],1),t._v(" "),e("li",[t._v("`__STDC_NO_COMPLEX__`\nThe integer constant 1, intended to indicate that the\nimplementation does not support complex types or the `"),e("complex.h",[t._v("`\nheader.")])],1),t._v(" "),e("li",[t._v("`__STDC_NO_THREADS__` The integer constant 1, intended to indicate that the\nimplementation does not support the `"),e("threads.h",[t._v("` header.")])],1),t._v(" "),e("li",[t._v("`__STDC_NO_VLA__`\nThe integer constant 1, intended to indicate that the\nimplementation does not support variable length arrays or variably\nmodified types.")])]),t._v(" "),e("h2",{attrs:{id:"cplusplus-for-using-c-externals-in-c-code-compiled-with-c-name-mangling"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cplusplus-for-using-c-externals-in-c-code-compiled-with-c-name-mangling"}},[t._v("#")]),t._v(" __cplusplus for using C externals in C++ code compiled with C++ - name mangling")]),t._v(" "),e("p",[t._v("There are times when an include file has to generate different output from the preprocessor depending on whether the compiler is a C compiler or a C++ compiler due to language differences.")]),t._v(" "),e("p",[t._v("For example a function or other external is defined in a C source file but is used in a C++ source file. Since C++ uses name mangling (or name decoration) in order to generate unique function names based on function argument types, a C function declaration used in a C++ source file will cause link errors. The C++ compiler will modify the specified external name for the compiler output using the name mangling rules for C++. The result is link errors due to externals not found when the C++ compiler output is linked with the C compiler output.")]),t._v(" "),e("p",[t._v("Since C compilers do not do name mangling but C++ compilers do for all external labels (function names or variable names) generated by the C++ compiler, a predefined preprocessor macro, "),e("code",[t._v("__cplusplus")]),t._v(", was introduced to allow for compiler detection.")]),t._v(" "),e("p",[t._v("In order to work around this problem of incompatible compiler output for external names between C and C++, the macro "),e("code",[t._v("__cplusplus")]),t._v(" is defined in the C++ Preprocessor and is not defined in the C Preprocessor. This macro name can be used with the conditional preprocessor "),e("code",[t._v("#ifdef")]),t._v(" directive or "),e("code",[t._v("#if")]),t._v(" with the "),e("code",[t._v("defined()")]),t._v(" operator to tell whether a source code or include file is being compiled as C++ or C.")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("ifdef")]),t._v(" __cplusplus")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"C++\\n"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("else")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"C\\n"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n\n")])])]),e("p",[t._v("Or you could use")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("if")]),t._v(" defined(__cplusplus)")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"C++\\n"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("else")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"C\\n"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n\n")])])]),e("p",[t._v("In order to specify the correct function name of a function from a C source file compiled with the C compiler that is being used in a C++ source file you could check for the "),e("code",[t._v("__cplusplus")]),t._v(" defined constant in order to cause the "),e("code",[t._v('extern "C" { /* ... */ };')]),t._v(" to be used to declare C externals when the header file is included in a C++ source file. However when compiled with a C compiler, the "),e("code",[t._v('extern "C" { */ ... */ };')]),t._v(" is not used. This conditional compilation is needed because "),e("code",[t._v('extern "C" { /* ... */ };')]),t._v(" is valid in C++ but not in C.")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("ifdef")]),t._v(" __cplusplus")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// if we are being compiled with a C++ compiler then declare the")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// following functions as C functions to prevent name mangling.")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extern")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"C"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// exported C function list.")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("ifdef")]),t._v(" __cplusplus")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// if this is a C++ compiler, we need to close off the extern declaration.")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n\n")])])]),e("h2",{attrs:{id:"variadic-arguments-macro"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#variadic-arguments-macro"}},[t._v("#")]),t._v(" Variadic arguments macro")]),t._v(" "),e("p",[t._v("Macros with variadic args:")]),t._v(" "),e("p",[t._v("Let's say you want to create some print-macro for debugging your code, let's take this macro as an example:")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(' debug_print(msg) printf("%s:%d %s", __FILE__, __LINE__, msg)')]),t._v("\n\n")])])]),e("p",[t._v("Some examples of usage:")]),t._v(" "),e("p",[t._v("The function "),e("code",[t._v("somefunc()")]),t._v(" returns -1 if failed and 0 if succeeded, and it is called from plenty different places within the code:")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" retVal "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("somefunc")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("retVal "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("debug_printf")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"somefunc() has failed"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* some other code */")]),t._v("\n\n retVal "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("somefunc")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("retVal "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("debug_printf")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"somefunc() has failed"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),e("p",[t._v("What happens if the implementation of "),e("code",[t._v("somefunc()")]),t._v(" changes, and it now returns different values matching different possible error types? You still want use the debug macro and print the error value.")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[t._v("debug_printf")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("retVal"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("      "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* this would obviously fail */")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("debug_printf")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"%d"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("retVal"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* this would also fail */")]),t._v("\n\n")])])]),e("p",[t._v("To solve this problem the "),e("code",[t._v("__VA_ARGS__")]),t._v(" macro was introduced. This macro allows multiple parameters X-macro's:")]),t._v(" "),e("p",[t._v("Example:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('\n#define debug_print(msg, ...) printf(msg, __VA_ARGS__) \\\n                               printf("\\nError occurred in file:line (%s:%d)\\n", __FILE__, __LINE)\n\n')])])]),e("p",[t._v("Usage:")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" retVal "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("somefunc")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("debug_print")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"retVal of somefunc() is-> %d"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" retVal"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),e("p",[t._v("This macro allows you to pass multiple parameters and print them, but now it forbids you from sending any parameters at all.")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[t._v("debug_print")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Hey"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),e("p",[t._v("This would raise some syntax error as the macro expects at least one more argument and the pre-processor would not ignore the lack of comma in the "),e("code",[t._v("debug_print()")]),t._v(" macro.\nAlso "),e("code",[t._v('debug_print("Hey",);')]),t._v(" would raise a syntax error as you cant keep the argument passed to macro empty.")]),t._v(" "),e("p",[t._v("To solve this, "),e("code",[t._v("##__VA_ARGS__")]),t._v(" macro was introduced, this macro states that if no variable arguments exist, the comma is deleted by the pre-processor from code.")]),t._v(" "),e("p",[t._v("Example:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('\n#define debug_print(msg, ...) printf(msg, ##__VA_ARGS__) \\\n                               printf("\\nError occured in file:line (%s:%d)\\n", __FILE__, __LINE)\n\n')])])]),e("p",[t._v("Usage:")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('\ndebug_print("Ret val of somefunc()?");\n debug_print("%d",somefunc());\n\n')])])]),e("h2",{attrs:{id:"macro-replacement"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#macro-replacement"}},[t._v("#")]),t._v(" Macro Replacement")]),t._v(" "),e("p",[t._v("The simplest form of macro replacement is to define a "),e("code",[t._v("manifest constant")]),t._v(", as in")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" ARRSIZE 100")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" array"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("ARRSIZE"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),e("p",[t._v("This defines a "),e("strong",[t._v("function-like")]),t._v(" macro that multiplies a variable by "),e("code",[t._v("10")]),t._v(" and stores the new value:")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" TIMES10(A) ((A) *= 10)")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("double")]),t._v(" b "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("34")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" c "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("23")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("TIMES10")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("b"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// good: ((b) *= 10);")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("TIMES10")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// good: ((c) *= 10);")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("TIMES10")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// bad:  ((5) *= 10);")]),t._v("\n\n")])])]),e("p",[t._v("The replacement is done before any other interpretation of the program text. In the first call to "),e("code",[t._v("TIMES10")]),t._v(" the name "),e("code",[t._v("A")]),t._v(" from the definition is replaced by "),e("code",[t._v("b")]),t._v(" and the so expanded text is then put in place of the call. Note that this definition of "),e("code",[t._v("TIMES10")]),t._v(" is not equivalent to")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" TIMES10(A) ((A) = (A) * 10)")]),t._v("\n\n")])])]),e("p",[t._v("because this could evaluate the replacement of "),e("code",[t._v("A")]),t._v(", twice, which can have unwanted side effects.")]),t._v(" "),e("p",[t._v("The following defines a function-like macro which value is the maximum of its arguments. It has the advantages of working for any compatible types of the arguments and of generating in-line code without the overhead of function calling. It has the disadvantages of evaluating one or the other of its arguments a second time (including side effects) and of generating more code than a function if invoked several times.")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" max(a, b) ((a) > (b) ? (a) : (b))")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" maxVal "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("max")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("11")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("43")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("              "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 43 */")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" maxValExpr "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("max")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("11")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("36")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("51")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* 47 */")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Should not be done, due to expression being evaluated twice */")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" j "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" i "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" sideEffect "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("max")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("i"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),t._v("j"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("       "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* i == 4 */")]),t._v("\n\n")])])]),e("p",[t._v("Because of this, such macros that evaluate their arguments multiple times are usually avoided in production code. Since C11 there is the "),e("code",[t._v("_Generic")]),t._v(" feature that allows to avoid such multiple invocations.")]),t._v(" "),e("p",[t._v("The abundant parentheses in the macro expansions (right hand side of the definition) ensure that the arguments and the resulting expression are bound properly and fit well into the context in which the macro is called.")]),t._v(" "),e("h2",{attrs:{id:"error-directive"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#error-directive"}},[t._v("#")]),t._v(" Error directive")]),t._v(" "),e("p",[t._v("If the preprocessor encounters an "),e("code",[t._v("#error")]),t._v(" directive, compilation is halted and the diagnostic message included is printed.")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" DEBUG")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("ifdef")]),t._v(" DEBUG")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("error")]),t._v(' "Debug Builds Not Supported"')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("endif")])]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),e("p",[t._v("Possible output:")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[t._v("$ gcc error"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("c\nerror"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("c"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" error"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" #error "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Debug Builds Not Supported"')]),t._v("\n\n")])])]),e("h2",{attrs:{id:"foreach-implementation"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#foreach-implementation"}},[t._v("#")]),t._v(" FOREACH implementation")]),t._v(" "),e("p",[t._v("We can also use macros for making code easier to read and write. For example we can implement macros for implementing the "),e("code",[t._v("foreach")]),t._v(" construct  in C for some data structures like singly- and doubly-linked lists, queues, etc.")]),t._v(" "),e("p",[t._v("Here is a small example.")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdio.h>")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdlib.h>")])]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("LinkedListNode")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" data"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("LinkedListNode")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("next"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" FOREACH_LIST(node, list) \\\n     for (node=list; node; node=node->next)")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Usage */")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("LinkedListNode")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("list"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("plist "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("list"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("node"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n         "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("plist "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("malloc")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("sizeof")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("LinkedListNode")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n         "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("plist"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("data "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" i"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n         "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("plist"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("next "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n         plist          "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("plist"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("next"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* printing the elements here */")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("FOREACH_LIST")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" list"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"%d\\n"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" node"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("data"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),e("p",[t._v("You can make a standard interface for such data-structures and write a generic implementation of "),e("code",[t._v("FOREACH")]),t._v(" as:")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdio.h>")])]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdlib.h>")])]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("CollectionItem_")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" data"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("CollectionItem_")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("next"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" CollectionItem"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Collection_")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* interface functions */")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("first"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("coll"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("last"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("coll"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("next"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("coll"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" CollectionItem "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("currItem"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    CollectionItem "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("collectionHead"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* Other fields */")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" Collection"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* must implement */")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("first")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("coll"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Collection"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("coll"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("collectionHead"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* must implement */")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("last")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("coll"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* must implement */")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("next")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("coll"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" CollectionItem "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("curr"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" curr"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("next"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\nCollectionItem "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("new_CollectionItem")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" data"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    CollectionItem "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("item "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("malloc")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("sizeof")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("CollectionItem"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    item"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("data "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" data"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    item"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("next "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" item"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("Add_Collection")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Collection "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("coll"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" data"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    CollectionItem "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("item "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("coll"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("collectionHead"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("item"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        item "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("item"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("next"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("item"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("new_CollectionItem")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("data"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\nCollection "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("new_Collection")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    Collection "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("nc "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("malloc")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("sizeof")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("Collection"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    nc"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("first "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" first"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    nc"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("last  "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" last"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    nc"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("next  "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" next"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" nc"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* generic implementation */")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token macro property"}},[t._v("#"),e("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("define")]),t._v(" FOREACH(node, collection)                      \\\n    for (node  = (collection)->first(collection);      \\\n         node != (collection)->last(collection);       \\\n         node  = (collection)->next(collection, node))")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    Collection "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("coll "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("new_Collection")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    CollectionItem "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("node"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n         "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("Add_Collection")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("coll"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" i"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/* printing the elements here */")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("FOREACH")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("node"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" coll"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("printf")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"%d\\n"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" node"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("data"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),e("p",[t._v("To use this generic implementation just implement these functions for your data structure.")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.")]),t._v("  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("first"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("coll"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2.")]),t._v("  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("last"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("coll"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3.")]),t._v("  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("next"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("coll"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" CollectionItem "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("currItem"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n")])])]),e("h4",{attrs:{id:"remarks"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#remarks"}},[t._v("#")]),t._v(" Remarks")]),t._v(" "),e("p",[t._v("When a compiler encounters a macro in the code, it performs simple string replacement, no additional operations are performed.   Because of this, changes by the preprocessor do not respect scope of C programs - for example, a macro definition is not limited to being within a block, so is unaffected by a "),e("code",[t._v("'}'")]),t._v(" that ends a block statement.")]),t._v(" "),e("p",[t._v("The preprocessor is, by design, not turing complete - there are several types of computation that cannot be done by the preprocessor alone.")]),t._v(" "),e("p",[t._v("Usually compilers have a command line flag (or configuration setting) that allows us to stop compilation after the preprocessing phase and to inspect the result. On POSIX platforms this flag is "),e("code",[t._v("-E")]),t._v(". So, running gcc with this flag  prints the expanded source to stdout:")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[t._v("$ gcc "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("E cprog"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("c\n\n")])])]),e("p",[t._v("Often the preprocessor is implemented as a separate program, which is invoked by the compiler, common name for that program is "),e("code",[t._v("cpp")]),t._v(".  A number of preprocessors emit supporting information, such as information about line numbers - which is used by subsequent phases of compilation to generate debugging information.   In the case the preprocessor is based on gcc, the -P option suppresses such information.")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[t._v("$ cpp "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("P cprog"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("c\n\n")])])])])}),[],!1,null,null,null);s.default=n.exports}}]);