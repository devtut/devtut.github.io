(window.webpackJsonp=window.webpackJsonp||[]).push([[610],{1018:function(e,t,a){"use strict";a.r(t);var n=a(31),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"alignment"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#alignment"}},[e._v("#")]),e._v(" Alignment")]),e._v(" "),a("p",[e._v("All types in C++ have an alignment. This is a restriction on the memory address that objects of that type can be created within. A memory address is valid for an object's creation if dividing that address by the object's alignment is a whole number.")]),e._v(" "),a("p",[e._v("Type alignments are always a power of two (including 1).")]),e._v(" "),a("h2",{attrs:{id:"controlling-alignment"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#controlling-alignment"}},[e._v("#")]),e._v(" Controlling alignment")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("alignas")]),e._v(" "),a("a",{attrs:{href:"http://stackoverflow.com/documentation/c%2b%2b/4891/keywords",target:"_blank",rel:"noopener noreferrer"}},[e._v("keyword"),a("OutboundLink")],1),e._v(" can be used to force a variable, class data member, declaration or definition of a class, or declaration or definition of an enum, to have a particular alignment, if supported. It comes in two forms:")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("alignas(x)")]),e._v(", where "),a("code",[e._v("x")]),e._v(" is a constant expression, gives the entity the alignment "),a("code",[e._v("x")]),e._v(", if supported.")]),e._v(" "),a("li",[a("code",[e._v("alignas(T)")]),e._v(", where "),a("code",[e._v("T")]),e._v(" is a type, gives the entity an alignment equal to the alignment requirement of "),a("code",[e._v("T")]),e._v(", that is, "),a("code",[e._v("alignof(T)")]),e._v(", if supported.")])]),e._v(" "),a("p",[e._v("If multiple "),a("code",[e._v("alignas")]),e._v(" specifiers are applied to the same entity, the strictest one applies.")]),e._v(" "),a("p",[e._v("In this example, the buffer "),a("code",[e._v("buf")]),e._v(" is guaranteed to be appropriately aligned to hold an "),a("code",[e._v("int")]),e._v(" object, even though its element type is "),a("code",[e._v("unsigned char")]),e._v(", which may have a weaker alignment requirement.")]),e._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("alignas")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("unsigned")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("char")]),e._v(" buf"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("sizeof")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("buf"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("42")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n")])])]),a("p",[a("code",[e._v("alignas")]),e._v(" cannot be used to give a type a smaller alignment than the type would have without this declaration:")]),e._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("alignas")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//Il-formed, unless `int` on this platform is aligned to 1 byte.")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("alignas")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("char")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" j"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("//Il-formed, unless `int` has the same or smaller alignment than `char`.")]),e._v("\n\n")])])]),a("p",[a("code",[e._v("alignas")]),e._v(", when given an integer constant expression, must be given a valid alignment. Valid alignments are always powers of two, and must be greater than zero. Compilers are required to support all valid alignments up to the alignment of the type "),a("code",[e._v("std::max_align_t")]),e._v(". They "),a("strong",[e._v("may")]),e._v(" support larger alignments than this, but support for allocating memory for such objects is limited. The upper limit on alignments is implementation dependent.")]),e._v(" "),a("p",[e._v("C++17 features direct support in "),a("code",[e._v("operator new")]),e._v(" for allocating memory for over-aligned types.")]),e._v(" "),a("h2",{attrs:{id:"querying-the-alignment-of-a-type"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#querying-the-alignment-of-a-type"}},[e._v("#")]),e._v(" Querying the alignment of a type")]),e._v(" "),a("p",[e._v("The alignment requirement of a type can be queried using the "),a("code",[e._v("alignof")]),e._v(" "),a("a",{attrs:{href:"http://stackoverflow.com/documentation/c%2b%2b/4891/keywords",target:"_blank",rel:"noopener noreferrer"}},[e._v("keyword"),a("OutboundLink")],1),e._v(" as a unary operator. The result is a constant expression of type "),a("code",[e._v("std::size_t")]),e._v(", "),a("strong",[e._v("i.e.,")]),e._v(" it can be evaluated at compile time.")]),e._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token macro property"}},[a("span",{pre:!0,attrs:{class:"token directive-hash"}},[e._v("#")]),a("span",{pre:!0,attrs:{class:"token directive keyword"}},[e._v("include")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("<iostream>")])]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("main")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    std"),a("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[e._v("::")]),e._v("cout "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<<")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"The alignment requirement of int is: "')]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<<")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("alignof")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<<")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'\\n'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n")])])]),a("p",[e._v("Possible output")]),e._v(" "),a("blockquote"),e._v(" "),a("p",[e._v("The alignment requirement of int is: 4")]),e._v(" "),a("p",[e._v("If applied to an array, it yields the alignment requirement of the element type. If applied to a reference type, it yields the alignment requirement of the referenced type. (References themselves have no alignment, since they are not objects.)")]),e._v(" "),a("h4",{attrs:{id:"remarks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#remarks"}},[e._v("#")]),e._v(" Remarks")]),e._v(" "),a("p",[e._v("The standard guarantees the following:")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("The alignment requirement of a type is a divisor of its size. For example, a class with size 16 bytes could have an alignment of 1, 2, 4, 8, or 16, but not 32. (If a class's members only total 14 bytes in size, but the class needs to have an alignment requirement of 8, the compiler will insert 2 padding bytes to make the class's size equal to 16.)")])]),e._v(" "),a("li",[a("p",[e._v("The signed and unsigned versions of an integer type have the same alignment requirement.")])]),e._v(" "),a("li",[a("p",[e._v("A pointer to "),a("code",[e._v("void")]),e._v(" has the same alignment requirement as a pointer to "),a("code",[e._v("char")]),e._v(".")])]),e._v(" "),a("li",[a("p",[e._v("The cv-qualified and cv-unqualified versions of a type have the same alignment requirement.")])])]),e._v(" "),a("p",[e._v("Note that while alignment exists in C++03, it was not until C++11 that it became possible to query alignment (using "),a("code",[e._v("alignof")]),e._v(") and control alignment (using "),a("code",[e._v("alignas")]),e._v(").")])])}),[],!1,null,null,null);t.default=s.exports}}]);