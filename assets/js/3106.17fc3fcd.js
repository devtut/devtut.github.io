(window.webpackJsonp=window.webpackJsonp||[]).push([[3106],{3514:function(t,a,s){"use strict";s.r(a);var e=s(31),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"recursion-in-ruby"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#recursion-in-ruby"}},[t._v("#")]),t._v(" Recursion in Ruby")]),t._v(" "),s("h2",{attrs:{id:"tail-recursion"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tail-recursion"}},[t._v("#")]),t._v(" Tail recursion")]),t._v(" "),s("p",[t._v("Many recursive algorithms can be expressed using iteration. For instance, the greatest common denominator function can be "),s("a",{attrs:{href:"https://en.wikipedia.org/wiki/Recursion_(computer_science)#Recursive_procedures",target:"_blank",rel:"noopener noreferrer"}},[t._v("written recursively"),s("OutboundLink")],1),t._v(":")]),t._v(" "),s("div",{staticClass:"language-ruby extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ruby"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token method-definition"}},[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("gdc")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" y"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" x "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" y "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" gdc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("y"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" x"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("y"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("end")]),t._v("\n\n")])])]),s("p",[t._v("or iteratively:")]),t._v(" "),s("div",{staticClass:"language-ruby extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ruby"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token method-definition"}},[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("gdc_iter")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" y"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" y "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("do")]),t._v("\n    x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" y "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" y"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" x"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("%")]),t._v("y\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("end")]),t._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" x\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("end")]),t._v("\n\n")])])]),s("p",[t._v("The two algorithms are equivalent in theory, but the recursive version risks a "),s("a",{attrs:{href:"https://ruby-doc.org/core/SystemStackError.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("SystemStackError"),s("OutboundLink")],1),t._v(". However, since the recursive method ends with a call to itself, it could be optimized to avoid a stack overflow. Another way to put it: the recursive algorithm can result in the same machine code as the iterative "),s("strong",[t._v("if")]),t._v(" the compiler knows to look for the recursive method call at the end of the method. Ruby doesn't do tail call optimization by default, but you can "),s("a",{attrs:{href:"https://ruby-doc.org/core/RubyVM/InstructionSequence.html#method-c-compile_option",target:"_blank",rel:"noopener noreferrer"}},[t._v("turn it on with"),s("OutboundLink")],1),t._v(":")]),t._v(" "),s("div",{staticClass:"language-ruby extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ruby"}},[s("code",[s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("RubyVM")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("InstructionSequence")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("compile_option "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  tailcall_optimization"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  trace_instruction"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),s("p",[t._v("In addition to turning on tail-call optimization, you also need to turn off instruction tracing. Unfortunately, these options only apply at compile time, so you either need to "),s("code",[t._v("require")]),t._v(" the recursive method from another file or "),s("code",[t._v("eval")]),t._v(" the method definition:")]),t._v(" "),s("div",{staticClass:"language-ruby extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ruby"}},[s("code",[s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("RubyVM")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("InstructionSequence")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("EOF")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("eval\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token method-definition"}},[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("me_myself_and_i")])]),t._v("\n    me_myself_and_i\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("end")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("EOF")]),t._v("\nme_myself_and_i "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Infinite loop, not stack overflow")]),t._v("\n\n")])])]),s("p",[t._v("Finally, the final return call must return the method and "),s("strong",[t._v("only the method")]),t._v(". That means you'll need to re-write the standard factorial function:")]),t._v(" "),s("div",{staticClass:"language-ruby extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ruby"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token method-definition"}},[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("fact")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" x "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" x"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("fact"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("x"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("end")]),t._v("\n\n")])])]),s("p",[t._v("To something like:")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("\ndef fact(x, acc=1)\n   return acc if x <= 1\n   return fact(x-1, x*acc)\n end\n\n")])])]),s("p",[t._v("This version passes the accumulated sum via a second (optional) argument that "),s("a",{attrs:{href:"http://stackoverflow.com/documentation/ruby/997/methods/3243/default-parameters#t=201705072356272378973",target:"_blank",rel:"noopener noreferrer"}},[t._v("defaults"),s("OutboundLink")],1),t._v(" to 1.")]),t._v(" "),s("p",[t._v("Further reading: "),s("a",{attrs:{href:"http://nithinbekal.com/posts/ruby-tco/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Tail Call Optimization in Ruby"),s("OutboundLink")],1),t._v(" and "),s("a",{attrs:{href:"http://timelessrepo.com/tailin-ruby",target:"_blank",rel:"noopener noreferrer"}},[t._v("Tailin' Ruby"),s("OutboundLink")],1),t._v(".")]),t._v(" "),s("h2",{attrs:{id:"recursive-function"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#recursive-function"}},[t._v("#")]),t._v(" Recursive function")]),t._v(" "),s("p",[t._v("Let's start with a simple algorithm to see how recursion could be implemented in Ruby.")]),t._v(" "),s("p",[t._v("A bakery has products to sell. Products are in packs. It services orders in packs only. Packaging starts from the largest pack size and then the remaining quantities are filled by next pack sizes available.")]),t._v(" "),s("p",[t._v("For e.g. If an order of 16 is received, bakery allocates 2 from 5 pack and 2 from 3 pack. 2"),s("strong",[t._v("5+2")]),t._v('3 = 16. Let\'s see how this is implemented in recursion. "allocate" is the recursive function here.')]),t._v(" "),s("div",{staticClass:"language-ruby extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ruby"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#!/usr/bin/ruby")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Bakery")]),t._v("\n  attr_accessor "),s("span",{pre:!0,attrs:{class:"token symbol"}},[t._v(":selected_packs")]),t._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token method-definition"}},[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("initialize")])]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@packs")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# pack sizes 5 and 3")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@selected_packs")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("end")]),t._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token method-definition"}},[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("allocate")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("qty"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    remaining_qty "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("nil")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# ==============================================")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# packs are allocated in large packs first order")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# to minimize the packaging space")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# ==============================================")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@packs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("each")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("do")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("pack"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("\n      remaining_qty "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" qty "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" pack\n\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" remaining_qty "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n        ret_val "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" allocate"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("remaining_qty"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" ret_val "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n          "),s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@selected_packs")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" pack\n          remaining_qty "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n          "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("end")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("elsif")]),t._v(" remaining_qty "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token variable"}},[t._v("@selected_packs")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" pack\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("end")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("end")]),t._v("\n\n    remaining_qty\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("end")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("end")]),t._v("\n\nbakery "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Bakery")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v("\nbakery"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("allocate"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("16")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\nputs "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Pack combination is: '),s("span",{pre:!0,attrs:{class:"token interpolation"}},[s("span",{pre:!0,attrs:{class:"token delimiter tag"}},[t._v("#{")]),t._v("bakery"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("selected_packs"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("inspect"),s("span",{pre:!0,attrs:{class:"token delimiter tag"}},[t._v("}")])]),t._v('"')]),t._v("\n\n")])])]),s("p",[t._v("Output is:")]),t._v(" "),s("blockquote"),t._v(" "),s("p",[t._v("Pack combination is: [3, 3, 5, 5]")])])}),[],!1,null,null,null);a.default=n.exports}}]);