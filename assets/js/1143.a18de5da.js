(window.webpackJsonp=window.webpackJsonp||[]).push([[1143],{1551:function(e,t,a){"use strict";a.r(t);var s=a(31),r=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"rebasing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rebasing"}},[e._v("#")]),e._v(" Rebasing")]),e._v(" "),a("h2",{attrs:{id:"local-branch-rebasing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#local-branch-rebasing"}},[e._v("#")]),e._v(" Local Branch Rebasing")]),e._v(" "),a("p",[a("strong",[a("a",{attrs:{href:"https://git-scm.com/docs/git-rebase",target:"_blank",rel:"noopener noreferrer"}},[e._v("Rebasing"),a("OutboundLink")],1)]),e._v(" reapplies a series of commits on top of another commit.")]),e._v(" "),a("p",[e._v("To "),a("code",[e._v("rebase")]),e._v(" a branch, checkout the branch and then "),a("code",[e._v("rebase")]),e._v(" it on top of another branch.")]),e._v(" "),a("div",{staticClass:"language-git extra-class"},[a("pre",{pre:!0,attrs:{class:"language-git"}},[a("code",[e._v("git checkout topic\ngit rebase master  # rebase current branch onto master branch\n\n")])])]),a("p",[e._v("This would cause:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("\n     A---B---C topic\n     /\nD---E---F---G master\n\n")])])]),a("p",[e._v("To turn into:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("\n             A'--B'--C' topic\n             /\nD---E---F---G master\n\n")])])]),a("p",[e._v("These operations can be combined into a single command that checks out the branch and immediately rebases it:")]),e._v(" "),a("div",{staticClass:"language-git extra-class"},[a("pre",{pre:!0,attrs:{class:"language-git"}},[a("code",[e._v("git rebase master topic   # rebase topic branch onto master branch\n\n")])])]),a("p",[a("strong",[e._v("Important:")]),e._v(" After the rebase, the applied commits will have a different hash. You should not rebase commits you have already pushed to a remote host. A consequence may be an inability to "),a("code",[e._v("git push")]),e._v(" your local rebased branch to a remote host, leaving your only option to "),a("code",[e._v("git push --force")]),e._v(".")]),e._v(" "),a("h2",{attrs:{id:"rebase-ours-and-theirs-local-and-remote"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rebase-ours-and-theirs-local-and-remote"}},[e._v("#")]),e._v(" Rebase: ours and theirs, local and remote")]),e._v(" "),a("p",[e._v('A rebase switches the meaning of "ours" and "theirs":')]),e._v(" "),a("div",{staticClass:"language-git extra-class"},[a("pre",{pre:!0,attrs:{class:"language-git"}},[a("code",[e._v("git checkout topic\ngit rebase   master    # rebase topic branch on top of master branch\n\n")])])]),a("p",[a("strong",[e._v('Whatever HEAD\'s pointing to is "ours"')])]),e._v(" "),a("p",[e._v("The first thing a rebase does is resetting the "),a("code",[e._v("HEAD")]),e._v(" to "),a("code",[e._v("master")]),e._v("; before cherry-picking commits from the old branch "),a("code",[e._v("topic")]),e._v(" to a new one (every commit in the former "),a("code",[e._v("topic")]),e._v(" branch will be rewritten and will be identified by a different hash).")]),e._v(" "),a("p",[e._v("With respect to terminologies used by merge tools (not to be confused with "),a("a",{attrs:{href:"https://git-scm.com/docs/gitglossary#gitglossary-aiddefrefspecarefspec",target:"_blank",rel:"noopener noreferrer"}},[e._v("local ref or remote ref"),a("OutboundLink")],1),e._v(")")]),e._v(" "),a("div",{staticClass:"language-git extra-class"},[a("pre",{pre:!0,attrs:{class:"language-git"}},[a("code",[e._v("=> local is master ("),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"ours"')]),e._v("),\n=> remote is topic ("),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"theirs"')]),e._v(")\n\n")])])]),a("p",[e._v("That means a merge/diff tool will present the upstream branch as "),a("code",[e._v("local")]),e._v(" ("),a("code",[e._v("master")]),e._v(": the branch on top of which you are rebasing), and the working branch as "),a("code",[e._v("remote")]),e._v(" ("),a("code",[e._v("topic")]),e._v(": the branch being rebased)")]),e._v(" "),a("div",{staticClass:"language-git extra-class"},[a("pre",{pre:!0,attrs:{class:"language-git"}},[a("code",[a("span",{pre:!0,attrs:{class:"token inserted"}},[e._v("+-----------------------------------------+")]),e._v("\n| LOCAL:master |    BASE   | REMOTE:topic |\n"),a("span",{pre:!0,attrs:{class:"token inserted"}},[e._v("+-----------------------------------------+")]),e._v("\n|             MERGED                      |\n"),a("span",{pre:!0,attrs:{class:"token inserted"}},[e._v("+-----------------------------------------+")]),e._v("\n\n")])])]),a("h3",{attrs:{id:"inversion-illustrated"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#inversion-illustrated"}},[e._v("#")]),e._v(" Inversion illustrated")]),e._v(" "),a("h3",{attrs:{id:"on-a-merge"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#on-a-merge"}},[e._v("#")]),e._v(" On a merge:")]),e._v(" "),a("div",{staticClass:"language-git extra-class"},[a("pre",{pre:!0,attrs:{class:"language-git"}},[a("code",[e._v("c--c--x--x--x(*) <- current branch topic ("),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'*'")]),e._v("=HEAD)\n    \\\n     \\\n      \\--y--y--y <- other branch to merge\n\n")])])]),a("p",[e._v("We don't change the current branch "),a("code",[e._v("topic")]),e._v(", so what we have is still what we were working on (and we merge from another branch)")]),e._v(" "),a("div",{staticClass:"language-git extra-class"},[a("pre",{pre:!0,attrs:{class:"language-git"}},[a("code",[e._v("c--c--x--x--x---------o(*)  MERGE, still on branch topic\n    \\       ^        /\n     \\     ours     /\n      \\            /\n       --y--y--y--/\n               ^\n              theirs\n\n")])])]),a("h3",{attrs:{id:"on-a-rebase"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#on-a-rebase"}},[e._v("#")]),e._v(" On a rebase:")]),e._v(" "),a("p",[e._v("But "),a("strong",[e._v("on a rebase")]),e._v(" we switch sides because the first thing a rebase does is to checkout the upstream branch to replay the current commits on top of it!")]),e._v(" "),a("div",{staticClass:"language-git extra-class"},[a("pre",{pre:!0,attrs:{class:"language-git"}},[a("code",[e._v("c--c--x--x--x(*) <- current branch topic ("),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'*'")]),e._v("=HEAD)\n    \\\n     \\\n      \\--y--y--y <- upstream branch\n\n")])])]),a("p",[e._v("A "),a("strong",[a("code",[e._v("git rebase upstream")])]),e._v(" will first set "),a("code",[e._v("HEAD")]),e._v(" to the upstream branch, hence the switch of 'ours' and 'theirs' compared to the previous \"current\" working branch.")]),e._v(" "),a("div",{staticClass:"language-git extra-class"},[a("pre",{pre:!0,attrs:{class:"language-git"}},[a("code",[e._v("c--c--x--x--x <- former "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"current"')]),e._v(" branch, new "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"theirs"')]),e._v("\n    \\\n     \\\n      \\--y--y--y(*) <- set HEAD to this commit, to replay x's on it\n               ^       this will be the new "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"ours"')]),e._v("\n               |\n            upstream\n\n")])])]),a("p",[e._v("The rebase will then replay 'their' commits on the new 'our' "),a("code",[e._v("topic")]),e._v(" branch:")]),e._v(" "),a("div",{staticClass:"language-git extra-class"},[a("pre",{pre:!0,attrs:{class:"language-git"}},[a("code",[e._v("c--c..x..x..x <- old "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"theirs"')]),e._v(" commits, now "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"ghosts"')]),e._v(", available through "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"reflogs"')]),e._v("\n    \\\n     \\\n      \\--y--y--y--x"),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'--x'")]),e._v("--x"),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'(*) <- topic  once all x'")]),e._v("s are replayed,\n               ^                      point branch topic to this commit\n               |\n        upstream branch\n\n")])])]),a("h2",{attrs:{id:"interactive-rebase"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#interactive-rebase"}},[e._v("#")]),e._v(" Interactive Rebase")]),e._v(" "),a("p",[e._v("This example aims to describe how one can utilize "),a("code",[e._v("git rebase")]),e._v(" in interactive mode. It is expected that one has a basic understanding of what "),a("code",[e._v("git rebase")]),e._v(" is and what it does.")]),e._v(" "),a("p",[e._v("Interactive rebase is initiated using following command:")]),e._v(" "),a("div",{staticClass:"language-git extra-class"},[a("pre",{pre:!0,attrs:{class:"language-git"}},[a("code",[e._v("git rebase -i\n\n")])])]),a("p",[e._v("The "),a("code",[e._v("-i")]),e._v(" option refers to "),a("strong",[e._v("interactive mode")]),e._v(". Using interactive rebase, the user can change commit messages, as well as reorder, split, and/or squash (combine to one) commits.")]),e._v(" "),a("p",[e._v("Say you want to rearrange your last three commits. To do this you can run:")]),e._v(" "),a("div",{staticClass:"language-git extra-class"},[a("pre",{pre:!0,attrs:{class:"language-git"}},[a("code",[e._v("git rebase -i HEAD~3\n\n")])])]),a("p",[e._v("After executing the above instruction, a file will be opened in your text editor where you will be able to select how your commits will be rebased. For the purpose of this example, just change the order of your commits, save the file, and close the editor. This will initiate a rebase with the order you've applied. If you check "),a("code",[e._v("git log")]),e._v(" you will see your commits in the new order you specified.")]),e._v(" "),a("h3",{attrs:{id:"rewording-commit-messages"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rewording-commit-messages"}},[e._v("#")]),e._v(" Rewording commit messages")]),e._v(" "),a("p",[e._v("Now, you've decided that one of the commit messages is vague and you want it to be more descriptive. Let's examine the last three commits using the same command.")]),e._v(" "),a("div",{staticClass:"language-git extra-class"},[a("pre",{pre:!0,attrs:{class:"language-git"}},[a("code",[e._v("git rebase -i HEAD~3\n\n")])])]),a("p",[e._v("Instead of rearranging the order the commits will be rebased, this time we will change "),a("code",[e._v("pick")]),e._v(", the default, to "),a("code",[e._v("reword")]),e._v(" on a commit where you would like to change the message.")]),e._v(" "),a("p",[e._v("When you close the editor, the rebase will initiate and it will stop at the specific commit message that you wanted to reword. This will let you change the commit message to whichever you desire. After you've changed the message, simply close the editor to proceed.")]),e._v(" "),a("h3",{attrs:{id:"changing-the-content-of-a-commit"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#changing-the-content-of-a-commit"}},[e._v("#")]),e._v(" Changing the content of a commit")]),e._v(" "),a("p",[e._v("Besides changing the commit message you can also adapt the changes done by the commit. To do so just change "),a("code",[e._v("pick")]),e._v(" to "),a("code",[e._v("edit")]),e._v(" for one commit. Git will stop when it arrives at that commit and provide the original changes of the commit in the staging area. You can now adapt those changes by unstaging them or adding new changes.")]),e._v(" "),a("p",[e._v("As soon as the staging area contains all changes you want in that commit, commit the changes. The old commit message will be shown and can be adapted to reflect the new commit.")]),e._v(" "),a("h3",{attrs:{id:"splitting-a-single-commit-into-multiple"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#splitting-a-single-commit-into-multiple"}},[e._v("#")]),e._v(" Splitting a single commit into multiple")]),e._v(" "),a("p",[e._v("Say you've made a commit but decided at a later point this commit could be split into two or more commits instead. Using the same command as before, replace "),a("code",[e._v("pick")]),e._v(" with "),a("code",[e._v("edit")]),e._v(" instead and hit enter.")]),e._v(" "),a("p",[e._v("Now, git will stop at the commit you have marked for editing and place all of its content into the staging area. From that point you can run "),a("code",[e._v("git reset HEAD^")]),e._v(" to place the commit into your working directory. Then, you can add and commit your files in a different sequence - ultimately splitting a single commit into "),a("strong",[e._v("n")]),e._v(" commits instead.")]),e._v(" "),a("h3",{attrs:{id:"squashing-multiple-commits-into-one"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#squashing-multiple-commits-into-one"}},[e._v("#")]),e._v(" Squashing multiple commits into one")]),e._v(" "),a("p",[e._v("Say you have done some work and have multiple commits which you think could be a single commit instead. For that you can carry out "),a("code",[e._v("git rebase -i HEAD~3")]),e._v(", replacing "),a("code",[e._v("3")]),e._v(" with an appropriate amount of commits.")]),e._v(" "),a("p",[e._v("This time replace "),a("code",[e._v("pick")]),e._v(" with "),a("code",[e._v("squash")]),e._v(" instead. During the rebase, the commit which you've instructed to be squashed will be squashed on top of the previous commit; turning them into a single commit instead.")]),e._v(" "),a("h2",{attrs:{id:"rebase-down-to-the-initial-commit"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rebase-down-to-the-initial-commit"}},[e._v("#")]),e._v(" Rebase down to the initial commit")]),e._v(" "),a("p",[e._v("Since Git "),a("a",{attrs:{href:"https://github.com/git/git/blob/1d1bdafd64266e5ee3bd46c6965228f32e4022ea/Documentation/RelNotes/1.7.12.txt#L59-L60",target:"_blank",rel:"noopener noreferrer"}},[e._v("1.7.12"),a("OutboundLink")],1),e._v(" it is possible to rebase down to the root commit. The root commit is the first commit ever made in a repository, and normally cannot be edited. Use the following command:")]),e._v(" "),a("div",{staticClass:"language-git extra-class"},[a("pre",{pre:!0,attrs:{class:"language-git"}},[a("code",[e._v("git rebase -i --root\n\n")])])]),a("h2",{attrs:{id:"rebasing-before-a-code-review"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rebasing-before-a-code-review"}},[e._v("#")]),e._v(" Rebasing before a code review")]),e._v(" "),a("h3",{attrs:{id:"summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#summary"}},[e._v("#")]),e._v(" Summary")]),e._v(" "),a("p",[e._v("This goal is to reorganize all of your scattered commits into more meaningful commits for easier code reviews. If there are too many layers of changes across too many files at once, it is harder to do a code review. If you can reorganize your chronologically created commits into topical commits, then the code review process is easier (and possibly less bugs slip through the code review process).")]),e._v(" "),a("p",[e._v("This overly-simplified example is not the only strategy for using git to do better code reviews. It is the way I do it, and it's something to inspire others to consider how to make code reviews and git history easier/better.")]),e._v(" "),a("p",[e._v("This also pedagogically demonstrates the power of rebase in general.")]),e._v(" "),a("p",[e._v("This example assumes you know about interactive rebasing.")]),e._v(" "),a("h3",{attrs:{id:"assuming"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#assuming"}},[e._v("#")]),e._v(" Assuming:")]),e._v(" "),a("ul",[a("li",[e._v("you're working on a feature branch off of master")]),e._v(" "),a("li",[e._v("your feature has three main layers: front-end, back-end, DB")]),e._v(" "),a("li",[e._v("you have made a lot of commits while working on a feature branch. Each commit touches multiple layers at once\n")]),a("li",[e._v("you want (in the end) only three commits in your branch\n"),a("ul")]),e._v(" "),a("li",[e._v("one containing all front end changes")]),e._v(" "),a("li",[e._v("one containing all back end changes")]),e._v(" "),a("li",[e._v("one containing all DB changes")])]),e._v(" "),a("h3",{attrs:{id:"strategy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#strategy"}},[e._v("#")]),e._v(" Strategy:")]),e._v(" "),a("ul",[a("li",[e._v('we are going to change our chronological commits into "topical" commits.')]),e._v(" "),a("li",[e._v("first, split all commits into multiple, smaller commits -- each containing only one topic at a time (in our example, the topics are front end, back end, DB changes)")]),e._v(" "),a("li",[e._v("Then reorder our topical commits together and 'squash' them into single topical commits")])]),e._v(" "),a("h3",{attrs:{id:"example"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#example"}},[e._v("#")]),e._v(" Example:")]),e._v(" "),a("div",{staticClass:"language-git extra-class"},[a("pre",{pre:!0,attrs:{class:"language-git"}},[a("code",[a("span",{pre:!0,attrs:{class:"token command"}},[e._v("$ git log"),a("span",{pre:!0,attrs:{class:"token parameter"}},[e._v(" --oneline")]),e._v(" master..")]),e._v("\n975430b db adding works: db.sql logic.rb\n3702650 trying to allow adding todo items: page.html logic.rb\n43b075a first draft: page.html and db.sql\n"),a("span",{pre:!0,attrs:{class:"token command"}},[e._v("$ git rebase"),a("span",{pre:!0,attrs:{class:"token parameter"}},[e._v(" -i")]),e._v(" master")]),e._v("\n\n")])])]),a("p",[e._v("This will be shown in text editor:")]),e._v(" "),a("div",{staticClass:"language-git extra-class"},[a("pre",{pre:!0,attrs:{class:"language-git"}},[a("code",[e._v("pick 43b075a first draft: page.html and db.sql\npick 3702650 trying to allow adding todo items: page.html logic.rb\npick 975430b db adding works: db.sql logic.rb\n\n")])])]),a("p",[e._v("Change it to this:")]),e._v(" "),a("div",{staticClass:"language-git extra-class"},[a("pre",{pre:!0,attrs:{class:"language-git"}},[a("code",[e._v("e 43b075a first draft: page.html and db.sql\ne 3702650 trying to allow adding todo items: page.html logic.rb\ne 975430b db adding works: db.sql logic.rb\n\n")])])]),a("p",[e._v("Then git will apply one commit at a time. After each commit, it will show a prompt, and then you can do the following:")]),e._v(" "),a("div",{staticClass:"language-git extra-class"},[a("pre",{pre:!0,attrs:{class:"language-git"}},[a("code",[e._v("Stopped at 43b075a92a952faf999e76c4e4d7fa0f44576579... first draft: page.html and db.sql\nYou can amend the commit now, with\n\n        git commit --amend\n\nOnce you are satisfied with your changes, run\n\n        git rebase --continue\n\n"),a("span",{pre:!0,attrs:{class:"token command"}},[e._v("$ git status")]),e._v("\nrebase in progress; onto 4975ae9\nYou are currently editing a commit while rebasing branch "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'feature'")]),e._v(" on "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'4975ae9'")]),e._v(".\n  (use "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"git commit --amend"')]),e._v(" to amend the current commit)\n  (use "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"git rebase --continue"')]),e._v(" once you are satisfied with your changes)\n\nnothing to commit, working directory clean\n"),a("span",{pre:!0,attrs:{class:"token command"}},[e._v("$ git reset HEAD^ #This ")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v("'uncommits'")]),e._v(" all the changes in this commit.\n"),a("span",{pre:!0,attrs:{class:"token command"}},[e._v("$ git status"),a("span",{pre:!0,attrs:{class:"token parameter"}},[e._v(" -s")])]),e._v("\n M db.sql\n M page.html\n"),a("span",{pre:!0,attrs:{class:"token command"}},[e._v("$ git add db.sql  #now we will create the smaller topical commits")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token command"}},[e._v("$ git commit"),a("span",{pre:!0,attrs:{class:"token parameter"}},[e._v(" -m")]),e._v(" ")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"first draft: db.sql"')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token command"}},[e._v("$ git add page.html")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token command"}},[e._v("$ git commit"),a("span",{pre:!0,attrs:{class:"token parameter"}},[e._v(" -m")]),e._v(" ")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"first draft: page.html"')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token command"}},[e._v("$ git rebase"),a("span",{pre:!0,attrs:{class:"token parameter"}},[e._v(" --continue")])]),e._v("\n\n")])])]),a("p",[e._v("Then you will repeat those steps for every commit. In the end, you have this:")]),e._v(" "),a("div",{staticClass:"language-git extra-class"},[a("pre",{pre:!0,attrs:{class:"language-git"}},[a("code",[a("span",{pre:!0,attrs:{class:"token command"}},[e._v("$ git log"),a("span",{pre:!0,attrs:{class:"token parameter"}},[e._v(" --oneline")])]),e._v("\n0309336 db adding works: logic.rb\n06f81c9 db adding works: db.sql\n3264de2 adding todo items: page.html\n675a02b adding todo items: logic.rb\n272c674 first draft: page.html\n08c275d first draft: db.sql\n\n")])])]),a("p",[e._v("Now we run rebase one more time to reorder and squash:")]),e._v(" "),a("div",{staticClass:"language-git extra-class"},[a("pre",{pre:!0,attrs:{class:"language-git"}},[a("code",[a("span",{pre:!0,attrs:{class:"token command"}},[e._v("$ git rebase"),a("span",{pre:!0,attrs:{class:"token parameter"}},[e._v(" -i")]),e._v(" master")]),e._v("\n\n")])])]),a("p",[e._v("This will be shown in text editor:")]),e._v(" "),a("div",{staticClass:"language-git extra-class"},[a("pre",{pre:!0,attrs:{class:"language-git"}},[a("code",[e._v("pick 08c275d first draft: db.sql\npick 272c674 first draft: page.html\npick 675a02b adding todo items: logic.rb\npick 3264de2 adding todo items: page.html\npick 06f81c9 db adding works: db.sql\npick 0309336 db adding works: logic.rb\n\n")])])]),a("p",[e._v("Change it to this:")]),e._v(" "),a("div",{staticClass:"language-git extra-class"},[a("pre",{pre:!0,attrs:{class:"language-git"}},[a("code",[e._v("pick 08c275d first draft: db.sql\ns 06f81c9 db adding works: db.sql\npick 675a02b adding todo items: logic.rb\ns 0309336 db adding works: logic.rb\npick 272c674 first draft: page.html\ns  3264de2 adding todo items: page.html\n\n")])])]),a("p",[e._v("NOTICE: make sure that you tell git rebase to apply/squash the smaller topical commits "),a("strong",[e._v("in the order they were chronologically commited")]),e._v(". Otherwise you might have false, needless merge conflicts to deal with.")]),e._v(" "),a("p",[e._v("When that interactive rebase is all said and done, you get this:")]),e._v(" "),a("div",{staticClass:"language-git extra-class"},[a("pre",{pre:!0,attrs:{class:"language-git"}},[a("code",[a("span",{pre:!0,attrs:{class:"token command"}},[e._v("$ git log"),a("span",{pre:!0,attrs:{class:"token parameter"}},[e._v(" --oneline")]),e._v(" master..")]),e._v("\n74bdd5f adding todos: GUI layer\ne8d8f7e adding todos: business logic layer\n121c578 adding todos: DB layer\n\n")])])]),a("h3",{attrs:{id:"recap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#recap"}},[e._v("#")]),e._v(" Recap")]),e._v(" "),a("p",[e._v("You have now rebased your chronological commits into topical commits. In real life, you may not need to do this every single time, but when you do want or need to do this, now you can. Plus, hopefully you learned more about git rebase.")]),e._v(" "),a("h2",{attrs:{id:"testing-all-commits-during-rebase"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#testing-all-commits-during-rebase"}},[e._v("#")]),e._v(" Testing all commits during rebase")]),e._v(" "),a("p",[e._v("Before making a pull request, it is useful to make sure that compile is successful and tests are passing for each commit in the branch. We can do that automatically using "),a("code",[e._v("-x")]),e._v(" parameter.")]),e._v(" "),a("p",[e._v("For example:")]),e._v(" "),a("p",[a("code",[e._v("git rebase -i -x make")])]),e._v(" "),a("p",[e._v("will perform the interactive rebase and stop after each commit to execute "),a("code",[e._v("make")]),e._v(". In case "),a("code",[e._v("make")]),e._v(" fails, git will stop to give you an opportunity to fix the issues and amend the commit before proceeding with picking the next one.")]),e._v(" "),a("h2",{attrs:{id:"configuring-autostash"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#configuring-autostash"}},[e._v("#")]),e._v(" Configuring autostash")]),e._v(" "),a("p",[e._v("Autostash is a very useful configuration option when using rebase for local changes. Oftentimes, you may need to bring in commits from the upstream branch, but are not ready to commit just yet.")]),e._v(" "),a("p",[e._v("However, Git does not allow a rebase to start if the working directory is not clean. Autostash to the rescue:")]),e._v(" "),a("div",{staticClass:"language-git extra-class"},[a("pre",{pre:!0,attrs:{class:"language-git"}},[a("code",[e._v("git config --global rebase.autostash    # one time configuration\ngit rebase @{u}                         # example rebase on upstream branch\n\n")])])]),a("p",[e._v("The autostash will be applied whenever the rebase is finished. It does not matter whether the rebase finishes successfully, or if it is aborted. Either way, the autostash will be applied. If the rebase was successful, and the base commit therefore changed, then there may be a conflict between the autostash and the new commits. In this case, you will have to resolve the conflicts before committing. This is no different than if you would have manually stashed, and then applied, so there is no downside to doing it automatically.")]),e._v(" "),a("h2",{attrs:{id:"aborting-an-interactive-rebase"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aborting-an-interactive-rebase"}},[e._v("#")]),e._v(" Aborting an Interactive Rebase")]),e._v(" "),a("p",[e._v("You have started an interactive rebase. In the editor where you pick your commits, you decide that something is going wrong (for example a commit is missing, or you chose the wrong rebase destination), and you want to abort the rebase.")]),e._v(" "),a("p",[e._v("To do this, simply delete all commits and actions (i.e. all lines not starting with the "),a("code",[e._v("#")]),e._v(" sign) and the rebase will be aborted!")]),e._v(" "),a("p",[e._v("The help text in the editor actually provides this hint:")]),e._v(" "),a("div",{staticClass:"language-git extra-class"},[a("pre",{pre:!0,attrs:{class:"language-git"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Rebase 36d15de..612f2f7 onto 36d15de (3 command(s))")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Commands:")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# p, pick = use commit")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# r, reword = use commit, but edit the commit message")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# e, edit = use commit, but stop for amending")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# s, squash = use commit, but meld into previous commit")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v('# f, fixup = like "squash", but discard this commit\'s log message')]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# x, exec = run command (the rest of the line) using shell")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# These lines can be re-ordered; they are executed from top to bottom.")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# If you remove a line here THAT COMMIT WILL BE LOST.")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# However, if you remove everything, the rebase will be aborted.")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Note that empty commits are commented out")]),e._v("\n\n")])])]),a("h2",{attrs:{id:"setup-git-pull-for-automatically-perform-a-rebase-instead-of-a-merge"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setup-git-pull-for-automatically-perform-a-rebase-instead-of-a-merge"}},[e._v("#")]),e._v(" Setup git-pull for automatically perform a rebase instead of a merge")]),e._v(" "),a("p",[e._v("If your team is following a rebase-based workflow, it may be a advantageous to setup git so that each newly created branch will perform a rebase operation, instead of a merge operation, during a "),a("code",[e._v("git pull")]),e._v(".")]),e._v(" "),a("p",[e._v("To setup every "),a("strong",[e._v("new")]),e._v(" branch to automatically rebase, add the following to your "),a("code",[e._v(".gitconfig")]),e._v(" or "),a("code",[e._v(".git/config")]),e._v(":")]),e._v(" "),a("div",{staticClass:"language-git extra-class"},[a("pre",{pre:!0,attrs:{class:"language-git"}},[a("code",[e._v("[branch]\nautosetuprebase = always\n\n")])])]),a("p",[a("strong",[e._v("Command line: "),a("code",[e._v("git config [--global] branch.autosetuprebase always")])])]),e._v(" "),a("p",[e._v("Alternatively, you can setup the "),a("code",[e._v("git pull")]),e._v(" command to always behave as if the option "),a("code",[e._v("--rebase")]),e._v(" was passed:")]),e._v(" "),a("div",{staticClass:"language-git extra-class"},[a("pre",{pre:!0,attrs:{class:"language-git"}},[a("code",[e._v("[pull]\nrebase = true\n\n")])])]),a("p",[a("strong",[e._v("Command line: "),a("code",[e._v("git config [--global] pull.rebase true")])])]),e._v(" "),a("h2",{attrs:{id:"pushing-after-a-rebase"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pushing-after-a-rebase"}},[e._v("#")]),e._v(" Pushing after a rebase")]),e._v(" "),a("p",[e._v("Sometimes you need rewrite history with a rebase, but "),a("code",[e._v("git push")]),e._v(" complains about doing so because you rewrote history.")]),e._v(" "),a("p",[e._v("This can be solved with a "),a("code",[e._v("git push --force")]),e._v(", but consider "),a("code",[e._v("git push --force-with-lease")]),e._v(", indicating that you want the push to fail if the local remote-tracking branch differs from the branch on the remote, e.g., someone else pushed to the remote after the last fetch. This avoids inadvertently overwriting someone else's recent push.")]),e._v(" "),a("p",[a("strong",[e._v("Note")]),e._v(": "),a("code",[e._v("git push --force")]),e._v(" - and even "),a("code",[e._v("--force-with-lease")]),e._v(" for that matter - can be a dangerous command because it rewrites the history of the branch. If another person had pulled the branch before the forced push, his/her "),a("code",[e._v("git pull")]),e._v(" or "),a("code",[e._v("git fetch")]),e._v(" will have errors because the local history and the remote history are diverged. This may cause the person to have unexpected errors. With enough looking at the reflogs the other user's work can be recovered, but it can lead to a lot of wasted time. If you must do a forced push to a branch with other contributors, try to coordinate with them so that they do not have to deal with errors.")]),e._v(" "),a("h4",{attrs:{id:"syntax"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#syntax"}},[e._v("#")]),e._v(" Syntax")]),e._v(" "),a("ul",[a("li",[a("code",[e._v("git rebase [-i | --interactive] [options] [--exec <cmd>] [--onto <newbase>] [<upstream>] [<branch>]")])]),e._v(" "),a("li",[a("code",[e._v("git rebase [-i | --interactive] [options] [--exec <cmd>] [--onto <newbase>] --root [<branch>]")])]),e._v(" "),a("li",[a("code",[e._v("git rebase --continue | --skip | --abort | --edit-todo")])])]),e._v(" "),a("h4",{attrs:{id:"parameters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters"}},[e._v("#")]),e._v(" Parameters")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("Parameter")]),e._v(" "),a("th",[e._v("Details")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("--continue")]),e._v(" "),a("td",[e._v("Restart the rebasing process after having resolved a merge conflict.")])]),e._v(" "),a("tr",[a("td",[e._v("--abort")]),e._v(" "),a("td",[e._v("Abort the rebase operation and reset HEAD to the original branch. If branch was provided when the rebase operation was started, then HEAD will be reset to branch. Otherwise HEAD will be reset to where it was when the rebase operation was started.")])]),e._v(" "),a("tr",[a("td",[e._v("--keep-empty")]),e._v(" "),a("td",[e._v("Keep the commits that do not change anything from its parents in the result.")])]),e._v(" "),a("tr",[a("td",[e._v("--skip")]),e._v(" "),a("td",[e._v("Restart the rebasing process by skipping the current patch.")])]),e._v(" "),a("tr",[a("td",[e._v("-m, --merge")]),e._v(" "),a("td",[e._v("Use merging strategies to rebase. When the recursive (default) merge strategy is used, this allows rebase to be aware of renames on the upstream side. Note that a rebase merge works by replaying each commit from the working branch on top of the upstream branch. Because of this, when a merge conflict happens, the side reported as ours is the so-far rebased series, starting with upstream, and theirs is the working branch. In other words, the sides are swapped.")])]),e._v(" "),a("tr",[a("td",[e._v("--stat")]),e._v(" "),a("td",[e._v("Show a diffstat of what changed upstream since the last rebase. The diffstat is also controlled by the configuration option rebase.stat.")])]),e._v(" "),a("tr",[a("td",[e._v("-x, --exec "),a("code",[e._v("command")])]),e._v(" "),a("td",[e._v("Perform interactive rebase, stopping between each commit and executing "),a("code",[e._v("command")])])])])]),e._v(" "),a("h4",{attrs:{id:"remarks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#remarks"}},[e._v("#")]),e._v(" Remarks")]),e._v(" "),a("p",[e._v("Please keep in mind that rebase effectively rewrites the repository history.")]),e._v(" "),a("p",[e._v("Rebasing commits that exists in the remote repository could rewrite repository nodes used by other developers as base node for their developments. Unless you really know what you are doing, it is a best practice to rebase before pushing your changes.")])])}),[],!1,null,null,null);t.default=r.exports}}]);