(window.webpackJsonp=window.webpackJsonp||[]).push([[1197],{1605:function(a,t,s){"use strict";s.r(t);var e=s(31),r=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"infix-operators"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#infix-operators"}},[a._v("#")]),a._v(" Infix operators")]),a._v(" "),s("h2",{attrs:{id:"prelude"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#prelude"}},[a._v("#")]),a._v(" Prelude")]),a._v(" "),s("h3",{attrs:{id:"logical"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#logical"}},[a._v("#")]),a._v(" Logical")]),a._v(" "),s("p",[s("a",{attrs:{href:"http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:-38--38-",target:"_blank",rel:"noopener noreferrer"}},[s("code",[a._v("&&")]),s("OutboundLink")],1),a._v(" is logical AND, "),s("a",{attrs:{href:"http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:-124--124-",target:"_blank",rel:"noopener noreferrer"}},[s("code",[a._v("||")]),s("OutboundLink")],1),a._v(" is logical OR.")]),a._v(" "),s("p",[s("a",{attrs:{href:"http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:-61--61-",target:"_blank",rel:"noopener noreferrer"}},[s("code",[a._v("==")]),s("OutboundLink")],1),a._v(" is equality, "),s("a",{attrs:{href:"http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:-47--61-",target:"_blank",rel:"noopener noreferrer"}},[s("code",[a._v("/=")]),s("OutboundLink")],1),a._v(" non-equality, "),s("a",{attrs:{href:"http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:-60-",target:"_blank",rel:"noopener noreferrer"}},[s("code",[a._v("<")]),s("OutboundLink")],1),a._v(" / "),s("code",[a._v("<=")]),a._v(" lesser and "),s("code",[a._v(">")]),a._v(" / "),s("code",[a._v(">=")]),a._v(" greater operators.")]),a._v(" "),s("h3",{attrs:{id:"arithmetic-operators"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#arithmetic-operators"}},[a._v("#")]),a._v(" Arithmetic operators")]),a._v(" "),s("p",[a._v("The numerical operators "),s("a",{attrs:{href:"http://hackage.haskell.org/package/base/docs/Prelude.html#v:-43-",target:"_blank",rel:"noopener noreferrer"}},[s("code",[a._v("+")]),s("OutboundLink")],1),a._v(", "),s("a",{attrs:{href:"http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:-45-",target:"_blank",rel:"noopener noreferrer"}},[s("code",[a._v("-")]),s("OutboundLink")],1),a._v(" and "),s("a",{attrs:{href:"http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:-47-",target:"_blank",rel:"noopener noreferrer"}},[s("code",[a._v("/")]),s("OutboundLink")],1),a._v(" behave largely as you'd expect. (Division works only on fractional numbers to avoid rounding issues – integer division must be done with "),s("a",{attrs:{href:"http://hackage.haskell.org/package/base/docs/Prelude.html#v:quot",target:"_blank",rel:"noopener noreferrer"}},[s("code",[a._v("quot")]),s("OutboundLink")],1),a._v(" or "),s("a",{attrs:{href:"http://hackage.haskell.org/package/base/docs/Prelude.html#v:div",target:"_blank",rel:"noopener noreferrer"}},[s("code",[a._v("div")]),s("OutboundLink")],1),a._v("). More unusual are Haskell's three exponentiation operators:")]),a._v(" "),s("li",[a._v("\n[`^`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:-94-) takes a base of any number type to a non-negative, integral power. This works simply by ([fast](https://en.wikipedia.org/wiki/Exponentiation_by_squaring)) iterated multiplication. E.g.\n"),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("^")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),a._v("  ≡  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),a._v("\n\n")])])])]),a._v(" "),s("li",[a._v("\n[`^^`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:-94-) does the same in the positive case, but also works for negative exponents. E.g.\n"),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("^^")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("  ≡  "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n")])])]),s("p",[a._v("Unlike "),s("code",[a._v("^")]),a._v(", this requires a fractional base type (i.e. "),s("code",[a._v("4^^5 :: Int")]),a._v(" will not work, only "),s("code",[a._v("4^5 :: Int")]),a._v(" or "),s("code",[a._v("4^^5 :: Rational")]),a._v(").\n")])]),a._v(" "),s("li",[s("a",{attrs:{href:"http://hackage.haskell.org/package/base/docs/Prelude.html#v:-42--42-",target:"_blank",rel:"noopener noreferrer"}},[s("code",[a._v("**")]),s("OutboundLink")],1),a._v(" implements real-number exponentiation. This works for very general arguments, but is more computionally expensive than "),s("code",[a._v("^")]),a._v(" or "),s("code",[a._v("^^")]),a._v(", and generally incurs small floating-point errors."),s("p"),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("**")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("pi")]),a._v("  ≡  "),s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("exp")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("pi")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("log")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n")])])])]),a._v(" "),s("h3",{attrs:{id:"lists"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#lists"}},[a._v("#")]),a._v(" Lists")]),a._v(" "),s("p",[a._v("There are two concatenation operators:")]),a._v(" "),s("li",[a._v("\n`:` (pronounced [cons](https://en.wikipedia.org/wiki/Cons)) prepends a single argument before a list. This operator is actually a constructor and can thus also be used to **pattern match** (“inverse construct”) a list.\n")]),a._v(" "),s("li",[a._v("\n[`++`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:-43--43-) concatenates entire lists.\n"),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("  ≡  "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("  ≡  "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("  ≡  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n\n")])])])]),a._v(" "),s("p",[s("a",{attrs:{href:"http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:-33--33-",target:"_blank",rel:"noopener noreferrer"}},[s("code",[a._v("!!")]),s("OutboundLink")],1),a._v(" is an indexing operator.")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("20")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("30")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("40")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("!!")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),a._v("  ≡  "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("30")]),a._v("\n\n")])])]),s("p",[a._v("Note that indexing lists is inefficient (complexity "),s("strong",[a._v("O")]),a._v("("),s("strong",[a._v("n")]),a._v(") instead of "),s("strong",[a._v("O")]),a._v("(1) for "),s("a",{attrs:{href:"http://hackage.haskell.org/package/vector/docs/Data-Vector.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("arrays"),s("OutboundLink")],1),a._v(" or "),s("strong",[a._v("O")]),a._v("(log "),s("strong",[a._v("n")]),a._v(") for "),s("a",{attrs:{href:"http://hackage.haskell.org/package/containers/docs/Data-Map.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("maps"),s("OutboundLink")],1),a._v("); it's generally preferred in Haskell to deconstruct lists by folding ot pattern matching instead of indexing.")]),a._v(" "),s("h3",{attrs:{id:"control-flow"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#control-flow"}},[a._v("#")]),a._v(" Control flow")]),a._v(" "),s("li",[a._v("\n[`$`](http://hackage.haskell.org/package/base/docs/Prelude.html#v:-36-) is a function application operator.\n"),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("f")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("$")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v("  ≡  "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("f")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v("\n       ≡  "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("f")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("-- disapproved style")]),a._v("\n\n")])])]),s("p",[a._v("This operator is mostly used to avoid parentheses. It also has a strict version "),s("a",{attrs:{href:"http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:-36--33-",target:"_blank",rel:"noopener noreferrer"}},[s("code",[a._v("$!")]),s("OutboundLink")],1),a._v(", which forces the argument to be evaluated before applying the function.\n")])]),a._v(" "),s("li",[s("a",{attrs:{href:"http://hackage.haskell.org/package/base/docs/Prelude.html#v:-36-",target:"_blank",rel:"noopener noreferrer"}},[s("code",[a._v(".")]),s("OutboundLink")],1),a._v(" composes functions."),s("p"),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("f")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(".")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("g")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v("  ≡  "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("f")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("g")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("  ≡  "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("f")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("$")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("g")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v("\n\n")])])])]),a._v(" "),s("li",[a._v('\n[`>>`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:-62--62-) sequences monadic actions. E.g. `writeFile "foo.txt" "bla" >> putStrLn "Done."` will first write to a file, then print a message to the screen.\n')]),a._v(" "),s("li",[a._v("\n[`>>=`](http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:-62--62--61-) does the same, while also accepting an argument to be passed from the first action to the following. `readLn >>= \\x -> print (x^2)` will wait for the user to input a number, then output the square of that number to the screen.\n")]),a._v(" "),s("h2",{attrs:{id:"finding-information-about-infix-operators"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#finding-information-about-infix-operators"}},[a._v("#")]),a._v(" Finding information about infix operators")]),a._v(" "),s("p",[a._v("Because infixes are so common in Haskell, you will regularly need to look up their signature etc.. Fortunately, this is just as easy as for any other function:")]),a._v(" "),s("li",[a._v("\nThe Haskell search engines [Hayoo](https://hayoo.fh-wedel.de/) and [Hoogle](https://www.haskell.org/hoogle/) can be used for infix operators, like for anything else that's defined in some library.\n")]),a._v(" "),s("li",[a._v("\nIn GHCi or IHaskell, you can use the `:i` and `:t` (**i**nfo and **t**ype) directives to learn the basic properties of an operator. For example,\n"),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Prelude")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("i")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Num")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("...")]),a._v("\n      "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("-- Defined in ‘GHC.Num’")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("infixl")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("6")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Prelude")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("i")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("^^")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("^^")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Fractional")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Integral")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v("\n      "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("-- Defined in ‘GHC.Real’")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("infixr")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("8")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("^^")]),a._v("\n\n")])])]),s("p",[a._v("This tells me that "),s("code",[a._v("^^")]),a._v(" binds more tightly than "),s("code",[a._v("+")]),a._v(", both take numerical types as their elements, but "),s("code",[a._v("^^")]),a._v(" requires the exponent to be integral and the base to be fractional."),s("br"),a._v("The less verbose "),s("code",[a._v(":t")]),a._v(" requires the operator in parentheses, like")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Prelude")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("t")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Eq")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Bool")]),a._v("\n\n")])])])]),a._v(" "),s("h2",{attrs:{id:"custom-operators"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#custom-operators"}},[a._v("#")]),a._v(" Custom operators")]),a._v(" "),s("p",[a._v("In Haskell, you can define any infix operator you like. For example, I could define the list-enveloping operator as")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">+<")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("env")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">+<")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("l")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("env")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("l")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("env")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("GHCi")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"**"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">+<")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"emphasis"')]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"**emphasis**"')]),a._v("\n\n")])])]),s("p",[a._v("You should always give such operators a "),s("a",{attrs:{href:"http://stackoverflow.com/documentation/haskell/4691/fixity-declarations#t=20160915221850422503",target:"_blank",rel:"noopener noreferrer"}},[a._v("fixity declaration"),s("OutboundLink")],1),a._v(", like")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("infixr")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">+<")]),a._v("\n\n")])])]),s("p",[a._v("(which would mean "),s("code",[a._v(">+<")]),a._v(" binds as tightly as "),s("code",[a._v("++")]),a._v(" and "),s("code",[a._v(":")]),a._v(" do).")]),a._v(" "),s("h4",{attrs:{id:"remarks"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#remarks"}},[a._v("#")]),a._v(" Remarks")]),a._v(" "),s("p",[a._v("Most Haskell functions are called with the function name followed by arguments (prefix notation). For functions that accept two arguments like (+), it sometimes makes sense to provide an argument before and after the function (infix).")])])}),[],!1,null,null,null);t.default=r.exports}}]);