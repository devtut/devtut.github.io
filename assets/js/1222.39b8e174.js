(window.webpackJsonp=window.webpackJsonp||[]).push([[1222],{1630:function(t,e,a){"use strict";a.r(e);var s=a(31),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"role"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#role"}},[t._v("#")]),t._v(" Role")]),t._v(" "),a("p",[t._v("The "),a("code",[t._v("TypeFamilies")]),t._v(" language extension allows the programmer to define type-level functions. What distinguishes type functions from non-GADT type constructors is that parameters of type functions can be non-parametric whereas parameters of type constructors are always parametric. This distinction is important to the correctness of the "),a("code",[t._v("GeneralizedNewTypeDeriving")]),t._v(" extension. To explicate this distinction, roles are introduced in Haskell.")]),t._v(" "),a("h2",{attrs:{id:"nominal-role"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nominal-role"}},[t._v("#")]),t._v(" Nominal Role")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://ghc.haskell.org/trac/ghc/wiki/Roles",target:"_blank",rel:"noopener noreferrer"}},[t._v("Haskell Wiki"),a("OutboundLink")],1),t._v(" has an example of a non-parametric parameter of a type function:")]),t._v(" "),a("div",{staticClass:"language-hs extra-class"},[a("pre",{pre:!0,attrs:{class:"language-hs"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("family")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Inspect")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("x")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("instance")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Inspect")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Age")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Int")]),t._v("    \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("instance")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Inspect")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Bool")]),t._v("\n\n")])])]),a("p",[t._v("Here "),a("code",[t._v("x")]),t._v(" is non-parametric because to determine the outcome of applying "),a("code",[t._v("Inspect")]),t._v(" to a type argument, the type function must inspect "),a("code",[t._v("x")]),t._v(".")]),t._v(" "),a("p",[t._v("In this case, the role of "),a("code",[t._v("x")]),t._v(" is nominal. We can declare the role explicitly with the "),a("code",[t._v("RoleAnnotations")]),t._v(" extension:")]),t._v(" "),a("div",{staticClass:"language-hs extra-class"},[a("pre",{pre:!0,attrs:{class:"language-hs"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("role")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Inspect")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("nominal")]),t._v("\n\n")])])]),a("h2",{attrs:{id:"representational-role"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#representational-role"}},[t._v("#")]),t._v(" Representational Role")]),t._v(" "),a("p",[t._v("An example of a parametric parameter of a type function:")]),t._v(" "),a("div",{staticClass:"language-hs extra-class"},[a("pre",{pre:!0,attrs:{class:"language-hs"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("data")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("List")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("a")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Nil")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Cons")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("a")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("List")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("a")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("family")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("DoNotInspect")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("x")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("instance")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("DoNotInspect")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("x")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("List")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("x")]),t._v("\n\n")])])]),a("p",[t._v("Here "),a("code",[t._v("x")]),t._v(" is parametric because to determine the outcome of applying "),a("code",[t._v("DoNotInspect")]),t._v(" to a type argument, the type function do not need to inspect "),a("code",[t._v("x")]),t._v(".")]),t._v(" "),a("p",[t._v("In this case, the role of x is representational. We can declare the role explicitly with the "),a("code",[t._v("RoleAnnotations")]),t._v(" extension:")]),t._v(" "),a("div",{staticClass:"language-hs extra-class"},[a("pre",{pre:!0,attrs:{class:"language-hs"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("role")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("DoNotInspect")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("representational")]),t._v("\n\n")])])]),a("h2",{attrs:{id:"phantom-role"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#phantom-role"}},[t._v("#")]),t._v(" Phantom Role")]),t._v(" "),a("p",[t._v("A "),a("a",{attrs:{href:"http://stackoverflow.com/documentation/haskell/5227/phantom-types#t=201701080732134400441",target:"_blank",rel:"noopener noreferrer"}},[t._v("phantom type parameter"),a("OutboundLink")],1),t._v(" has a phantom role. Phantom roles cannot be declared explicitly.")]),t._v(" "),a("h4",{attrs:{id:"remarks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#remarks"}},[t._v("#")]),t._v(" Remarks")]),t._v(" "),a("p",[t._v("See also "),a("a",{attrs:{href:"https://ghc.haskell.org/trac/ghc/wiki/SafeRoles",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("SafeNewtypeDeriving")]),a("OutboundLink")],1),t._v(".")])])}),[],!1,null,null,null);e.default=n.exports}}]);