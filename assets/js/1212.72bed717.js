(window.webpackJsonp=window.webpackJsonp||[]).push([[1212],{1620:function(t,e,s){"use strict";s.r(e);var a=s(31),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"phantom-types"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#phantom-types"}},[t._v("#")]),t._v(" Phantom types")]),t._v(" "),s("h2",{attrs:{id:"use-case-for-phantom-types-currencies"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#use-case-for-phantom-types-currencies"}},[t._v("#")]),t._v(" Use Case for Phantom Types: Currencies")]),t._v(" "),s("p",[t._v("Phantom types are useful for dealing with data, that has identical representations but isn't logically of the same type.")]),t._v(" "),s("p",[t._v("A good example is dealing with currencies. If you work with currencies you absolutely never want to e.g. add two amounts of different currencies. What would the result currency of "),s("code",[t._v("5.32â‚¬ + 2.94$")]),t._v(" be? It's not defined and there is no good reason to do this.")]),t._v(" "),s("p",[t._v("A solution to this could look something like this:")]),t._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("{-# LANGUAGE GeneralizedNewtypeDeriving #-}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("data")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("USD")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("data")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("EUR")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("newtype")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Amount")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[t._v("a")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Amount")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Double")]),t._v("\n                 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("deriving")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Show")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Eq")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Ord")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("Num")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n")])])]),s("p",[t._v("The "),s("code",[t._v("GeneralisedNewtypeDeriving")]),t._v(" extension allows us to derive "),s("code",[t._v("Num")]),t._v(" for the "),s("code",[t._v("Amount")]),t._v(" type. GHC reuses "),s("code",[t._v("Double")]),t._v("'s "),s("code",[t._v("Num")]),t._v(" instance.")]),t._v(" "),s("p",[t._v("Now if you represent Euro amounts with e.g. "),s("code",[t._v("(5.0 :: Amount EUR)")]),t._v(" you have solved the problem of keeping double amounts separate at the type level without introducing overhead. Stuff like "),s("code",[t._v("(1.13 :: Amount EUR) + (5.30 :: Amount USD)")]),t._v(" will result in a type error and require you to deal with currency conversion appropriately.")]),t._v(" "),s("p",[t._v("More comprehensive documentation can be found in the "),s("a",{attrs:{href:"https://wiki.haskell.org/Phantom_type",target:"_blank",rel:"noopener noreferrer"}},[t._v("haskell wiki article"),s("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=n.exports}}]);