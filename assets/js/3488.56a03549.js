(window.webpackJsonp=window.webpackJsonp||[]).push([[3488],{3896:function(t,e,s){"use strict";s.r(e);var n=s(31),a=Object(n.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"recursion"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#recursion"}},[t._v("#")]),t._v(" Recursion")]),t._v(" "),s("h2",{attrs:{id:"compute-nth-fibonacci-number"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#compute-nth-fibonacci-number"}},[t._v("#")]),t._v(" Compute nth Fibonacci number")]),t._v(" "),s("p",[t._v("Visual Basic.NET, like most languages, permits recursion, a process by which a function calls "),s("strong",[t._v("itself")]),t._v(" under certain conditions.")]),t._v(" "),s("p",[t._v("Here is a basic function in Visual Basic .NET to compute "),s("a",{attrs:{href:"https://en.wikipedia.org/wiki/Fibonacci_number",target:"_blank",rel:"noopener noreferrer"}},[t._v("Fibonacci"),s("OutboundLink")],1),t._v(" numbers.")]),t._v(" "),s("div",{staticClass:"language-vb extra-class"},[s("pre",{pre:!0,attrs:{class:"language-vb"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("''' <summary>")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("''' Gets the n'th Fibonacci number")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("''' </summary>")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("''' <param name=\"n\">The 1-indexed ordinal number of the Fibonacci sequence that you wish to receive. Precondition: Must be greater than or equal to 1.</param>")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("''' <returns>The nth Fibonacci number. Throws an exception if a precondition is violated.</returns>")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("Public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("Shared")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("Function")]),t._v(" Fibonacci"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("ByVal")]),t._v(" n "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("Integer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("as")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("Integer")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("If")]),t._v(" n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("Throw")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("New")]),t._v(" ArgumentOutOfRangeException"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"n must be greater than or equal to one."')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("End")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("If")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("If")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("or")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("''Base case. The first two Fibonacci numbers (n=1 and n=2) are both 1, by definition.")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("Return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("End")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("If")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("''Recursive case.")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("''Get the two previous Fibonacci numbers via recursion, add them together, and return the result.")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("Return")]),t._v(" Fibonacci"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" Fibonacci"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("End")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("Function")]),t._v("\n\n")])])]),s("p",[t._v("This function works by first checking if the function has been called with the parameter "),s("code",[t._v("n")]),t._v(" equal to "),s("code",[t._v("1")]),t._v(" or "),s("code",[t._v("2")]),t._v(".  By definition, the first two values in the Fibonacci sequence are 1 and 1, so no further computation is necessary to determine this. If "),s("code",[t._v("n")]),t._v(" is greater than 2, we cannot look up the associated value as easily, but we know that any such Fibonacci number is equal to the sum of the prior two numbers, so we request those via "),s("strong",[t._v("recursion")]),t._v(" (calling our own Fibonacci function). Since successive recursive calls get called with smaller and smaller numbers via decrements of -1 and -2, we know that eventually they will reach numbers that are smaller than 2. Once those conditions (called "),s("strong",[t._v("base cases")]),t._v(") are reached, the stack unwinds and we get our final result.")])])}),[],!1,null,null,null);e.default=a.exports}}]);