(window.webpackJsonp=window.webpackJsonp||[]).push([[1173],{1581:function(a,t,s){"use strict";s.r(t);var e=s(31),n=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"common-ghc-language-extensions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#common-ghc-language-extensions"}},[a._v("#")]),a._v(" Common GHC Language Extensions")]),a._v(" "),s("h2",{attrs:{id:"rankntypes"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rankntypes"}},[a._v("#")]),a._v(" RankNTypes")]),a._v(" "),s("p",[a._v("Imagine the following situation:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("foo")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Show")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("String")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("IO")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("foo")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("show")]),a._v("' "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("string")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("do")]),a._v("\n   "),s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("putStrLn")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("show")]),a._v("' "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("string")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n   "),s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("putStrLn")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("show")]),a._v("' "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n")])])]),s("p",[a._v("Here, we want to pass in a function that converts a value into a String, apply that function to both a string parameter and and int parameter and print them both. In my mind, there is no reason this should fail! We have a function that works on both types of the parameters we're passing in.")]),a._v(" "),s("p",[a._v("Unfortunately, this won't type check! GHC infers the "),s("code",[a._v("a")]),a._v(" type based off of its first occurrence in the function body. That is, as soon as we hit:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("putStrLn")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("show")]),a._v("' "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("string")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n")])])]),s("p",[a._v("GHC will infer that "),s("code",[a._v("show' :: String -> String")]),a._v(", since "),s("code",[a._v("string")]),a._v(" is a "),s("code",[a._v("String")]),a._v(". It will proceed to blow up while trying to "),s("code",[a._v("show' int")]),a._v(".")]),a._v(" "),s("p",[s("code",[a._v("RankNTypes")]),a._v(" lets you instead write the type signature as follows, quantifying over all functions that satisfy the "),s("code",[a._v("show'")]),a._v(" type:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("foo")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("forall")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Show")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("String")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("IO")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n")])])]),s("p",[a._v("This is rank 2 polymorphism: We are asserting that the "),s("code",[a._v("show'")]),a._v(" function must work for all "),s("code",[a._v("a")]),a._v("s "),s("strong",[a._v("within")]),a._v(" our function, and the previous implementation now works.")]),a._v(" "),s("p",[a._v("The "),s("code",[a._v("RankNTypes")]),a._v(" extension allows arbitrary nesting of "),s("code",[a._v("forall ...")]),a._v(" blocks in type signatures. In other words, it allows rank N polymorphism.")]),a._v(" "),s("h2",{attrs:{id:"overloadedstrings"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#overloadedstrings"}},[a._v("#")]),a._v(" OverloadedStrings")]),a._v(" "),s("p",[a._v("Normally, string literals in Haskell have a type of "),s("code",[a._v("String")]),a._v(" (which is a type alias for "),s("code",[a._v("[Char]")]),a._v("). While this isn't a problem for smaller, educational programs, real-world applications often require more efficient storage such as "),s("code",[a._v("Text")]),a._v(" or "),s("code",[a._v("ByteString")]),a._v(".")]),a._v(" "),s("p",[s("code",[a._v("OverloadedStrings")]),a._v(" simply changes the type of literals to")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"test"')]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Data"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("String"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("IsString")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v("\n\n")])])]),s("p",[a._v("Allowing them to be directly passed to functions expecting such a type. Many libraries implement this interface for their string-like types including "),s("a",{attrs:{href:"http://stackoverflow.com/documentation/haskell/3406/text",target:"_blank",rel:"noopener noreferrer"}},[a._v("Data.Text"),s("OutboundLink")],1),a._v(" and "),s("a",{attrs:{href:"https://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("Data.ByteString"),s("OutboundLink")],1),a._v(" which both provide certain time and space advantages over "),s("code",[a._v("[Char]")]),a._v(".")]),a._v(" "),s("p",[a._v("There are also some unique uses of "),s("code",[a._v("OverloadedStrings")]),a._v(" like those from the "),s("a",{attrs:{href:"http://hackage.haskell.org/package/postgresql-simple",target:"_blank",rel:"noopener noreferrer"}},[a._v("Postgresql-simple"),s("OutboundLink")],1),a._v(" library which allows SQL queries to be written in double quotes like a normal string, but provides protections against improper concatenation, a notorious source of SQL injection attacks.")]),a._v(" "),s("p",[a._v("To create a instance of the "),s("code",[a._v("IsString")]),a._v(" class you need to impliment the "),s("code",[a._v("fromString")]),a._v(" function.  Example"),s("sup",[a._v("†")]),a._v(":")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("data")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Foo")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("A")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("B")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Other")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("String")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("deriving")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Show")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("instance")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("IsString")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Foo")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("fromString")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"A"')]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("A")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("fromString")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"B"')]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("B")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("fromString")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("xs")]),a._v("  "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Other")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("xs")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("tests")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Foo")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("tests")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"A"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"B"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Testing"')]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n\n")])])]),s("p",[s("sup",[a._v("†")]),a._v(" This example courtesy of Lyndon Maydwell ("),s("code",[a._v("sordina")]),a._v(" on GitHub) found "),s("a",{attrs:{href:"https://gist.github.com/sordina/5714390",target:"_blank",rel:"noopener noreferrer"}},[a._v("here"),s("OutboundLink")],1),a._v(".")]),a._v(" "),s("h2",{attrs:{id:"binaryliterals"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#binaryliterals"}},[a._v("#")]),a._v(" BinaryLiterals")]),a._v(" "),s("p",[a._v("Standard Haskell allows you to write integer literals in decimal (without any prefix), hexadecimal (preceded by "),s("code",[a._v("0x")]),a._v(" or "),s("code",[a._v("0X")]),a._v("), and octal (preceded by "),s("code",[a._v("0o")]),a._v(" or "),s("code",[a._v("0O")]),a._v("). The "),s("code",[a._v("BinaryLiterals")]),a._v(" extension adds the option of binary (preceded by "),s("code",[a._v("0b")]),a._v(" or "),s("code",[a._v("0B")]),a._v(").")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[a._v("0b1111 "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("15")]),a._v("     "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("-- evaluates to: True")]),a._v("\n\n")])])]),s("h2",{attrs:{id:"existentialquantification"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#existentialquantification"}},[a._v("#")]),a._v(" ExistentialQuantification")]),a._v(" "),s("p",[a._v("This is a type system extension that allows types that are existentially quantified, or, in other words, have type variables that only get instantiated at runtime"),s("sup",[a._v("†")]),a._v(".")]),a._v(" "),s("p",[a._v("A value of existential type is similar to an abstract-base-class reference in OO languages: you don't know the exact type in contains, but you can constrain the "),s("strong",[a._v("class")]),a._v(" of types.")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("data")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("S")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("forall")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Show")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("S")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v("\n\n")])])]),s("p",[a._v("or equivalently, with GADT syntax:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("{-# LANGUAGE GADTs #-}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("data")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("S")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v("\n   "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("S")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Show")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("S")]),a._v("\n\n")])])]),s("p",[a._v("Existential types open the door to things like almost-heterogenous containers: as said above, there can actually be various types in an "),s("code",[a._v("S")]),a._v(" value, but all of them can be "),s("code",[a._v("show")]),a._v("n, hence you can also do")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("instance")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Show")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("S")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("show")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("S")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("show")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("-- we rely on (Show a) from the above")]),a._v("\n\n")])])]),s("p",[a._v("Now we can create a collection of such objects:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("ss")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("S")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("S")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"test"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("S")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3.0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n\n")])])]),s("p",[a._v("Which also allows us to use the polymorphic behaviour:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("mapM_")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("print")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("ss")]),a._v("\n\n")])])]),s("p",[a._v("Existentials can be very powerful, but note that they are actually not necessary very often in Haskell. In the example above, all you can actually do with the "),s("code",[a._v("Show")]),a._v(" instance is show (duh!) the values, i.e. create a string representation. The entire "),s("code",[a._v("S")]),a._v(" type therefore contains exactly as much information as the string you get when showing it. Therefore, it is usually better to simply store that string right away, especially since Haskell is lazy and therefore the string will at first only be an unevaluated thunk anyway.")]),a._v(" "),s("p",[a._v("On the other hand, existentials cause some unique problems. For instance, the way the type information is “hidden” in an existential. If you pattern-match on an "),s("code",[a._v("S")]),a._v(" value, you will have the contained type in scope (more precisely, its "),s("code",[a._v("Show")]),a._v(" instance), but this information can never escape its scope, which therefore becomes a bit of a “secret society”: the compiler doesn't let "),s("strong",[a._v("anything")]),a._v(" escape the scope except values whose type is already known from the outside. This can lead to strange errors "),s("a",{attrs:{href:"http://stackoverflow.com/questions/28582210/type-inference-with-gadts-a0-is-untouchable",target:"_blank",rel:"noopener noreferrer"}},[a._v("like "),s("code",[a._v("Couldn't match type ‘a0’ with ‘()’ ‘a0’ is untouchable")]),s("OutboundLink")],1),a._v(".")]),a._v(" "),s("p",[s("sup",[a._v("†")]),s("sub",[a._v("Contrast this with ordinary parametric polymorphism, which is generally resolved at compile time (allowing full type erasure).")])]),a._v(" "),s("p",[a._v("Existential types are different from Rank-N types – these extensions are, roughly speaking, dual to each other: to actually use values of an existential type, you need a (possibly constrained-) polymorphic function, like "),s("code",[a._v("show")]),a._v(" in the example. A polymorphic function is "),s("strong",[a._v("universally")]),a._v(" quantified, i.e. it works "),s("strong",[a._v("for any")]),a._v(" type in a given class, whereas existential quantification means it works "),s("strong",[a._v("for some")]),a._v(" particular type which is a priori unknown. If you have a polymorphic function, that's sufficient, however to pass polymorphic functions as such as arguments, you need "),s("code",[a._v("{-# LANGUAGE Rank2Types #-}")]),a._v(":")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("genShowSs")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("∀ "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(".")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Show")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("S")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("genShowSs")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("f")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("map")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("\\")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("S")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("f")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n")])])]),s("h2",{attrs:{id:"lambdacase"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#lambdacase"}},[a._v("#")]),a._v(" LambdaCase")]),a._v(" "),s("p",[a._v("A syntactic extension that lets you write "),s("code",[a._v("\\case")]),a._v(" in place of "),s("code",[a._v("\\arg -> case arg of")]),a._v(".")]),a._v(" "),s("p",[a._v("Consider the following function definition:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("dayOfTheWeek")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("String")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("dayOfTheWeek")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Sunday"')]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("dayOfTheWeek")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Monday"')]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("dayOfTheWeek")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Tuesday"')]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("dayOfTheWeek")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Wednesday"')]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("dayOfTheWeek")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Thursday"')]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("dayOfTheWeek")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Friday"')]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("dayOfTheWeek")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("6")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Saturday"')]),a._v("\n\n")])])]),s("p",[a._v("If you want to avoid repeating the function name, you might write something like:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("dayOfTheWeek")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("String")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("dayOfTheWeek")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("i")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("case")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("i")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("of")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Sunday"')]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Monday"')]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Tuesday"')]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Wednesday"')]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Thursday"')]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Friday"')]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("6")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Saturday"')]),a._v("\n\n")])])]),s("p",[a._v("Using the LambdaCase extension, you can write that as a function expression, without having to name the argument:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("{-# LANGUAGE LambdaCase #-}")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("dayOfTheWeek")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("String")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("dayOfTheWeek")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("\\")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("case")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Sunday"')]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Monday"')]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Tuesday"')]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Wednesday"')]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Thursday"')]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Friday"')]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("6")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Saturday"')]),a._v("\n\n")])])]),s("h2",{attrs:{id:"functionaldependencies"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#functionaldependencies"}},[a._v("#")]),a._v(" FunctionalDependencies")]),a._v(" "),s("p",[a._v("If you have a multi-parameter type-class with arguments a, b, c, and x, this extension lets you express that the type x can be uniquely identified from a, b, and c:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("SomeClass")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("...")]),a._v("\n\n")])])]),s("p",[a._v("When declaring an instance of such class, it will be checked against all other instances to make sure that the functional dependency holds, that is, no other instance with same "),s("code",[a._v("a b c")]),a._v(" but different "),s("code",[a._v("x")]),a._v(" exists.")]),a._v(" "),s("p",[a._v("You can specify multiple dependencies in a comma-separated list:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("OtherClass")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("d")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("d")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("d")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("...")]),a._v("\n\n")])])]),s("p",[a._v("For example in MTL we can see:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("MonadReader")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("r")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("m")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("m")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("r")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("...")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("instance")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("MonadReader")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("r")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("r")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("...")]),a._v("\n\n")])])]),s("p",[a._v("Now, if you have a value of type "),s("code",[a._v("MonadReader a ((->) Foo) => a")]),a._v(", the compiler can infer that "),s("code",[a._v("a ~ Foo")]),a._v(", since the second argument completely determines the first, and will simplify the type accordingly.")]),a._v(" "),s("p",[a._v("The "),s("code",[a._v("SomeClass")]),a._v(" class can be thought of as a function of the arguments "),s("code",[a._v("a b c")]),a._v(" that results in "),s("code",[a._v("x")]),a._v(". Such classes can be used to do computations in the typesystem.")]),a._v(" "),s("h2",{attrs:{id:"flexibleinstances"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#flexibleinstances"}},[a._v("#")]),a._v(" FlexibleInstances")]),a._v(" "),s("p",[a._v("Regular instances require:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("All")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("instance")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("types")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("must")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("be")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("of")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("the")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("form")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("T")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a1")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("...")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("an")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a1")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("...")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("an")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("are")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("distinct")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("type")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("variables")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("and")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("each")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("type")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("variable")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("appears")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("at")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("most")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("once")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("in")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("the")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("instance")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("head")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("\n\n")])])]),s("p",[a._v("That means that, for example, while you can create an instance for "),s("code",[a._v("[a]")]),a._v(" you can't create an instance for specifically "),s("code",[a._v("[Int]")]),a._v(".; "),s("code",[a._v("FlexibleInstances")]),a._v(" relaxes that:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("C")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("-- works out of the box")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("instance")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("C")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("-- requires FlexibleInstances")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("instance")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("C")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v("\n\n")])])]),s("h2",{attrs:{id:"gadts"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#gadts"}},[a._v("#")]),a._v(" GADTs")]),a._v(" "),s("p",[a._v("Conventional algebraic datatypes are parametric in their type variables. For example, if we define an ADT like")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("data")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Expr")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("IntLit")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Int")]),a._v(" \n            "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("BoolLit")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Bool")]),a._v(" \n            "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("If")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Expr")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Bool")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Expr")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Expr")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n")])])]),s("p",[a._v("with the hope that this will statically rule out non-well-typed conditionals, this will not behave as expected since the type of "),s("code",[a._v("IntLit :: Int -> Expr a")]),a._v(" is universially quantified: for "),s("strong",[a._v("any")]),a._v(" choice of "),s("code",[a._v("a")]),a._v(", it produces a value of type "),s("code",[a._v("Expr a")]),a._v(". In particular, for "),s("code",[a._v("a ~ Bool")]),a._v(", we have "),s("code",[a._v("IntLit :: Int -> Expr Bool")]),a._v(", allowing us to construct something like "),s("code",[a._v("If (IntLit 1) e1 e2")]),a._v(" which is what the type of the "),s("code",[a._v("If")]),a._v(" constructor was trying to rule out.")]),a._v(" "),s("p",[a._v("Generalised Algebraic Data Types allows us to control the resulting type of a data constructor so that they are not merely parametric. We can rewrite our "),s("code",[a._v("Expr")]),a._v(" type as a GADT like this:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("data")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Expr")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("IntLit")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Expr")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Int")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("BoolLit")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Bool")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Expr")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Bool")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("If")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Expr")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Bool")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Expr")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Expr")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Expr")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v("\n\n")])])]),s("p",[a._v("Here, the type of the constructor "),s("code",[a._v("IntLit")]),a._v(" is "),s("code",[a._v("Int -> Expr Int")]),a._v(", and so "),s("code",[a._v("IntLit 1 :: Expr Bool")]),a._v(" will not typecheck.")]),a._v(" "),s("p",[a._v("Pattern matching on a GADT value causes refinement of the type of the term returned. For example, it is possible to write an evaluator for "),s("code",[a._v("Expr a")]),a._v(" like this:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("crazyEval")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Expr")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("crazyEval")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("IntLit")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" \n   "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("-- Here we can use `(+)` because x :: Int")]),a._v("\n   "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v(" \n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("crazyEval")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("BoolLit")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" \n   "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("-- Here we can use `not` because b :: Bool")]),a._v("\n   "),s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("not")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("crazyEval")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("If")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("thn")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("els")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" \n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("-- Because b :: Expr Bool, we can use `crazyEval b :: Bool`.")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("-- Also, because thn :: Expr a and els :: Expr a, we can pass either to ")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("-- the recursive call to `crazyEval` and get an a back")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("crazyEval")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("$")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("crazyEval")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("then")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("thn")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("else")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("els")]),a._v(" \n\n")])])]),s("p",[a._v("Note that we are able to use "),s("code",[a._v("(+)")]),a._v(" in the above definitions because when e.g. "),s("code",[a._v("IntLit x")]),a._v(" is pattern matched, we also learn that "),s("code",[a._v("a ~ Int")]),a._v(" (and likewise for "),s("code",[a._v("not")]),a._v(" and "),s("code",[a._v("if_then_else_")]),a._v(" when "),s("code",[a._v("a ~ Bool")]),a._v(").")]),a._v(" "),s("h2",{attrs:{id:"tuplesections"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tuplesections"}},[a._v("#")]),a._v(" TupleSections")]),a._v(" "),s("p",[a._v("A syntactic extension that allows applying the tuple constructor (which is an operator) in a section way:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("-- With TupleSections")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v("\n\n")])])]),s("h3",{attrs:{id:"n-tuples"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#n-tuples"}},[a._v("#")]),a._v(" N-tuples")]),a._v(" "),s("p",[a._v("It also works for tuples with arity greater than two")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n")])])]),s("h3",{attrs:{id:"mapping"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mapping"}},[a._v("#")]),a._v(" Mapping")]),a._v(" "),s("p",[a._v("This can be useful in other places where sections are used:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("map")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"tag"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"tag"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"tag"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"tag"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n\n")])])]),s("p",[a._v("The above example without this extension would look like this:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("map")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("\\")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"tag"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("\n\n")])])]),s("h2",{attrs:{id:"overloadedlists"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#overloadedlists"}},[a._v("#")]),a._v(" OverloadedLists")]),a._v(" "),s("p",[s("strong",[a._v("added in GHC 7.8")]),a._v(".")]),a._v(" "),s("p",[a._v("OverloadedLists, similar to "),s("a",{attrs:{href:"http://stackoverflow.com/documentation/haskell/1274/common-language-extensions/4173/overloadedstrings",target:"_blank",rel:"noopener noreferrer"}},[a._v("OverloadedStrings"),s("OutboundLink")],1),a._v(", allows list literals to be desugared as follows:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("          "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("-- fromListN 0 []")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("         "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("-- fromListN 1 (x : [])")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("..")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("     "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("-- fromList (enumFrom x)")]),a._v("\n\n")])])]),s("p",[a._v("This comes handy when dealing with types such as "),s("code",[a._v("Set")]),a._v(", "),s("code",[a._v("Vector")]),a._v(" and "),s("code",[a._v("Map")]),a._v("s.")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token char string"}},[a._v("'0'")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("..")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token char string"}},[a._v("'9'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("             "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Set")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Char")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("..")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("                "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Vector")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Int")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"default"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("k1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("v1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Map")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("String")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Int")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token char string"}},[a._v("'a'")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("..")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token char string"}},[a._v("'z'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v("             "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Text")]),a._v("\n\n")])])]),s("p",[s("a",{attrs:{href:"https://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-Exts.html#t:IsList",target:"_blank",rel:"noopener noreferrer"}},[s("code",[a._v("IsList")]),s("OutboundLink")],1),a._v(" class in "),s("code",[a._v("GHC.Exts")]),a._v(" is intended to be used with this extension.")]),a._v(" "),s("p",[s("code",[a._v("IsList")]),a._v(" is equipped with one type function, "),s("code",[a._v("Item")]),a._v(", and three functions, "),s("code",[a._v("fromList :: [Item l] -> l")]),a._v(", "),s("code",[a._v("toList :: l -> [Item l]")]),a._v(" and "),s("code",[a._v("fromListN :: Int -> [Item l] -> l")]),a._v(" where "),s("code",[a._v("fromListN")]),a._v(" is optional. Typical implementations are:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("instance")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("IsList")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("type")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Item")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("fromList")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("id")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("toList")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("id")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("instance")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Ord")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("IsList")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Set")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("type")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Item")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Set")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("fromList")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("Set"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("fromList")]),a._v("\n  "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("toList")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("Set"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("toList")]),a._v("\n\n")])])]),s("p",[s("strong",[a._v("Examples taken from "),s("a",{attrs:{href:"https://ghc.haskell.org/trac/ghc/wiki/OverloadedLists",target:"_blank",rel:"noopener noreferrer"}},[a._v("OverloadedLists – GHC"),s("OutboundLink")],1)]),a._v(".")]),a._v(" "),s("h2",{attrs:{id:"multiparamtypeclasses"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#multiparamtypeclasses"}},[a._v("#")]),a._v(" MultiParamTypeClasses")]),a._v(" "),s("p",[a._v("It's a very common extension that allows type classes with multiple type parameters. You can think of MPTC as a relation between types.")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("{-# LANGUAGE MultiParamTypeClasses #-}")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Convertable")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("convert")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("instance")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Convertable")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Float")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("convert")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("i")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("fromIntegral")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("i")]),a._v("\n\n")])])]),s("p",[a._v("The order of parameters matters.")]),a._v(" "),s("p",[a._v("MPTCs can sometimes be replaced with type families.")]),a._v(" "),s("h2",{attrs:{id:"unicodesyntax"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#unicodesyntax"}},[a._v("#")]),a._v(" UnicodeSyntax")]),a._v(" "),s("p",[a._v("An extension that allows you to use Unicode characters in lieu of certain built-in operators and names.")]),a._v(" "),s("table",[s("thead",[s("tr",[s("th",[a._v("ASCII")]),a._v(" "),s("th",[a._v("Unicode")]),a._v(" "),s("th",[a._v("Use(s)")])])]),a._v(" "),s("tbody",[s("tr",[s("td",[s("code",[a._v("::")])]),a._v(" "),s("td",[s("code",[a._v("∷")])]),a._v(" "),s("td",[a._v("has type")])]),a._v(" "),s("tr",[s("td",[s("code",[a._v("->")])]),a._v(" "),s("td",[s("code",[a._v("→")])]),a._v(" "),s("td",[a._v("function types, lambdas, "),s("code",[a._v("case")]),a._v(" branches, etc.")])]),a._v(" "),s("tr",[s("td",[s("code",[a._v("=>")])]),a._v(" "),s("td",[s("code",[a._v("⇒")])]),a._v(" "),s("td",[a._v("class constraints")])]),a._v(" "),s("tr",[s("td",[s("code",[a._v("forall")])]),a._v(" "),s("td",[s("code",[a._v("∀")])]),a._v(" "),s("td",[a._v("explicit polymorphism")])]),a._v(" "),s("tr",[s("td",[s("code",[a._v("<-")])]),a._v(" "),s("td",[s("code",[a._v("←")])]),a._v(" "),s("td",[s("code",[a._v("do")]),a._v(" notation")])]),a._v(" "),s("tr",[s("td",[s("code",[a._v("*")])]),a._v(" "),s("td",[s("code",[a._v("★")])]),a._v(" "),s("td",[a._v("the type (or kind) of types (e.g., "),s("code",[a._v("Int :: ★")]),a._v(")")])]),a._v(" "),s("tr",[s("td",[s("code",[a._v(">-")])]),a._v(" "),s("td",[s("code",[a._v("⤚")])]),a._v(" "),s("td",[s("a",{attrs:{href:"https://downloads.haskell.org/%7Eghc/8.0.1/docs/html/users_guide/glasgow_exts.html#arrow-notation",target:"_blank",rel:"noopener noreferrer"}},[s("code",[a._v("proc")]),a._v(" notation"),s("OutboundLink")],1),a._v(" for "),s("a",{attrs:{href:"https://downloads.haskell.org/%7Eghc/latest/docs/html/libraries/base-4.9.0.0/Control-Arrow.html",target:"_blank",rel:"noopener noreferrer"}},[s("code",[a._v("Arrows")]),s("OutboundLink")],1)])]),a._v(" "),s("tr",[s("td",[s("code",[a._v("-<")])]),a._v(" "),s("td",[s("code",[a._v("⤙")])]),a._v(" "),s("td",[s("a",{attrs:{href:"https://downloads.haskell.org/%7Eghc/8.0.1/docs/html/users_guide/glasgow_exts.html#arrow-notation",target:"_blank",rel:"noopener noreferrer"}},[s("code",[a._v("proc")]),a._v(" notation"),s("OutboundLink")],1),a._v(" for "),s("a",{attrs:{href:"https://downloads.haskell.org/%7Eghc/latest/docs/html/libraries/base-4.9.0.0/Control-Arrow.html",target:"_blank",rel:"noopener noreferrer"}},[s("code",[a._v("Arrows")]),s("OutboundLink")],1)])]),a._v(" "),s("tr",[s("td",[s("code",[a._v(">>-")])]),a._v(" "),s("td",[s("code",[a._v("⤜")])]),a._v(" "),s("td",[s("a",{attrs:{href:"https://downloads.haskell.org/%7Eghc/8.0.1/docs/html/users_guide/glasgow_exts.html#arrow-notation",target:"_blank",rel:"noopener noreferrer"}},[s("code",[a._v("proc")]),a._v(" notation"),s("OutboundLink")],1),a._v(" for "),s("a",{attrs:{href:"https://downloads.haskell.org/%7Eghc/latest/docs/html/libraries/base-4.9.0.0/Control-Arrow.html",target:"_blank",rel:"noopener noreferrer"}},[s("code",[a._v("Arrows")]),s("OutboundLink")],1)])]),a._v(" "),s("tr",[s("td",[s("code",[a._v("-<<")])]),a._v(" "),s("td",[s("code",[a._v("⤛")])]),a._v(" "),s("td",[s("a",{attrs:{href:"https://downloads.haskell.org/%7Eghc/8.0.1/docs/html/users_guide/glasgow_exts.html#arrow-notation",target:"_blank",rel:"noopener noreferrer"}},[s("code",[a._v("proc")]),a._v(" notation"),s("OutboundLink")],1),a._v(" for "),s("a",{attrs:{href:"https://downloads.haskell.org/%7Eghc/latest/docs/html/libraries/base-4.9.0.0/Control-Arrow.html",target:"_blank",rel:"noopener noreferrer"}},[s("code",[a._v("Arrows")]),s("OutboundLink")],1)])])])]),a._v(" "),s("p",[a._v("For example:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("runST")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("forall")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("s")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("ST")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("s")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v("\n\n")])])]),s("p",[a._v("would become")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("runST")]),a._v(" ∷ "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("∀ "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("s")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("ST")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("s")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" → "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v("\n\n")])])]),s("p",[a._v("Note that the "),s("code",[a._v("*")]),a._v(" vs. "),s("code",[a._v("★")]),a._v(" example is slightly different: since "),s("code",[a._v("*")]),a._v(" isn't reserved, "),s("code",[a._v("★")]),a._v(" also works the same way as "),s("code",[a._v("*")]),a._v(" for multiplication, or any other function named "),s("code",[a._v("(*)")]),a._v(", and vice-versa.  For example:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("ghci")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),a._v(" ★ "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("6")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("ghci")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("let")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("in")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),a._v(" ★ "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("ghci")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("let")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("★"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("in")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),a._v("\n\n")])])]),s("h2",{attrs:{id:"patternsynonyms"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#patternsynonyms"}},[a._v("#")]),a._v(" PatternSynonyms")]),a._v(" "),s("p",[s("a",{attrs:{href:"https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms",target:"_blank",rel:"noopener noreferrer"}},[a._v("Pattern synonyms"),s("OutboundLink")],1),a._v(" are abstractions of patterns similar to how functions are abstractions of expressions.")]),a._v(" "),s("p",[a._v("For this example, let's look at the interface "),s("a",{attrs:{href:"https://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-Sequence.html",target:"_blank",rel:"noopener noreferrer"}},[s("code",[a._v("Data.Sequence")]),s("OutboundLink")],1),a._v(" exposes, and let's see how it can be improved with pattern synonyms. The "),s("a",{attrs:{href:"https://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-Sequence.html#t:Seq",target:"_blank",rel:"noopener noreferrer"}},[s("code",[a._v("Seq")]),s("OutboundLink")],1),a._v(" type is a data type that, internally, uses a "),s("a",{attrs:{href:"http://staff.city.ac.uk/%7Eross/papers/FingerTree.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("complicated representation"),s("OutboundLink")],1),a._v(" to achieve good asymptotic complexity for various operations, most notably both O(1) (un)consing and (un)snocing.")]),a._v(" "),s("p",[a._v("But this representation is unwieldy and some of its invariants cannot be expressed in Haskell's type system. Because of this, the "),s("code",[a._v("Seq")]),a._v(" type is exposed to users as an abstract type, along with invariant-preserving accessor and constructor functions, among them:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("empty")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Seq")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<|")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Seq")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Seq")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("data")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("ViewL")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("EmptyL")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":<")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Seq")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("viewl")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Seq")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("ViewL")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|>")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Seq")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Seq")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" \n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("data")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("ViewR")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("EmptyR")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("|")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Seq")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":>")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" \n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("viewr")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Seq")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("ViewR")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v("\n\n")])])]),s("p",[a._v("But using this interface can be a bit cumbersome:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("uncons")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Seq")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Maybe")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Seq")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("uncons")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("xs")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("case")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("viewl")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("xs")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("of")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":<")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("xs'")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Just")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("xs'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("EmptyL")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Nothing")]),a._v("\n\n")])])]),s("p",[a._v("We can use "),s("a",{attrs:{href:"https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns",target:"_blank",rel:"noopener noreferrer"}},[a._v("view patterns"),s("OutboundLink")],1),a._v(" to clean it up somewhat:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("{-# LANGUAGE ViewPatterns #-}")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("uncons")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Seq")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Maybe")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Seq")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("uncons")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("viewl")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":<")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("xs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Just")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("xs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("uncons")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("_")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Nothing")]),a._v("\n\n")])])]),s("p",[a._v("Using the "),s("code",[a._v("PatternSynonyms")]),a._v(" language extension, we can give an even nicer interface by allowing pattern matching to pretend that we have a cons- or a snoc-list:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("{-# LANGUAGE PatternSynonyms #-}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token import-statement"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("import")]),a._v(" Data"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("Sequence")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Seq")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token import-statement"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("import")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("qualified")]),a._v(" Data"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("Sequence "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("as")]),a._v(" Seq")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("pattern")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Empty")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Seq")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("pattern")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Empty")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<-")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("Seq"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("viewl")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Seq"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("EmptyL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("pattern")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":<")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Seq")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Seq")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("pattern")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":<")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("xs")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<-")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("Seq"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("viewl")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Seq")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(".:<")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("xs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("pattern")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":>")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Seq")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Seq")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("pattern")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("xs")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":>")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<-")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("Seq"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("viewr")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("xs")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Seq")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(".:>")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n")])])]),s("p",[a._v("This allows us to write "),s("code",[a._v("uncons")]),a._v(" in a very natural style:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("uncons")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Seq")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Maybe")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Seq")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("uncons")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":<")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("xs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Just")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("x")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("xs")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("uncons")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("_")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Nothing")]),a._v("\n\n")])])]),s("h2",{attrs:{id:"scopedtypevariables"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#scopedtypevariables"}},[a._v("#")]),a._v(" ScopedTypeVariables")]),a._v(" "),s("p",[s("code",[a._v("ScopedTypeVariables")]),a._v(" let you refer to universally quantified types inside of a declaration. To be more explicit:")]),a._v(" "),s("div",{staticClass:"language-hs extra-class"},[s("pre",{pre:!0,attrs:{class:"language-hs"}},[s("code",[s("span",{pre:!0,attrs:{class:"token import-statement"}},[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("import")]),a._v(" Data"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("Monoid")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("foo")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("forall")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Monoid")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Monoid")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("foo")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b''")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c''")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("where")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b''")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c''")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<>")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<>")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("b")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n")])])]),s("p",[a._v("The important thing is that we can use "),s("code",[a._v("a")]),a._v(", "),s("code",[a._v("b")]),a._v(" and "),s("code",[a._v("c")]),a._v(" to instruct the compiler in subexpressions of the declaration (the tuple in the "),s("code",[a._v("where")]),a._v(" clause and the first "),s("code",[a._v("a")]),a._v(" in the final result). In practice, "),s("code",[a._v("ScopedTypeVariables")]),a._v(" assist in writing complex functions as a sum of parts, allowing the programmer to add type signatures to intermediate values that don't have concrete types.")]),a._v(" "),s("h2",{attrs:{id:"recordwildcards"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#recordwildcards"}},[a._v("#")]),a._v(" RecordWildCards")]),a._v(" "),s("p",[a._v("See "),s("a",{attrs:{href:"http://stackoverflow.com/documentation/haskell/1950/record-syntax/13072/recordwildcards#t=201607291417389498572",target:"_blank",rel:"noopener noreferrer"}},[a._v("RecordWildCards"),s("OutboundLink")],1)]),a._v(" "),s("h4",{attrs:{id:"remarks"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#remarks"}},[a._v("#")]),a._v(" Remarks")]),a._v(" "),s("p",[a._v("These language extensions are typically available when using the Glasgow Haskell Compiler (GHC) as they are not part of the approved "),s("a",{attrs:{href:"https://www.haskell.org/onlinereport/haskell2010/",target:"_blank",rel:"noopener noreferrer"}},[a._v("Haskell 2010 language Report"),s("OutboundLink")],1),a._v(". To use these extensions, one must either inform the compiler using a "),s("a",{attrs:{href:"https://downloads.haskell.org/%7Eghc/7.2.2/docs/html/users_guide/flag-reference.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("flag"),s("OutboundLink")],1),a._v(" or place "),s("a",{attrs:{href:"https://downloads.haskell.org/%7Eghc/7.2.2/docs/html/users_guide/pragmas.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("a "),s("code",[a._v("LANGUAGE")]),a._v(" programa"),s("OutboundLink")],1),a._v(" before the "),s("code",[a._v("module")]),a._v(" keyword in a file. The official documentation can be found in "),s("a",{attrs:{href:"https://downloads.haskell.org/%7Eghc/7.2.2/docs/html/users_guide/ghc-language-features.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("section 7"),s("OutboundLink")],1),a._v(" of the GCH users guide.")]),a._v(" "),s("p",[a._v("The format of the "),s("code",[a._v("LANGUAGE")]),a._v(" programa is "),s("code",[a._v("{-# LANGUAGE ExtensionOne, ExtensionTwo ... #-}")]),a._v(".  That is the literal "),s("code",[a._v("{-#")]),a._v(" followed by "),s("code",[a._v("LANGUAGE")]),a._v(" followed by a comma separated list of extensions, and finally the closing "),s("code",[a._v("#-}")]),a._v(". Multiple "),s("code",[a._v("LANGUAGE")]),a._v(" programas may be placed in one file.")])])}),[],!1,null,null,null);t.default=n.exports}}]);