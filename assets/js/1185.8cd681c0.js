(window.webpackJsonp=window.webpackJsonp||[]).push([[1185],{1593:function(a,s,t){"use strict";t.r(s);var e=t(31),r=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"foreign-function-interface"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#foreign-function-interface"}},[a._v("#")]),a._v(" Foreign Function Interface")]),a._v(" "),t("h2",{attrs:{id:"calling-c-from-haskell"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#calling-c-from-haskell"}},[a._v("#")]),a._v(" Calling C from Haskell")]),a._v(" "),t("p",[a._v("For performance reasons, or due to the existence of mature C libraries, you may want to call C code from a Haskell program. Here is a simple example of how you can pass data to a C library and get an answer back.")]),a._v(" "),t("p",[a._v("foo.c:")]),a._v(" "),t("div",{staticClass:"language-hs extra-class"},[t("pre",{pre:!0,attrs:{class:"language-hs"}},[t("code",[t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("#")]),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("include")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("inttypes")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("h")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("int32_t")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("foo")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("int32_t")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("return")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("a")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n")])])]),t("p",[a._v("Foo.hs:")]),a._v(" "),t("div",{staticClass:"language-hs extra-class"},[t("pre",{pre:!0,attrs:{class:"language-hs"}},[t("code",[t("span",{pre:!0,attrs:{class:"token import-statement"}},[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("import")]),a._v(" Data"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("Int")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("main")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("IO")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("main")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("print")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=<<")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("hFoo")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("41")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("foreign")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("import")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("ccall")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("unsafe")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"foo"')]),a._v(" "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("hFoo")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Int32")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("IO")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Int32")]),a._v("\n\n")])])]),t("p",[a._v("The "),t("code",[a._v("unsafe")]),a._v(" keyword generates a more efficient call than 'safe', but requires that the C code never makes a callback to the Haskell system. Since "),t("code",[a._v("foo")]),a._v(" is completely in C and will never call Haskell, we can use "),t("code",[a._v("unsafe")]),a._v(".")]),a._v(" "),t("p",[a._v("We also need to instruct cabal to compile and link in C source.")]),a._v(" "),t("p",[a._v("foo.cabal:")]),a._v(" "),t("div",{staticClass:"language-hs extra-class"},[t("pre",{pre:!0,attrs:{class:"language-hs"}},[t("code",[t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("name")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v("                "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("foo")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("version")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v("             "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0.0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("0.1")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("build")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("type")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v("          "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Simple")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("extra")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("source")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("files")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v("  "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*.")]),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("cabal")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("version")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v("       "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("1.10")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("executable")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("foo")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("default")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("language")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Haskell2010")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("main")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("is")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v("       "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("Foo"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("hs")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("C")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("sources")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v("     "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("foo")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("c")]),a._v("\n  "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("build")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("depends")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("base")]),a._v("\n\n")])])]),t("p",[a._v("Then you can run:")]),a._v(" "),t("div",{staticClass:"language-hs extra-class"},[t("pre",{pre:!0,attrs:{class:"language-hs"}},[t("code",[t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("cabal")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("configure")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("cabal")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("build")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("foo")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("./")]),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("dist")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("build")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("foo")]),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("foo")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("42")]),a._v("\n\n")])])]),t("h2",{attrs:{id:"passing-haskell-functions-as-callbacks-to-c-code"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#passing-haskell-functions-as-callbacks-to-c-code"}},[a._v("#")]),a._v(" Passing Haskell functions as callbacks to C code.")]),a._v(" "),t("p",[a._v("It is very common for C functions to accept pointers to other functions as arguments. Most popular example is setting an action to be executed when a button is clicked in some GUI toolkit library. It is possible to pass Haskell functions as C callbacks.")]),a._v(" "),t("p",[a._v("To call this C function:")]),a._v(" "),t("div",{staticClass:"language-hs extra-class"},[t("pre",{pre:!0,attrs:{class:"language-hs"}},[t("code",[t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("void")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("event_callback_add")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Object")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("obj")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Object_Event_Cb")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("func")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("const")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("void")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("data")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n")])])]),t("p",[a._v("we first import it to Haskell code:")]),a._v(" "),t("div",{staticClass:"language-hs extra-class"},[t("pre",{pre:!0,attrs:{class:"language-hs"}},[t("code",[t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("foreign")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("import")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("ccall")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"header.h event_callback_add"')]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("callbackAdd")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Ptr")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("FunPtr")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Callback")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Ptr")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("IO")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n")])])]),t("p",[a._v("Now looking at how "),t("code",[a._v("Object_Event_Cb")]),a._v(" is defined in C header, define what "),t("code",[a._v("Callback")]),a._v(" is in Haskell:")]),a._v(" "),t("div",{staticClass:"language-hs extra-class"},[t("pre",{pre:!0,attrs:{class:"language-hs"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("type")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Callback")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Ptr")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Ptr")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("IO")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n")])])]),t("p",[a._v("Finally, create a special function that would wrap Haskell function of type "),t("code",[a._v("Callback")]),a._v(" into a pointer "),t("code",[a._v("FunPtr Callback")]),a._v(":")]),a._v(" "),t("div",{staticClass:"language-hs extra-class"},[t("pre",{pre:!0,attrs:{class:"language-hs"}},[t("code",[t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("foreign")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("import")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("ccall")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[a._v('"wrapper"')]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("mkCallback")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("::")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Callback")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("IO")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("FunPtr")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token constant"}},[a._v("Callback")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n")])])]),t("p",[a._v("Now we can register callback with C code:")]),a._v(" "),t("div",{staticClass:"language-hs extra-class"},[t("pre",{pre:!0,attrs:{class:"language-hs"}},[t("code",[t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("cbPtr")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<-")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("mkCallback")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("$")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("\\")]),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("objPtr")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("dataPtr")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("do")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("-- callback code")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("return")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("callbackAdd")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("cpPtr")]),a._v("\n\n")])])]),t("p",[a._v("It is important to free allocated "),t("code",[a._v("FunPtr")]),a._v(" once you unregister the callback:")]),a._v(" "),t("div",{staticClass:"language-hs extra-class"},[t("pre",{pre:!0,attrs:{class:"language-hs"}},[t("code",[t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("freeHaskellFunPtr")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token hvariable"}},[a._v("cbPtr")]),a._v("\n\n")])])]),t("h4",{attrs:{id:"syntax"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#syntax"}},[a._v("#")]),a._v(" Syntax")]),a._v(" "),t("ul",[t("li",[a._v('foreign import ccall unsafe "foo" hFoo :: Int32 -> IO Int32 {- Imports a function named '),t("code",[a._v("foo")]),a._v(" in some object file, and defines the symbol "),t("code",[a._v("hFoo")]),a._v(" which can be called with Haskell code. -}")])]),a._v(" "),t("h4",{attrs:{id:"remarks"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#remarks"}},[a._v("#")]),a._v(" Remarks")]),a._v(" "),t("p",[a._v("While cabal has support for including a C and C++ libraries in a Haskell package, there are a few bugs. First, if you have data (rather than a function) defined in "),t("code",[a._v("b.o")]),a._v(" that is used in "),t("code",[a._v("a.o")]),a._v(", and list the "),t("code",[a._v("C-sources: a.c, b.c")]),a._v(", then cabal will be unable to find the data. This is documented in "),t("a",{attrs:{href:"https://ghc.haskell.org/trac/ghc/ticket/12152",target:"_blank",rel:"noopener noreferrer"}},[a._v("#12152"),t("OutboundLink")],1),a._v(". A workaround when using cabal is to reorder the "),t("code",[a._v("C-sources")]),a._v(" list to be "),t("code",[a._v("C-sources: b.c, a.c")]),a._v(". This may not work when using stack, because stack always links the "),t("code",[a._v("C-sources")]),a._v(" alphabetically, regardless of the order in which you list them.")]),a._v(" "),t("p",[a._v("Another issues is that you must surround any C++ code in header (.h) files with "),t("code",[a._v("#ifdef __cplusplus")]),a._v(" guards. This is because GHC doesn't understand C++ code in header files. You can still write C++ code in header files, but you must surround it with guards.")]),a._v(" "),t("p",[t("code",[a._v("ccall")]),a._v(" refers to the "),t("strong",[a._v("calling convention")]),a._v("; currently "),t("code",[a._v("ccall")]),a._v(" and "),t("code",[a._v("stdcall")]),a._v(" (Pascal convention) are supported. The "),t("code",[a._v("unsafe")]),a._v(" keyword is optional; this reduces overhead for simple functions but may cause deadlocks if the foreign function blocks indefinitely or has insufficient permission to execute"),t("a",{attrs:{href:"https://wiki.haskell.org/Foreign_Function_Interface",target:"_blank",rel:"noopener noreferrer"}},[a._v("1"),t("OutboundLink")],1),a._v(".")])])}),[],!1,null,null,null);s.default=r.exports}}]);