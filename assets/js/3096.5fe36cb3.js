(window.webpackJsonp=window.webpackJsonp||[]).push([[3096],{3504:function(t,s,e){"use strict";e.r(s);var a=e(31),n=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"monkey-patching-in-ruby"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#monkey-patching-in-ruby"}},[t._v("#")]),t._v(" Monkey Patching in Ruby")]),t._v(" "),e("h2",{attrs:{id:"adding-functionality"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#adding-functionality"}},[t._v("#")]),t._v(" Adding Functionality")]),t._v(" "),e("p",[t._v("You can add a method to any class in Ruby, whether it's a builtin or not. The calling object is referenced using "),e("code",[t._v("self")]),t._v(".")]),t._v(" "),e("div",{staticClass:"language-ruby extra-class"},[e("pre",{pre:!0,attrs:{class:"language-ruby"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Fixnum")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token method-definition"}},[e("span",{pre:!0,attrs:{class:"token function"}},[t._v("plus_one")])]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("end")]),t._v("\n\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token method-definition"}},[e("span",{pre:!0,attrs:{class:"token function"}},[t._v("plus")])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("num"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" num\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("end")]),t._v("\n\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token method-definition"}},[e("span",{pre:!0,attrs:{class:"token function"}},[t._v("concat_one")])]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("to_s "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("'1'")]),t._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("end")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("end")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1.")]),t._v("plus_one "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# => 2")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3.")]),t._v("plus"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# => 8")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("6.")]),t._v("concat_one "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# => '61'")]),t._v("\n\n")])])]),e("h4",{attrs:{id:"remarks"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#remarks"}},[t._v("#")]),t._v(" Remarks")]),t._v(" "),e("p",[t._v("Monkey patching, while convenient, has some pitfalls that aren't immediately obvious. Most notably, a patch like that in the example pollutes the global scope. If two modules both add "),e("code",[t._v("Hash#symbolize")]),t._v(", only the last module required actually applies its change; the rest are erased.")]),t._v(" "),e("p",[t._v("Furthermore, if there's an error in a patched method, the stacktrace simply points to the patched class. This implies that there's a bug in the "),e("code",[t._v("Hash")]),t._v(" class itself (which there is now).")]),t._v(" "),e("p",[t._v("Lastly, because Ruby is very flexible with what containers to hold, a method that seems very straightforward when you write it has lots of undefined functionality. For instance, creating "),e("code",[t._v("Array#sum")]),t._v(" is good for an array of numbers, but breaks when given an array of a custom class.")]),t._v(" "),e("p",[t._v("A safer alternative is refinements, available in Ruby >= 2.0.")])])}),[],!1,null,null,null);s.default=n.exports}}]);