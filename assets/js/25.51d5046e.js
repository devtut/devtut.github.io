(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{432:function(t,e,s){"use strict";s.r(e);var a=s(31),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"check-if-a-tree-is-bst-or-not"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#check-if-a-tree-is-bst-or-not"}},[t._v("#")]),t._v(" Check if a tree is BST or not")]),t._v(" "),s("h2",{attrs:{id:"algorithm-to-check-if-a-given-binary-tree-is-bst"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-to-check-if-a-given-binary-tree-is-bst"}},[t._v("#")]),t._v(" Algorithm to check if a given binary tree is BST")]),t._v(" "),s("p",[t._v("A binary tree is BST if it satisfies any one of the following condition:")]),t._v(" "),s("ol",[s("li",[t._v("It is empty")]),t._v(" "),s("li",[t._v("It has no subtrees")]),t._v(" "),s("li",[t._v("For every node x in the tree all the keys (if any) in the left sub tree must be less than key(x) and all the keys (if any) in the right sub tree must be greater than key(x).")])]),t._v(" "),s("p",[t._v("So a straightforward recursive algorithm would be:")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("is_BST")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" root "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Check values in left subtree")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" root"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("left "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n    max_key_in_left "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("find_max_key")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("root"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" max_key_in_left "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" root"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Check values in right subtree")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" root"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("right "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n    min_key_in_right "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("find_min_key")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("root"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" min_key_in_right "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" root"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("\n\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("is_BST")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("root"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("is_BST")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("root"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n")])])]),s("p",[t._v("The above recursive algorithm is correct but inefficient, because it traverses each node mutiple times.")]),t._v(" "),s("p",[t._v("Another approach to minimize the multiple visits of each node is to remember the min and max possible values of the keys in the subtree we are visiting. Let the minimum possible value of any key be "),s("code",[t._v("K_MIN")]),t._v(" and maximum value be "),s("code",[t._v("K_MAX")]),t._v(". When we start from the root of the tree, the range of values in the tree is "),s("code",[t._v("[K_MIN,K_MAX]")]),t._v(". Let the key of root node be "),s("code",[t._v("x")]),t._v(". Then the range of values in left subtree is "),s("code",[t._v("[K_MIN,x)")]),t._v(" and the range of values in right subtree is "),s("code",[t._v("(x,K_MAX]")]),t._v(".  We will use this idea to develop a more efficient algorithm.")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("is_BST")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" min"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" max"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" root "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("NULL")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// is the current node key out of range?")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" root"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("key "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" min "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("||")]),t._v(" root"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("key "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" max"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// check if left and right subtree is BST")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("is_BST")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("root"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("left"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("min"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("root"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("is_BST")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("root"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("right"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("root"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v("key"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("max"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n")])])]),s("p",[t._v("It will be initially called as:")]),t._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[t._v("is_BST")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("my_tree_root"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("KEY_MIN"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("KEY_MAX"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n")])])]),s("p",[t._v("Another approach will be to do inorder traversal of the Binary tree. If the inorder traversal produces a sorted sequence of keys then the given tree is a BST. To check if the inorder sequence is sorted remember the value of previously visited node and compare it  against the current node.")]),t._v(" "),s("h2",{attrs:{id:"if-a-given-input-tree-follows-binary-search-tree-property-or-not"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#if-a-given-input-tree-follows-binary-search-tree-property-or-not"}},[t._v("#")]),t._v(" If a given input tree follows Binary search tree property or not")]),t._v(" "),s("p",[t._v("For example")]),t._v(" "),s("p",[s("strong",[t._v("if the input is:")])]),t._v(" "),s("p",[s("a",{attrs:{href:"https://i.stack.imgur.com/sd2Zq.png",target:"_blank",rel:"noopener noreferrer"}},[s("img",{attrs:{src:"https://i.stack.imgur.com/sd2Zq.png",alt:"enter image description here"}}),s("OutboundLink")],1)]),t._v(" "),s("p",[s("strong",[t._v("Output should be false:")])]),t._v(" "),s("p",[t._v("As 4 in the left sub-tree is greater than the root value(3)")]),t._v(" "),s("p",[s("strong",[t._v("If the input is:")])]),t._v(" "),s("p",[s("a",{attrs:{href:"https://i.stack.imgur.com/GR41M.png",target:"_blank",rel:"noopener noreferrer"}},[s("img",{attrs:{src:"https://i.stack.imgur.com/GR41M.png",alt:"enter image description here"}}),s("OutboundLink")],1)]),t._v(" "),s("p",[s("strong",[t._v("Output should be true")])])])}),[],!1,null,null,null);e.default=r.exports}}]);