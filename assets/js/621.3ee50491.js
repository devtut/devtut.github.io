(window.webpackJsonp=window.webpackJsonp||[]).push([[621],{967:function(e,t,a){"use strict";a.r(t);var s=a(19),o=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"c-11-memory-model"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#c-11-memory-model"}},[e._v("#")]),e._v(" C++11 Memory Model")]),e._v(" "),a("h2",{attrs:{id:"need-for-memory-model"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#need-for-memory-model"}},[e._v("#")]),e._v(" Need for Memory Model")]),e._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("bool")]),e._v(" ready "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("init")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  x "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  y "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  ready "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("use")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("if")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("ready"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n    std"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("::")]),e._v("cout "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<<")]),e._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("+")]),e._v(" y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n")])])]),a("p",[e._v("One thread calls the "),a("code",[e._v("init()")]),e._v(" function while another thread (or signal handler) calls the "),a("code",[e._v("use()")]),e._v(" function. One might expect that the "),a("code",[e._v("use()")]),e._v(" function will either print "),a("code",[e._v("5")]),e._v(" or do nothing. This may not always be the case for several reasons:")]),e._v(" "),a("li",[e._v("\nThe CPU may reorder the writes that happen in `init()` so that the code that  actually executes might look like:\n"),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("init")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  ready "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  x "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  y "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n")])])])]),e._v(" "),a("li",[e._v("\nThe CPU may reorder the reads that happen in `use()` so that the actually executed code might become:\n"),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("use")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" local_x "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" local_y "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("if")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("ready"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n    std"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("::")]),e._v("cout "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<<")]),e._v(" local_x "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("+")]),e._v(" local_y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n")])])])]),e._v(" "),a("li",[e._v("\nAn optimizing C++ compiler may decide to reorder the program in similar way.\n")]),e._v(" "),a("p",[e._v("Such reordering cannot change the behavior of a program running in single thread because a thread cannot interleave the calls to "),a("code",[e._v("init()")]),e._v(" and "),a("code",[e._v("use()")]),e._v(". On the other hand in a multi-threaded setting one thread may see part of the writes performed by the other thread where it may happen that "),a("code",[e._v("use()")]),e._v(" may see "),a("code",[e._v("ready==true")]),e._v(" and garbage in "),a("code",[e._v("x")]),e._v(" or "),a("code",[e._v("y")]),e._v(" or both.")]),e._v(" "),a("p",[e._v("The C++ Memory Model allows the programmer to specify which reordering operations are permitted and which are not, so that a multi-threaded program would also be able to behave as expected. The example above can be rewritten in thread-safe way like this:")]),e._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\nstd"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("::")]),e._v("atomic"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("bool")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" ready"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("init")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  x "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  y "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  ready"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("store")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" std"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("::")]),e._v("memory_order_release"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("use")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("if")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("ready"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("load")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("std"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("::")]),e._v("memory_order_acquire"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n    std"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("::")]),e._v("cout "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<<")]),e._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("+")]),e._v(" y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n")])])]),a("p",[e._v("Here "),a("code",[e._v("init()")]),e._v(" performs "),a("strong",[e._v("atomic store-release")]),e._v(" operation. This not only stores the value "),a("code",[e._v("true")]),e._v(" into "),a("code",[e._v("ready")]),e._v(", but also tells the compiler that it cannot move this operation before write operations that are "),a("strong",[e._v("sequenced before")]),e._v(" it.")]),e._v(" "),a("p",[e._v("The "),a("code",[e._v("use()")]),e._v(" function does an "),a("strong",[e._v("atomic load-acquire")]),e._v(" operation. It reads the current value of "),a("code",[e._v("ready")]),e._v(" and also forbids the compiler from placing read operations that are "),a("strong",[e._v("sequenced after")]),e._v(" it to "),a("strong",[e._v("happen before")]),e._v(" the "),a("strong",[e._v("atomic load-acquire")]),e._v(".")]),e._v(" "),a("p",[e._v("These atomic operations also cause the compiler to put whatever hardware instructions are needed to inform the CPU to refrain from the unwanted reorderings.")]),e._v(" "),a("p",[e._v("Because the "),a("strong",[e._v("atomic store-release")]),e._v(" is to the same memory location as the "),a("strong",[e._v("atomic load-acquire")]),e._v(", the memory model stipulates that if the "),a("strong",[e._v("load-acquire")]),e._v(" operation sees the value written by the "),a("strong",[e._v("store-release")]),e._v(" operation, then all writes performed by "),a("code",[e._v("init()")]),e._v("'s thread prior to that "),a("strong",[e._v("store-release")]),e._v(" will be visible to loads that "),a("code",[e._v("use()")]),e._v("'s thread executes after its "),a("strong",[e._v("load-acquire")]),e._v(". That is if "),a("code",[e._v("use()")]),e._v(" sees "),a("code",[e._v("ready==true")]),e._v(", then it is guaranteed to see "),a("code",[e._v("x==2")]),e._v(" and "),a("code",[e._v("y==3")]),e._v(".")]),e._v(" "),a("p",[e._v("Note that the compiler and the CPU are still allowed to write to "),a("code",[e._v("y")]),e._v(" before writing to "),a("code",[e._v("x")]),e._v(", and similarly the reads from these variables in "),a("code",[e._v("use()")]),e._v(" can happen in any order.")]),e._v(" "),a("h2",{attrs:{id:"fence-example"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fence-example"}},[e._v("#")]),e._v(" Fence example")]),e._v(" "),a("p",[e._v("The example above can also be implemented with fences and relaxed atomic operations:")]),e._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" x"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\nstd"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("::")]),e._v("atomic"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("bool")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" ready"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("false")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("init")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  x "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  y "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("atomic_thread_fence")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("std"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("::")]),e._v("memory_order_release"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  ready"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("store")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" std"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("::")]),e._v("memory_order_relaxed"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("use")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("if")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("ready"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("load")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("std"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("::")]),e._v("memory_order_relaxed"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("atomic_thread_fence")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("std"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("::")]),e._v("memory_order_acquire"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    std"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("::")]),e._v("cout "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<<")]),e._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("+")]),e._v(" y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n")])])]),a("p",[e._v("If the atomic load operation sees the value written by the atomic store then the store happens before the load, and so do the fences: the release fence happens before the acquire fence making the writes to "),a("code",[e._v("x")]),e._v(" and "),a("code",[e._v("y")]),e._v(" that precede the release fence to become visible to the "),a("code",[e._v("std::cout")]),e._v(" statement that follows the acquire fence.")]),e._v(" "),a("p",[e._v("A fence might be beneficial if it can reduce the overall number of acquire, release or other synchronization operations. For example:")]),e._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("block_and_use")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("while")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("!")]),e._v("ready"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("load")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("std"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("::")]),e._v("memory_order_relaxed"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("atomic_thread_fence")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("std"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("::")]),e._v("memory_order_acquire"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  std"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("::")]),e._v("cout "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<<")]),e._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("+")]),e._v(" y"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n")])])]),a("p",[e._v("The "),a("code",[e._v("block_and_use()")]),e._v(" function spins until the "),a("code",[e._v("ready")]),e._v(" flag is set with the help of relaxed atomic load. Then a single acquire fence is used to provide the needed memory ordering.")]),e._v(" "),a("h4",{attrs:{id:"remarks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#remarks"}},[e._v("#")]),e._v(" Remarks")]),e._v(" "),a("p",[e._v("Different threads trying to access the same memory location participate in a "),a("strong",[e._v("data race")]),e._v(" if at least one of the operations is a modification (also known as "),a("strong",[e._v("store operation")]),e._v("). These "),a("strong",[e._v("data races")]),e._v(" cause "),a("strong",[e._v("undefined behavior")]),e._v(". To avoid them one needs to prevent these threads from concurrently executing such conflicting operations.")]),e._v(" "),a("p",[e._v("Synchronization primitives (mutex, critical section and the like) can guard such accesses. The Memory Model introduced in C++11 defines two new portable ways to synchronize access to memory in multi-threaded environment: atomic operations and fences.")]),e._v(" "),a("h3",{attrs:{id:"atomic-operations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#atomic-operations"}},[e._v("#")]),e._v(" Atomic Operations")]),e._v(" "),a("p",[e._v("It is now possible to read and write to given memory location by the use of "),a("strong",[e._v("atomic load")]),e._v(" and "),a("strong",[e._v("atomic store")]),e._v(" operations. For convenience these are wrapped in the "),a("code",[e._v("std::atomic<t>")]),e._v(" template class. This class wraps a value of type "),a("code",[e._v("t")]),e._v(" but this time "),a("strong",[e._v("loads")]),e._v(" and "),a("strong",[e._v("stores")]),e._v(" to the object are atomic.")]),e._v(" "),a("p",[e._v("The template is not available for all types. Which types are available is implementation specific, but this usually includes most (or all) available integral types as well as pointer types. So that "),a("code",[e._v("std::atomic<unsigned>")]),e._v(" and "),a("code",[e._v("std::atomic<std::vector<foo> *>")]),e._v(" should be available, while "),a("code",[e._v("std::atomic<std::pair<bool,char>>")]),e._v(" most probably wont be.")]),e._v(" "),a("p",[e._v("Atomic operations have the following properties:")]),e._v(" "),a("ul",[a("li",[e._v("All atomic operations can be performed concurrently from multiple threads without causing undefined behavior.")]),e._v(" "),a("li",[e._v("An "),a("strong",[e._v("atomic load")]),e._v(" will see either the initial value which the atomic object was constructed with, or the value written to it via some "),a("strong",[e._v("atomic store")]),e._v(" operation.")]),e._v(" "),a("li",[a("strong",[e._v("Atomic stores")]),e._v(" to the same atomic object are ordered the same in all threads. If a thread has already seen the value of some "),a("strong",[e._v("atomic store")]),e._v(" operation, subsequent "),a("strong",[e._v("atomic load")]),e._v(" operations will see either the same value, or the value stored by subsequent "),a("strong",[e._v("atomic store")]),e._v(" operation.")]),e._v(" "),a("li",[a("strong",[e._v("Atomic read-modify-write")]),e._v(" operations allow "),a("strong",[e._v("atomic load")]),e._v(" and "),a("strong",[e._v("atomic store")]),e._v(" to happen without other "),a("strong",[e._v("atomic store")]),e._v(" in between. For example one can atomically increment a counter from multiple threads, and no increment will be lost regardless of the contention between the threads.")]),e._v(" "),a("li",[e._v("Atomic operations receive an optional "),a("code",[e._v("std::memory_order")]),e._v(" parameter which defines what additional properties the operation has regarding other memory locations.")])]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("std::memory_order")]),e._v(" "),a("th",[e._v("Meaning")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[a("code",[e._v("std::memory_order_relaxed")])]),e._v(" "),a("td",[e._v("no additional restrictions")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("std::memory_order_release")]),e._v(" â†’ "),a("code",[e._v("std::memory_order_acquire")])]),e._v(" "),a("td",[e._v("if "),a("code",[e._v("load-acquire")]),e._v(" sees the value stored by "),a("code",[e._v("store-release")]),e._v(" then stores "),a("strong",[e._v("sequenced before")]),e._v(" the "),a("code",[e._v("store-release")]),e._v(" happen before loads sequenced after the "),a("strong",[e._v("load acquire")])])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("std::memory_order_consume")])]),e._v(" "),a("td",[e._v("like "),a("code",[e._v("memory_order_acquire")]),e._v(" but only for dependent loads")])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("std::memory_order_acq_rel")])]),e._v(" "),a("td",[e._v("combines "),a("code",[e._v("load-acquire")]),e._v(" and "),a("code",[e._v("store-release")])])]),e._v(" "),a("tr",[a("td",[a("code",[e._v("std::memory_order_seq_cst")])]),e._v(" "),a("td",[e._v("sequential consistency")])])])]),e._v(" "),a("p",[e._v("These memory order tags allow three different memory ordering disciplines: "),a("strong",[e._v("sequential consistency")]),e._v(", "),a("strong",[e._v("relaxed")]),e._v(", and "),a("strong",[e._v("release-acquire")]),e._v(" with its sibling "),a("strong",[e._v("release-consume")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"sequential-consistency"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sequential-consistency"}},[e._v("#")]),e._v(" Sequential Consistency")]),e._v(" "),a("p",[e._v("If no memory order is specified for an atomic operation, the order defaults to "),a("strong",[e._v("sequential consistency")]),e._v(". This mode can also be explicitly selected by tagging the operation with "),a("code",[e._v("std::memory_order_seq_cst")]),e._v(".")]),e._v(" "),a("p",[e._v("With this order no memory operation can cross the atomic operation. All memory operations sequenced before the atomic operation happen before the atomic operation and the atomic operation happens before all memory operations that are sequenced after it. This mode is probably the easiest one to reason about but it also leads to the greatest penalty to performance. It also prevents all compiler optimizations that might otherwise try to reorder operations past the atomic operation.")]),e._v(" "),a("h3",{attrs:{id:"relaxed-ordering"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#relaxed-ordering"}},[e._v("#")]),e._v(" Relaxed Ordering")]),e._v(" "),a("p",[e._v("The opposite to "),a("strong",[e._v("sequential consistency")]),e._v(" is the "),a("strong",[e._v("relaxed")]),e._v(" memory ordering. It is selected with the "),a("code",[e._v("std::memory_order_relaxed")]),e._v(" tag. Relaxed atomic operation will impose no restrictions on other memory operations. The only effect that remains, is that the operation is itself still atomic.")]),e._v(" "),a("h3",{attrs:{id:"release-acquire-ordering"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#release-acquire-ordering"}},[e._v("#")]),e._v(" Release-Acquire Ordering")]),e._v(" "),a("p",[e._v("An "),a("strong",[e._v("atomic store")]),e._v(" operation can be tagged with "),a("code",[e._v("std::memory_order_release")]),e._v(" and an "),a("strong",[e._v("atomic load")]),e._v(" operation can be tagged with "),a("code",[e._v("std::memory_order_acquire")]),e._v(". The first operation is called "),a("strong",[e._v("(atomic) store-release")]),e._v(" while the second is called "),a("strong",[e._v("(atomic) load-acquire")]),e._v(".")]),e._v(" "),a("p",[e._v("When "),a("strong",[e._v("load-acquire")]),e._v(" sees the value written by a "),a("strong",[e._v("store-release")]),e._v(" the following happens: all store operations sequenced before the "),a("strong",[e._v("store-release")]),e._v(" become visible to ("),a("strong",[e._v("happen before")]),e._v(") load operations that are sequenced after the "),a("strong",[e._v("load-acquire")]),e._v(".")]),e._v(" "),a("p",[e._v("Atomic read-modify-write operations can also receive the cumulative tag "),a("code",[e._v("std::memory_order_acq_rel")]),e._v(". This makes the "),a("strong",[e._v("atomic load")]),e._v(" portion of the operation an "),a("strong",[e._v("atomic load-acquire")]),e._v(" while the "),a("strong",[e._v("atomic store")]),e._v(" portion becomes "),a("strong",[e._v("atomic store-release")]),e._v(".")]),e._v(" "),a("p",[e._v("The compiler is not allowed to move store operations after an "),a("strong",[e._v("atomic store-release")]),e._v(" operation. It is also not allowed to move load operations before "),a("strong",[e._v("atomic load-acquire")]),e._v(" (or "),a("strong",[e._v("load-consume")]),e._v(").")]),e._v(" "),a("p",[e._v("Also note that there is no "),a("strong",[e._v("atomic load-release")]),e._v(" or "),a("strong",[e._v("atomic store-acquire")]),e._v(". Attempting to create such operations makes them "),a("strong",[e._v("relaxed")]),e._v(" operations.")]),e._v(" "),a("h3",{attrs:{id:"release-consume-ordering"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#release-consume-ordering"}},[e._v("#")]),e._v(" Release-Consume Ordering")]),e._v(" "),a("p",[e._v("This combination is similar to "),a("strong",[e._v("release-acquire")]),e._v(", but this time the "),a("strong",[e._v("atomic load")]),e._v(" is tagged with "),a("code",[e._v("std::memory_order_consume")]),e._v(" and becomes "),a("strong",[e._v("(atomic) load-consume")]),e._v(" operation. This mode is the same as "),a("strong",[e._v("release-acquire")]),e._v(" with the only difference that among the load operations sequenced after the "),a("strong",[e._v("load-consume")]),e._v(" only these depending on the value loaded by the "),a("strong",[e._v("load-consume")]),e._v(" are ordered.")]),e._v(" "),a("h3",{attrs:{id:"fences"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fences"}},[e._v("#")]),e._v(" Fences")]),e._v(" "),a("p",[e._v("Fences also allow memory operations to be ordered between threads. A fence is either a release fence or acquire fence.")]),e._v(" "),a("p",[e._v("If a release fence happens before an acquire fence, then stores sequenced before the release fence are visible to loads sequenced after the acquire fence. To guarantee that the release fence happens before the acquire fence one may use other synchronization primitives including relaxed atomic operations.")])])}),[],!1,null,null,null);t.default=o.exports}}]);