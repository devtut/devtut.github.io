(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{471:function(t,e,a){"use strict";a.r(e);var s=a(31),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"polynomial-time-bounded-algorithm-for-minimum-vertex-cover"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#polynomial-time-bounded-algorithm-for-minimum-vertex-cover"}},[t._v("#")]),t._v(" polynomial-time bounded algorithm for Minimum Vertex Cover")]),t._v(" "),a("p",[t._v("This is a polynomial algorithm for getting the minimum vertex cover of connected undirected graph.\nThe time complexity of this algorithm is O(n2)")]),t._v(" "),a("h2",{attrs:{id:"algorithm-pseudo-code"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-pseudo-code"}},[t._v("#")]),t._v(" Algorithm Pseudo Code")]),t._v(" "),a("h3",{attrs:{id:"algorithm-pminvertexcover-graph-g"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#algorithm-pminvertexcover-graph-g"}},[t._v("#")]),t._v(" Algorithm PMinVertexCover (graph G)")]),t._v(" "),a("h3",{attrs:{id:"input-connected-graph-g"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#input-connected-graph-g"}},[t._v("#")]),t._v(" Input connected graph G")]),t._v(" "),a("h3",{attrs:{id:"output-minimum-vertex-cover-set-c"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#output-minimum-vertex-cover-set-c"}},[t._v("#")]),t._v(" Output Minimum Vertex Cover Set C")]),t._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[t._v("Set C "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token generic-function"}},[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Set")]),a("span",{pre:!0,attrs:{class:"token generic class-name"}},[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Vertex"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")])])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \n\nSet X "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token generic-function"}},[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("Set")]),a("span",{pre:!0,attrs:{class:"token generic class-name"}},[a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Vertex"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")])])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" \n\nX "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" G"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getAllVerticiesArrangedDescendinglyByDegree")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" v in X "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("do")]),t._v("\n    List"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Vertex"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" adjacentVertices1 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" G"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getAdjacent")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("C contains any of adjacentVertices1 then\n        \n        C"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("v"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" vertex in C "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("do")]),t._v("\n\n    List"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("vertex"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" adjacentVertices2 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" G"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("adjacentVertecies")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vertex"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" C contains any of adjacentVertices2 then\n        \n        C"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("remove")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("vertex"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n        \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" C\n\n")])])]),a("blockquote"),t._v(" "),a("p",[t._v("C is the minimum vertex cover of graph G")]),t._v(" "),a("blockquote"),t._v(" "),a("p",[t._v("we can use bucket sort for sorting the vertices according to its degree because the maximum value of degrees is (n-1) where n is the number of vertices then the time complexity of the sorting will be O(n)")]),t._v(" "),a("h4",{attrs:{id:"parameters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters"}},[t._v("#")]),t._v(" Parameters")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Variable")]),t._v(" "),a("th",[t._v("Meaning")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("G")]),t._v(" "),a("td",[t._v("Input connected un-directed graph")])]),t._v(" "),a("tr",[a("td",[t._v("X")]),t._v(" "),a("td",[t._v("Set of vertices")])]),t._v(" "),a("tr",[a("td",[t._v("C")]),t._v(" "),a("td",[t._v("Final set of vertices")])])])]),t._v(" "),a("h4",{attrs:{id:"remarks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#remarks"}},[t._v("#")]),t._v(" Remarks")]),t._v(" "),a("p",[t._v("The first thing you have to do in this algorithm to get all of the vertices of the graph sorted in descending order according to its degree.")]),t._v(" "),a("p",[t._v("After that you have iterate on them and add each one to final vertices set which don't have any adjacent vertex in this set.")]),t._v(" "),a("p",[t._v("In the final stage iterate on the final vertices set and remove all of the vertices which have one of its adjacent vertices in this set.")])])}),[],!1,null,null,null);e.default=r.exports}}]);