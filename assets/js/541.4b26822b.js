(window.webpackJsonp=window.webpackJsonp||[]).push([[541],{949:function(t,s,a){"use strict";a.r(s);var e=a(31),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"using-trap-to-react-to-signals-and-system-events"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#using-trap-to-react-to-signals-and-system-events"}},[t._v("#")]),t._v(' Using "trap" to react to signals and system events')]),t._v(" "),a("h2",{attrs:{id:"introduction-clean-up-temporary-files"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#introduction-clean-up-temporary-files"}},[t._v("#")]),t._v(" Introduction: clean up temporary files")]),t._v(" "),a("p",[t._v("You can use the "),a("code",[t._v("trap")]),t._v(' command to "trap" signals; this is the shell equivalent of the '),a("code",[t._v("signal()")]),t._v(" or "),a("code",[t._v("sigaction()")]),t._v(" call in C and most other programming languages to catch signals.")]),t._v(" "),a("p",[t._v("One of the most common uses of "),a("code",[t._v("trap")]),t._v(" is to clean up temporary files on both an expected and unexpected exit.")]),t._v(" "),a("p",[t._v("Unfortunately not enough shell scripts do this ðŸ˜¦")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token shebang important"}},[t._v("#!/bin/sh")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Make a cleanup function")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function-name function"}},[t._v("cleanup")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("rm")]),t._v(" --force -- "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"'),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("${tmp}")]),t._v('"')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('# Trap the special "EXIT" group, which is always run when the shell exits.')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("trap")]),t._v(" cleanup EXIT\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Create a temporary file")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("tmp")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"'),a("span",{pre:!0,attrs:{class:"token variable"}},[a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$(")]),t._v("mktemp -p /tmp tmpfileXXXXXXX"),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v(")")])]),t._v('"')]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Hello, world!"')]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"'),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("${tmp}")]),t._v('"')]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('# No rm -f "$tmp" needed. The advantage of using EXIT is that it still works')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# even if there was an error or if you used exit.")]),t._v("\n\n")])])]),a("h2",{attrs:{id:"catching-sigint-or-ctl-c"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#catching-sigint-or-ctl-c"}},[t._v("#")]),t._v(" Catching SIGINT or Ctl+C")]),t._v(" "),a("p",[t._v("The trap is reset for subshells, so the "),a("code",[t._v("sleep")]),t._v(" will still act on the "),a("code",[t._v("SIGINT")]),t._v(" signal sent by "),a("code",[t._v("^C")]),t._v(" (usually by quitting), but the parent process (i.e. the shell script) won't.")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token shebang important"}},[t._v("#!/bin/sh")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Run a command on signal 2 (SIGINT, which is what ^C sends)")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function-name function"}},[t._v("sigint")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Killed subshell!"')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("trap")]),t._v(" sigint INT\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Or use the no-op command for no output")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#trap : INT")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# This will be killed on the first ^C")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Sleeping..."')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("sleep")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("500")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Sleeping..."')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("sleep")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("500")]),t._v("\n\n")])])]),a("p",[t._v("And a variant which still allows you to quit the main program by pressing "),a("code",[t._v("^C")]),t._v(" twice in a second:")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("last")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function-name function"}},[t._v("allow_quit")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("date")]),t._v(" +%s"),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v(")")])]),t._v(" -lt "),a("span",{pre:!0,attrs:{class:"token variable"}},[a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$((")]),t._v(" $last "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("))")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("exit")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Press ^C twice in a row to quit"')]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("last")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token variable"}},[a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$(")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("date")]),t._v(" +%s"),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v(")")])]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("trap")]),t._v(" allow_quit INT\n\n")])])]),a("h2",{attrs:{id:"accumulate-a-list-of-trap-work-to-run-at-exit"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#accumulate-a-list-of-trap-work-to-run-at-exit"}},[t._v("#")]),t._v(" Accumulate a list of trap work to run at exit.")]),t._v(" "),a("p",[t._v("Have you ever forgotten to add a "),a("code",[t._v("trap")]),t._v(" to clean up a temporary file or do other work at exit?")]),t._v(" "),a("p",[t._v("Have you ever set one trap which canceled another?")]),t._v(" "),a("p",[t._v("This code makes it easy to add things to be done on exit one item at a time, rather than having one large "),a("code",[t._v("trap")]),t._v(" statement somewhere in your code, which may be easy to forget.")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# on_exit and add_on_exit")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Usage:")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#   add_on_exit rm -f /tmp/foo")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('#   add_on_exit echo "I am exiting"')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#   tempfile=$(mktemp)")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v('#   add_on_exit rm -f "$tempfile"')]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# Based on http://www.linuxjournal.com/content/use-bash-trap-statement-cleanup-temporary-files")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-name function"}},[t._v("on_exit")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token for-or-select variable"}},[t._v("i")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("in")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"'),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("${on_exit_items"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("@"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("}")]),t._v('"')]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("do")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("eval")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$i")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("done")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-name function"}},[t._v("add_on_exit")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("local")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("n")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("${"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("#")]),t._v("on_exit_items"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("*"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("}")]),t._v("\n    on_exit_items"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$n")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"'),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$*")]),t._v('"')]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$n")]),t._v(" -eq "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("then")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("trap")]),t._v(" on_exit EXIT\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fi")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])])]),a("h2",{attrs:{id:"killing-child-processes-on-exit"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#killing-child-processes-on-exit"}},[t._v("#")]),t._v(" Killing Child Processes on Exit")]),t._v(" "),a("p",[t._v("Trap expressions don't have to be individual functions or programs, they can be more complex expressions as well.")]),t._v(" "),a("p",[t._v("By combining "),a("code",[t._v("jobs -p")]),t._v(" and "),a("code",[t._v("kill")]),t._v(", we can kill all spawned child processes of the shell on exit:")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("trap")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'jobs -p | xargs kill'")]),t._v(" EXIT\n\n")])])]),a("h2",{attrs:{id:"react-on-change-of-terminals-window-size"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-on-change-of-terminals-window-size"}},[t._v("#")]),t._v(" react on change of terminals window size")]),t._v(" "),a("p",[t._v("There is a signal WINCH ( WINdowCHange), which is fired when one resizes a terminal window.")]),t._v(" "),a("div",{staticClass:"language-bash extra-class"},[a("pre",{pre:!0,attrs:{class:"language-bash"}},[a("code",[a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("declare")]),t._v(" -x rows cols\n\n"),a("span",{pre:!0,attrs:{class:"token function-name function"}},[t._v("update_size")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("rows")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token variable"}},[a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$(")]),t._v("tput lines"),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v(")")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# get actual lines of term")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token assign-left variable"}},[t._v("cols")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token variable"}},[a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$(")]),t._v("tput cols"),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v(")")])]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# get actual columns of term")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("echo")]),t._v(" DEBUG terminal window has no "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$rows")]),t._v(" lines and is "),a("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$cols")]),t._v(" characters wide\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[t._v("trap")]),t._v(" update_size WINCH\n\n")])])]),a("h4",{attrs:{id:"syntax"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#syntax"}},[t._v("#")]),t._v(" Syntax")]),t._v(" "),a("ul",[a("li",[t._v('trap action sigspec... # Run "action" on a list of signals')]),t._v(" "),a("li",[t._v("trap sigspec... # Omitting action resets traps for signals")])]),t._v(" "),a("h4",{attrs:{id:"parameters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parameters"}},[t._v("#")]),t._v(" Parameters")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Parameter")]),t._v(" "),a("th",[t._v("Meaning")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("-p")]),t._v(" "),a("td",[t._v("List currently installed traps")])]),t._v(" "),a("tr",[a("td",[t._v("-l")]),t._v(" "),a("td",[t._v("List signal names and corresponding numbers")])])])]),t._v(" "),a("h4",{attrs:{id:"remarks"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#remarks"}},[t._v("#")]),t._v(" Remarks")]),t._v(" "),a("p",[t._v("The "),a("code",[t._v("trap")]),t._v(" utility is a special shell built-in. It's "),a("a",{attrs:{href:"http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#trap",target:"_blank",rel:"noopener noreferrer"}},[t._v("defined in POSIX"),a("OutboundLink")],1),t._v(", but bash adds some useful extensions as well.")]),t._v(" "),a("p",[t._v("Examples that are POSIX-compatible start with "),a("code",[t._v("#!/bin/sh")]),t._v(", and examples that start with "),a("code",[t._v("#!/bin/bash")]),t._v(" use a bash extension.")]),t._v(" "),a("p",[t._v("The signals can either be a signal number, a signal name (without the SIG prefix), or the special keyword "),a("code",[t._v("EXIT")]),t._v(".")]),t._v(" "),a("p",[t._v("Those guaranteed by POSIX are:")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Number")]),t._v(" "),a("th",[t._v("Name")]),t._v(" "),a("th",[t._v("Notes")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("0")]),t._v(" "),a("td",[t._v("EXIT")]),t._v(" "),a("td",[t._v("Always run on shell exit, regardless of exit code")])]),t._v(" "),a("tr",[a("td",[t._v("1")]),t._v(" "),a("td",[t._v("SIGHUP")]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("2")]),t._v(" "),a("td",[t._v("SIGINT")]),t._v(" "),a("td",[t._v("This is what "),a("code",[t._v("^C")]),t._v(" sends")])]),t._v(" "),a("tr",[a("td",[t._v("3")]),t._v(" "),a("td",[t._v("SIGQUIT")]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("6")]),t._v(" "),a("td",[t._v("SIGABRT")]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("9")]),t._v(" "),a("td",[t._v("SIGKILL")]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("14")]),t._v(" "),a("td",[t._v("SIGALRM")]),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("15")]),t._v(" "),a("td",[t._v("SIGTERM")]),t._v(" "),a("td",[t._v("This is what "),a("code",[t._v("kill")]),t._v(" sends by default")])])])])])}),[],!1,null,null,null);s.default=n.exports}}]);