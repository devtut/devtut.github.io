(window.webpackJsonp=window.webpackJsonp||[]).push([[661],{1068:function(e,t,s){"use strict";s.r(t);var a=s(31),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"header-files"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#header-files"}},[e._v("#")]),e._v(" Header Files")]),e._v(" "),s("h2",{attrs:{id:"basic-example"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#basic-example"}},[e._v("#")]),e._v(" Basic Example")]),e._v(" "),s("p",[e._v("The following example will contain a block of code that is meant to be split into several source files, as denoted by "),s("code",[e._v("// filename")]),e._v(" comments.")]),e._v(" "),s("h3",{attrs:{id:"source-files"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#source-files"}},[e._v("#")]),e._v(" Source Files")]),e._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// my_function.h")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/* Note how this header contains only a declaration of a function.\n * Header functions usually do not define implementations for declarations\n * unless code must be further processed at compile time, as in templates.\n */")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/* Also, usually header files include preprocessor guards so that every header\n * is never included twice.\n *\n * The guard is implemented by checking if a header-file unique preprocessor\n * token is defined, and only including the header if it hasn't been included\n * once before.\n */")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[e._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[e._v("ifndef")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token expression"}},[e._v("MY_FUNCTION_H")])]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[e._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[e._v("define")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token macro-name"}},[e._v("MY_FUNCTION_H")])]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// global_value and my_function() will be")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// recognized as the same constructs if this header is included by different files.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" global_value "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("42")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("my_function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[e._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[e._v("endif")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// MY_FUNCTION_H")])]),e._v("\n\n")])])]),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// my_function.cpp")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/* Note how the corresponding source file for the header includes the interface  \n * defined in the header so that the compiler is aware of what the source file is \n * implementing.\n *\n * In this case, the source file requires knowledge of the global constant\n * global_value only defined in my_function.h. Without inclusion of the header\n * file, this source file would not compile.\n */")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[e._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[e._v("include")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"my_function.h"')]),e._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v('// or #include "my_function.hpp"')])]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("my_function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" global_value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// return 42;")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n")])])]),s("p",[e._v("Header files are then included by other source files that want to use the functionality defined by the header interface, but don't require knowledge of its implementation (thus, reducing code coupling). The following program makes use of the header "),s("code",[e._v("my_function.h")]),e._v(" as defined above:")]),e._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// main.cpp")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[e._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[e._v("include")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("<iostream>")]),e._v("       "),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// A C++ Standard Library header.")])]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[e._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[e._v("include")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"my_function.h"')]),e._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// A personal header")])]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" argc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("char")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("*")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("*")]),e._v(" argv"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  std"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[e._v("::")]),e._v("cout "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<<")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("my_function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<<")]),e._v(" std"),s("span",{pre:!0,attrs:{class:"token double-colon punctuation"}},[e._v("::")]),e._v("endl"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n")])])]),s("h3",{attrs:{id:"the-compilation-process"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#the-compilation-process"}},[e._v("#")]),e._v(" The Compilation Process")]),e._v(" "),s("p",[e._v("Since header files are often part of a compilation process workflow, a typical compilation process making use of the header/source file convention will usually do the following.")]),e._v(" "),s("p",[e._v("Assuming that the header file and source code file is already in the same directory, a programmer would execute the following commands:")]),e._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[e._v("g"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("++")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("-")]),e._v("c my_function"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("cpp       # Compiles the source file my_function"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("cpp\n                             # "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("--")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v(" object file my_function"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("o\n\ng"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("++")]),e._v(" main"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("cpp my_function"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("o   # Links the object file containing the \n                             "),s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[e._v("#")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[e._v("implementation")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token expression"}},[e._v("of "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("my_function")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")])])]),e._v("\n                             "),s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[e._v("#")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[e._v("to")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token expression"}},[e._v("the compiled"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" object version of main"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("cpp")])]),e._v("\n                             "),s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[e._v("#")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[e._v("and")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token expression"}},[e._v("then produces the "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("final")]),e._v(" executable a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("out")])]),e._v("\n\n")])])]),s("p",[e._v("Alternatively, if one wishes to compile "),s("code",[e._v("main.cpp")]),e._v(" to an object file first, and\nthen link only object files together as the final step:")]),e._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[e._v("g"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("++")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("-")]),e._v("c my_function"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("cpp\ng"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("++")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("-")]),e._v("c main"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("cpp\n\ng"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("++")]),e._v(" main"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("o my_function"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("o\n\n")])])]),s("h2",{attrs:{id:"templates-in-header-files"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#templates-in-header-files"}},[e._v("#")]),e._v(" Templates in Header Files")]),e._v(" "),s("p",[e._v("Templates require compile-time generation of code: a templated function, for example, will be effectively turned into multiple distinct functions once a templated function is parameterized by use in source code.")]),e._v(" "),s("p",[e._v("This means that template function, member function, and class definitions cannot be delegated to a separate source code file, as any code that will use any templated construct requires knowledge of its definition to generally generate any derivative code.")]),e._v(" "),s("p",[e._v("Thus, templated code, if put in headers, must also contain its definition. An example of this is below:")]),e._v(" "),s("div",{staticClass:"language-cpp extra-class"},[s("pre",{pre:!0,attrs:{class:"language-cpp"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// templated_function.h")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("template")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("typename")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("T")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("\nT"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("*")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("null_T_pointer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  T"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("*")]),e._v(" type_point "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token constant"}},[e._v("NULL")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// or, alternatively, nullptr instead of NULL")]),e._v("\n                        "),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// for C++11 or later")]),e._v("\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" type_point"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v(" \n\n")])])]),s("h4",{attrs:{id:"remarks"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#remarks"}},[e._v("#")]),e._v(" Remarks")]),e._v(" "),s("p",[e._v("In C++, as in C, the C++ compiler and compilation process makes use of the C preprocessor. As specified by the GNU C Preprocessor manual, a header file is defined as the following:")]),e._v(" "),s("blockquote"),e._v(" "),s("p",[e._v("A header file is a file containing C declarations and macro\ndefinitions (see Macros) to be shared between several source files.\nYou request the use of a header file in your program by including it,\nwith the C preprocessing directive ‘#include’.")]),e._v("\nHeader files serve two purposes.\n"),s("ul",[s("li",[e._v("System header files declare the interfaces to parts of the operating system. You include them in your program to supply the\ndefinitions and declarations you need to invoke system calls and\nlibraries.")]),e._v(" "),s("li",[e._v("Your own header files contain declarations for interfaces between the source files of your program. Each time you have a group of\nrelated declarations and macro definitions all or most of which are\nneeded in several different source files, it is a good idea to create\na header file for them.")])]),e._v(" "),s("p",[e._v("However, to the C preprocessor itself, a header file is no different than a source file.")]),e._v(" "),s("p",[e._v("The header/source file organization scheme is simply a strongly-held and standard convention set by various software projects in order to provide separation between interface and implementation.")]),e._v(" "),s("p",[e._v("Although it is not formally enforced by the C++ Standard itself, following the header/source file convention is highly recommended, and, in practice, is already almost ubiquitous.")]),e._v(" "),s("p",[e._v("Note that header files may be replaced as a project file structure convention by the upcoming feature of modules, which is still to be considered for inclusion in a future C++ Standard as of the time of writing (e.g. C++20).")])])}),[],!1,null,null,null);t.default=n.exports}}]);