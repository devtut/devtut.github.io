<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Algorithm - Bellman–Ford Algorithm</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="description" content="Single Source Shortest Path Algorithm (Given there is a negative cycle in a graph), Detecting Negative Cycle in a Graph, Why do we need to relax all the edges at most (V-1) times">
    <meta property="og:site_name" content="DevTut">
    <meta property="og:title" content="Algorithm - Bellman–Ford Algorithm">
    <meta property="og:description" content="Single Source Shortest Path Algorithm (Given there is a negative cycle in a graph), Detecting Negative Cycle in a Graph, Why do we need to relax all the edges at most (V-1) times">
    <meta property="og:type" content="article">
    <meta property="og:url" content="/algorithm/bellman-ford-algorithm.html">
    <meta property="og:image" content="/logo.png">
    <meta name="twitter:title" content="Algorithm - Bellman–Ford Algorithm">
    <meta name="twitter:description" content="Single Source Shortest Path Algorithm (Given there is a negative cycle in a graph), Detecting Negative Cycle in a Graph, Why do we need to relax all the edges at most (V-1) times">
    <meta name="twitter:url" content="/algorithm/bellman-ford-algorithm.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="/logo.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/mstile-150x150.png">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="google-site-verification" content="76_rKXgwMVIjd-axJC_1zPV9OS4mEjvtgjYOWVkAdnQ">
    
    <link rel="preload" href="/assets/css/0.styles.60619e34.css" as="style"><link rel="preload" href="/assets/js/app.1779e102.js" as="script"><link rel="preload" href="/assets/js/3.2cfa8016.js" as="script"><link rel="preload" href="/assets/js/17.c36c9768.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.60619e34.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">DevTut</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Algorithm</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/algorithm/" aria-current="page" class="sidebar-link">Disclaimer</a></li><li><a href="/algorithm/getting-started-with-algorithm.html" class="sidebar-link">Getting started with algorithm</a></li><li><a href="/algorithm/algorithm-complexity.html" class="sidebar-link">Algorithm Complexity</a></li><li><a href="/algorithm/big-o-notation.html" class="sidebar-link">Big-O Notation</a></li><li><a href="/algorithm/trees.html" class="sidebar-link">Trees</a></li><li><a href="/algorithm/binary-search-trees.html" class="sidebar-link">Binary Search Trees</a></li><li><a href="/algorithm/check-if-a-tree-is-bst-or-not.html" class="sidebar-link">Check if a tree is BST or not</a></li><li><a href="/algorithm/binary-tree-traversals.html" class="sidebar-link">Binary Tree traversals</a></li><li><a href="/algorithm/lowest-common-ancestor-of-a-binary-tree.html" class="sidebar-link">Lowest common ancestor of a Binary Tree</a></li><li><a href="/algorithm/graph.html" class="sidebar-link">Graph</a></li><li><a href="/algorithm/graph-traversals.html" class="sidebar-link">Graph Traversals</a></li><li><a href="/algorithm/dijkstras-algorithm.html" class="sidebar-link">Dijkstra’s Algorithm</a></li><li><a href="/algorithm/a-pathfinding.html" class="sidebar-link">A* Pathfinding</a></li><li><a href="/algorithm/a-pathfinding-algorithm.html" class="sidebar-link">A* Pathfinding Algorithm</a></li><li><a href="/algorithm/dynamic-programming.html" class="sidebar-link">Dynamic Programming</a></li><li><a href="/algorithm/applications-of-dynamic-programming.html" class="sidebar-link">Applications of Dynamic Programming</a></li><li><a href="/algorithm/kruskal-s-algorithm.html" class="sidebar-link">Kruskal's Algorithm</a></li><li><a href="/algorithm/greedy-algorithms.html" class="sidebar-link">Greedy Algorithms</a></li><li><a href="/algorithm/applications-of-greedy-technique.html" class="sidebar-link">Applications of Greedy technique</a></li><li><a href="/algorithm/prim-s-algorithm.html" class="sidebar-link">Prim's Algorithm</a></li><li><a href="/algorithm/bellman-ford-algorithm.html" aria-current="page" class="active sidebar-link">Bellman–Ford Algorithm</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/algorithm/bellman-ford-algorithm.html#single-source-shortest-path-algorithm-given-there-is-a-negative-cycle-in-a-graph" class="sidebar-link">Single Source Shortest Path Algorithm (Given there is a negative cycle in a graph)</a></li><li class="sidebar-sub-header"><a href="/algorithm/bellman-ford-algorithm.html#detecting-negative-cycle-in-a-graph" class="sidebar-link">Detecting Negative Cycle in a Graph</a></li><li class="sidebar-sub-header"><a href="/algorithm/bellman-ford-algorithm.html#why-do-we-need-to-relax-all-the-edges-at-most-v-1-times" class="sidebar-link">Why do we need to relax all the edges at most (V-1) times</a></li></ul></li><li><a href="/algorithm/line-algorithm.html" class="sidebar-link">Line Algorithm</a></li><li><a href="/algorithm/floyd-warshall-algorithm.html" class="sidebar-link">Floyd-Warshall Algorithm</a></li><li><a href="/algorithm/catalan-number-algorithm.html" class="sidebar-link">Catalan Number Algorithm</a></li><li><a href="/algorithm/multithreaded-algorithms.html" class="sidebar-link">Multithreaded Algorithms</a></li><li><a href="/algorithm/knuth-morris-pratt-kmp-algorithm.html" class="sidebar-link">Knuth Morris Pratt (KMP) Algorithm</a></li><li><a href="/algorithm/edit-distance-dynamic-algorithm.html" class="sidebar-link">Edit Distance Dynamic Algorithm</a></li><li><a href="/algorithm/online-algorithms.html" class="sidebar-link">Online algorithms</a></li><li><a href="/algorithm/integer-partition-algorithm.html" class="sidebar-link">Integer Partition Algorithm</a></li><li><a href="/algorithm/maximum-path-sum-algorithm.html" class="sidebar-link">Maximum Path Sum Algorithm</a></li><li><a href="/algorithm/maximum-subarray-algorithm.html" class="sidebar-link">Maximum Subarray Algorithm</a></li><li><a href="/algorithm/sliding-window-algorithm.html" class="sidebar-link">Sliding Window Algorithm</a></li><li><a href="/algorithm/sorting.html" class="sidebar-link">Sorting</a></li><li><a href="/algorithm/bubble-sort.html" class="sidebar-link">Bubble Sort</a></li><li><a href="/algorithm/merge-sort.html" class="sidebar-link">Merge Sort</a></li><li><a href="/algorithm/insertion-sort.html" class="sidebar-link">Insertion Sort</a></li><li><a href="/algorithm/bucket-sort.html" class="sidebar-link">Bucket Sort</a></li><li><a href="/algorithm/quicksort.html" class="sidebar-link">Quicksort</a></li><li><a href="/algorithm/counting-sort.html" class="sidebar-link">Counting Sort</a></li><li><a href="/algorithm/heap-sort.html" class="sidebar-link">Heap Sort</a></li><li><a href="/algorithm/cycle-sort.html" class="sidebar-link">Cycle Sort</a></li><li><a href="/algorithm/odd-even-sort.html" class="sidebar-link">Odd-Even Sort</a></li><li><a href="/algorithm/selection-sort.html" class="sidebar-link">Selection Sort</a></li><li><a href="/algorithm/pigeonhole-sort.html" class="sidebar-link">Pigeonhole Sort</a></li><li><a href="/algorithm/radix-sort.html" class="sidebar-link">Radix Sort</a></li><li><a href="/algorithm/shell-sort.html" class="sidebar-link">Shell Sort</a></li><li><a href="/algorithm/pancake-sort.html" class="sidebar-link">Pancake Sort</a></li><li><a href="/algorithm/searching.html" class="sidebar-link">Searching</a></li><li><a href="/algorithm/substring-search.html" class="sidebar-link">Substring Search</a></li><li><a href="/algorithm/breadth-first-search.html" class="sidebar-link">Breadth-First Search</a></li><li><a href="/algorithm/depth-first-search.html" class="sidebar-link">Depth First Search</a></li><li><a href="/algorithm/hash-functions.html" class="sidebar-link">Hash Functions</a></li><li><a href="/algorithm/travelling-salesman.html" class="sidebar-link">Travelling Salesman</a></li><li><a href="/algorithm/shortest-common-supersequence-problem.html" class="sidebar-link">Shortest Common Supersequence Problem</a></li><li><a href="/algorithm/knapsack-problem.html" class="sidebar-link">Knapsack Problem</a></li><li><a href="/algorithm/equation-solving.html" class="sidebar-link">Equation Solving</a></li><li><a href="/algorithm/longest-common-subsequence.html" class="sidebar-link">Longest Common Subsequence</a></li><li><a href="/algorithm/longest-increasing-subsequence.html" class="sidebar-link">Longest Increasing Subsequence</a></li><li><a href="/algorithm/check-two-strings-are-anagrams.html" class="sidebar-link">Check two strings are anagrams</a></li><li><a href="/algorithm/pascal-s-triangle.html" class="sidebar-link">Pascal's Triangle</a></li><li><a href="/algorithm/algo-print-a-m-n-matrix-in-square-wise.html" class="sidebar-link">Algo:- Print a m*n matrix in square wise</a></li><li><a href="/algorithm/matrix-exponentiation.html" class="sidebar-link">Matrix Exponentiation</a></li><li><a href="/algorithm/polynomial-time-bounded-algorithm-for-minimum-vertex-cover.html" class="sidebar-link">polynomial-time bounded algorithm for Minimum Vertex Cover</a></li><li><a href="/algorithm/dynamic-time-warping.html" class="sidebar-link">Dynamic Time Warping</a></li><li><a href="/algorithm/fast-fourier-transform.html" class="sidebar-link">Fast Fourier Transform</a></li><li><a href="/algorithm/pseudocode.html" class="sidebar-link">Pseudocode</a></li><li><a href="/algorithm/contributors.html" class="sidebar-link">The Contributors</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="bellman-ford-algorithm"><a href="#bellman-ford-algorithm" class="header-anchor">#</a> Bellman–Ford Algorithm</h1> <h2 id="single-source-shortest-path-algorithm-given-there-is-a-negative-cycle-in-a-graph"><a href="#single-source-shortest-path-algorithm-given-there-is-a-negative-cycle-in-a-graph" class="header-anchor">#</a> Single Source Shortest Path Algorithm (Given there is a negative cycle in a graph)</h2> <p><strong>Before reading this example, it is required to have a brief idea on edge-relaxation. You can learn it from <a href="http://stackoverflow.com/documentation/algorithm/7151/dijkstra-s-algorithm#t=201610020826272688942" target="_blank" rel="noopener noreferrer">here<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></strong></p> <p><a href="https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm" target="_blank" rel="noopener noreferrer">Bellman-Ford<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> Algorithm is computes the shortest paths from a single source vertex to all of the other vertices in a weighted digraph. Even though it is slower than <a href="http://stackoverflow.com/documentation/algorithm/7151/dijkstra-s-algorithm#t=201610020826272688942" target="_blank" rel="noopener noreferrer">Dijkstra's Algorithm<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, it works in the cases when the weight of the edge is negative and it also finds negative weight cycle in the graph. The problem with Dijkstra's Algorithm is, if there's a negative cycle, you keep going through the cycle again and again and keep reducing the distance between two vertices.</p> <p>The idea of this algorithm is to go through all the edges of this graph one-by-one in some random order. It can be any random order. But you must ensure, if <strong>u-v</strong> (where <strong>u</strong> and <strong>v</strong> are two vertices in a graph) is one of your orders, then there must be an edge from <strong>u</strong> to <strong>v</strong>. Usually it is taken directly from the order of the input given. Again, any random order will work.</p> <p>After selecting the order, we will <strong>relax</strong> the edges according to the relaxation formula. For a given edge <strong>u-v</strong> going from <strong>u</strong> to <strong>v</strong> the relaxation formula is:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">if</span> distance<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> cost<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&lt;</span> d<span class="token punctuation">[</span>v<span class="token punctuation">]</span>
    d<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> d<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> cost<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span>

</code></pre></div><p>That is, if the distance from <strong>source</strong> to any vertex <strong>u</strong> + the weight of the <strong>edge u-v</strong> is less than the distance from <strong>source</strong> to another vertex <strong>v</strong>, we update the distance from <strong>source</strong> to <strong>v</strong>. We need to <strong>relax</strong> the edges at most <strong>(V-1)</strong> times where <strong>V</strong> is the number of edges in the graph. Why <strong>(V-1)</strong> you ask? We'll explain it in another example. Also we are going to keep track of the parent vertex of any vertex, that is when we relax an edge, we will set:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>parent<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">=</span> u

</code></pre></div><p>It means we've found another shorter path to reach <strong>v</strong> via <strong>u</strong>. We will need this later to print the shortest path from <strong>source</strong> to the destined vertex.</p> <p>Let's look at an example. We have a graph:<a href="https://i.stack.imgur.com/qIriI.png" target="_blank" rel="noopener noreferrer"><img src="https://i.stack.imgur.com/qIriI.png" alt="Example Graph"><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>We have selected <strong>1</strong> as the <strong>source</strong> vertex. We want to find out the shortest path from the <strong>source</strong> to all other vertices.</p> <p>At first, <strong>d[1] = 0</strong> because it is the source. And rest are <strong>infinity</strong>, because we don't know their distance yet.</p> <p>We will relax the edges in this sequence:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>
<span class="token operator">|</span> Serial <span class="token operator">|</span>    <span class="token number">1</span>   <span class="token operator">|</span>    <span class="token number">2</span>   <span class="token operator">|</span>    <span class="token number">3</span>   <span class="token operator">|</span>    <span class="token number">4</span>   <span class="token operator">|</span>    <span class="token number">5</span>   <span class="token operator">|</span>    <span class="token number">6</span>   <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>
<span class="token operator">|</span>  Edge  <span class="token operator">|</span>  <span class="token number">4</span><span class="token operator">-&gt;</span><span class="token number">5</span>  <span class="token operator">|</span>  <span class="token number">3</span><span class="token operator">-&gt;</span><span class="token number">4</span>  <span class="token operator">|</span>  <span class="token number">1</span><span class="token operator">-&gt;</span><span class="token number">3</span>  <span class="token operator">|</span>  <span class="token number">1</span><span class="token operator">-&gt;</span><span class="token number">4</span>  <span class="token operator">|</span>  <span class="token number">4</span><span class="token operator">-&gt;</span><span class="token number">6</span>  <span class="token operator">|</span>  <span class="token number">2</span><span class="token operator">-&gt;</span><span class="token number">3</span>  <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>

</code></pre></div><p>You can take any sequence you want. If we <strong>relax</strong> the edges once, what do we get? We get the distance from <strong>source</strong> to all other vertices of the path that uses at most 1 edge. Now let's relax the edges and update the values of <strong>d[]</strong>. We get:</p> <ol><li><strong>d[4]</strong> + <strong>cost[4][5]</strong> = <strong>infinity</strong> + <strong>7</strong> = <strong>infinity</strong>. We can't update this one.</li> <li><strong>d[2]</strong> + <strong>cost[3][4]</strong> = <strong>infinity</strong>. We can't update this one.</li> <li><strong>d[1]</strong> + <strong>cost[1][2]</strong> = <strong>0</strong> + <strong>2</strong> = <strong>2</strong> &lt; <strong>d[2]</strong>. So <strong>d[2]</strong> = <strong>2</strong>. Also <strong>parent[2] = 1</strong>.</li> <li><strong>d[1]</strong> + <strong>cost[1][4]</strong> = <strong>4</strong>. So <strong>d[4] = 4</strong> &lt; <strong>d[4]</strong>. <strong>parent[4]</strong> = <strong>1</strong>.</li> <li><strong>d[4]</strong> + <strong>cost[4][6]</strong> = <strong>9</strong>. <strong>d[6]</strong> = <strong>9</strong> &lt; <strong>d[6]</strong>. <strong>parent[6]</strong> = <strong>4</strong>.</li> <li><strong>d[2]</strong> + <strong>cost[2][2]</strong> = <strong>infinity</strong>. We can't update this one.</li></ol> <p>We couldn't update some vertices, because the <code>d[u] + cost[u][v] &lt; d[v]</code> condition didn't match. As we have said before, we found the paths from <strong>source</strong> to other nodes using maximum 1 edge. <a href="https://i.stack.imgur.com/Pkhx2.png" target="_blank" rel="noopener noreferrer"><img src="https://i.stack.imgur.com/Pkhx2.png" alt="After First Iteration"><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>Our second iteration will provide us with the path using 2 nodes. We get:</p> <ol><li><strong>d[4]</strong> + <strong>cost[4][5]</strong> = <strong>12</strong> &lt; <strong>d[5]</strong>. <strong>d[5]</strong> = <strong>12</strong>. <strong>parent[5]</strong> = <strong>4</strong>.</li> <li><strong>d[3]</strong> + <strong>cost[3][4]</strong> = <strong>1</strong> &lt; <strong>d[4]</strong>. <strong>d[4]</strong> = <strong>1</strong>. <strong>parent[4]</strong> = <strong>3</strong>.</li> <li><strong>d[3]</strong> remains unchanged.</li> <li><strong>d[4]</strong> remains unchanged.</li> <li><strong>d[4]</strong> + <strong>cost[4][6]</strong> = <strong>6</strong> &lt; <strong>d[6]</strong>. <strong>d[6]</strong> = <strong>6</strong>. <strong>parent[6]</strong> = <strong>4</strong>.</li> <li><strong>d[3]</strong> remains unchanged.</li></ol> <p>Our graph will look like: <a href="https://i.stack.imgur.com/hX168.png" target="_blank" rel="noopener noreferrer"><img src="https://i.stack.imgur.com/hX168.png" alt="After second iteration"><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>Our 3rd iteration will only update <strong>vertex 5</strong>, where <strong>d[5]</strong> will be <strong>8</strong>. Our graph will look like: <a href="https://i.stack.imgur.com/CUtPh.png" target="_blank" rel="noopener noreferrer"><img src="https://i.stack.imgur.com/CUtPh.png" alt="After third iteration"><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>After this no matter how many iterations we do, we'll have the same distances. So we will keep a flag that checks if any update takes place or not. If it doesn't, we'll simply break the loop. Our pseudo-code will be:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>Procedure Bellman<span class="token operator">-</span><span class="token function">Ford</span><span class="token punctuation">(</span>Graph<span class="token punctuation">,</span> source<span class="token punctuation">)</span><span class="token operator">:</span>
n <span class="token operator">:</span><span class="token operator">=</span> number of vertices in Graph
<span class="token keyword">for</span> i from <span class="token number">1</span> to n
    d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">:</span><span class="token operator">=</span> infinity
    parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token constant">NULL</span>
end <span class="token keyword">for</span>
d<span class="token punctuation">[</span>source<span class="token punctuation">]</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">for</span> i from <span class="token number">1</span> to n<span class="token operator">-</span><span class="token number">1</span>
    flag <span class="token operator">:</span><span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token keyword">for</span> all edges <span class="token function">from</span> <span class="token punctuation">(</span>u<span class="token punctuation">,</span>v<span class="token punctuation">)</span> in Graph
        <span class="token keyword">if</span> d<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> cost<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&lt;</span> d<span class="token punctuation">[</span>v<span class="token punctuation">]</span>
            d<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">:</span><span class="token operator">=</span> d<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> cost<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span>
            parent<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">:</span><span class="token operator">=</span> u
            flag <span class="token operator">:</span><span class="token operator">=</span> <span class="token boolean">true</span>
        end <span class="token keyword">if</span>
    end <span class="token keyword">for</span>
    <span class="token keyword">if</span> flag <span class="token operator">==</span> <span class="token boolean">false</span>
        <span class="token keyword">break</span>
end <span class="token keyword">for</span>
Return d

</code></pre></div><p>To keep track of negative cycle, we can modify our code using the procedure described <a href="http://stackoverflow.com/documentation/algorithm/4791/bellman-ford-algorithm/24034/detecting-negative-cycle-in-a-graph" target="_blank" rel="noopener noreferrer">here<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>. Our completed pseudo-code will be:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>Procedure Bellman<span class="token operator">-</span>Ford<span class="token operator">-</span>With<span class="token operator">-</span>Negative<span class="token operator">-</span>Cycle<span class="token operator">-</span><span class="token function">Detection</span><span class="token punctuation">(</span>Graph<span class="token punctuation">,</span> source<span class="token punctuation">)</span><span class="token operator">:</span>
n <span class="token operator">:</span><span class="token operator">=</span> number of vertices in Graph
<span class="token keyword">for</span> i from <span class="token number">1</span> to n
    d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">:</span><span class="token operator">=</span> infinity
    parent<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token constant">NULL</span>
end <span class="token keyword">for</span>
d<span class="token punctuation">[</span>source<span class="token punctuation">]</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">for</span> i from <span class="token number">1</span> to n<span class="token operator">-</span><span class="token number">1</span>
    flag <span class="token operator">:</span><span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token keyword">for</span> all edges <span class="token function">from</span> <span class="token punctuation">(</span>u<span class="token punctuation">,</span>v<span class="token punctuation">)</span> in Graph
        <span class="token keyword">if</span> d<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> cost<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&lt;</span> d<span class="token punctuation">[</span>v<span class="token punctuation">]</span>
            d<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">:</span><span class="token operator">=</span> d<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> cost<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span>
            parent<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">:</span><span class="token operator">=</span> u
            flag <span class="token operator">:</span><span class="token operator">=</span> <span class="token boolean">true</span>
        end <span class="token keyword">if</span>
    end <span class="token keyword">for</span>
    <span class="token keyword">if</span> flag <span class="token operator">==</span> <span class="token boolean">false</span>
        <span class="token keyword">break</span>
end <span class="token keyword">for</span>
<span class="token keyword">for</span> all edges <span class="token function">from</span> <span class="token punctuation">(</span>u<span class="token punctuation">,</span>v<span class="token punctuation">)</span> in Graph
    <span class="token keyword">if</span> d<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> cost<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&lt;</span> d<span class="token punctuation">[</span>v<span class="token punctuation">]</span>
        Return <span class="token string">&quot;Negative Cycle Detected&quot;</span>
    end <span class="token keyword">if</span>
end <span class="token keyword">for</span>
Return d

</code></pre></div><p><strong>Printing Path:</strong></p> <p>To print the shortest path to a vertex, we'll iterate back to its parent until we find <strong>NULL</strong> and then print the vertices. The pseudo-code will be:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>Procedure <span class="token function">PathPrinting</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span>
v <span class="token operator">:</span><span class="token operator">=</span> parent<span class="token punctuation">[</span>u<span class="token punctuation">]</span>
<span class="token keyword">if</span> v <span class="token operator">==</span> <span class="token constant">NULL</span>
    <span class="token keyword">return</span>
<span class="token function">PathPrinting</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
print <span class="token operator">-&gt;</span> u

</code></pre></div><p><strong>Complexity:</strong></p> <p>Since we need to relax the edges maximum <strong>(V-1)</strong> times, the time complexity of this algorithm will be equal to <strong>O(V * E)</strong> where <strong>E</strong> denotes the number of edges, if we use <code>adjacency list</code> to represent the graph. However, if <code>adjacency matrix</code> is used to represent the graph, time complexity will be <strong>O(V^3)</strong>. Reason is we can iterate through all edges in <strong>O(E)</strong> time when <code>adjacency list</code> is used, but it takes <strong>O(V^2)</strong> time when <code>adjacency matrix</code> is used.</p> <h2 id="detecting-negative-cycle-in-a-graph"><a href="#detecting-negative-cycle-in-a-graph" class="header-anchor">#</a> Detecting Negative Cycle in a Graph</h2> <p><strong>To understand this example, it is recommended to have a brief idea about Bellman-Ford algorithm which can be found <a href="http://stackoverflow.com/documentation/algorithm/4791/bellman-ford-algorithm/24021/single-source-shortest-path-algorithm-given-there-is-a-negative-cycle-in-a-grap" target="_blank" rel="noopener noreferrer">here<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></strong></p> <p>Using Bellman-Ford algorithm, we can detect if there is a negative cycle in our graph. We know that, to find out the shortest path, we need to <strong>relax</strong> all the edges of the graph <strong>(V-1)</strong> times, where <strong>V</strong> is the number of vertices in a graph. We have already seen that in this <a href="http://stackoverflow.com/documentation/algorithm/4791/bellman-ford-algorithm/24029/why-do-we-need-to-relax-all-the-edges-at-most-v-1-times" target="_blank" rel="noopener noreferrer">example<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, after <strong>(V-1)</strong> iterations, we can't update <strong>d[]</strong>, no matter how many iterations we do. Or can we?</p> <p>If there is a negative cycle in a graph, even after <strong>(V-1)</strong> iterations, we can update <strong>d[]</strong>. This happens because for every iteration, traversing through the negative cycle always decreases the cost of the shortest path. This is why Bellman-Ford algorithm limits the number of iterations to <strong>(V-1)</strong>. If we used <a href="http://stackoverflow.com/documentation/algorithm/7151/dijkstra-s-algorithm/23947/dijkstras-shortest-path-algorithm#t=20161002124031483303" target="_blank" rel="noopener noreferrer">Dijkstra's Algorithm<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> here, we'd be stuck in an endless loop. However, let's concentrate on finding negative cycle.</p> <p>Let's assume, we have a graph:</p> <p><a href="http://i.stack.imgur.com/AMKuZ.png" target="_blank" rel="noopener noreferrer"><img src="http://i.stack.imgur.com/AMKuZ.png" alt="Example Graph"><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>Let's pick <strong>vertex 1</strong> as the <strong>source</strong>. After applying Bellman-Ford's single source shortest path algorithm to the graph, we'll find out the distances from the <strong>source</strong> to all the other vertices.</p> <p><a href="http://i.stack.imgur.com/2P5k7.png" target="_blank" rel="noopener noreferrer"><img src="http://i.stack.imgur.com/2P5k7.png" alt="After Applying Bellman Ford"><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>This is how the graph looks like after <strong>(V-1)</strong> = <strong>3</strong> iterations. It should be the result since there are <strong>4</strong> edges, we need at most <strong>3</strong> iterations to find out the shortest path. So either this is the answer, or there is a negative weight cycle in the graph. To find that, after <strong>(V-1)</strong> iterations, we do one more final iteration and if the distance continues to decrease, it means that there is definitely a negative weight cycle in the graph.</p> <p>For this example: if we check <strong>2-3</strong>, <strong>d[2]</strong> + <strong>cost[2][3]</strong> will give us <strong>1</strong> which is less than <strong>d[3]</strong>. So we can conclude that there is a negative cycle in our graph.</p> <p>So how do we find out the negative cycle? We do a bit modification to Bellman-Ford procedure:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>Procedure <span class="token function">NegativeCycleDetector</span><span class="token punctuation">(</span>Graph<span class="token punctuation">,</span> source<span class="token punctuation">)</span><span class="token operator">:</span>
n <span class="token operator">:</span><span class="token operator">=</span> number of vertices in Graph
<span class="token keyword">for</span> i from <span class="token number">1</span> to n
    d<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">:</span><span class="token operator">=</span> infinity
end <span class="token keyword">for</span>
d<span class="token punctuation">[</span>source<span class="token punctuation">]</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">for</span> i from <span class="token number">1</span> to n<span class="token operator">-</span><span class="token number">1</span>
    flag <span class="token operator">:</span><span class="token operator">=</span> <span class="token boolean">false</span>
    <span class="token keyword">for</span> all edges <span class="token function">from</span> <span class="token punctuation">(</span>u<span class="token punctuation">,</span>v<span class="token punctuation">)</span> in Graph
        <span class="token keyword">if</span> d<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> cost<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&lt;</span> d<span class="token punctuation">[</span>v<span class="token punctuation">]</span>
            d<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">:</span><span class="token operator">=</span> d<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> cost<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span>
            flag <span class="token operator">:</span><span class="token operator">=</span> <span class="token boolean">true</span>
        end <span class="token keyword">if</span>
    end <span class="token keyword">for</span>
    <span class="token keyword">if</span> flag <span class="token operator">==</span> <span class="token boolean">false</span>
        <span class="token keyword">break</span>
end <span class="token keyword">for</span>
<span class="token keyword">for</span> all edges <span class="token function">from</span> <span class="token punctuation">(</span>u<span class="token punctuation">,</span>v<span class="token punctuation">)</span> in Graph
    <span class="token keyword">if</span> d<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">+</span> cost<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&lt;</span> d<span class="token punctuation">[</span>v<span class="token punctuation">]</span>
        Return <span class="token string">&quot;Negative Cycle Detected&quot;</span>
    end <span class="token keyword">if</span>
end <span class="token keyword">for</span>
Return <span class="token string">&quot;No Negative Cycle&quot;</span>

</code></pre></div><p>This is how we find out if there is a negative cycle in a graph. We can also modify Bellman-Ford Algorithm to keep track of negative cycles.</p> <h2 id="why-do-we-need-to-relax-all-the-edges-at-most-v-1-times"><a href="#why-do-we-need-to-relax-all-the-edges-at-most-v-1-times" class="header-anchor">#</a> Why do we need to relax all the edges at most (V-1) times</h2> <p><strong>To understand this example, it is recommended to have a brief idea on Bellman-Ford single source shortest path algorithm which can be found <a href="http://stackoverflow.com/documentation/algorithm/4791/bellman-ford-algorithm/24021/single-source-shortest-path-algorithm-given-there-is-a-negative-cycle-in-a-grap" target="_blank" rel="noopener noreferrer">here<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></strong></p> <p>In Bellman-Ford algorithm, to find out the shortest path, we need to <strong>relax</strong> all the edges of the graph. This process is repeated at most <strong>(V-1)</strong> times, where <strong>V</strong> is the number of vertices in the graph.</p> <p>The number of iterations needed to find out the shortest path from <strong>source</strong> to all other vertices depends on the order that we select to <strong>relax</strong> the edges.</p> <p>Let's take a look at an example:</p> <p><a href="http://i.stack.imgur.com/vunss.png" target="_blank" rel="noopener noreferrer"><img src="http://i.stack.imgur.com/vunss.png" alt="Example Graph"><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>Here, the <strong>source</strong> vertex is 1. We will find out the shortest distance between the <strong>source</strong> and all the other vertices. We can clearly see that, to reach <strong>vertex 4</strong>, in the worst case, it'll take <strong>(V-1)</strong> edges. Now depending on the order in which the edges are discovered, it might take <strong>(V-1)</strong> times to discover <strong>vertex 4</strong>. Didn't get it? Let's use Bellman-Ford algorithm to find out the shortest path here:</p> <p>We're going to use this sequence:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>
<span class="token operator">|</span> Serial <span class="token operator">|</span>    <span class="token number">1</span>   <span class="token operator">|</span>    <span class="token number">2</span>   <span class="token operator">|</span>    <span class="token number">3</span>   <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>
<span class="token operator">|</span>  Edge  <span class="token operator">|</span>  <span class="token number">3</span><span class="token operator">-&gt;</span><span class="token number">4</span>  <span class="token operator">|</span>  <span class="token number">2</span><span class="token operator">-&gt;</span><span class="token number">3</span>  <span class="token operator">|</span>  <span class="token number">1</span><span class="token operator">-&gt;</span><span class="token number">2</span>  <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>

</code></pre></div><p>For our first iteration:</p> <ol><li><strong>d[3]</strong> + <strong>cost[3][4]</strong> = <strong>infinity</strong>. It won't change anything.</li> <li><strong>d[2]</strong> + <strong>cost[2][3]</strong> = <strong>infinity</strong>. It won't change anything.</li> <li><strong>d[1]</strong> + <strong>cost[1][2]</strong> = <strong>2</strong> &lt; <strong>d[2]</strong>. <strong>d[2]</strong> = <strong>2</strong>. <strong>parent[2]</strong> = <strong>1</strong>.</li></ol> <p>We can see that our <strong>relaxation</strong> process only changed <strong>d[2]</strong>. Our graph will look like: <a href="http://i.stack.imgur.com/ePGvK.png" target="_blank" rel="noopener noreferrer"><img src="http://i.stack.imgur.com/ePGvK.png" alt="After First Iteration"><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>Second iteration:</p> <ol><li><strong>d[3]</strong> + <strong>cost[3][4]</strong> = <strong>infinity</strong>. It won't change anything.</li> <li><strong>d[2]</strong> + <strong>cost[2][3]</strong> = <strong>5</strong> &lt; <strong>d[3]</strong>. <strong>d[3]</strong> = <strong>5</strong>. <strong>parent[3]</strong> = <strong>2.</strong></li> <li>It won't be changed.</li></ol> <p>This time the <strong>relaxation</strong> process changed <strong>d[3]</strong>. Our graph will look like: <a href="http://i.stack.imgur.com/jAH0f.png" target="_blank" rel="noopener noreferrer"><img src="http://i.stack.imgur.com/jAH0f.png" alt="After Second Iteration"><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>Third iteration:</p> <ol><li><strong>d[3]</strong> + <strong>cost[3][4]</strong> = <strong>7</strong> &lt; <strong>d[4]</strong>. <strong>d[4]</strong> = <strong>7</strong>. <strong>parent[4]</strong> = <strong>3</strong>.</li> <li>It won't be changed.</li> <li>It won't be changed.</li></ol> <p>Our third iteration finally found out the shortest path to <strong>4</strong> from <strong>1</strong>. Our graph will look like: <a href="http://i.stack.imgur.com/0CsqX.png" target="_blank" rel="noopener noreferrer"><img src="http://i.stack.imgur.com/0CsqX.png" alt="After Third Iteration"><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>So, it took <strong>3</strong> iterations to find out the shortest path. After this one, no matter how many times we <strong>relax</strong> the edges, the values in <strong>d[]</strong> will remain the same. Now, if we considered another sequence:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>
<span class="token operator">|</span> Serial <span class="token operator">|</span>    <span class="token number">1</span>   <span class="token operator">|</span>    <span class="token number">2</span>   <span class="token operator">|</span>    <span class="token number">3</span>   <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>
<span class="token operator">|</span>  Edge  <span class="token operator">|</span>  <span class="token number">1</span><span class="token operator">-&gt;</span><span class="token number">2</span>  <span class="token operator">|</span>  <span class="token number">2</span><span class="token operator">-&gt;</span><span class="token number">3</span>  <span class="token operator">|</span>  <span class="token number">3</span><span class="token operator">-&gt;</span><span class="token number">4</span>  <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">+</span>

</code></pre></div><p>We'd get:</p> <ol><li><strong>d[1]</strong> + <strong>cost[1][2]</strong> = <strong>2</strong> &lt; <strong>d[2]</strong>. <strong>d[2]</strong> = <strong>2</strong>.</li> <li><strong>d[2]</strong> + <strong>cost[2][3]</strong> = <strong>5</strong> &lt; <strong>d[3]</strong>. <strong>d[3]</strong> = <strong>5</strong>.</li> <li><strong>d[3]</strong> + <strong>cost[3][4]</strong> = <strong>7</strong> &lt; <strong>d[4]</strong>. <strong>d[4]</strong> = <strong>5</strong>.</li></ol> <p>Our very first iteration has found the shortest path from <strong>source</strong> to all the other nodes. Another sequence <strong>1-&gt;2</strong>, <strong>3-&gt;4</strong>, <strong>2-&gt;3</strong> is possible, which will give us shortest path after <strong>2</strong> iterations. We can come to the decision that, no matter how we arrange the sequence, it won't take more than <strong>3</strong> iterations to find out shortest path from the <strong>source</strong> in this example.</p> <p>We can conclude that, for the best case, it'll take <strong>1</strong> iteration to find out the shortest path from <strong>source</strong>. For the worst case, it'll take <strong>(V-1)</strong> iterations, which is why we repeat the process of <strong>relaxation</strong> <strong>(V-1)</strong> times.</p> <h4 id="remarks"><a href="#remarks" class="header-anchor">#</a> Remarks</h4> <p>Given a directed graph <code>G</code>, we often want to find the shortest distance from a given node <code>A</code> to rest of the nodes in the graph. <strong>Dijkstra</strong> algorithm is the most famous algorithm for finding the shortest path, however it works only if edge weights of the given graph are non-negative. <strong>Bellman-Ford</strong> however aims to find the shortest path from a given node (if one exists) even if some of the weights are negative. Note that, shortest distance may not exist if a negative cycle is present in the graph (in which case we can go around the cycle resulting in infinitely small total distance ). <strong>Bellman-Ford</strong> additionally allows us to determine the presence of such a cycle.</p> <p>Total complexity of the algorithm is <code>O(V*E)</code>, where V - is the number of vertices and <code>E</code> number of edges</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/devtut/generate/edit/master/docs/algorithm/bellman-ford-algorithm.md" target="_blank" rel="noopener noreferrer">Edit this page on GitHub</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/algorithm/prim-s-algorithm.html" class="prev">
        Prim's Algorithm
      </a></span> <span class="next"><a href="/algorithm/line-algorithm.html">
        Line Algorithm
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.1779e102.js" defer></script><script src="/assets/js/3.2cfa8016.js" defer></script><script src="/assets/js/17.c36c9768.js" defer></script>
  </body>
</html>
