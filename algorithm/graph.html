<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Algorithm - Graph</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="description" content="Storing Graphs (Adjacency Matrix), Introduction To Graph Theory, Storing Graphs (Adjacency List), Topological Sort, Thorup's algorithm, Detecting a cycle in a directed graph using Depth First Traversal">
    <meta property="og:site_name" content="DevTut">
    <meta property="og:title" content="Algorithm - Graph">
    <meta property="og:description" content="Storing Graphs (Adjacency Matrix), Introduction To Graph Theory, Storing Graphs (Adjacency List), Topological Sort, Thorup's algorithm, Detecting a cycle in a directed graph using Depth First Traversal">
    <meta property="og:type" content="article">
    <meta property="og:url" content="/algorithm/graph.html">
    <meta property="og:image" content="/logo.png">
    <meta name="twitter:title" content="Algorithm - Graph">
    <meta name="twitter:description" content="Storing Graphs (Adjacency Matrix), Introduction To Graph Theory, Storing Graphs (Adjacency List), Topological Sort, Thorup's algorithm, Detecting a cycle in a directed graph using Depth First Traversal">
    <meta name="twitter:url" content="/algorithm/graph.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="/logo.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/mstile-150x150.png">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="google-site-verification" content="76_rKXgwMVIjd-axJC_1zPV9OS4mEjvtgjYOWVkAdnQ">
    <link rel="preload" href="/assets/css/0.styles.8b877eb8.css" as="style"><link rel="preload" href="/assets/js/app.ced448ab.js" as="script"><link rel="preload" href="/assets/js/3.f1d73125.js" as="script"><link rel="preload" href="/assets/js/38.90d7c7f4.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.8b877eb8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">DevTut</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Algorithm</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/algorithm/" class="sidebar-link">Disclaimer</a></li><li><a href="/algorithm/getting-started-with-algorithm.html" class="sidebar-link">Getting started with algorithm</a></li><li><a href="/algorithm/algorithm-complexity.html" class="sidebar-link">Algorithm Complexity</a></li><li><a href="/algorithm/big-o-notation.html" class="sidebar-link">Big-O Notation</a></li><li><a href="/algorithm/trees.html" class="sidebar-link">Trees</a></li><li><a href="/algorithm/binary-search-trees.html" class="sidebar-link">Binary Search Trees</a></li><li><a href="/algorithm/check-if-a-tree-is-bst-or-not.html" class="sidebar-link">Check if a tree is BST or not</a></li><li><a href="/algorithm/binary-tree-traversals.html" class="sidebar-link">Binary Tree traversals</a></li><li><a href="/algorithm/lowest-common-ancestor-of-a-binary-tree.html" class="sidebar-link">Lowest common ancestor of a Binary Tree</a></li><li><a href="/algorithm/graph.html" class="active sidebar-link">Graph</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/algorithm/graph.html#storing-graphs-adjacency-matrix" class="sidebar-link">Storing Graphs (Adjacency Matrix)</a></li><li class="sidebar-sub-header"><a href="/algorithm/graph.html#introduction-to-graph-theory" class="sidebar-link">Introduction To Graph Theory</a></li><li class="sidebar-sub-header"><a href="/algorithm/graph.html#storing-graphs-adjacency-list" class="sidebar-link">Storing Graphs (Adjacency List)</a></li><li class="sidebar-sub-header"><a href="/algorithm/graph.html#topological-sort" class="sidebar-link">Topological Sort</a></li><li class="sidebar-sub-header"><a href="/algorithm/graph.html#thorup-s-algorithm" class="sidebar-link">Thorup's algorithm</a></li><li class="sidebar-sub-header"><a href="/algorithm/graph.html#detecting-a-cycle-in-a-directed-graph-using-depth-first-traversal" class="sidebar-link">Detecting a cycle in a directed graph using Depth First Traversal</a></li></ul></li><li><a href="/algorithm/graph-traversals.html" class="sidebar-link">Graph Traversals</a></li><li><a href="/algorithm/dijkstras-algorithm.html" class="sidebar-link">Dijkstra’s Algorithm</a></li><li><a href="/algorithm/a-pathfinding.html" class="sidebar-link">A* Pathfinding</a></li><li><a href="/algorithm/a-pathfinding-algorithm.html" class="sidebar-link">A* Pathfinding Algorithm</a></li><li><a href="/algorithm/dynamic-programming.html" class="sidebar-link">Dynamic Programming</a></li><li><a href="/algorithm/applications-of-dynamic-programming.html" class="sidebar-link">Applications of Dynamic Programming</a></li><li><a href="/algorithm/kruskal-s-algorithm.html" class="sidebar-link">Kruskal's Algorithm</a></li><li><a href="/algorithm/greedy-algorithms.html" class="sidebar-link">Greedy Algorithms</a></li><li><a href="/algorithm/applications-of-greedy-technique.html" class="sidebar-link">Applications of Greedy technique</a></li><li><a href="/algorithm/prim-s-algorithm.html" class="sidebar-link">Prim's Algorithm</a></li><li><a href="/algorithm/bellman-ford-algorithm.html" class="sidebar-link">Bellman–Ford Algorithm</a></li><li><a href="/algorithm/line-algorithm.html" class="sidebar-link">Line Algorithm</a></li><li><a href="/algorithm/floyd-warshall-algorithm.html" class="sidebar-link">Floyd-Warshall Algorithm</a></li><li><a href="/algorithm/catalan-number-algorithm.html" class="sidebar-link">Catalan Number Algorithm</a></li><li><a href="/algorithm/multithreaded-algorithms.html" class="sidebar-link">Multithreaded Algorithms</a></li><li><a href="/algorithm/knuth-morris-pratt-kmp-algorithm.html" class="sidebar-link">Knuth Morris Pratt (KMP) Algorithm</a></li><li><a href="/algorithm/edit-distance-dynamic-algorithm.html" class="sidebar-link">Edit Distance Dynamic Algorithm</a></li><li><a href="/algorithm/online-algorithms.html" class="sidebar-link">Online algorithms</a></li><li><a href="/algorithm/integer-partition-algorithm.html" class="sidebar-link">Integer Partition Algorithm</a></li><li><a href="/algorithm/maximum-path-sum-algorithm.html" class="sidebar-link">Maximum Path Sum Algorithm</a></li><li><a href="/algorithm/maximum-subarray-algorithm.html" class="sidebar-link">Maximum Subarray Algorithm</a></li><li><a href="/algorithm/sliding-window-algorithm.html" class="sidebar-link">Sliding Window Algorithm</a></li><li><a href="/algorithm/sorting.html" class="sidebar-link">Sorting</a></li><li><a href="/algorithm/bubble-sort.html" class="sidebar-link">Bubble Sort</a></li><li><a href="/algorithm/merge-sort.html" class="sidebar-link">Merge Sort</a></li><li><a href="/algorithm/insertion-sort.html" class="sidebar-link">Insertion Sort</a></li><li><a href="/algorithm/bucket-sort.html" class="sidebar-link">Bucket Sort</a></li><li><a href="/algorithm/quicksort.html" class="sidebar-link">Quicksort</a></li><li><a href="/algorithm/counting-sort.html" class="sidebar-link">Counting Sort</a></li><li><a href="/algorithm/heap-sort.html" class="sidebar-link">Heap Sort</a></li><li><a href="/algorithm/cycle-sort.html" class="sidebar-link">Cycle Sort</a></li><li><a href="/algorithm/odd-even-sort.html" class="sidebar-link">Odd-Even Sort</a></li><li><a href="/algorithm/selection-sort.html" class="sidebar-link">Selection Sort</a></li><li><a href="/algorithm/pigeonhole-sort.html" class="sidebar-link">Pigeonhole Sort</a></li><li><a href="/algorithm/radix-sort.html" class="sidebar-link">Radix Sort</a></li><li><a href="/algorithm/shell-sort.html" class="sidebar-link">Shell Sort</a></li><li><a href="/algorithm/pancake-sort.html" class="sidebar-link">Pancake Sort</a></li><li><a href="/algorithm/searching.html" class="sidebar-link">Searching</a></li><li><a href="/algorithm/substring-search.html" class="sidebar-link">Substring Search</a></li><li><a href="/algorithm/breadth-first-search.html" class="sidebar-link">Breadth-First Search</a></li><li><a href="/algorithm/depth-first-search.html" class="sidebar-link">Depth First Search</a></li><li><a href="/algorithm/hash-functions.html" class="sidebar-link">Hash Functions</a></li><li><a href="/algorithm/travelling-salesman.html" class="sidebar-link">Travelling Salesman</a></li><li><a href="/algorithm/shortest-common-supersequence-problem.html" class="sidebar-link">Shortest Common Supersequence Problem</a></li><li><a href="/algorithm/knapsack-problem.html" class="sidebar-link">Knapsack Problem</a></li><li><a href="/algorithm/equation-solving.html" class="sidebar-link">Equation Solving</a></li><li><a href="/algorithm/longest-common-subsequence.html" class="sidebar-link">Longest Common Subsequence</a></li><li><a href="/algorithm/longest-increasing-subsequence.html" class="sidebar-link">Longest Increasing Subsequence</a></li><li><a href="/algorithm/check-two-strings-are-anagrams.html" class="sidebar-link">Check two strings are anagrams</a></li><li><a href="/algorithm/pascal-s-triangle.html" class="sidebar-link">Pascal's Triangle</a></li><li><a href="/algorithm/algo-print-a-m-n-matrix-in-square-wise.html" class="sidebar-link">Algo:- Print a m*n matrix in square wise</a></li><li><a href="/algorithm/matrix-exponentiation.html" class="sidebar-link">Matrix Exponentiation</a></li><li><a href="/algorithm/polynomial-time-bounded-algorithm-for-minimum-vertex-cover.html" class="sidebar-link">polynomial-time bounded algorithm for Minimum Vertex Cover</a></li><li><a href="/algorithm/dynamic-time-warping.html" class="sidebar-link">Dynamic Time Warping</a></li><li><a href="/algorithm/fast-fourier-transform.html" class="sidebar-link">Fast Fourier Transform</a></li><li><a href="/algorithm/pseudocode.html" class="sidebar-link">Pseudocode</a></li><li><a href="/algorithm/contributors.html" class="sidebar-link">The Contributors</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="graph"><a href="#graph" class="header-anchor">#</a> Graph</h1> <p>A graph is a collection of points and lines connecting some (possibly empty) subset of them. The points of a graph are called graph vertices, &quot;nodes&quot; or simply &quot;points.&quot; Similarly, the lines connecting the vertices of a graph are called graph edges, &quot;arcs&quot; or &quot;lines.&quot;</p> <p>A graph G can be defined as a pair (V,E), where V is a set of vertices, and E is a set of edges between the vertices E ⊆ {(u,v) | u, v ∈ V}.</p> <h2 id="storing-graphs-adjacency-matrix"><a href="#storing-graphs-adjacency-matrix" class="header-anchor">#</a> Storing Graphs (Adjacency Matrix)</h2> <p>To store a graph, two methods are common:</p> <ul><li>Adjacency Matrix</li> <li>Adjacency List</li></ul> <p>An <a href="https://en.wikipedia.org/wiki/Adjacency_matrix" target="_blank" rel="noopener noreferrer">adjacency matrix<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> is a square matrix used to represent a finite graph. The elements of the matrix indicate whether pairs of vertices are adjacent or not in the graph.</p> <p>Adjacent means 'next to or adjoining something else' or to be beside something. For example, your neighbors are adjacent to you. In graph theory, if we can go to <strong>node B</strong> from <strong>node A</strong>, we can say that <strong>node B</strong> is adjacent to <strong>node A</strong>. Now we will learn about how to store which nodes are adjacent to which one via Adjacency Matrix. This means, we will represent which nodes share edge between them. Here matrix means 2D array.</p> <p><a href="https://i.stack.imgur.com/Oh7b1.jpg" target="_blank" rel="noopener noreferrer"><img src="https://i.stack.imgur.com/Oh7b1.jpg" alt="Graph and Adjacency Matrix"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>Here you can see a table beside the graph, this is our adjacency matrix. Here <strong>Matrix[i][j] = 1</strong> represents there is an edge between <strong>i</strong> and <strong>j</strong>. If there's no edge, we simply put <strong>Matrix[i][j] = 0</strong>.</p> <p>These edges can be weighted, like it can represent the distance between two cities. Then we'll put the value in <strong>Matrix[i][j]</strong> instead of putting 1.</p> <p>The graph described above is <strong>Bidirectional</strong> or <strong>Undirected</strong>, that means, if we can go to <strong>node 1</strong> from <strong>node 2</strong>, we can also go to <strong>node 2</strong> from <strong>node 1</strong>. If the graph was <strong>Directed</strong>, then there would've been arrow sign on one side of the graph. Even then, we could represent it using adjacency matrix.</p> <p><a href="https://i.stack.imgur.com/MBM3s.jpg" target="_blank" rel="noopener noreferrer"><img src="https://i.stack.imgur.com/MBM3s.jpg" alt="Adjacency Matrix of Directed Weighted Graph"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>We represent the nodes that don't share edge by <strong>infinity</strong>. One thing to be noticed is that, if the graph is undirected, the matrix becomes <strong>symmetric</strong>.</p> <p>The pseudo-code to create the matrix:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>Procedure <span class="token function">AdjacencyMatrix</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token operator">:</span>    <span class="token comment">//N represents the number of nodes</span>
Matrix<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span>
<span class="token keyword">for</span> i from <span class="token number">1</span> to N
    <span class="token keyword">for</span> j from <span class="token number">1</span> to N
        Take input <span class="token operator">-&gt;</span> Matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
    endfor
endfor

</code></pre></div><p>We can also populate the Matrix using this common way:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>Procedure <span class="token function">AdjacencyMatrix</span><span class="token punctuation">(</span>N<span class="token punctuation">,</span> E<span class="token punctuation">)</span><span class="token operator">:</span>    <span class="token comment">// N -&gt; number of nodes</span>
Matrix<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">[</span>E<span class="token punctuation">]</span>                        <span class="token comment">// E -&gt; number of edges</span>
<span class="token keyword">for</span> i from <span class="token number">1</span> to E
    input <span class="token operator">-&gt;</span> n1<span class="token punctuation">,</span> n2<span class="token punctuation">,</span> cost
    Matrix<span class="token punctuation">[</span>n1<span class="token punctuation">]</span><span class="token punctuation">[</span>n2<span class="token punctuation">]</span> <span class="token operator">=</span> cost
    Matrix<span class="token punctuation">[</span>n2<span class="token punctuation">]</span><span class="token punctuation">[</span>n1<span class="token punctuation">]</span> <span class="token operator">=</span> cost
endfor

</code></pre></div><p>For directed graphs, we can remove <strong>Matrix[n2][n1] = cost</strong> line.</p> <p><strong>The drawbacks of using Adjacency Matrix:</strong></p> <p>Memory is a huge problem. No matter how many edges are there, we will always need N * N sized matrix where N is the number of nodes. If there are 10000 nodes, the matrix size will be 4 * 10000 * 10000 around 381 megabytes. This is a huge waste of memory if we consider
graphs that have a few edges.</p> <p>Suppose we want to find out to which node we can go from a node <strong>u</strong>. We'll need to check the whole row of <strong>u</strong>, which costs a lot of time.</p> <p>The only benefit is that, we can easily find the connection between <strong>u-v</strong> nodes, and their cost using Adjacency Matrix.</p> <p>Java code implemented using above pseudo-code:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>import java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Scanner<span class="token punctuation">;</span>
 
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Represent_Graph_Adjacency_Matrix</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">private</span> final <span class="token keyword">int</span> vertices<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> adjacency_matrix<span class="token punctuation">;</span>
 
    <span class="token keyword">public</span> <span class="token function">Represent_Graph_Adjacency_Matrix</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        vertices <span class="token operator">=</span> v<span class="token punctuation">;</span>
        adjacency_matrix <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>vertices <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>vertices <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">makeEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> to<span class="token punctuation">,</span> <span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> edge<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">try</span> 
        <span class="token punctuation">{</span>
            adjacency_matrix<span class="token punctuation">[</span>to<span class="token punctuation">]</span><span class="token punctuation">[</span>from<span class="token punctuation">]</span> <span class="token operator">=</span> edge<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">catch</span> <span class="token punctuation">(</span>ArrayIndexOutOfBoundsException index<span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;The vertices does not exists&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getEdge</span><span class="token punctuation">(</span><span class="token keyword">int</span> to<span class="token punctuation">,</span> <span class="token keyword">int</span> from<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">try</span> 
        <span class="token punctuation">{</span>
            <span class="token keyword">return</span> adjacency_matrix<span class="token punctuation">[</span>to<span class="token punctuation">]</span><span class="token punctuation">[</span>from<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">catch</span> <span class="token punctuation">(</span>ArrayIndexOutOfBoundsException index<span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;The vertices does not exists&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> v<span class="token punctuation">,</span> e<span class="token punctuation">,</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> to <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> from <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        Scanner sc <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Represent_Graph_Adjacency_Matrix graph<span class="token punctuation">;</span>
        <span class="token keyword">try</span> 
        <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Enter the number of vertices: &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            v <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Enter the number of edges: &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            e <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
            graph <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Represent_Graph_Adjacency_Matrix</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Enter the edges: &lt;to&gt; &lt;from&gt;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> e<span class="token punctuation">)</span> 
            <span class="token punctuation">{</span>
                to <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                from <span class="token operator">=</span> sc<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
                graph<span class="token punctuation">.</span><span class="token function">makeEdge</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> from<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                count<span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
 
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;The adjacency matrix for the given graph is: &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;  &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> v<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> v<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
            <span class="token punctuation">{</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> v<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> 
                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>graph<span class="token punctuation">.</span><span class="token function">getEdge</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
 
        <span class="token punctuation">}</span>
        <span class="token keyword">catch</span> <span class="token punctuation">(</span>Exception E<span class="token punctuation">)</span> 
        <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Somthing went wrong&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
 
        sc<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Running the code:
Save the file and compile using <code>javac Represent_Graph_Adjacency_Matrix.java</code></p> <p>Example:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>$ java Represent_Graph_Adjacency_Matrix
Enter the number of vertices<span class="token operator">:</span>
<span class="token number">4</span>
Enter the number of edges<span class="token operator">:</span>
<span class="token number">6</span>
Enter the edges<span class="token operator">:</span> <span class="token operator">&lt;</span>to<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>from<span class="token operator">&gt;</span>
<span class="token number">1</span> <span class="token number">1</span>
<span class="token number">3</span> <span class="token number">4</span>
<span class="token number">2</span> <span class="token number">3</span>
<span class="token number">1</span> <span class="token number">4</span>
<span class="token number">2</span> <span class="token number">4</span>
<span class="token number">1</span> <span class="token number">2</span>
The adjacency matrix <span class="token keyword">for</span> the given graph is<span class="token operator">:</span>
  <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span>
<span class="token number">1</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">0</span> <span class="token number">1</span>
<span class="token number">2</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">1</span> <span class="token number">1</span>
<span class="token number">3</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">1</span>
<span class="token number">4</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">0</span>

</code></pre></div><h2 id="introduction-to-graph-theory"><a href="#introduction-to-graph-theory" class="header-anchor">#</a> Introduction To Graph Theory</h2> <p><a href="https://en.wikipedia.org/wiki/Graph_theory" target="_blank" rel="noopener noreferrer">Graph Theory<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> is the study of graphs, which are mathematical structures used to model pairwise relations between objects.</p> <p>Did you know, almost all the problems of planet Earth can be converted into problems of Roads and Cities, and solved? Graph Theory was invented many years ago, even before the invention of computer. <a href="https://en.wikipedia.org/wiki/Leonhard_Euler" target="_blank" rel="noopener noreferrer">Leonhard Euler<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> wrote a paper on the <a href="https://en.wikipedia.org/wiki/Seven_Bridges_of_K%C3%B6nigsberg" target="_blank" rel="noopener noreferrer">Seven Bridges of Königsberg<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> which is regarded as the first paper of Graph Theory. Since then, people have come to realize that if we can convert any problem to this City-Road problem, we can solve it easily by Graph Theory.</p> <p>Graph Theory has many applications.One of the most common application is to find the shortest distance between one city to another. We all know that to reach your PC, this web-page had to travel many routers from the server. Graph Theory helps it to find out the routers that needed to be crossed. During war, which street needs to be bombarded to disconnect the capital city from others, that too can be found out using Graph Theory.</p> <p>Let us first learn some basic definitions on Graph Theory.</p> <p><strong>Graph:</strong></p> <p>Let's say, we have 6 cities. We mark them as 1, 2, 3, 4, 5, 6. Now we connect the cities that have roads between each other.</p> <p><a href="http://i.stack.imgur.com/YzZHT.png" target="_blank" rel="noopener noreferrer"><img src="http://i.stack.imgur.com/YzZHT.png" alt="Connection between cities"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>This is a simple graph where some cities are shown with the roads that are connecting them. In Graph Theory, we call each of these cities <strong>Node</strong> or <strong>Vertex</strong> and the roads are called <strong>Edge.</strong> Graph is simply a connection of these nodes and edges.</p> <p>A <strong>node</strong> can represent a lot of things. In some graphs, nodes represent cities, some represent airports, some represent a square in a chessboard. <strong>Edge</strong> represents the relation between each nodes. That relation can be the time to go from one airport to another, the moves of a knight from one square to all the other squares etc.</p> <p><a href="http://i.stack.imgur.com/2EAW1.png" target="_blank" rel="noopener noreferrer"><img src="http://i.stack.imgur.com/2EAW1.png" alt="Moves of Knight from a single point"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><strong>Path of Knight in a Chessboard</strong></p> <p>In simple words, a <strong>Node</strong> represents any object and <strong>Edge</strong> represents the relation between two objects.</p> <p><strong>Adjacent Node:</strong></p> <p>If a node <strong>A</strong> shares an edge with node <strong>B</strong>, then <strong>B</strong> is considered to be adjacent to <strong>A</strong>. In other words, if two nodes are directly connected, they are called adjacent nodes. One node can have multiple adjacent nodes.</p> <p><strong>Directed and Undirected Graph:</strong></p> <p>In directed graphs, the edges have direction signs on one side, that means the edges are <strong>Unidirectional</strong>. On the other hand, the edges of undirected graphs have direction signs on both sides, that means they are <strong>Bidirectional</strong>. Usually undirected graphs are represented with no signs on the either sides of the edges.</p> <p>Let's assume there is a party going on. The people in the party are represented by nodes and there is an edge between two people if they shake hands. Then this graph is undirected because any person <strong>A</strong> shake hands with person <strong>B</strong> if and only if <strong>B</strong> also shakes hands with <strong>A</strong>. In contrast, if the edges from a person <strong>A</strong> to another person <strong>B</strong> corresponds to <strong>A</strong>'s admiring <strong>B</strong>, then this graph is directed, because admiration is not necessarily reciprocated. The former type of graph is called an <strong>undirected graph</strong> and the edges are called <strong>undirected edges</strong> while the latter type of graph is called a <strong>directed graph</strong> and the edges are called <strong>directed edges.</strong></p> <p><strong>Weighted and Unweighted Graph:</strong></p> <p>A weighted graph is a graph in which a number (the weight) is assigned to each edge. Such weights might represent for example costs, lengths or capacities, depending on the problem at hand.
<a href="http://i.stack.imgur.com/pnP5z.png" target="_blank" rel="noopener noreferrer"><img src="http://i.stack.imgur.com/pnP5z.png" alt="Weighted Graph"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>An unweighted graph is simply the opposite. We assume that, the weight of all the edges are same (presumably 1).</p> <p><strong>Path:</strong></p> <p>A path represents a way of going from one node to another. It consists of sequence of edges. There can be multiple paths between two nodes.
<a href="http://i.stack.imgur.com/3IPXO.png" target="_blank" rel="noopener noreferrer"><img src="http://i.stack.imgur.com/3IPXO.png" alt="Path Graph"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>In the example above, there are two paths from <strong>A</strong> to <strong>D</strong>. <strong>A-&gt;B, B-&gt;C, C-&gt;D</strong> is one path. The cost of this path is <strong>3 + 4 + 2 = 9</strong>. Again, there's another path <strong>A-&gt;D</strong>. The cost of this path is <strong>10</strong>. The path that costs the lowest is called <strong>shortest path</strong>.</p> <p><strong>Degree:</strong></p> <p>The degree of a vertex is the number of edges that are connected to it. If there's any edge that connects to the vertex at both ends (a loop) is counted twice.</p> <p>In directed graphs, the nodes have two types of degrees:</p> <ul><li>In-degree: The number of edges that point to the node.</li> <li>Out-degree: The number of edges that point from the node to other nodes.</li></ul> <p>For undirected graphs, they are simply called degree.</p> <p><a href="http://i.stack.imgur.com/fEQuL.png" target="_blank" rel="noopener noreferrer"><img src="http://i.stack.imgur.com/fEQuL.png" alt="Degrees of a graph"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><strong>Some Algorithms Related to Graph Theory</strong></p> <ul><li>Bellman–Ford algorithm</li> <li>Dijkstra's algorithm</li> <li>Ford–Fulkerson algorithm</li> <li>Kruskal's algorithm</li> <li>Nearest neighbour algorithm</li> <li>Prim's algorithm</li> <li>Depth-first search</li> <li>Breadth-first search</li></ul> <h2 id="storing-graphs-adjacency-list"><a href="#storing-graphs-adjacency-list" class="header-anchor">#</a> Storing Graphs (Adjacency List)</h2> <p><a href="https://en.wikipedia.org/wiki/Adjacency_list" target="_blank" rel="noopener noreferrer">Adjacency list<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a vertex in a graph. It takes less memory to store graphs.</p> <p>Let's see a graph, and its adjacency matrix:<a href="http://i.stack.imgur.com/PwJ3D.jpg" target="_blank" rel="noopener noreferrer"><img src="http://i.stack.imgur.com/PwJ3D.jpg" alt="Adjacency Matrix and It's Graph"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>Now we create a list using these values.</p> <p><a href="http://i.stack.imgur.com/WEEcx.jpg" target="_blank" rel="noopener noreferrer"><img src="http://i.stack.imgur.com/WEEcx.jpg" alt="Adjacency List"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>This is called adjacency list. It shows which nodes are connected to which nodes. We can store this information using a 2D array. But will cost us the same memory as Adjacency Matrix. Instead we are going to use dynamically allocated memory to store this one.</p> <p>Many languages support <strong>Vector</strong> or <strong>List</strong> which we can use to store adjacency list. For these, we don't need to specify the size of the <strong>List</strong>. We only need to specify the maximum number of nodes.</p> <p>The pseudo-code will be:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>Procedure Adjacency<span class="token operator">-</span><span class="token function">List</span><span class="token punctuation">(</span>maxN<span class="token punctuation">,</span> E<span class="token punctuation">)</span><span class="token operator">:</span>       <span class="token comment">// maxN denotes the maximum number of nodes</span>
edge<span class="token punctuation">[</span>maxN<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                    <span class="token comment">// E denotes the number of edges</span>
<span class="token keyword">for</span> i from <span class="token number">1</span> to E
    input <span class="token operator">-&gt;</span> x<span class="token punctuation">,</span> y                        <span class="token comment">// Here x, y denotes there is an edge between x, y</span>
    edge<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>
    edge<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
end <span class="token keyword">for</span>
Return edge

</code></pre></div><p>Since this one is an undirected graph, it there is an edge from <strong>x</strong> to <strong>y</strong>, there is also an edge from <strong>y</strong> to <strong>x</strong>. If it was a directed graph, we'd omit the second one. For weighted graphs, we need to store the cost too. We'll create another <strong>vector</strong> or <strong>list</strong> named <strong>cost[]</strong> to store these. The pseudo-code:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>Procedure Adjacency<span class="token operator">-</span><span class="token function">List</span><span class="token punctuation">(</span>maxN<span class="token punctuation">,</span> E<span class="token punctuation">)</span><span class="token operator">:</span>
edge<span class="token punctuation">[</span>maxN<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
cost<span class="token punctuation">[</span>maxN<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> i from <span class="token number">1</span> to E
    input <span class="token operator">-&gt;</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> w
    edge<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>
    cost<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span>
end <span class="token keyword">for</span>
Return edge<span class="token punctuation">,</span> cost

</code></pre></div><p>From this one, we can easily find out the total number of nodes connected to any node, and what these nodes are. It takes less time than Adjacency Matrix. But if we needed to find out if there's an edge between <strong>u</strong> and <strong>v</strong>, it'd have been easier if we kept an adjacency matrix.</p> <h2 id="topological-sort"><a href="#topological-sort" class="header-anchor">#</a> Topological Sort</h2> <p>A topological ordering, or a topological sort, orders the vertices
in a directed acyclic graph on a line, i.e. in a list, such that all directed
edges go from left to right. Such an ordering cannot exist
if the graph contains a directed cycle because there is no way that you can keep going right on a line and still return back to where you started from.</p> <p>Formally, in a graph <code>G = (V, E)</code>, then a linear ordering of all its
vertices is such that if <code>G</code> contains an edge <code>(u, v) ∈ E</code>from vertex <code>u</code> to vertex <code>v</code> then <code>u</code> precedes <code>v</code> in the ordering.</p> <p>It is important to note that each DAG has <strong>at least one</strong>
topological sort.</p> <p>There are known algorithms for constructing a topological ordering
of any DAG in linear time, one example is:</p> <ol><li>Call <code>depth_first_search(G)</code> to compute finishing times <code>v.f</code> for each vertex <code>v</code></li> <li>As each vertex is finished, insert it into the front of a linked list</li> <li>the linked list of vertices, as it is now sorted.</li></ol> <p>A topological sort can be performed in <code>ϴ(V + E)</code> time, since the
depth-first search algorithm takes <code>ϴ(V + E)</code> time and it takes <code>Ω(1)</code>
(constant time) to insert each of <code>|V|</code> vertices into the front of
a linked list.</p> <p>Many applications use directed acyclic graphs to indicate precedences
among events. We use topological sorting
so that we get an ordering to process each vertex before any of
its successors.</p> <p>Vertices in a graph may represent tasks to be performed and the edges
may represent constraints that one task must be performed before
another; a topological ordering is a valid sequence to perform the
tasks set of tasks described in <code>V</code>.</p> <h3 id="problem-instance-and-its-solution"><a href="#problem-instance-and-its-solution" class="header-anchor">#</a> Problem instance and its solution</h3> <p>Let a vertice <code>v</code> describe a <code>Task(hours_to_complete: int)</code>, i. e. <code>Task(4)</code> describes a <code>Task</code> that takes <code>4</code> hours to complete, and an edge <code>e</code> describe a <code>Cooldown(hours: int)</code> such that <code>Cooldown(3)</code> describes a duration of time to cool down after a completed task.</p> <p>Let our graph be called <code>dag</code> (since it is a directed acyclic graph), and let it contain 5 vertices:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>A <span class="token operator">&lt;</span><span class="token operator">-</span> dag<span class="token punctuation">.</span><span class="token function">add_vertex</span><span class="token punctuation">(</span><span class="token function">Task</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
B <span class="token operator">&lt;</span><span class="token operator">-</span> dag<span class="token punctuation">.</span><span class="token function">add_vertex</span><span class="token punctuation">(</span><span class="token function">Task</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
C <span class="token operator">&lt;</span><span class="token operator">-</span> dag<span class="token punctuation">.</span><span class="token function">add_vertex</span><span class="token punctuation">(</span><span class="token function">Task</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
D <span class="token operator">&lt;</span><span class="token operator">-</span> dag<span class="token punctuation">.</span><span class="token function">add_vertex</span><span class="token punctuation">(</span><span class="token function">Task</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
E <span class="token operator">&lt;</span><span class="token operator">-</span> dag<span class="token punctuation">.</span><span class="token function">add_vertex</span><span class="token punctuation">(</span><span class="token function">Task</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>where we connect the vertices with directed edges such that the graph is acyclic,</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// A ---&gt; C ----+</span>
<span class="token comment">// |      |     |</span>
<span class="token comment">// v      v     v</span>
<span class="token comment">// B ---&gt; D --&gt; E</span>
dag<span class="token punctuation">.</span><span class="token function">add_edge</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> <span class="token function">Cooldown</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
dag<span class="token punctuation">.</span><span class="token function">add_edge</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> C<span class="token punctuation">,</span> <span class="token function">Cooldown</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
dag<span class="token punctuation">.</span><span class="token function">add_edge</span><span class="token punctuation">(</span>B<span class="token punctuation">,</span> D<span class="token punctuation">,</span> <span class="token function">Cooldown</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
dag<span class="token punctuation">.</span><span class="token function">add_edge</span><span class="token punctuation">(</span>C<span class="token punctuation">,</span> D<span class="token punctuation">,</span> <span class="token function">Cooldown</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
dag<span class="token punctuation">.</span><span class="token function">add_edge</span><span class="token punctuation">(</span>C<span class="token punctuation">,</span> E<span class="token punctuation">,</span> <span class="token function">Cooldown</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
dag<span class="token punctuation">.</span><span class="token function">add_edge</span><span class="token punctuation">(</span>D<span class="token punctuation">,</span> E<span class="token punctuation">,</span> <span class="token function">Cooldown</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>then there are three possible topological orderings between <code>A</code> and <code>E</code>,</p> <ol><li><code>A -&gt; B -&gt; D -&gt; E</code></li> <li><code>A -&gt; C -&gt; D -&gt; E</code></li> <li><code>A -&gt; C -&gt; E</code></li></ol> <h2 id="thorup-s-algorithm"><a href="#thorup-s-algorithm" class="header-anchor">#</a> Thorup's algorithm</h2> <p>Thorup's algorithm for single source shortest path for undirected graph has the time complexity O(m), lower than Dijkstra.</p> <p>Basic ideas are the following. (Sorry, I didn't try implementing it yet, so I might miss some minor details. And the original paper is paywalled so I tried to reconstruct it from other sources referencing it. Please remove this comment if you could verify.)</p> <ul><li>There are ways to find the spanning tree in O(m) (not described here). You need to &quot;grow&quot; the spanning tree from the shortest edge to the longest, and it would be a forest with several connected components before fully grown.</li> <li>Select an integer b (b&gt;=2) and only consider the spanning forests with length limit b^k. Merge the components which are exactly the same but with different k, and call the minimum k the level of the component. Then logically make components into a tree. u is the parent of v iff u is the smallest component distinct from v that fully contains v. The root is the whole graph and the leaves are single vertices in the original graph (with the level of negative infinity). The tree still has only O(n) nodes.</li> <li>Maintain the distance of each component to the source (like in Dijkstra's algorithm). The distance of a component with more than one vertices is the minimum distance of its unexpanded children. Set the distance of the source vertex to 0 and update the ancestors accordingly.</li> <li>Consider the distances in base b. When visiting a node in level k the first time, put its children into buckets shared by all nodes of level k (as in bucket sort, replacing the heap in Dijkstra's algorithm) by the digit k and higher of its distance. Each time visiting a node, consider only its first b buckets, visit and remove each of them, update the distance of the current node, and relink the current node to its own parent using the new distance and wait for the next visit for the following buckets.</li> <li>When a leaf is visited, the current distance is the final distance of the vertex. Expand all edges from it in the original graph and update the distances accordingly.</li> <li>Visit the root node (whole graph) repeatedly until the destination is reached.</li></ul> <p>It is based on the fact that, there isn't an edge with length less than l between two connected components of the spanning forest with length limitation l, so, starting at distance x, you could focus only on one connected component until you reach the distance x + l. You'll visit some vertices before vertices with shorter distance are all visited, but that doesn't matter because it is known there won't be a shorter path to here from those vertices. Other parts work like the bucket sort / MSD radix sort, and of course, it requires the O(m) spanning tree.</p> <h2 id="detecting-a-cycle-in-a-directed-graph-using-depth-first-traversal"><a href="#detecting-a-cycle-in-a-directed-graph-using-depth-first-traversal" class="header-anchor">#</a> Detecting a cycle in a directed graph using Depth First Traversal</h2> <p>A cycle in a directed graph exists if there's a back edge discovered during a DFS. A back edge is an edge from a node to itself or one of the ancestors in a DFS tree. For a disconnected graph, we get a DFS forest, so you have to iterate through all vertices in the graph to find disjoint DFS trees.</p> <p>C++ implementation:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;list&gt;</span></span>
    
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span> 

<span class="token macro property">#<span class="token directive keyword">define</span> NUM_V   4</span>

<span class="token keyword">bool</span> <span class="token function">helper</span><span class="token punctuation">(</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">*</span>graph<span class="token punctuation">,</span> <span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">*</span> visited<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token operator">*</span> recStack<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    visited<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>
    recStack<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>
    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">::</span>iterator i<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">!=</span>graph<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>  
        <span class="token keyword">if</span><span class="token punctuation">(</span>recStack<span class="token punctuation">[</span><span class="token operator">*</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//if vertice v is found in recursion stack of this DFS traversal</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">*</span>i<span class="token operator">==</span>u<span class="token punctuation">)</span> <span class="token comment">//if there's an edge from the vertex to itself</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span><span class="token operator">*</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>   <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">helper</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span> <span class="token operator">*</span>i<span class="token punctuation">,</span> visited<span class="token punctuation">,</span> recStack<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    recStack<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/*
/The wrapper function calls helper function on each vertices which have not been visited. Helper function returns true if it detects a back edge in the subgraph(tree) or false.
*/</span>
<span class="token keyword">bool</span> <span class="token function">isCyclic</span><span class="token punctuation">(</span>list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">*</span>graph<span class="token punctuation">,</span> <span class="token keyword">int</span> V<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">bool</span> visited<span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//array to track vertices already visited</span>
    <span class="token keyword">bool</span> recStack<span class="token punctuation">[</span>V<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//array to track vertices in recursion stack of the traversal.</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>V<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
    visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">,</span> recStack<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment">//initialize all vertices as not visited and not recursed</span>

    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> u <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> u <span class="token operator">&lt;</span> V<span class="token punctuation">;</span> u<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">//Iteratively checks if every vertices have been visited</span>
    <span class="token punctuation">{</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>visited<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">==</span><span class="token boolean">false</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">helper</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span> u<span class="token punctuation">,</span> visited<span class="token punctuation">,</span> recStack<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//checks if the DFS tree from the vertex contains a cycle</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/*
Driver function
*/</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">*</span> graph <span class="token operator">=</span> <span class="token keyword">new</span> list<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">[</span>NUM_V<span class="token punctuation">]</span><span class="token punctuation">;</span>
    graph<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    graph<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    graph<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    graph<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    graph<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    graph<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">bool</span> res <span class="token operator">=</span> <span class="token function">isCyclic</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span> NUM_V<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span>res<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Result:
As shown below, there are three back edges in the graph. One between vertex 0 and 2; between vertice 0, 1, and 2; and vertex 3. Time complexity of search is O(V+E) where V is the number of vertices and E is the number of edges.
<a href="http://i.stack.imgur.com/UHwvp.png" target="_blank" rel="noopener noreferrer"><img src="http://i.stack.imgur.com/UHwvp.png" alt="enter image description here"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h4 id="remarks"><a href="#remarks" class="header-anchor">#</a> Remarks</h4> <p>Graphs are a mathematical structure that model sets of objects that may or may not be connected with members from sets of edges or links.</p> <p>A graph can be described through two different sets of mathematical objects:</p> <ul><li>A set of <strong>vertices</strong>.</li> <li>A set of <strong>edges</strong> that connect pairs of vertices.</li></ul> <p>Graphs can be either directed or undirected.</p> <ul><li><strong>Directed graphs</strong> contain edges that &quot;connect&quot; only one way.</li> <li><strong>Undirected graphs</strong> contain only edges that automatically connect two vertices together in both directions.</li></ul></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/devtut/generate/edit/master/docs/algorithm/graph.md" target="_blank" rel="noopener noreferrer">Edit this page on GitHub</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/algorithm/lowest-common-ancestor-of-a-binary-tree.html" class="prev">
        Lowest common ancestor of a Binary Tree
      </a></span> <span class="next"><a href="/algorithm/graph-traversals.html">
        Graph Traversals
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.ced448ab.js" defer></script><script src="/assets/js/3.f1d73125.js" defer></script><script src="/assets/js/38.90d7c7f4.js" defer></script>
  </body>
</html>
