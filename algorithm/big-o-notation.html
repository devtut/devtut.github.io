<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Algorithm - Big-O Notation</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="description" content="A Simple Loop, A Nested Loop, An O(log n) example, O(log n) types of Algorithms">
    <meta property="og:site_name" content="DevTut">
    <meta property="og:title" content="Algorithm - Big-O Notation">
    <meta property="og:description" content="A Simple Loop, A Nested Loop, An O(log n) example, O(log n) types of Algorithms">
    <meta property="og:type" content="article">
    <meta property="og:url" content="/algorithm/big-o-notation.html">
    <meta property="og:image" content="/logo.png">
    <meta name="twitter:title" content="Algorithm - Big-O Notation">
    <meta name="twitter:description" content="A Simple Loop, A Nested Loop, An O(log n) example, O(log n) types of Algorithms">
    <meta name="twitter:url" content="/algorithm/big-o-notation.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="/logo.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/mstile-150x150.png">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="google-site-verification" content="76_rKXgwMVIjd-axJC_1zPV9OS4mEjvtgjYOWVkAdnQ">
    <link rel="preload" href="/assets/css/0.styles.8b877eb8.css" as="style"><link rel="preload" href="/assets/js/app.ced448ab.js" as="script"><link rel="preload" href="/assets/js/3.f1d73125.js" as="script"><link rel="preload" href="/assets/js/16.cb1b60bb.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.8b877eb8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">DevTut</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Algorithm</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/algorithm/" class="sidebar-link">Disclaimer</a></li><li><a href="/algorithm/getting-started-with-algorithm.html" class="sidebar-link">Getting started with algorithm</a></li><li><a href="/algorithm/algorithm-complexity.html" class="sidebar-link">Algorithm Complexity</a></li><li><a href="/algorithm/big-o-notation.html" class="active sidebar-link">Big-O Notation</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/algorithm/big-o-notation.html#a-simple-loop" class="sidebar-link">A Simple Loop</a></li><li class="sidebar-sub-header"><a href="/algorithm/big-o-notation.html#a-nested-loop" class="sidebar-link">A Nested Loop</a></li><li class="sidebar-sub-header"><a href="/algorithm/big-o-notation.html#an-o-log-n-example" class="sidebar-link">An O(log n) example</a></li><li class="sidebar-sub-header"><a href="/algorithm/big-o-notation.html#o-log-n-types-of-algorithms" class="sidebar-link">O(log n) types of Algorithms</a></li></ul></li><li><a href="/algorithm/trees.html" class="sidebar-link">Trees</a></li><li><a href="/algorithm/binary-search-trees.html" class="sidebar-link">Binary Search Trees</a></li><li><a href="/algorithm/check-if-a-tree-is-bst-or-not.html" class="sidebar-link">Check if a tree is BST or not</a></li><li><a href="/algorithm/binary-tree-traversals.html" class="sidebar-link">Binary Tree traversals</a></li><li><a href="/algorithm/lowest-common-ancestor-of-a-binary-tree.html" class="sidebar-link">Lowest common ancestor of a Binary Tree</a></li><li><a href="/algorithm/graph.html" class="sidebar-link">Graph</a></li><li><a href="/algorithm/graph-traversals.html" class="sidebar-link">Graph Traversals</a></li><li><a href="/algorithm/dijkstras-algorithm.html" class="sidebar-link">Dijkstra’s Algorithm</a></li><li><a href="/algorithm/a-pathfinding.html" class="sidebar-link">A* Pathfinding</a></li><li><a href="/algorithm/a-pathfinding-algorithm.html" class="sidebar-link">A* Pathfinding Algorithm</a></li><li><a href="/algorithm/dynamic-programming.html" class="sidebar-link">Dynamic Programming</a></li><li><a href="/algorithm/applications-of-dynamic-programming.html" class="sidebar-link">Applications of Dynamic Programming</a></li><li><a href="/algorithm/kruskal-s-algorithm.html" class="sidebar-link">Kruskal's Algorithm</a></li><li><a href="/algorithm/greedy-algorithms.html" class="sidebar-link">Greedy Algorithms</a></li><li><a href="/algorithm/applications-of-greedy-technique.html" class="sidebar-link">Applications of Greedy technique</a></li><li><a href="/algorithm/prim-s-algorithm.html" class="sidebar-link">Prim's Algorithm</a></li><li><a href="/algorithm/bellman-ford-algorithm.html" class="sidebar-link">Bellman–Ford Algorithm</a></li><li><a href="/algorithm/line-algorithm.html" class="sidebar-link">Line Algorithm</a></li><li><a href="/algorithm/floyd-warshall-algorithm.html" class="sidebar-link">Floyd-Warshall Algorithm</a></li><li><a href="/algorithm/catalan-number-algorithm.html" class="sidebar-link">Catalan Number Algorithm</a></li><li><a href="/algorithm/multithreaded-algorithms.html" class="sidebar-link">Multithreaded Algorithms</a></li><li><a href="/algorithm/knuth-morris-pratt-kmp-algorithm.html" class="sidebar-link">Knuth Morris Pratt (KMP) Algorithm</a></li><li><a href="/algorithm/edit-distance-dynamic-algorithm.html" class="sidebar-link">Edit Distance Dynamic Algorithm</a></li><li><a href="/algorithm/online-algorithms.html" class="sidebar-link">Online algorithms</a></li><li><a href="/algorithm/integer-partition-algorithm.html" class="sidebar-link">Integer Partition Algorithm</a></li><li><a href="/algorithm/maximum-path-sum-algorithm.html" class="sidebar-link">Maximum Path Sum Algorithm</a></li><li><a href="/algorithm/maximum-subarray-algorithm.html" class="sidebar-link">Maximum Subarray Algorithm</a></li><li><a href="/algorithm/sliding-window-algorithm.html" class="sidebar-link">Sliding Window Algorithm</a></li><li><a href="/algorithm/sorting.html" class="sidebar-link">Sorting</a></li><li><a href="/algorithm/bubble-sort.html" class="sidebar-link">Bubble Sort</a></li><li><a href="/algorithm/merge-sort.html" class="sidebar-link">Merge Sort</a></li><li><a href="/algorithm/insertion-sort.html" class="sidebar-link">Insertion Sort</a></li><li><a href="/algorithm/bucket-sort.html" class="sidebar-link">Bucket Sort</a></li><li><a href="/algorithm/quicksort.html" class="sidebar-link">Quicksort</a></li><li><a href="/algorithm/counting-sort.html" class="sidebar-link">Counting Sort</a></li><li><a href="/algorithm/heap-sort.html" class="sidebar-link">Heap Sort</a></li><li><a href="/algorithm/cycle-sort.html" class="sidebar-link">Cycle Sort</a></li><li><a href="/algorithm/odd-even-sort.html" class="sidebar-link">Odd-Even Sort</a></li><li><a href="/algorithm/selection-sort.html" class="sidebar-link">Selection Sort</a></li><li><a href="/algorithm/pigeonhole-sort.html" class="sidebar-link">Pigeonhole Sort</a></li><li><a href="/algorithm/radix-sort.html" class="sidebar-link">Radix Sort</a></li><li><a href="/algorithm/shell-sort.html" class="sidebar-link">Shell Sort</a></li><li><a href="/algorithm/pancake-sort.html" class="sidebar-link">Pancake Sort</a></li><li><a href="/algorithm/searching.html" class="sidebar-link">Searching</a></li><li><a href="/algorithm/substring-search.html" class="sidebar-link">Substring Search</a></li><li><a href="/algorithm/breadth-first-search.html" class="sidebar-link">Breadth-First Search</a></li><li><a href="/algorithm/depth-first-search.html" class="sidebar-link">Depth First Search</a></li><li><a href="/algorithm/hash-functions.html" class="sidebar-link">Hash Functions</a></li><li><a href="/algorithm/travelling-salesman.html" class="sidebar-link">Travelling Salesman</a></li><li><a href="/algorithm/shortest-common-supersequence-problem.html" class="sidebar-link">Shortest Common Supersequence Problem</a></li><li><a href="/algorithm/knapsack-problem.html" class="sidebar-link">Knapsack Problem</a></li><li><a href="/algorithm/equation-solving.html" class="sidebar-link">Equation Solving</a></li><li><a href="/algorithm/longest-common-subsequence.html" class="sidebar-link">Longest Common Subsequence</a></li><li><a href="/algorithm/longest-increasing-subsequence.html" class="sidebar-link">Longest Increasing Subsequence</a></li><li><a href="/algorithm/check-two-strings-are-anagrams.html" class="sidebar-link">Check two strings are anagrams</a></li><li><a href="/algorithm/pascal-s-triangle.html" class="sidebar-link">Pascal's Triangle</a></li><li><a href="/algorithm/algo-print-a-m-n-matrix-in-square-wise.html" class="sidebar-link">Algo:- Print a m*n matrix in square wise</a></li><li><a href="/algorithm/matrix-exponentiation.html" class="sidebar-link">Matrix Exponentiation</a></li><li><a href="/algorithm/polynomial-time-bounded-algorithm-for-minimum-vertex-cover.html" class="sidebar-link">polynomial-time bounded algorithm for Minimum Vertex Cover</a></li><li><a href="/algorithm/dynamic-time-warping.html" class="sidebar-link">Dynamic Time Warping</a></li><li><a href="/algorithm/fast-fourier-transform.html" class="sidebar-link">Fast Fourier Transform</a></li><li><a href="/algorithm/pseudocode.html" class="sidebar-link">Pseudocode</a></li><li><a href="/algorithm/contributors.html" class="sidebar-link">The Contributors</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="big-o-notation"><a href="#big-o-notation" class="header-anchor">#</a> Big-O Notation</h1> <h2 id="a-simple-loop"><a href="#a-simple-loop" class="header-anchor">#</a> A Simple Loop</h2> <p>The following function finds the maximal element in an array:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">find_max</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>array<span class="token punctuation">,</span> size_t len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> max <span class="token operator">=</span> INT_MIN<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>max <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            max <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> max<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>The input size is the size of the array, which I called <code>len</code> in the code.</p> <p>Let's count the operations.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> max <span class="token operator">=</span> INT_MIN<span class="token punctuation">;</span>
size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

</code></pre></div><p>These two assignments are done only once, so that's 2 operations. The operations that are looped are:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>max <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
i<span class="token operator">++</span><span class="token punctuation">;</span>
max <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span>

</code></pre></div><p>Since there are 3 operations in the loop, and the loop is done n times, we add <code>3n</code>  to our already existing 2 operations to get <code>3n + 2</code>. So our function takes <code>3n + 2</code> operations to find the max (its complexity is <code>3n + 2</code>). This is a polynomial where the fastest growing term is a factor of n, so it is O(n).</p> <p>You probably have noticed that &quot;operation&quot; is not very well defined. For instance I said that <code>if (max &lt; array[i])</code> was one operation, but depending on the architecture this statement can compile to for instance three instructions : one memory read, one comparison and one branch. I have also considered all operations as the same, even though for instance the memory operations will be slower than the others, and their performance will vary wildly due for instance to cache effects. I also have completely ignored the return statement, the fact that a frame will be created for the function, etc. In the end it doesn't matter to complexity analysis, because whatever way I choose to count operations, it will only change the coefficient of the n factor and the constant, so the result will still be O(n). Complexity shows how the algorithm scales with the size of the input, but it isn't the only aspect of performance!</p> <h2 id="a-nested-loop"><a href="#a-nested-loop" class="header-anchor">#</a> A Nested Loop</h2> <p>The following function checks if an array has any duplicates by taking each element, then iterating over the whole array to see if the element is there</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>_Bool <span class="token function">contains_duplicates</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>array<span class="token punctuation">,</span> size_t len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> j <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>The inner loop performs at each iteration a number of operations that is constant with <code>n</code>. The outer loop also does a few constant operations, and runs the inner loop <code>n</code> times. The outer loop itself is run <code>n</code> times. So the operations inside the inner loop are run <code>n^2</code> times, the operations in the outer loop are run <code>n</code> times, and the assignment to <code>i</code> is done one time. Thus, the complexity will be something like <code>an^2 + bn + c</code>, and since the highest term is <code>n^2</code>, the O notation is <code>O(n^2)</code>.</p> <p>As you may have noticed, we can improve the algorithm by avoiding doing the same comparisons multiple times. We can start from <code>i + 1</code> in the inner loop, because all elements before it will already have been checked against all array elements, including the one at index <code>i + 1</code>. This allows us to drop the <code>i == j</code> check.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>_Bool <span class="token function">faster_contains_duplicates</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>array<span class="token punctuation">,</span> size_t len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Obviously, this second version does less operations and so is more efficient. How does that translate to Big-O notation? Well, now the inner loop body is run <code>1 + 2 + ... + n - 1 = n(n-1)/2</code> times. This is <strong>still</strong> a polynomial of the second degree, and so is still only <code>O(n^2)</code>. We have clearly lowered the complexity, since we roughly divided by 2 the number of operations that we are doing, but we are still in the same complexity <strong>class</strong> as defined by Big-O. In order to lower the complexity to a lower class we would need to divide the number of operations by something that <strong>tends to infinity</strong> with <code>n</code>.</p> <h2 id="an-o-log-n-example"><a href="#an-o-log-n-example" class="header-anchor">#</a> An O(log n) example</h2> <h3 id="introduction"><a href="#introduction" class="header-anchor">#</a> Introduction</h3> <p>Consider the following problem:</p> <p><code>L</code> is a sorted list containing <code>n</code> signed integers (<code>n</code> being big enough), for example <code>[-5, -2, -1, 0, 1, 2, 4]</code> (here, <code>n</code> has a value of 7). If <code>L</code> is known to contain the integer 0, how can you find the index of 0 ?</p> <h3 id="naive-approach"><a href="#naive-approach" class="header-anchor">#</a> Naïve approach</h3> <p>The first thing that comes to mind is to just read every index until 0 is found. In the worst case, the number of operations is <code>n</code>, so the complexity is O(n).</p> <p>This works fine for small values of <code>n</code>, but is there a more efficient way ?</p> <h3 id="dichotomy"><a href="#dichotomy" class="header-anchor">#</a> Dichotomy</h3> <p>Consider the following algorithm (Python3):</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>a <span class="token operator">=</span> <span class="token number">0</span>
b <span class="token operator">=</span> n<span class="token operator">-</span><span class="token number">1</span>
<span class="token keyword">while</span> True<span class="token operator">:</span>
  h <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token comment">//2 ## // is the integer division, so h is an integer</span>
  <span class="token keyword">if</span> L<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token operator">:</span>
    <span class="token keyword">return</span> h
  elif L<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token operator">:</span>
    b <span class="token operator">=</span> h
  elif L<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token operator">:</span>
    a <span class="token operator">=</span> h

</code></pre></div><p><code>a</code> and <code>b</code> are the indexes between which 0 is to be found. Each time we enter the loop, we use an index between <code>a</code> and <code>b</code> and use it to narrow the area to be searched.</p> <p>In the worst case, we have to wait until <code>a</code> and <code>b</code> are equal. But how many operations does that take? Not n, because each time we enter the loop, we divide the distance between <code>a</code> and <code>b</code> by about two. Rather, the complexity is O(log n).</p> <h3 id="explanation"><a href="#explanation" class="header-anchor">#</a> Explanation</h3> <p><strong>Note: When we write &quot;log&quot;, we mean the binary logarithm, or log base 2 (which we will write &quot;log_2&quot;). As O(log_2 n) = O(log n) (you can do the math) we will use &quot;log&quot; instead of &quot;log_2&quot;.</strong></p> <p>Let's call x the number of operations: we know that 1 = n / (2^x).</p> <p>So 2^x = n, then x = log n</p> <h3 id="conclusion"><a href="#conclusion" class="header-anchor">#</a> Conclusion</h3> <p>When faced with successive divisions (be it by two or by any number), remember that the complexity is logarithmic.</p> <h2 id="o-log-n-types-of-algorithms"><a href="#o-log-n-types-of-algorithms" class="header-anchor">#</a> O(log n) types of Algorithms</h2> <p>Let's say we have a problem of size n. Now for each step of our algorithm(which we need write), our original problem becomes half of its previous size(n/2).</p> <p>So at each step, our problem becomes half.</p> <table><thead><tr><th>Step</th> <th>Problem</th></tr></thead> <tbody><tr><td>1</td> <td>n/2</td></tr> <tr><td>2</td> <td>n/4</td></tr> <tr><td>3</td> <td>n/8</td></tr> <tr><td>4</td> <td>n/16</td></tr></tbody></table> <p>When the problem space is reduced(i.e solved completely), it cannot be reduced any further(n becomes equal to 1) after exiting check condition.</p> <li>
Let's say at kth step or number of operations:
**problem-size** = 1
</li> <li>
But we know at kth step, our problem-size should be:
**problem-size** = n/2<sup>k</sup></li> <li>
From 1 and 2:
n/2<sup>k</sup> = 1 or
n = 2<sup>k</sup></li> <li>
Take log on both sides
log<sub>e</sub> n = k log<sub>e</sub>2
or
k = log<sub>e</sub> n / log<sub>e</sub> 2
</li> <li>
Using formula **log<sub>x</sub> m / log<sub>x</sub> n = log<sub>n</sub> m**
k = log<sub>2</sub> n
or simply    k = log n
</li> <blockquote></blockquote> <p>Now we know that our algorithm can run maximum up to log n, hence
time complexity comes as<br>
O( log n)</p> <p>A very simple example in code to support above text is :</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">=</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// perform some operation</span>
<span class="token punctuation">}</span>

</code></pre></div><p>So now if some one asks you if n is 256 how many steps that loop( or any other algorithm that cuts down it's problem size into half) will run you can very easily calculate.</p> <p>k = log<sub>2</sub> 256</p> <p>k = log<sub>2</sub> 2 <sup>8</sup>       ( =&gt; log<sub>a</sub>a = 1)</p> <p>k = 8</p> <p>Another very good example for similar case is <strong>Binary Search Algorithm</strong>.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">bSearch</span><span class="token punctuation">(</span><span class="token keyword">int</span> arr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> size<span class="token punctuation">,</span><span class="token keyword">int</span> item<span class="token punctuation">)</span><span class="token punctuation">{</span>
 <span class="token keyword">int</span> low<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token keyword">int</span> high<span class="token operator">=</span>size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

 <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;=</span>high<span class="token punctuation">)</span><span class="token punctuation">{</span>                 
     mid<span class="token operator">=</span>low<span class="token operator">+</span><span class="token punctuation">(</span>high<span class="token operator">-</span>low<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>                 
     <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">==</span>item<span class="token punctuation">)</span>                        
         <span class="token keyword">return</span> mid<span class="token punctuation">;</span>                 
     <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token operator">&lt;</span>item<span class="token punctuation">)</span>                         
         low<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                
     <span class="token keyword">else</span>  high<span class="token operator">=</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>      
     <span class="token punctuation">}</span>  
  <span class="token keyword">return</span> –<span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// Unsuccessful result</span>
<span class="token punctuation">}</span>

</code></pre></div><h4 id="remarks"><a href="#remarks" class="header-anchor">#</a> Remarks</h4> <p><strong>Definition</strong></p> <p>The Big-O notation is at its heart a mathematical notation, used to compare the rate of convergence of functions. Let <code>n -&gt; f(n)</code> and <code>n -&gt; g(n)</code> be functions defined over the natural numbers. Then we say that <code>f = O(g)</code> if and only if <code>f(n)/g(n)</code> is bounded when n approaches infinity. In other words, <code>f = O(g)</code> if and only if there exists a constant A, such that for all n, <code>f(n)/g(n) &lt;= A</code>.</p> <p>Actually the scope of the Big-O notation is a bit wider in mathematics but for simplicity I have narrowed it to what is used in algorithm complexity analysis : functions defined on the naturals, that have non-zero values, and the case of n growing to infinity.</p> <p><strong>What does it mean ?</strong></p> <p>Let's take the case of <code>f(n) = 100n^2 + 10n + 1</code> and <code>g(n) = n^2</code>. It is quite clear that both of these functions tend to infinity as n tends to infinity. But sometimes knowing the limit is not enough, and we also want to know the <strong>speed</strong> at which the functions approach their limit. Notions like Big-O help compare and classify functions by their speed of convergence.</p> <p>Let's find out if <code>f = O(g)</code> by applying the definition. We have <code>f(n)/g(n) = 100 + 10/n + 1/n^2</code>. Since <code>10/n</code> is 10 when n is 1 and is decreasing, and since <code>1/n^2</code> is 1 when n is 1 and is also decreasing, we have ̀<code>f(n)/g(n) &lt;= 100 + 10 + 1 = 111</code>. The definition is satisfied because we have found a bound of <code>f(n)/g(n)</code> (111) and so <code>f = O(g)</code> (we say that f is a Big-O of <code>n^2</code>).</p> <p>This means that f tends to infinity at approximately the same speed as g. Now this may seem like a strange thing to say, because what we have found is that f is at most 111 times bigger than g, or in other words when g grows by 1, f grows by at most 111. It may seem that growing 111 times faster is not &quot;approximately the same speed&quot;. And indeed the Big-O notation is not a very precise way to classify function convergence speed, which is why in mathematics we use the <a href="https://en.wikipedia.org/wiki/Asymptotic_analysis" target="_blank" rel="noopener noreferrer">equivalence relationship<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> when we want a precise estimation of speed. But for the purposes of separating algorithms in large speed classes, Big-O is enough. We don't need to separate functions that grow a fixed number of times faster than each other, but only functions that grow <strong>infinitely</strong> faster than each other. For instance if we take <code>h(n) = n^2*log(n)</code>, we see that <code>h(n)/g(n) = log(n)</code> which tends to infinity with n so h is <strong>not</strong> O(n^2), because h grows <strong>infinitely</strong> faster than n^2.</p> <p>Now I need to make a side note : you might have noticed that if <code>f = O(g)</code> and <code>g = O(h)</code>, then <code>f = O(h)</code>. For instance in our case, we have <code>f = O(n^3)</code>, and <code>f = O(n^4)</code>... In algorithm complexity analysis, we frequently say <code>f = O(g)</code> to mean that <code>f = O(g)</code> <strong>and</strong> <code>g = O(f)</code>, which can be understood as &quot;g is the smallest Big-O for f&quot;. In mathematics we say that such functions are Big-Thetas of each other.</p> <p><strong>How is it used ?</strong></p> <p>When comparing algorithm performance, we are interested in the number of operations that an algorithm performs. This is called <strong>time complexity</strong>. In this model, we consider that each basic operation (addition, multiplication, comparison, assignment, etc.) takes a fixed amount of time, and we count the number of such operations.   We can usually express this number as a function of the size of the input, which we call n. And sadly, this number usually grows to infinity with n (if it doesn't, we say that the algorithm is O(1)). We separate our algorithms in big speed classes defined by Big-O : when we speak about a &quot;O(n^2) algorithm&quot;, we mean that the number of operations it performs, expressed as a function of n, is a O(n^2). This says that our algorithm is approximately as fast as an algorithm that would do a number of operations equal to the square of the size of its input, <strong>or faster</strong>. The &quot;or faster&quot; part is there because I used Big-O instead of Big-Theta, but usually people will say Big-O to mean Big-Theta.</p> <p>When counting operations, we usually consider the worst case: for instance if we have a loop that can run at most n times and that contains 5 operations, the number of operations we count is 5n. It is also possible to consider the average case complexity.</p> <p>Quick note : a fast algorithm is one that performs few operations, so if the number of operations grows to infinity <strong>faster</strong>, then the algorithm is <strong>slower</strong>: O(n) is better than O(n^2).</p> <p>We are also sometimes interested in the <strong>space complexity</strong> of our algorithm. For this we consider the number of bytes in memory occupied by the algorithm as a function of the size of the input, and use Big-O the same way.</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/devtut/generate/edit/master/docs/algorithm/big-o-notation.md" target="_blank" rel="noopener noreferrer">Edit this page on GitHub</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/algorithm/algorithm-complexity.html" class="prev">
        Algorithm Complexity
      </a></span> <span class="next"><a href="/algorithm/trees.html">
        Trees
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.ced448ab.js" defer></script><script src="/assets/js/3.f1d73125.js" defer></script><script src="/assets/js/16.cb1b60bb.js" defer></script>
  </body>
</html>
