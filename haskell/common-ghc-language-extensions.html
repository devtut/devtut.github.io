<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Haskell - Common GHC Language Extensions</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="description" content="RankNTypes, OverloadedStrings, BinaryLiterals, ExistentialQuantification, LambdaCase, FunctionalDependencies, FlexibleInstances, GADTs, TupleSections, OverloadedLists, MultiParamTypeClasses, UnicodeSyntax, PatternSynonyms, ScopedTypeVariables, RecordWildCards">
    <meta property="og:site_name" content="DevTut">
    <meta property="og:title" content="Haskell - Common GHC Language Extensions">
    <meta property="og:description" content="RankNTypes, OverloadedStrings, BinaryLiterals, ExistentialQuantification, LambdaCase, FunctionalDependencies, FlexibleInstances, GADTs, TupleSections, OverloadedLists, MultiParamTypeClasses, UnicodeSyntax, PatternSynonyms, ScopedTypeVariables, RecordWildCards">
    <meta property="og:type" content="article">
    <meta property="og:url" content="/haskell/common-ghc-language-extensions.html">
    <meta property="og:image" content="/logo.png">
    <meta name="twitter:title" content="Haskell - Common GHC Language Extensions">
    <meta name="twitter:description" content="RankNTypes, OverloadedStrings, BinaryLiterals, ExistentialQuantification, LambdaCase, FunctionalDependencies, FlexibleInstances, GADTs, TupleSections, OverloadedLists, MultiParamTypeClasses, UnicodeSyntax, PatternSynonyms, ScopedTypeVariables, RecordWildCards">
    <meta name="twitter:url" content="/haskell/common-ghc-language-extensions.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="/logo.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/mstile-150x150.png">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="google-site-verification" content="76_rKXgwMVIjd-axJC_1zPV9OS4mEjvtgjYOWVkAdnQ">
    
    <link rel="preload" href="/assets/css/0.styles.60619e34.css" as="style"><link rel="preload" href="/assets/js/app.1779e102.js" as="script"><link rel="preload" href="/assets/js/3.2cfa8016.js" as="script"><link rel="preload" href="/assets/js/1173.47f03932.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.60619e34.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">DevTut</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Haskell</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/haskell/" aria-current="page" class="sidebar-link">Disclaimer</a></li><li><a href="/haskell/getting-started-with-haskell-language.html" class="sidebar-link">Getting started with Haskell Language</a></li><li><a href="/haskell/overloaded-literals.html" class="sidebar-link">Overloaded Literals</a></li><li><a href="/haskell/foldable.html" class="sidebar-link">Foldable</a></li><li><a href="/haskell/traversable.html" class="sidebar-link">Traversable</a></li><li><a href="/haskell/lens.html" class="sidebar-link">Lens</a></li><li><a href="/haskell/quickcheck.html" class="sidebar-link">QuickCheck</a></li><li><a href="/haskell/common-ghc-language-extensions.html" aria-current="page" class="active sidebar-link">Common GHC Language Extensions</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/haskell/common-ghc-language-extensions.html#rankntypes" class="sidebar-link">RankNTypes</a></li><li class="sidebar-sub-header"><a href="/haskell/common-ghc-language-extensions.html#overloadedstrings" class="sidebar-link">OverloadedStrings</a></li><li class="sidebar-sub-header"><a href="/haskell/common-ghc-language-extensions.html#binaryliterals" class="sidebar-link">BinaryLiterals</a></li><li class="sidebar-sub-header"><a href="/haskell/common-ghc-language-extensions.html#existentialquantification" class="sidebar-link">ExistentialQuantification</a></li><li class="sidebar-sub-header"><a href="/haskell/common-ghc-language-extensions.html#lambdacase" class="sidebar-link">LambdaCase</a></li><li class="sidebar-sub-header"><a href="/haskell/common-ghc-language-extensions.html#functionaldependencies" class="sidebar-link">FunctionalDependencies</a></li><li class="sidebar-sub-header"><a href="/haskell/common-ghc-language-extensions.html#flexibleinstances" class="sidebar-link">FlexibleInstances</a></li><li class="sidebar-sub-header"><a href="/haskell/common-ghc-language-extensions.html#gadts" class="sidebar-link">GADTs</a></li><li class="sidebar-sub-header"><a href="/haskell/common-ghc-language-extensions.html#tuplesections" class="sidebar-link">TupleSections</a></li><li class="sidebar-sub-header"><a href="/haskell/common-ghc-language-extensions.html#overloadedlists" class="sidebar-link">OverloadedLists</a></li><li class="sidebar-sub-header"><a href="/haskell/common-ghc-language-extensions.html#multiparamtypeclasses" class="sidebar-link">MultiParamTypeClasses</a></li><li class="sidebar-sub-header"><a href="/haskell/common-ghc-language-extensions.html#unicodesyntax" class="sidebar-link">UnicodeSyntax</a></li><li class="sidebar-sub-header"><a href="/haskell/common-ghc-language-extensions.html#patternsynonyms" class="sidebar-link">PatternSynonyms</a></li><li class="sidebar-sub-header"><a href="/haskell/common-ghc-language-extensions.html#scopedtypevariables" class="sidebar-link">ScopedTypeVariables</a></li><li class="sidebar-sub-header"><a href="/haskell/common-ghc-language-extensions.html#recordwildcards" class="sidebar-link">RecordWildCards</a></li></ul></li><li><a href="/haskell/free-monads.html" class="sidebar-link">Free Monads</a></li><li><a href="/haskell/type-classes.html" class="sidebar-link">Type Classes</a></li><li><a href="/haskell/io.html" class="sidebar-link">IO</a></li><li><a href="/haskell/record-syntax.html" class="sidebar-link">Record Syntax</a></li><li><a href="/haskell/partial-application.html" class="sidebar-link">Partial Application</a></li><li><a href="/haskell/monoid.html" class="sidebar-link">Monoid</a></li><li><a href="/haskell/category-theory.html" class="sidebar-link">Category Theory</a></li><li><a href="/haskell/lists.html" class="sidebar-link">Lists</a></li><li><a href="/haskell/sorting-algorithms.html" class="sidebar-link">Sorting Algorithms</a></li><li><a href="/haskell/type-families.html" class="sidebar-link">Type Families</a></li><li><a href="/haskell/monads.html" class="sidebar-link">Monads</a></li><li><a href="/haskell/stack.html" class="sidebar-link">Stack</a></li><li><a href="/haskell/generalized-algebraic-data-types.html" class="sidebar-link">Generalized Algebraic Data Types</a></li><li><a href="/haskell/recursion-schemes.html" class="sidebar-link">Recursion Schemes</a></li><li><a href="/haskell/data-text.html" class="sidebar-link">Data.Text</a></li><li><a href="/haskell/using-ghci.html" class="sidebar-link">Using GHCi</a></li><li><a href="/haskell/strictness.html" class="sidebar-link">Strictness</a></li><li><a href="/haskell/syntax-in-functions.html" class="sidebar-link">Syntax in Functions</a></li><li><a href="/haskell/functor.html" class="sidebar-link">Functor</a></li><li><a href="/haskell/testing-with-tasty.html" class="sidebar-link">Testing with Tasty</a></li><li><a href="/haskell/creating-custom-data-types.html" class="sidebar-link">Creating Custom Data Types</a></li><li><a href="/haskell/reactive-banana.html" class="sidebar-link">Reactive-banana</a></li><li><a href="/haskell/optimization.html" class="sidebar-link">Optimization</a></li><li><a href="/haskell/concurrency.html" class="sidebar-link">Concurrency</a></li><li><a href="/haskell/function-composition.html" class="sidebar-link">Function composition</a></li><li><a href="/haskell/databases.html" class="sidebar-link">Databases</a></li><li><a href="/haskell/data-aeson-json-in-haskell.html" class="sidebar-link">Data.Aeson - JSON in Haskell</a></li><li><a href="/haskell/higher-order-functions.html" class="sidebar-link">Higher-order functions</a></li><li><a href="/haskell/containers-data-map.html" class="sidebar-link">Containers - Data.Map</a></li><li><a href="/haskell/fixity-declarations.html" class="sidebar-link">Fixity declarations</a></li><li><a href="/haskell/web-development.html" class="sidebar-link">Web Development</a></li><li><a href="/haskell/vectors.html" class="sidebar-link">Vectors</a></li><li><a href="/haskell/cabal.html" class="sidebar-link">Cabal</a></li><li><a href="/haskell/type-algebra.html" class="sidebar-link">Type algebra</a></li><li><a href="/haskell/arrows.html" class="sidebar-link">Arrows</a></li><li><a href="/haskell/typed-holes.html" class="sidebar-link">Typed holes</a></li><li><a href="/haskell/rewrite-rules-ghc.html" class="sidebar-link">Rewrite rules (GHC)</a></li><li><a href="/haskell/date-and-time.html" class="sidebar-link">Date and Time</a></li><li><a href="/haskell/list-comprehensions.html" class="sidebar-link">List Comprehensions</a></li><li><a href="/haskell/streaming-io.html" class="sidebar-link">Streaming IO</a></li><li><a href="/haskell/google-protocol-buffers.html" class="sidebar-link">Google Protocol Buffers</a></li><li><a href="/haskell/template-haskell-quasiquotes.html" class="sidebar-link">Template Haskell &amp; QuasiQuotes</a></li><li><a href="/haskell/phantom-types.html" class="sidebar-link">Phantom types</a></li><li><a href="/haskell/modules.html" class="sidebar-link">Modules</a></li><li><a href="/haskell/tuples-pairs-triples.html" class="sidebar-link">Tuples (Pairs, Triples, ...)</a></li><li><a href="/haskell/graphics-with-gloss.html" class="sidebar-link">Graphics with Gloss</a></li><li><a href="/haskell/state-monad.html" class="sidebar-link">State Monad</a></li><li><a href="/haskell/pipes.html" class="sidebar-link">Pipes</a></li><li><a href="/haskell/infix-operators.html" class="sidebar-link">Infix operators</a></li><li><a href="/haskell/parallelism.html" class="sidebar-link">Parallelism</a></li><li><a href="/haskell/parsing-html-with-taggy-lens-and-lens.html" class="sidebar-link">Parsing HTML with taggy-lens and lens</a></li><li><a href="/haskell/foreign-function-interface.html" class="sidebar-link">Foreign Function Interface</a></li><li><a href="/haskell/gtk3.html" class="sidebar-link">Gtk3</a></li><li><a href="/haskell/monad-transformers.html" class="sidebar-link">Monad Transformers</a></li><li><a href="/haskell/bifunctor.html" class="sidebar-link">Bifunctor</a></li><li><a href="/haskell/proxies.html" class="sidebar-link">Proxies</a></li><li><a href="/haskell/applicative-functor.html" class="sidebar-link">Applicative Functor</a></li><li><a href="/haskell/common-monads-as-free-monads.html" class="sidebar-link">Common monads as free monads</a></li><li><a href="/haskell/common-functors-as-the-base-of-cofree-comonads.html" class="sidebar-link">Common functors as the base of cofree comonads</a></li><li><a href="/haskell/arithmetic.html" class="sidebar-link">Arithmetic</a></li><li><a href="/haskell/role.html" class="sidebar-link">Role</a></li><li><a href="/haskell/arbitrary-rank-polymorphism-with-rankntypes.html" class="sidebar-link">Arbitrary-rank polymorphism with RankNTypes</a></li><li><a href="/haskell/ghcjs.html" class="sidebar-link">GHCJS</a></li><li><a href="/haskell/xml.html" class="sidebar-link">XML</a></li><li><a href="/haskell/reader-readert.html" class="sidebar-link">Reader / ReaderT</a></li><li><a href="/haskell/function-call-syntax.html" class="sidebar-link">Function call syntax</a></li><li><a href="/haskell/logging.html" class="sidebar-link">Logging</a></li><li><a href="/haskell/attoparsec.html" class="sidebar-link">Attoparsec</a></li><li><a href="/haskell/zipwithm.html" class="sidebar-link">zipWithM</a></li><li><a href="/haskell/profunctor.html" class="sidebar-link">Profunctor</a></li><li><a href="/haskell/type-application.html" class="sidebar-link">Type Application</a></li><li><a href="/haskell/contributors.html" class="sidebar-link">The Contributors</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="common-ghc-language-extensions"><a href="#common-ghc-language-extensions" class="header-anchor">#</a> Common GHC Language Extensions</h1> <h2 id="rankntypes"><a href="#rankntypes" class="header-anchor">#</a> RankNTypes</h2> <p>Imagine the following situation:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">foo</span> <span class="token operator">::</span> <span class="token constant">Show</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">foo</span> <span class="token builtin">show</span>' <span class="token hvariable">string</span> <span class="token hvariable">int</span> <span class="token operator">=</span> <span class="token keyword">do</span>
   <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token builtin">show</span>' <span class="token hvariable">string</span><span class="token punctuation">)</span>
   <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token builtin">show</span>' <span class="token hvariable">int</span><span class="token punctuation">)</span>

</code></pre></div><p>Here, we want to pass in a function that converts a value into a String, apply that function to both a string parameter and and int parameter and print them both. In my mind, there is no reason this should fail! We have a function that works on both types of the parameters we're passing in.</p> <p>Unfortunately, this won't type check! GHC infers the <code>a</code> type based off of its first occurrence in the function body. That is, as soon as we hit:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token builtin">show</span>' <span class="token hvariable">string</span><span class="token punctuation">)</span>

</code></pre></div><p>GHC will infer that <code>show' :: String -&gt; String</code>, since <code>string</code> is a <code>String</code>. It will proceed to blow up while trying to <code>show' int</code>.</p> <p><code>RankNTypes</code> lets you instead write the type signature as follows, quantifying over all functions that satisfy the <code>show'</code> type:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">foo</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">forall</span> <span class="token hvariable">a</span><span class="token punctuation">.</span> <span class="token constant">Show</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre></div><p>This is rank 2 polymorphism: We are asserting that the <code>show'</code> function must work for all <code>a</code>s <strong>within</strong> our function, and the previous implementation now works.</p> <p>The <code>RankNTypes</code> extension allows arbitrary nesting of <code>forall ...</code> blocks in type signatures. In other words, it allows rank N polymorphism.</p> <h2 id="overloadedstrings"><a href="#overloadedstrings" class="header-anchor">#</a> OverloadedStrings</h2> <p>Normally, string literals in Haskell have a type of <code>String</code> (which is a type alias for <code>[Char]</code>). While this isn't a problem for smaller, educational programs, real-world applications often require more efficient storage such as <code>Text</code> or <code>ByteString</code>.</p> <p><code>OverloadedStrings</code> simply changes the type of literals to</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token string">&quot;test&quot;</span> <span class="token operator">::</span> <span class="token constant">Data<span class="token punctuation">.</span>String<span class="token punctuation">.</span>IsString</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span>

</code></pre></div><p>Allowing them to be directly passed to functions expecting such a type. Many libraries implement this interface for their string-like types including <a href="http://stackoverflow.com/documentation/haskell/3406/text" target="_blank" rel="noopener noreferrer">Data.Text<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> and <a href="https://hackage.haskell.org/package/bytestring-0.10.8.1/docs/Data-ByteString.html" target="_blank" rel="noopener noreferrer">Data.ByteString<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> which both provide certain time and space advantages over <code>[Char]</code>.</p> <p>There are also some unique uses of <code>OverloadedStrings</code> like those from the <a href="http://hackage.haskell.org/package/postgresql-simple" target="_blank" rel="noopener noreferrer">Postgresql-simple<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> library which allows SQL queries to be written in double quotes like a normal string, but provides protections against improper concatenation, a notorious source of SQL injection attacks.</p> <p>To create a instance of the <code>IsString</code> class you need to impliment the <code>fromString</code> function.  Example<sup>†</sup>:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">data</span> <span class="token constant">Foo</span> <span class="token operator">=</span> <span class="token constant">A</span> <span class="token operator">|</span> <span class="token constant">B</span> <span class="token operator">|</span> <span class="token constant">Other</span> <span class="token constant">String</span> <span class="token keyword">deriving</span> <span class="token constant">Show</span>

<span class="token keyword">instance</span> <span class="token constant">IsString</span> <span class="token constant">Foo</span> <span class="token keyword">where</span>
  <span class="token hvariable">fromString</span> <span class="token string">&quot;A&quot;</span> <span class="token operator">=</span> <span class="token constant">A</span>
  <span class="token hvariable">fromString</span> <span class="token string">&quot;B&quot;</span> <span class="token operator">=</span> <span class="token constant">B</span>
  <span class="token hvariable">fromString</span> <span class="token hvariable">xs</span>  <span class="token operator">=</span> <span class="token constant">Other</span> <span class="token hvariable">xs</span>

<span class="token hvariable">tests</span> <span class="token operator">::</span> <span class="token punctuation">[</span> <span class="token constant">Foo</span> <span class="token punctuation">]</span>
<span class="token hvariable">tests</span> <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token string">&quot;A&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;B&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Testing&quot;</span> <span class="token punctuation">]</span>

</code></pre></div><p><sup>†</sup> This example courtesy of Lyndon Maydwell (<code>sordina</code> on GitHub) found <a href="https://gist.github.com/sordina/5714390" target="_blank" rel="noopener noreferrer">here<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <h2 id="binaryliterals"><a href="#binaryliterals" class="header-anchor">#</a> BinaryLiterals</h2> <p>Standard Haskell allows you to write integer literals in decimal (without any prefix), hexadecimal (preceded by <code>0x</code> or <code>0X</code>), and octal (preceded by <code>0o</code> or <code>0O</code>). The <code>BinaryLiterals</code> extension adds the option of binary (preceded by <code>0b</code> or <code>0B</code>).</p> <div class="language-hs extra-class"><pre class="language-hs"><code>0b1111 <span class="token operator">==</span> <span class="token number">15</span>     <span class="token comment">-- evaluates to: True</span>

</code></pre></div><h2 id="existentialquantification"><a href="#existentialquantification" class="header-anchor">#</a> ExistentialQuantification</h2> <p>This is a type system extension that allows types that are existentially quantified, or, in other words, have type variables that only get instantiated at runtime<sup>†</sup>.</p> <p>A value of existential type is similar to an abstract-base-class reference in OO languages: you don't know the exact type in contains, but you can constrain the <strong>class</strong> of types.</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">data</span> <span class="token constant">S</span> <span class="token operator">=</span> <span class="token hvariable">forall</span> <span class="token hvariable">a</span><span class="token punctuation">.</span> <span class="token constant">Show</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token constant">S</span> <span class="token hvariable">a</span>

</code></pre></div><p>or equivalently, with GADT syntax:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token comment">{-# LANGUAGE GADTs #-}</span>
<span class="token keyword">data</span> <span class="token constant">S</span> <span class="token keyword">where</span>
   <span class="token constant">S</span> <span class="token operator">::</span> <span class="token constant">Show</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">S</span>

</code></pre></div><p>Existential types open the door to things like almost-heterogenous containers: as said above, there can actually be various types in an <code>S</code> value, but all of them can be <code>show</code>n, hence you can also do</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">instance</span> <span class="token constant">Show</span> <span class="token constant">S</span> <span class="token keyword">where</span>
    <span class="token builtin">show</span> <span class="token punctuation">(</span><span class="token constant">S</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">show</span> <span class="token hvariable">a</span>   <span class="token comment">-- we rely on (Show a) from the above</span>

</code></pre></div><p>Now we can create a collection of such objects:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">ss</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">S</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token constant">S</span> <span class="token string">&quot;test&quot;</span><span class="token punctuation">,</span> <span class="token constant">S</span> <span class="token number">3.0</span><span class="token punctuation">]</span>

</code></pre></div><p>Which also allows us to use the polymorphic behaviour:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token builtin">mapM_</span> <span class="token builtin">print</span> <span class="token hvariable">ss</span>

</code></pre></div><p>Existentials can be very powerful, but note that they are actually not necessary very often in Haskell. In the example above, all you can actually do with the <code>Show</code> instance is show (duh!) the values, i.e. create a string representation. The entire <code>S</code> type therefore contains exactly as much information as the string you get when showing it. Therefore, it is usually better to simply store that string right away, especially since Haskell is lazy and therefore the string will at first only be an unevaluated thunk anyway.</p> <p>On the other hand, existentials cause some unique problems. For instance, the way the type information is “hidden” in an existential. If you pattern-match on an <code>S</code> value, you will have the contained type in scope (more precisely, its <code>Show</code> instance), but this information can never escape its scope, which therefore becomes a bit of a “secret society”: the compiler doesn't let <strong>anything</strong> escape the scope except values whose type is already known from the outside. This can lead to strange errors <a href="http://stackoverflow.com/questions/28582210/type-inference-with-gadts-a0-is-untouchable" target="_blank" rel="noopener noreferrer">like <code>Couldn't match type ‘a0’ with ‘()’ ‘a0’ is untouchable</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <p><sup>†</sup><sub>Contrast this with ordinary parametric polymorphism, which is generally resolved at compile time (allowing full type erasure).</sub></p> <p>Existential types are different from Rank-N types – these extensions are, roughly speaking, dual to each other: to actually use values of an existential type, you need a (possibly constrained-) polymorphic function, like <code>show</code> in the example. A polymorphic function is <strong>universally</strong> quantified, i.e. it works <strong>for any</strong> type in a given class, whereas existential quantification means it works <strong>for some</strong> particular type which is a priori unknown. If you have a polymorphic function, that's sufficient, however to pass polymorphic functions as such as arguments, you need <code>{-# LANGUAGE Rank2Types #-}</code>:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">genShowSs</span> <span class="token operator">::</span> <span class="token punctuation">(</span>∀ <span class="token hvariable">x</span> <span class="token operator">.</span> <span class="token constant">Show</span> <span class="token hvariable">x</span> <span class="token operator">=&gt;</span> <span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">S</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span>
<span class="token hvariable">genShowSs</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token punctuation">(</span><span class="token constant">S</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>

</code></pre></div><h2 id="lambdacase"><a href="#lambdacase" class="header-anchor">#</a> LambdaCase</h2> <p>A syntactic extension that lets you write <code>\case</code> in place of <code>\arg -&gt; case arg of</code>.</p> <p>Consider the following function definition:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">dayOfTheWeek</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">dayOfTheWeek</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token string">&quot;Sunday&quot;</span>
<span class="token hvariable">dayOfTheWeek</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token string">&quot;Monday&quot;</span>
<span class="token hvariable">dayOfTheWeek</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token string">&quot;Tuesday&quot;</span>
<span class="token hvariable">dayOfTheWeek</span> <span class="token number">3</span> <span class="token operator">=</span> <span class="token string">&quot;Wednesday&quot;</span>
<span class="token hvariable">dayOfTheWeek</span> <span class="token number">4</span> <span class="token operator">=</span> <span class="token string">&quot;Thursday&quot;</span>
<span class="token hvariable">dayOfTheWeek</span> <span class="token number">5</span> <span class="token operator">=</span> <span class="token string">&quot;Friday&quot;</span>
<span class="token hvariable">dayOfTheWeek</span> <span class="token number">6</span> <span class="token operator">=</span> <span class="token string">&quot;Saturday&quot;</span>

</code></pre></div><p>If you want to avoid repeating the function name, you might write something like:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">dayOfTheWeek</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">dayOfTheWeek</span> <span class="token hvariable">i</span> <span class="token operator">=</span> <span class="token keyword">case</span> <span class="token hvariable">i</span> <span class="token keyword">of</span>
    <span class="token number">0</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;Sunday&quot;</span>
    <span class="token number">1</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;Monday&quot;</span>
    <span class="token number">2</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;Tuesday&quot;</span>
    <span class="token number">3</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;Wednesday&quot;</span>
    <span class="token number">4</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;Thursday&quot;</span>
    <span class="token number">5</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;Friday&quot;</span>
    <span class="token number">6</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;Saturday&quot;</span>

</code></pre></div><p>Using the LambdaCase extension, you can write that as a function expression, without having to name the argument:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token comment">{-# LANGUAGE LambdaCase #-}</span>

<span class="token hvariable">dayOfTheWeek</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">dayOfTheWeek</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token keyword">case</span>
    <span class="token number">0</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;Sunday&quot;</span>
    <span class="token number">1</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;Monday&quot;</span>
    <span class="token number">2</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;Tuesday&quot;</span>
    <span class="token number">3</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;Wednesday&quot;</span>
    <span class="token number">4</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;Thursday&quot;</span>
    <span class="token number">5</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;Friday&quot;</span>
    <span class="token number">6</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;Saturday&quot;</span>

</code></pre></div><h2 id="functionaldependencies"><a href="#functionaldependencies" class="header-anchor">#</a> FunctionalDependencies</h2> <p>If you have a multi-parameter type-class with arguments a, b, c, and x, this extension lets you express that the type x can be uniquely identified from a, b, and c:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">class</span> <span class="token constant">SomeClass</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token hvariable">c</span> <span class="token hvariable">x</span> <span class="token operator">|</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token hvariable">c</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token keyword">where</span> <span class="token operator">...</span>

</code></pre></div><p>When declaring an instance of such class, it will be checked against all other instances to make sure that the functional dependency holds, that is, no other instance with same <code>a b c</code> but different <code>x</code> exists.</p> <p>You can specify multiple dependencies in a comma-separated list:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">class</span> <span class="token constant">OtherClass</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token hvariable">c</span> <span class="token hvariable">d</span> <span class="token operator">|</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span> <span class="token hvariable">d</span><span class="token punctuation">,</span> <span class="token hvariable">a</span> <span class="token hvariable">d</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token keyword">where</span> <span class="token operator">...</span>

</code></pre></div><p>For example in MTL we can see:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">class</span> <span class="token constant">MonadReader</span> <span class="token hvariable">r</span> <span class="token hvariable">m</span><span class="token operator">|</span> <span class="token hvariable">m</span> <span class="token operator">-&gt;</span> <span class="token hvariable">r</span> <span class="token keyword">where</span> <span class="token operator">...</span>
<span class="token keyword">instance</span> <span class="token constant">MonadReader</span> <span class="token hvariable">r</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">-&gt;</span><span class="token punctuation">)</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token keyword">where</span> <span class="token operator">...</span>

</code></pre></div><p>Now, if you have a value of type <code>MonadReader a ((-&gt;) Foo) =&gt; a</code>, the compiler can infer that <code>a ~ Foo</code>, since the second argument completely determines the first, and will simplify the type accordingly.</p> <p>The <code>SomeClass</code> class can be thought of as a function of the arguments <code>a b c</code> that results in <code>x</code>. Such classes can be used to do computations in the typesystem.</p> <h2 id="flexibleinstances"><a href="#flexibleinstances" class="header-anchor">#</a> FlexibleInstances</h2> <p>Regular instances require:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token constant">All</span> <span class="token keyword">instance</span> <span class="token hvariable">types</span> <span class="token hvariable">must</span> <span class="token hvariable">be</span> <span class="token keyword">of</span> <span class="token hvariable">the</span> <span class="token hvariable">form</span> <span class="token punctuation">(</span><span class="token constant">T</span> <span class="token hvariable">a1</span> <span class="token operator">...</span> <span class="token hvariable">an</span><span class="token punctuation">)</span>
<span class="token keyword">where</span> <span class="token hvariable">a1</span> <span class="token operator">...</span> <span class="token hvariable">an</span> <span class="token hvariable">are</span> <span class="token operator">*</span><span class="token hvariable">distinct</span> <span class="token keyword">type</span> <span class="token hvariable">variables</span><span class="token operator">*</span><span class="token punctuation">,</span>
<span class="token builtin">and</span> <span class="token hvariable">each</span> <span class="token keyword">type</span> <span class="token hvariable">variable</span> <span class="token hvariable">appears</span> <span class="token hvariable">at</span> <span class="token hvariable">most</span> <span class="token hvariable">once</span> <span class="token keyword">in</span> <span class="token hvariable">the</span> <span class="token keyword">instance</span> <span class="token builtin">head</span><span class="token punctuation">.</span>

</code></pre></div><p>That means that, for example, while you can create an instance for <code>[a]</code> you can't create an instance for specifically <code>[Int]</code>.; <code>FlexibleInstances</code> relaxes that:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">class</span> <span class="token constant">C</span> <span class="token hvariable">a</span> <span class="token keyword">where</span>

<span class="token comment">-- works out of the box</span>
<span class="token keyword">instance</span> <span class="token constant">C</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token keyword">where</span>

<span class="token comment">-- requires FlexibleInstances</span>
<span class="token keyword">instance</span> <span class="token constant">C</span> <span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span> <span class="token keyword">where</span>

</code></pre></div><h2 id="gadts"><a href="#gadts" class="header-anchor">#</a> GADTs</h2> <p>Conventional algebraic datatypes are parametric in their type variables. For example, if we define an ADT like</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">data</span> <span class="token constant">Expr</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">IntLit</span> <span class="token constant">Int</span> 
            <span class="token operator">|</span> <span class="token constant">BoolLit</span> <span class="token constant">Bool</span> 
            <span class="token operator">|</span> <span class="token constant">If</span> <span class="token punctuation">(</span><span class="token constant">Expr</span> <span class="token constant">Bool</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Expr</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Expr</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>

</code></pre></div><p>with the hope that this will statically rule out non-well-typed conditionals, this will not behave as expected since the type of <code>IntLit :: Int -&gt; Expr a</code> is universially quantified: for <strong>any</strong> choice of <code>a</code>, it produces a value of type <code>Expr a</code>. In particular, for <code>a ~ Bool</code>, we have <code>IntLit :: Int -&gt; Expr Bool</code>, allowing us to construct something like <code>If (IntLit 1) e1 e2</code> which is what the type of the <code>If</code> constructor was trying to rule out.</p> <p>Generalised Algebraic Data Types allows us to control the resulting type of a data constructor so that they are not merely parametric. We can rewrite our <code>Expr</code> type as a GADT like this:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">data</span> <span class="token constant">Expr</span> <span class="token hvariable">a</span> <span class="token keyword">where</span>
  <span class="token constant">IntLit</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Expr</span> <span class="token constant">Int</span>
  <span class="token constant">BoolLit</span> <span class="token operator">::</span> <span class="token constant">Bool</span> <span class="token operator">-&gt;</span> <span class="token constant">Expr</span> <span class="token constant">Bool</span>
  <span class="token constant">If</span> <span class="token operator">::</span> <span class="token constant">Expr</span> <span class="token constant">Bool</span> <span class="token operator">-&gt;</span> <span class="token constant">Expr</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Expr</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Expr</span> <span class="token hvariable">a</span>

</code></pre></div><p>Here, the type of the constructor <code>IntLit</code> is <code>Int -&gt; Expr Int</code>, and so <code>IntLit 1 :: Expr Bool</code> will not typecheck.</p> <p>Pattern matching on a GADT value causes refinement of the type of the term returned. For example, it is possible to write an evaluator for <code>Expr a</code> like this:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">crazyEval</span> <span class="token operator">::</span> <span class="token constant">Expr</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">crazyEval</span> <span class="token punctuation">(</span><span class="token constant">IntLit</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> 
   <span class="token comment">-- Here we can use `(+)` because x :: Int</span>
   <span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token number">1</span> 
<span class="token hvariable">crazyEval</span> <span class="token punctuation">(</span><span class="token constant">BoolLit</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">=</span> 
   <span class="token comment">-- Here we can use `not` because b :: Bool</span>
   <span class="token builtin">not</span> <span class="token hvariable">b</span>
<span class="token hvariable">crazyEval</span> <span class="token punctuation">(</span><span class="token constant">If</span> <span class="token hvariable">b</span> <span class="token hvariable">thn</span> <span class="token hvariable">els</span><span class="token punctuation">)</span> <span class="token operator">=</span> 
  <span class="token comment">-- Because b :: Expr Bool, we can use `crazyEval b :: Bool`.</span>
  <span class="token comment">-- Also, because thn :: Expr a and els :: Expr a, we can pass either to </span>
  <span class="token comment">-- the recursive call to `crazyEval` and get an a back</span>
  <span class="token hvariable">crazyEval</span> <span class="token operator">$</span> <span class="token keyword">if</span> <span class="token hvariable">crazyEval</span> <span class="token hvariable">b</span> <span class="token keyword">then</span> <span class="token hvariable">thn</span> <span class="token keyword">else</span> <span class="token hvariable">els</span> 

</code></pre></div><p>Note that we are able to use <code>(+)</code> in the above definitions because when e.g. <code>IntLit x</code> is pattern matched, we also learn that <code>a ~ Int</code> (and likewise for <code>not</code> and <code>if_then_else_</code> when <code>a ~ Bool</code>).</p> <h2 id="tuplesections"><a href="#tuplesections" class="header-anchor">#</a> TupleSections</h2> <p>A syntactic extension that allows applying the tuple constructor (which is an operator) in a section way:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token punctuation">,</span><span class="token punctuation">)</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span>

<span class="token comment">-- With TupleSections</span>
<span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token punctuation">,</span><span class="token punctuation">)</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token punctuation">)</span> <span class="token hvariable">b</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token hvariable">a</span>

</code></pre></div><h3 id="n-tuples"><a href="#n-tuples" class="header-anchor">#</a> N-tuples</h3> <p>It also works for tuples with arity greater than two</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token punctuation">(</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">)</span> <span class="token number">1</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>

</code></pre></div><h3 id="mapping"><a href="#mapping" class="header-anchor">#</a> Mapping</h3> <p>This can be useful in other places where sections are used:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token punctuation">,</span><span class="token string">&quot;tag&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">&quot;tag&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">&quot;tag&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">&quot;tag&quot;</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

</code></pre></div><p>The above example without this extension would look like this:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token string">&quot;tag&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>

</code></pre></div><h2 id="overloadedlists"><a href="#overloadedlists" class="header-anchor">#</a> OverloadedLists</h2> <p><strong>added in GHC 7.8</strong>.</p> <p>OverloadedLists, similar to <a href="http://stackoverflow.com/documentation/haskell/1274/common-language-extensions/4173/overloadedstrings" target="_blank" rel="noopener noreferrer">OverloadedStrings<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, allows list literals to be desugared as follows:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token punctuation">[</span><span class="token punctuation">]</span>          <span class="token comment">-- fromListN 0 []</span>
<span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span>         <span class="token comment">-- fromListN 1 (x : [])</span>
<span class="token punctuation">[</span><span class="token hvariable">x</span> <span class="token operator">..</span> <span class="token punctuation">]</span>     <span class="token comment">-- fromList (enumFrom x)</span>

</code></pre></div><p>This comes handy when dealing with types such as <code>Set</code>, <code>Vector</code> and <code>Map</code>s.</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token punctuation">[</span><span class="token char string">'0'</span> <span class="token operator">..</span> <span class="token char string">'9'</span><span class="token punctuation">]</span>             <span class="token operator">::</span> <span class="token constant">Set</span> <span class="token constant">Char</span>
<span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">..</span> <span class="token number">10</span><span class="token punctuation">]</span>                <span class="token operator">::</span> <span class="token constant">Vector</span> <span class="token constant">Int</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">&quot;default&quot;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token hvariable">k1</span><span class="token punctuation">,</span><span class="token hvariable">v1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">::</span> <span class="token constant">Map</span> <span class="token constant">String</span> <span class="token constant">Int</span>
<span class="token punctuation">[</span><span class="token char string">'a'</span> <span class="token operator">..</span> <span class="token char string">'z'</span><span class="token punctuation">]</span>             <span class="token operator">::</span> <span class="token constant">Text</span>

</code></pre></div><p><a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/GHC-Exts.html#t:IsList" target="_blank" rel="noopener noreferrer"><code>IsList</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> class in <code>GHC.Exts</code> is intended to be used with this extension.</p> <p><code>IsList</code> is equipped with one type function, <code>Item</code>, and three functions, <code>fromList :: [Item l] -&gt; l</code>, <code>toList :: l -&gt; [Item l]</code> and <code>fromListN :: Int -&gt; [Item l] -&gt; l</code> where <code>fromListN</code> is optional. Typical implementations are:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">instance</span> <span class="token constant">IsList</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token keyword">where</span>
  <span class="token keyword">type</span> <span class="token constant">Item</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token hvariable">a</span>
  <span class="token hvariable">fromList</span> <span class="token operator">=</span> <span class="token builtin">id</span>
  <span class="token hvariable">toList</span>   <span class="token operator">=</span> <span class="token builtin">id</span>

<span class="token keyword">instance</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">IsList</span> <span class="token punctuation">(</span><span class="token constant">Set</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
  <span class="token keyword">type</span> <span class="token constant">Item</span> <span class="token punctuation">(</span><span class="token constant">Set</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">a</span>
  <span class="token hvariable">fromList</span> <span class="token operator">=</span> <span class="token hvariable">Set<span class="token punctuation">.</span>fromList</span>
  <span class="token hvariable">toList</span>   <span class="token operator">=</span> <span class="token hvariable">Set<span class="token punctuation">.</span>toList</span>

</code></pre></div><p><strong>Examples taken from <a href="https://ghc.haskell.org/trac/ghc/wiki/OverloadedLists" target="_blank" rel="noopener noreferrer">OverloadedLists – GHC<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></strong>.</p> <h2 id="multiparamtypeclasses"><a href="#multiparamtypeclasses" class="header-anchor">#</a> MultiParamTypeClasses</h2> <p>It's a very common extension that allows type classes with multiple type parameters. You can think of MPTC as a relation between types.</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token comment">{-# LANGUAGE MultiParamTypeClasses #-}</span>

<span class="token keyword">class</span> <span class="token constant">Convertable</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token keyword">where</span>
    <span class="token hvariable">convert</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span>

<span class="token keyword">instance</span> <span class="token constant">Convertable</span> <span class="token constant">Int</span> <span class="token constant">Float</span> <span class="token keyword">where</span>
    <span class="token hvariable">convert</span> <span class="token hvariable">i</span> <span class="token operator">=</span> <span class="token builtin">fromIntegral</span> <span class="token hvariable">i</span>

</code></pre></div><p>The order of parameters matters.</p> <p>MPTCs can sometimes be replaced with type families.</p> <h2 id="unicodesyntax"><a href="#unicodesyntax" class="header-anchor">#</a> UnicodeSyntax</h2> <p>An extension that allows you to use Unicode characters in lieu of certain built-in operators and names.</p> <table><thead><tr><th>ASCII</th> <th>Unicode</th> <th>Use(s)</th></tr></thead> <tbody><tr><td><code>::</code></td> <td><code>∷</code></td> <td>has type</td></tr> <tr><td><code>-&gt;</code></td> <td><code>→</code></td> <td>function types, lambdas, <code>case</code> branches, etc.</td></tr> <tr><td><code>=&gt;</code></td> <td><code>⇒</code></td> <td>class constraints</td></tr> <tr><td><code>forall</code></td> <td><code>∀</code></td> <td>explicit polymorphism</td></tr> <tr><td><code>&lt;-</code></td> <td><code>←</code></td> <td><code>do</code> notation</td></tr> <tr><td><code>*</code></td> <td><code>★</code></td> <td>the type (or kind) of types (e.g., <code>Int :: ★</code>)</td></tr> <tr><td><code>&gt;-</code></td> <td><code>⤚</code></td> <td><a href="https://downloads.haskell.org/%7Eghc/8.0.1/docs/html/users_guide/glasgow_exts.html#arrow-notation" target="_blank" rel="noopener noreferrer"><code>proc</code> notation<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> for <a href="https://downloads.haskell.org/%7Eghc/latest/docs/html/libraries/base-4.9.0.0/Control-Arrow.html" target="_blank" rel="noopener noreferrer"><code>Arrows</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></td></tr> <tr><td><code>-&lt;</code></td> <td><code>⤙</code></td> <td><a href="https://downloads.haskell.org/%7Eghc/8.0.1/docs/html/users_guide/glasgow_exts.html#arrow-notation" target="_blank" rel="noopener noreferrer"><code>proc</code> notation<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> for <a href="https://downloads.haskell.org/%7Eghc/latest/docs/html/libraries/base-4.9.0.0/Control-Arrow.html" target="_blank" rel="noopener noreferrer"><code>Arrows</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></td></tr> <tr><td><code>&gt;&gt;-</code></td> <td><code>⤜</code></td> <td><a href="https://downloads.haskell.org/%7Eghc/8.0.1/docs/html/users_guide/glasgow_exts.html#arrow-notation" target="_blank" rel="noopener noreferrer"><code>proc</code> notation<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> for <a href="https://downloads.haskell.org/%7Eghc/latest/docs/html/libraries/base-4.9.0.0/Control-Arrow.html" target="_blank" rel="noopener noreferrer"><code>Arrows</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></td></tr> <tr><td><code>-&lt;&lt;</code></td> <td><code>⤛</code></td> <td><a href="https://downloads.haskell.org/%7Eghc/8.0.1/docs/html/users_guide/glasgow_exts.html#arrow-notation" target="_blank" rel="noopener noreferrer"><code>proc</code> notation<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> for <a href="https://downloads.haskell.org/%7Eghc/latest/docs/html/libraries/base-4.9.0.0/Control-Arrow.html" target="_blank" rel="noopener noreferrer"><code>Arrows</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></td></tr></tbody></table> <p>For example:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">runST</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">forall</span> <span class="token hvariable">s</span><span class="token punctuation">.</span> <span class="token constant">ST</span> <span class="token hvariable">s</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>

</code></pre></div><p>would become</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">runST</span> ∷ <span class="token punctuation">(</span>∀ <span class="token hvariable">s</span><span class="token punctuation">.</span> <span class="token constant">ST</span> <span class="token hvariable">s</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> → <span class="token hvariable">a</span>

</code></pre></div><p>Note that the <code>*</code> vs. <code>★</code> example is slightly different: since <code>*</code> isn't reserved, <code>★</code> also works the same way as <code>*</code> for multiplication, or any other function named <code>(*)</code>, and vice-versa.  For example:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">2</span> ★ <span class="token number">3</span>
<span class="token number">6</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token number">2</span> ★ <span class="token number">3</span>
<span class="token number">5</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token punctuation">(</span>★<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">3</span>
<span class="token operator">-</span><span class="token number">1</span>

</code></pre></div><h2 id="patternsynonyms"><a href="#patternsynonyms" class="header-anchor">#</a> PatternSynonyms</h2> <p><a href="https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms" target="_blank" rel="noopener noreferrer">Pattern synonyms<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> are abstractions of patterns similar to how functions are abstractions of expressions.</p> <p>For this example, let's look at the interface <a href="https://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-Sequence.html" target="_blank" rel="noopener noreferrer"><code>Data.Sequence</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> exposes, and let's see how it can be improved with pattern synonyms. The <a href="https://hackage.haskell.org/package/containers-0.5.7.1/docs/Data-Sequence.html#t:Seq" target="_blank" rel="noopener noreferrer"><code>Seq</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> type is a data type that, internally, uses a <a href="http://staff.city.ac.uk/%7Eross/papers/FingerTree.html" target="_blank" rel="noopener noreferrer">complicated representation<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> to achieve good asymptotic complexity for various operations, most notably both O(1) (un)consing and (un)snocing.</p> <p>But this representation is unwieldy and some of its invariants cannot be expressed in Haskell's type system. Because of this, the <code>Seq</code> type is exposed to users as an abstract type, along with invariant-preserving accessor and constructor functions, among them:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">empty</span> <span class="token operator">::</span> <span class="token constant">Seq</span> <span class="token hvariable">a</span>

<span class="token punctuation">(</span><span class="token operator">&lt;|</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Seq</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Seq</span> <span class="token hvariable">a</span>
<span class="token keyword">data</span> <span class="token constant">ViewL</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">EmptyL</span> <span class="token operator">|</span> <span class="token hvariable">a</span> <span class="token operator">:&lt;</span> <span class="token punctuation">(</span><span class="token constant">Seq</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">viewl</span> <span class="token operator">::</span> <span class="token constant">Seq</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">ViewL</span> <span class="token hvariable">a</span>

<span class="token punctuation">(</span><span class="token operator">|&gt;</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Seq</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Seq</span> <span class="token hvariable">a</span> 
<span class="token keyword">data</span> <span class="token constant">ViewR</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">EmptyR</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token constant">Seq</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">:&gt;</span> <span class="token hvariable">a</span> 
<span class="token hvariable">viewr</span> <span class="token operator">::</span> <span class="token constant">Seq</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">ViewR</span> <span class="token hvariable">a</span>

</code></pre></div><p>But using this interface can be a bit cumbersome:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">uncons</span> <span class="token operator">::</span> <span class="token constant">Seq</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Seq</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">uncons</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token keyword">case</span> <span class="token hvariable">viewl</span> <span class="token hvariable">xs</span> <span class="token keyword">of</span>
    <span class="token hvariable">x</span> <span class="token operator">:&lt;</span> <span class="token hvariable">xs'</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token hvariable">xs'</span><span class="token punctuation">)</span>
    <span class="token constant">EmptyL</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span>

</code></pre></div><p>We can use <a href="https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns" target="_blank" rel="noopener noreferrer">view patterns<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> to clean it up somewhat:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token comment">{-# LANGUAGE ViewPatterns #-}</span>

<span class="token hvariable">uncons</span> <span class="token operator">::</span> <span class="token constant">Seq</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Seq</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">uncons</span> <span class="token punctuation">(</span><span class="token hvariable">viewl</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">:&lt;</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
<span class="token hvariable">uncons</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>

</code></pre></div><p>Using the <code>PatternSynonyms</code> language extension, we can give an even nicer interface by allowing pattern matching to pretend that we have a cons- or a snoc-list:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token comment">{-# LANGUAGE PatternSynonyms #-}</span>
<span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Sequence</span> <span class="token punctuation">(</span><span class="token constant">Seq</span><span class="token punctuation">)</span>
<span class="token import-statement"><span class="token keyword">import</span> <span class="token keyword">qualified</span> Data<span class="token punctuation">.</span>Sequence <span class="token keyword">as</span> Seq</span>

<span class="token hvariable">pattern</span> <span class="token constant">Empty</span> <span class="token operator">::</span> <span class="token constant">Seq</span> <span class="token hvariable">a</span>
<span class="token hvariable">pattern</span> <span class="token constant">Empty</span> <span class="token operator">&lt;-</span> <span class="token punctuation">(</span><span class="token hvariable">Seq<span class="token punctuation">.</span>viewl</span> <span class="token operator">-&gt;</span> <span class="token constant">Seq<span class="token punctuation">.</span>EmptyL</span><span class="token punctuation">)</span>

<span class="token hvariable">pattern</span> <span class="token punctuation">(</span><span class="token operator">:&lt;</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Seq</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Seq</span> <span class="token hvariable">a</span>
<span class="token hvariable">pattern</span> <span class="token hvariable">x</span> <span class="token operator">:&lt;</span> <span class="token hvariable">xs</span> <span class="token operator">&lt;-</span> <span class="token punctuation">(</span><span class="token hvariable">Seq<span class="token punctuation">.</span>viewl</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token constant">Seq</span><span class="token operator">.:&lt;</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>

<span class="token hvariable">pattern</span> <span class="token punctuation">(</span><span class="token operator">:&gt;</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Seq</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Seq</span> <span class="token hvariable">a</span>
<span class="token hvariable">pattern</span> <span class="token hvariable">xs</span> <span class="token operator">:&gt;</span> <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token punctuation">(</span><span class="token hvariable">Seq<span class="token punctuation">.</span>viewr</span> <span class="token operator">-&gt;</span> <span class="token hvariable">xs</span> <span class="token constant">Seq</span><span class="token operator">.:&gt;</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>

</code></pre></div><p>This allows us to write <code>uncons</code> in a very natural style:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">uncons</span> <span class="token operator">::</span> <span class="token constant">Seq</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Seq</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">uncons</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">:&lt;</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
<span class="token hvariable">uncons</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>

</code></pre></div><h2 id="scopedtypevariables"><a href="#scopedtypevariables" class="header-anchor">#</a> ScopedTypeVariables</h2> <p><code>ScopedTypeVariables</code> let you refer to universally quantified types inside of a declaration. To be more explicit:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Monoid</span>

<span class="token hvariable">foo</span> <span class="token operator">::</span> <span class="token hvariable">forall</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token hvariable">c</span><span class="token punctuation">.</span> <span class="token punctuation">(</span><span class="token constant">Monoid</span> <span class="token hvariable">b</span><span class="token punctuation">,</span> <span class="token constant">Monoid</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">b</span><span class="token punctuation">,</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">b</span><span class="token punctuation">,</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">b</span><span class="token punctuation">,</span> <span class="token hvariable">c</span><span class="token punctuation">)</span>
<span class="token hvariable">foo</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">b</span><span class="token punctuation">,</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">b'</span><span class="token punctuation">,</span> <span class="token hvariable">c'</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">::</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">b''</span><span class="token punctuation">,</span> <span class="token hvariable">c''</span><span class="token punctuation">)</span>
    <span class="token keyword">where</span> <span class="token punctuation">(</span><span class="token hvariable">b''</span><span class="token punctuation">,</span> <span class="token hvariable">c''</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">b</span> <span class="token operator">&lt;&gt;</span> <span class="token hvariable">b'</span><span class="token punctuation">,</span> <span class="token hvariable">c</span> <span class="token operator">&lt;&gt;</span> <span class="token hvariable">c'</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">b</span><span class="token punctuation">,</span> <span class="token hvariable">c</span><span class="token punctuation">)</span>

</code></pre></div><p>The important thing is that we can use <code>a</code>, <code>b</code> and <code>c</code> to instruct the compiler in subexpressions of the declaration (the tuple in the <code>where</code> clause and the first <code>a</code> in the final result). In practice, <code>ScopedTypeVariables</code> assist in writing complex functions as a sum of parts, allowing the programmer to add type signatures to intermediate values that don't have concrete types.</p> <h2 id="recordwildcards"><a href="#recordwildcards" class="header-anchor">#</a> RecordWildCards</h2> <p>See <a href="http://stackoverflow.com/documentation/haskell/1950/record-syntax/13072/recordwildcards#t=201607291417389498572" target="_blank" rel="noopener noreferrer">RecordWildCards<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h4 id="remarks"><a href="#remarks" class="header-anchor">#</a> Remarks</h4> <p>These language extensions are typically available when using the Glasgow Haskell Compiler (GHC) as they are not part of the approved <a href="https://www.haskell.org/onlinereport/haskell2010/" target="_blank" rel="noopener noreferrer">Haskell 2010 language Report<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>. To use these extensions, one must either inform the compiler using a <a href="https://downloads.haskell.org/%7Eghc/7.2.2/docs/html/users_guide/flag-reference.html" target="_blank" rel="noopener noreferrer">flag<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> or place <a href="https://downloads.haskell.org/%7Eghc/7.2.2/docs/html/users_guide/pragmas.html" target="_blank" rel="noopener noreferrer">a <code>LANGUAGE</code> programa<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> before the <code>module</code> keyword in a file. The official documentation can be found in <a href="https://downloads.haskell.org/%7Eghc/7.2.2/docs/html/users_guide/ghc-language-features.html" target="_blank" rel="noopener noreferrer">section 7<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> of the GCH users guide.</p> <p>The format of the <code>LANGUAGE</code> programa is <code>{-# LANGUAGE ExtensionOne, ExtensionTwo ... #-}</code>.  That is the literal <code>{-#</code> followed by <code>LANGUAGE</code> followed by a comma separated list of extensions, and finally the closing <code>#-}</code>. Multiple <code>LANGUAGE</code> programas may be placed in one file.</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/devtut/generate/edit/master/docs/haskell/common-ghc-language-extensions.md" target="_blank" rel="noopener noreferrer">Edit this page on GitHub</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/haskell/quickcheck.html" class="prev">
        QuickCheck
      </a></span> <span class="next"><a href="/haskell/free-monads.html">
        Free Monads
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.1779e102.js" defer></script><script src="/assets/js/3.2cfa8016.js" defer></script><script src="/assets/js/1173.47f03932.js" defer></script>
  </body>
</html>
