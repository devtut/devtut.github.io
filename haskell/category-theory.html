<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Haskell - Category Theory</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="description" content="Category theory as a system for organizing abstraction, Haskell types as a category, Definition of a Category, Product of types in Hask, Coproduct of types in Hask, Haskell Applicative in terms of Category Theory">
    <meta property="og:site_name" content="DevTut">
    <meta property="og:title" content="Haskell - Category Theory">
    <meta property="og:description" content="Category theory as a system for organizing abstraction, Haskell types as a category, Definition of a Category, Product of types in Hask, Coproduct of types in Hask, Haskell Applicative in terms of Category Theory">
    <meta property="og:type" content="article">
    <meta property="og:url" content="/haskell/category-theory.html">
    <meta property="og:image" content="/logo.png">
    <meta name="twitter:title" content="Haskell - Category Theory">
    <meta name="twitter:description" content="Category theory as a system for organizing abstraction, Haskell types as a category, Definition of a Category, Product of types in Hask, Coproduct of types in Hask, Haskell Applicative in terms of Category Theory">
    <meta name="twitter:url" content="/haskell/category-theory.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="/logo.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/mstile-150x150.png">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="google-site-verification" content="76_rKXgwMVIjd-axJC_1zPV9OS4mEjvtgjYOWVkAdnQ">
    <link rel="preload" href="/assets/css/0.styles.8b877eb8.css" as="style"><link rel="preload" href="/assets/js/app.ced448ab.js" as="script"><link rel="preload" href="/assets/js/3.f1d73125.js" as="script"><link rel="preload" href="/assets/js/1169.8142c409.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.8b877eb8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">DevTut</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Haskell</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/haskell/" class="sidebar-link">Disclaimer</a></li><li><a href="/haskell/getting-started-with-haskell-language.html" class="sidebar-link">Getting started with Haskell Language</a></li><li><a href="/haskell/overloaded-literals.html" class="sidebar-link">Overloaded Literals</a></li><li><a href="/haskell/foldable.html" class="sidebar-link">Foldable</a></li><li><a href="/haskell/traversable.html" class="sidebar-link">Traversable</a></li><li><a href="/haskell/lens.html" class="sidebar-link">Lens</a></li><li><a href="/haskell/quickcheck.html" class="sidebar-link">QuickCheck</a></li><li><a href="/haskell/common-ghc-language-extensions.html" class="sidebar-link">Common GHC Language Extensions</a></li><li><a href="/haskell/free-monads.html" class="sidebar-link">Free Monads</a></li><li><a href="/haskell/type-classes.html" class="sidebar-link">Type Classes</a></li><li><a href="/haskell/io.html" class="sidebar-link">IO</a></li><li><a href="/haskell/record-syntax.html" class="sidebar-link">Record Syntax</a></li><li><a href="/haskell/partial-application.html" class="sidebar-link">Partial Application</a></li><li><a href="/haskell/monoid.html" class="sidebar-link">Monoid</a></li><li><a href="/haskell/category-theory.html" class="active sidebar-link">Category Theory</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/haskell/category-theory.html#category-theory-as-a-system-for-organizing-abstraction" class="sidebar-link">Category theory as a system for organizing abstraction</a></li><li class="sidebar-sub-header"><a href="/haskell/category-theory.html#haskell-types-as-a-category" class="sidebar-link">Haskell types as a category</a></li><li class="sidebar-sub-header"><a href="/haskell/category-theory.html#definition-of-a-category" class="sidebar-link">Definition of a Category</a></li><li class="sidebar-sub-header"><a href="/haskell/category-theory.html#product-of-types-in-hask" class="sidebar-link">Product of types in Hask</a></li><li class="sidebar-sub-header"><a href="/haskell/category-theory.html#coproduct-of-types-in-hask" class="sidebar-link">Coproduct of types in Hask</a></li><li class="sidebar-sub-header"><a href="/haskell/category-theory.html#haskell-applicative-in-terms-of-category-theory" class="sidebar-link">Haskell Applicative in terms of Category Theory</a></li></ul></li><li><a href="/haskell/lists.html" class="sidebar-link">Lists</a></li><li><a href="/haskell/sorting-algorithms.html" class="sidebar-link">Sorting Algorithms</a></li><li><a href="/haskell/type-families.html" class="sidebar-link">Type Families</a></li><li><a href="/haskell/monads.html" class="sidebar-link">Monads</a></li><li><a href="/haskell/stack.html" class="sidebar-link">Stack</a></li><li><a href="/haskell/generalized-algebraic-data-types.html" class="sidebar-link">Generalized Algebraic Data Types</a></li><li><a href="/haskell/recursion-schemes.html" class="sidebar-link">Recursion Schemes</a></li><li><a href="/haskell/data-text.html" class="sidebar-link">Data.Text</a></li><li><a href="/haskell/using-ghci.html" class="sidebar-link">Using GHCi</a></li><li><a href="/haskell/strictness.html" class="sidebar-link">Strictness</a></li><li><a href="/haskell/syntax-in-functions.html" class="sidebar-link">Syntax in Functions</a></li><li><a href="/haskell/functor.html" class="sidebar-link">Functor</a></li><li><a href="/haskell/testing-with-tasty.html" class="sidebar-link">Testing with Tasty</a></li><li><a href="/haskell/creating-custom-data-types.html" class="sidebar-link">Creating Custom Data Types</a></li><li><a href="/haskell/reactive-banana.html" class="sidebar-link">Reactive-banana</a></li><li><a href="/haskell/optimization.html" class="sidebar-link">Optimization</a></li><li><a href="/haskell/concurrency.html" class="sidebar-link">Concurrency</a></li><li><a href="/haskell/function-composition.html" class="sidebar-link">Function composition</a></li><li><a href="/haskell/databases.html" class="sidebar-link">Databases</a></li><li><a href="/haskell/data-aeson-json-in-haskell.html" class="sidebar-link">Data.Aeson - JSON in Haskell</a></li><li><a href="/haskell/higher-order-functions.html" class="sidebar-link">Higher-order functions</a></li><li><a href="/haskell/containers-data-map.html" class="sidebar-link">Containers - Data.Map</a></li><li><a href="/haskell/fixity-declarations.html" class="sidebar-link">Fixity declarations</a></li><li><a href="/haskell/web-development.html" class="sidebar-link">Web Development</a></li><li><a href="/haskell/vectors.html" class="sidebar-link">Vectors</a></li><li><a href="/haskell/cabal.html" class="sidebar-link">Cabal</a></li><li><a href="/haskell/type-algebra.html" class="sidebar-link">Type algebra</a></li><li><a href="/haskell/arrows.html" class="sidebar-link">Arrows</a></li><li><a href="/haskell/typed-holes.html" class="sidebar-link">Typed holes</a></li><li><a href="/haskell/rewrite-rules-ghc.html" class="sidebar-link">Rewrite rules (GHC)</a></li><li><a href="/haskell/date-and-time.html" class="sidebar-link">Date and Time</a></li><li><a href="/haskell/list-comprehensions.html" class="sidebar-link">List Comprehensions</a></li><li><a href="/haskell/streaming-io.html" class="sidebar-link">Streaming IO</a></li><li><a href="/haskell/google-protocol-buffers.html" class="sidebar-link">Google Protocol Buffers</a></li><li><a href="/haskell/template-haskell-quasiquotes.html" class="sidebar-link">Template Haskell &amp; QuasiQuotes</a></li><li><a href="/haskell/phantom-types.html" class="sidebar-link">Phantom types</a></li><li><a href="/haskell/modules.html" class="sidebar-link">Modules</a></li><li><a href="/haskell/tuples-pairs-triples.html" class="sidebar-link">Tuples (Pairs, Triples, ...)</a></li><li><a href="/haskell/graphics-with-gloss.html" class="sidebar-link">Graphics with Gloss</a></li><li><a href="/haskell/state-monad.html" class="sidebar-link">State Monad</a></li><li><a href="/haskell/pipes.html" class="sidebar-link">Pipes</a></li><li><a href="/haskell/infix-operators.html" class="sidebar-link">Infix operators</a></li><li><a href="/haskell/parallelism.html" class="sidebar-link">Parallelism</a></li><li><a href="/haskell/parsing-html-with-taggy-lens-and-lens.html" class="sidebar-link">Parsing HTML with taggy-lens and lens</a></li><li><a href="/haskell/foreign-function-interface.html" class="sidebar-link">Foreign Function Interface</a></li><li><a href="/haskell/gtk3.html" class="sidebar-link">Gtk3</a></li><li><a href="/haskell/monad-transformers.html" class="sidebar-link">Monad Transformers</a></li><li><a href="/haskell/bifunctor.html" class="sidebar-link">Bifunctor</a></li><li><a href="/haskell/proxies.html" class="sidebar-link">Proxies</a></li><li><a href="/haskell/applicative-functor.html" class="sidebar-link">Applicative Functor</a></li><li><a href="/haskell/common-monads-as-free-monads.html" class="sidebar-link">Common monads as free monads</a></li><li><a href="/haskell/common-functors-as-the-base-of-cofree-comonads.html" class="sidebar-link">Common functors as the base of cofree comonads</a></li><li><a href="/haskell/arithmetic.html" class="sidebar-link">Arithmetic</a></li><li><a href="/haskell/role.html" class="sidebar-link">Role</a></li><li><a href="/haskell/arbitrary-rank-polymorphism-with-rankntypes.html" class="sidebar-link">Arbitrary-rank polymorphism with RankNTypes</a></li><li><a href="/haskell/ghcjs.html" class="sidebar-link">GHCJS</a></li><li><a href="/haskell/xml.html" class="sidebar-link">XML</a></li><li><a href="/haskell/reader-readert.html" class="sidebar-link">Reader / ReaderT</a></li><li><a href="/haskell/function-call-syntax.html" class="sidebar-link">Function call syntax</a></li><li><a href="/haskell/logging.html" class="sidebar-link">Logging</a></li><li><a href="/haskell/attoparsec.html" class="sidebar-link">Attoparsec</a></li><li><a href="/haskell/zipwithm.html" class="sidebar-link">zipWithM</a></li><li><a href="/haskell/profunctor.html" class="sidebar-link">Profunctor</a></li><li><a href="/haskell/type-application.html" class="sidebar-link">Type Application</a></li><li><a href="/haskell/contributors.html" class="sidebar-link">The Contributors</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="category-theory"><a href="#category-theory" class="header-anchor">#</a> Category Theory</h1> <h2 id="category-theory-as-a-system-for-organizing-abstraction"><a href="#category-theory-as-a-system-for-organizing-abstraction" class="header-anchor">#</a> Category theory as a system for organizing abstraction</h2> <p>Category theory is a modern mathematical theory and a branch of abstract algebra focused on the nature of connectedness and relation. It is useful for giving solid foundations and common language to many highly reusable programming abstractions. Haskell uses Category theory as inspiration for some of the core typeclasses available in both the standard library and several popular third-party libraries.</p> <h3 id="an-example"><a href="#an-example" class="header-anchor">#</a> An example</h3> <p>The <code>Functor</code> typeclass says that if a type <code>F</code> instantiates <code>Functor</code> (for which we write <code>Functor F</code>) then we have a generic operation</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token builtin">fmap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">F</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">F</span> <span class="token hvariable">b</span><span class="token punctuation">)</span>

</code></pre></div><p>which lets us &quot;map&quot; over <code>F</code>. The standard (but imperfect) intuition is that <code>F a</code> is a container full of values of type <code>a</code> and <code>fmap</code> lets us apply a transformation to each of these contained elements. An example is <code>Maybe</code></p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token constant">Maybe</span> <span class="token keyword">where</span>
  <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token constant">Nothing</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>     <span class="token comment">-- if there are no values contained, do nothing</span>
  <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token comment">-- else, apply our transformation</span>

</code></pre></div><p>Given this intuition, a common question is &quot;why not call <code>Functor</code> something obvious like <code>Mappable</code>?&quot;.</p> <h3 id="a-hint-of-category-theory"><a href="#a-hint-of-category-theory" class="header-anchor">#</a> A hint of Category Theory</h3> <p>The reason is that Functor fits into a set of common structures in Category theory and therefore by calling <code>Functor</code> &quot;Functor&quot; we can see how it connects to this deeper body of knowledge.</p> <p>In particular, Category Theory is highly concerned with the idea of arrows from one place to another. In Haskell, the most important set of arrows are the function arrows <code>a -&gt; b</code>. A common thing to study in Category Theory is how one set of arrows relates to another set. In particular, for any type constructor <code>F</code>, the set of arrows of the shape <code>F a -&gt; F b</code> are also interesting.</p> <p>So a Functor is any <code>F</code> such that there is a connection between normal Haskell arrows <code>a -&gt; b</code> and the <code>F</code>-specific arrows <code>F a -&gt; F b</code>. The connection is defined by <code>fmap</code> and we also recognize a few laws which must hold</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">forall</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">::</span> <span class="token constant">F</span> <span class="token hvariable">a</span><span class="token punctuation">)</span><span class="token operator"> . </span><span class="token builtin">fmap</span> <span class="token builtin">id</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">x</span>

<span class="token hvariable">forall</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token operator">::</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span><span class="token operator"> . </span><span class="token builtin">fmap</span> <span class="token hvariable">g</span><span class="token operator"> . </span><span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token hvariable">g</span><span class="token operator"> . </span><span class="token hvariable">f</span><span class="token punctuation">)</span>

</code></pre></div><p>All of these laws arise naturally from the Category Theoretic interpretation of <code>Functor</code> and would not be as obviously necessary if we only thought of <code>Functor</code> as relating to &quot;mapping over elements&quot;.</p> <h2 id="haskell-types-as-a-category"><a href="#haskell-types-as-a-category" class="header-anchor">#</a> Haskell types as a category</h2> <h3 id="definition-of-the-category"><a href="#definition-of-the-category" class="header-anchor">#</a> Definition of the category</h3> <p>The Haskell types along with functions between types form (almost†) a category. We have an identity morphism (function) (<code>id :: a -&gt; a</code>) for every object (type) <code>a</code>; and composition of morphisms (<code>(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c</code>), which obey category laws:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">f</span><span class="token operator"> . </span><span class="token builtin">id</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token builtin">id</span><span class="token operator"> . </span><span class="token hvariable">f</span>
<span class="token hvariable">h</span><span class="token operator"> . </span><span class="token punctuation">(</span><span class="token hvariable">g</span><span class="token operator"> . </span><span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">h</span><span class="token operator"> . </span><span class="token hvariable">g</span><span class="token punctuation">)</span><span class="token operator"> . </span><span class="token hvariable">f</span> 

</code></pre></div><p>We usually call this category <strong>Hask</strong>.</p> <h3 id="isomorphisms"><a href="#isomorphisms" class="header-anchor">#</a> Isomorphisms</h3> <p>In category theory, we have an isomorphism when we have a morphism which has an inverse, in other words, there is a morphism which can be composed with it in order to create the identity. In <strong>Hask</strong> this amounts to have a pair of morphisms <code>f</code>,<code>g</code> such that:</p> <div class="language- extra-class"><pre class="language-text"><code>
f . g == id == g . f

</code></pre></div><p>If we find a pair of such morphisms between two types, we call them <strong>isomorphic to one another</strong>.</p> <p>An example of two isomorphic types would be <code>((),a)</code> and <code>a</code> for some <code>a</code>. We can construct the two morphisms:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">f</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">x</span>

<span class="token hvariable">g</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">g</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token hvariable">x</span><span class="token punctuation">)</span>

</code></pre></div><p>And we can check that <code>f . g == id == g . f</code>.</p> <h3 id="functors"><a href="#functors" class="header-anchor">#</a> Functors</h3> <p>A functor, in category theory, goes from a category to another, mapping objects and morphisms. We are working only on one category, the category <strong>Hask</strong> of Haskell types, so we are going to see only functors from <strong>Hask</strong> to <strong>Hask</strong>, those functors, whose origin and destination category are the same, are called <strong>endofunctors</strong>. Our endofunctors will be the polymorphic types taking a type and returning another:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token constant">F</span> <span class="token operator">::</span> <span class="token operator">*</span> <span class="token operator">-&gt;</span> <span class="token operator">*</span>

</code></pre></div><p>To obey the categorical functor laws (preserve identities and composition) is equivalent to obey the Haskell functor laws:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token hvariable">f</span><span class="token operator"> . </span><span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token hvariable">f</span><span class="token punctuation">)</span><span class="token operator"> . </span><span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token hvariable">g</span><span class="token punctuation">)</span>
<span class="token builtin">fmap</span> <span class="token builtin">id</span> <span class="token operator">=</span> <span class="token builtin">id</span>

</code></pre></div><p>So, we have, for example, that <code>[]</code>, <code>Maybe</code> or <code>(-&gt; r)</code> are functors in <strong>Hask</strong>.</p> <h3 id="monads"><a href="#monads" class="header-anchor">#</a> Monads</h3> <p>A monad in category theory is a monoid on the <strong>category of endofunctors</strong>. This category has endofunctors as objects <code>F :: * -&gt; *</code> and natural transformations (transformations between them <code>forall a . F a -&gt; G a</code>) as morphisms.</p> <p>A monoid object can be defined on a monoidal category, and is a type having two morphisms:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">zero</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">M</span>
<span class="token hvariable">mappend</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">M</span><span class="token punctuation">,</span><span class="token constant">M</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">M</span>

</code></pre></div><p>We can translate this roughly to the category of Hask endofunctors as:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token builtin">return</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span>
<span class="token hvariable">join</span> <span class="token operator">::</span> <span class="token hvariable">m</span> <span class="token punctuation">(</span><span class="token hvariable">m</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> 

</code></pre></div><p>And, to obey the monad laws is equivalent to obey the categorical monoid object laws.</p> <p>†In fact, the class of all types along with the class of functions between types do <strong>not</strong> strictly form a category in Haskell, due to the existance of <code>undefined</code>. Typically this is remedied by simply defining the objects of the <strong>Hask</strong> category as types without bottom values, which excludes non-terminating functions and infinite values (codata). For a detailed discussion of this topic, see <a href="https://wiki.haskell.org/Hask" target="_blank" rel="noopener noreferrer">here<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>.</p> <h2 id="definition-of-a-category"><a href="#definition-of-a-category" class="header-anchor">#</a> Definition of a Category</h2> <p>A category <code>C</code> consists of:</p> <ul><li>A collection of objects called <code>Obj(C)</code> ;</li> <li>A collection (called <code>Hom(C)</code>) of morphisms between those objects. If <code>a</code> and <code>b</code> are in <code>Obj(C)</code>, then a morphism <code>f</code> in <code>Hom(C)</code> is typically denoted <code>f : a -&gt; b</code>, and the collection of all morphism between <code>a</code> and <code>b</code> is denoted <code>hom(a,b)</code> ;</li> <li>A special morphism called the <strong>identity</strong> morphism - for every <code>a : Obj(C)</code> there exists a morphism <code>id : a -&gt; a</code> ;</li> <li>A composition operator (<code>.</code>), taking two morphisms <code>f : a -&gt; b</code>, <code>g : b -&gt; c</code> and producing a morphism <code>a -&gt; c</code></li></ul> <p>which obey the following laws:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token constant">For</span> <span class="token builtin">all</span> <span class="token hvariable">f</span> <span class="token operator">:</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token hvariable">g</span> <span class="token operator">:</span> <span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">,</span> <span class="token keyword">then</span> <span class="token builtin">id</span><span class="token operator"> . </span><span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token builtin">and</span> <span class="token hvariable">g</span><span class="token operator"> . </span><span class="token builtin">id</span> <span class="token operator">=</span> <span class="token hvariable">g</span>

</code></pre></div><div class="language-hs extra-class"><pre class="language-hs"><code><span class="token constant">For</span> <span class="token builtin">all</span> <span class="token hvariable">f</span> <span class="token operator">:</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">,</span> <span class="token hvariable">g</span> <span class="token operator">:</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span> <span class="token builtin">and</span> <span class="token hvariable">h</span> <span class="token operator">:</span> <span class="token hvariable">c</span> <span class="token operator">-&gt;</span> <span class="token hvariable">d</span><span class="token punctuation">,</span> <span class="token keyword">then</span> <span class="token hvariable">h</span><span class="token operator"> . </span><span class="token punctuation">(</span><span class="token hvariable">g</span><span class="token operator"> . </span><span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">h</span><span class="token operator"> . </span><span class="token hvariable">g</span><span class="token punctuation">)</span><span class="token operator"> . </span><span class="token hvariable">f</span>

</code></pre></div><p>In other words, composition with the identity morphism (on either the left or right) does not change the other morphism, and composition is associative.</p> <p>In Haskell, the <code>Category</code> is defined as a typeclass in <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Control-Category.html" target="_blank" rel="noopener noreferrer">Control.Category<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>:</p> <p>In this case, <code>cat :: k -&gt; k -&gt; *</code> objectifies the morphism relation - there exists a morphism <code>cat a b</code> if and only if <code>cat a b</code> is inhabited (i.e. has a value). <code>a</code>, <code>b</code> and <code>c</code> are all in <code>Obj(C)</code>. <code>Obj(C)</code> itself is represented by the <strong>kind</strong> <code>k</code> - for example, when <code>k ~ *</code>, as is typically the case, objects are types.</p> <p>The canonical example of a Category in Haskell is the function category:</p> <p>Another common example is the <code>Category</code> of <code>Kleisli</code> arrows for a <code>Monad</code>:</p> <h2 id="product-of-types-in-hask"><a href="#product-of-types-in-hask" class="header-anchor">#</a> Product of types in Hask</h2> <h3 id="categorical-products"><a href="#categorical-products" class="header-anchor">#</a> Categorical products</h3> <p>In category theory, the product of two objects <strong>X</strong>, <strong>Y</strong> is another object <strong>Z</strong> with two projections: <strong>π₁  : Z → X</strong> and <strong>π₂ : Z → Y</strong>; such that any other two morphisms from another object decompose uniquely through those projections. In other words, if there exist <strong>f₁  : W → X</strong> and <strong>f₂  : W → Y</strong>, exists a unique morphism <strong>g : W → Z</strong> such that <strong>π₁ ○ g = f₁</strong> and <strong>π₂ ○ g = f₂</strong>.</p> <h3 id="products-in-hask"><a href="#products-in-hask" class="header-anchor">#</a> Products in Hask</h3> <p>This translates into the <strong>Hask</strong> category of Haskell types as follows, <code>Z</code> is product of <code>A</code>, <code>B</code> when:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token comment">-- if there are two functions</span>
<span class="token hvariable">f1</span> <span class="token operator">::</span> <span class="token constant">W</span> <span class="token operator">-&gt;</span> <span class="token constant">A</span>
<span class="token hvariable">f2</span> <span class="token operator">::</span> <span class="token constant">W</span> <span class="token operator">-&gt;</span> <span class="token constant">B</span>
<span class="token comment">-- we can construct a unique function</span>
<span class="token hvariable">g</span>  <span class="token operator">::</span> <span class="token constant">W</span> <span class="token operator">-&gt;</span> <span class="token constant">Z</span>
<span class="token comment">-- and we have two projections</span>
<span class="token hvariable">p1</span> <span class="token operator">::</span> <span class="token constant">Z</span> <span class="token operator">-&gt;</span> <span class="token constant">A</span>
<span class="token hvariable">p2</span> <span class="token operator">::</span> <span class="token constant">Z</span> <span class="token operator">-&gt;</span> <span class="token constant">B</span>
<span class="token comment">-- such that the other two functions decompose using g</span>
<span class="token hvariable">p1</span><span class="token operator"> . </span><span class="token hvariable">g</span> <span class="token operator">==</span> <span class="token hvariable">f1</span>
<span class="token hvariable">p2</span><span class="token operator"> . </span><span class="token hvariable">g</span> <span class="token operator">==</span> <span class="token hvariable">f2</span>

</code></pre></div><p>The <strong>product type of two types</strong> <code>A</code>, <code>B</code>, which follows the law stated above, <strong>is the tuple</strong> of the two types <code>(A,B)</code>, and the two projections are <code>fst</code> and <code>snd</code>. We can check that it follows the above rule, if we have two functions <code>f1 :: W -&gt; A</code> and <code>f2 :: W -&gt; B</code> we can decompose them uniquely as follow:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">decompose</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">W</span> <span class="token operator">-&gt;</span> <span class="token constant">A</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">W</span> <span class="token operator">-&gt;</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">W</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span><span class="token constant">B</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token hvariable">decompose</span> <span class="token hvariable">f1</span> <span class="token hvariable">f2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">f1</span> <span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token hvariable">f2</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

</code></pre></div><p>And we can check that the decomposition is correct:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token builtin">fst</span><span class="token operator"> . </span><span class="token punctuation">(</span><span class="token hvariable">decompose</span> <span class="token hvariable">f1</span> <span class="token hvariable">f2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f1</span>
<span class="token builtin">snd</span><span class="token operator"> . </span><span class="token punctuation">(</span><span class="token hvariable">decompose</span> <span class="token hvariable">f1</span> <span class="token hvariable">f2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f2</span>

</code></pre></div><h3 id="uniqueness-up-to-isomorphism"><a href="#uniqueness-up-to-isomorphism" class="header-anchor">#</a> Uniqueness up to isomorphism</h3> <p>The choice of <code>(A,B)</code> as the product of <code>A</code> and <code>B</code> is not unique. Another logical and equivalent choice would have been:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">data</span> <span class="token constant">Pair</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token constant">Pair</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span>

</code></pre></div><p>Moreover, we could have also chosen <code>(B,A)</code> as the product, or even <code>(B,A,())</code>, and we could find a decomposition function like the above also following the rules:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">decompose2</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">W</span> <span class="token operator">-&gt;</span> <span class="token constant">A</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">W</span> <span class="token operator">-&gt;</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">W</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span><span class="token constant">A</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token hvariable">decompose2</span> <span class="token hvariable">f1</span> <span class="token hvariable">f2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">f2</span> <span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token hvariable">f1</span> <span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

</code></pre></div><p>This is because the product is not unique but <strong>unique up to isomorphism</strong>. Every two products of <code>A</code> and <code>B</code> do not have to be equal, but they should be isomorphic. As an example, the two different products we have just defined, <code>(A,B)</code> and <code>(B,A,())</code>, are isomorphic:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">iso1</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span><span class="token constant">B</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span><span class="token constant">A</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token hvariable">iso1</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">y</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">y</span><span class="token punctuation">,</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token hvariable">iso2</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span><span class="token constant">A</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span><span class="token constant">B</span><span class="token punctuation">)</span>
<span class="token hvariable">iso2</span> <span class="token punctuation">(</span><span class="token hvariable">y</span><span class="token punctuation">,</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">y</span><span class="token punctuation">)</span>

</code></pre></div><h3 id="uniqueness-of-the-decomposition"><a href="#uniqueness-of-the-decomposition" class="header-anchor">#</a> Uniqueness of the decomposition</h3> <p>It is important to remark that also the decomposition function must be unique. There are types which follow all the rules required to be product, but the decomposition is not unique. As an example, we can try to use <code>(A,(B,Bool))</code> with projections <code>fst</code> <code>fst . snd</code> as a product of <code>A</code> and <code>B</code>:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">decompose3</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">W</span> <span class="token operator">-&gt;</span> <span class="token constant">A</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">W</span> <span class="token operator">-&gt;</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">W</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span><span class="token constant">Bool</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token hvariable">decompose3</span> <span class="token hvariable">f1</span> <span class="token hvariable">f2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">f1</span> <span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token hvariable">f2</span> <span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token constant">True</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

</code></pre></div><p>We can check that it does work:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token builtin">fst</span>        <span class="token operator"> . </span><span class="token punctuation">(</span><span class="token hvariable">decompose3</span> <span class="token hvariable">f1</span> <span class="token hvariable">f2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f1</span> <span class="token hvariable">x</span>
<span class="token punctuation">(</span><span class="token builtin">fst</span><span class="token operator"> . </span><span class="token builtin">snd</span><span class="token punctuation">)</span><span class="token operator"> . </span><span class="token punctuation">(</span><span class="token hvariable">decompose3</span> <span class="token hvariable">f1</span> <span class="token hvariable">f2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f2</span> <span class="token hvariable">x</span>

</code></pre></div><p>But the problem here is that we could have written another decomposition, namely:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">decompose3</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">W</span> <span class="token operator">-&gt;</span> <span class="token constant">A</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">W</span> <span class="token operator">-&gt;</span> <span class="token constant">B</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">W</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span><span class="token constant">Bool</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token hvariable">decompose3</span>' <span class="token hvariable">f1</span> <span class="token hvariable">f2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">f1</span> <span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token hvariable">f2</span> <span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token constant">False</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

</code></pre></div><p>And, as the decomposition is <strong>not unique</strong>, <code>(A,(B,Bool))</code> is <strong>not</strong> the product of <code>A</code> and <code>B</code> in <strong>Hask</strong></p> <h2 id="coproduct-of-types-in-hask"><a href="#coproduct-of-types-in-hask" class="header-anchor">#</a> Coproduct of types in Hask</h2> <h3 id="intuition"><a href="#intuition" class="header-anchor">#</a> Intuition</h3> <p>The categorical product of two types <strong>A</strong> and <strong>B</strong> should contain the minimal information necessary to contain inside an instance of type <strong>A</strong> or type <strong>B</strong>. We can see now that the intuitive coproduct of two types should be <code>Either a b</code>. Other candidates, such as <code>Either a (b,Bool)</code>, would contain a part of unnecessary information, and they wouldn't be minimal.</p> <p>The formal definition is derived from the categorical definition of coproduct.</p> <h3 id="categorical-coproducts"><a href="#categorical-coproducts" class="header-anchor">#</a> Categorical coproducts</h3> <p>A categorical coproduct is the dual notion of a categorical product. It is obtained directly by reversing all the arrows in the definition of the product. The coproduct of two objects <strong>X</strong>,<strong>Y</strong> is another object <strong>Z</strong> with two inclusions: <strong>i_1: X → Z</strong> and <strong>i_2: Y → Z</strong>; such that any other two morphisms from <strong>X</strong> and <strong>Y</strong> to another object decompose uniquely through those inclusions. In other words, if there are two morphisms <strong>f₁ : X → W</strong> and <strong>f₂ : Y → W</strong>, exists a unique morphism <strong>g : Z →  W</strong> such that <strong>g ○ i₁ = f₁</strong> and <strong>g ○ i₂ = f₂</strong></p> <h3 id="coproducts-in-hask"><a href="#coproducts-in-hask" class="header-anchor">#</a> Coproducts in Hask</h3> <p>The translation into the <strong>Hask</strong> category is similar to the translation of the product:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token comment">-- if there are two functions</span>
<span class="token hvariable">f1</span> <span class="token operator">::</span> <span class="token constant">A</span> <span class="token operator">-&gt;</span> <span class="token constant">W</span>
<span class="token hvariable">f2</span> <span class="token operator">::</span> <span class="token constant">B</span> <span class="token operator">-&gt;</span> <span class="token constant">W</span>
<span class="token comment">-- and we have a coproduct with two inclusions</span>
<span class="token hvariable">i1</span> <span class="token operator">::</span> <span class="token constant">A</span> <span class="token operator">-&gt;</span> <span class="token constant">Z</span>
<span class="token hvariable">i2</span> <span class="token operator">::</span> <span class="token constant">B</span> <span class="token operator">-&gt;</span> <span class="token constant">Z</span>
<span class="token comment">-- we can construct a unique function</span>
<span class="token hvariable">g</span>  <span class="token operator">::</span> <span class="token constant">Z</span> <span class="token operator">-&gt;</span> <span class="token constant">W</span>
<span class="token comment">-- such that the other two functions decompose using g</span>
<span class="token hvariable">g</span><span class="token operator"> . </span><span class="token hvariable">i1</span> <span class="token operator">==</span> <span class="token hvariable">f1</span>
<span class="token hvariable">g</span><span class="token operator"> . </span><span class="token hvariable">i2</span> <span class="token operator">==</span> <span class="token hvariable">f2</span>

</code></pre></div><p>The coproduct type of two types <code>A</code> and <code>B</code> in <strong>Hask</strong> is <code>Either a b</code> or any other type isomorphic to it:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token comment">-- Coproduct</span>
<span class="token comment">-- The two inclusions are Left and Right</span>
<span class="token keyword">data</span> <span class="token constant">Either</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token constant">Left</span> <span class="token hvariable">a</span> <span class="token operator">|</span> <span class="token constant">Right</span> <span class="token hvariable">b</span>

<span class="token comment">-- If we have those functions, we can decompose them through the coproduct</span>
<span class="token hvariable">decompose</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">A</span> <span class="token operator">-&gt;</span> <span class="token constant">W</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">B</span> <span class="token operator">-&gt;</span> <span class="token constant">W</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">Either</span> <span class="token constant">A</span> <span class="token constant">B</span> <span class="token operator">-&gt;</span> <span class="token constant">W</span><span class="token punctuation">)</span>
<span class="token hvariable">decompose</span> <span class="token hvariable">f1</span> <span class="token hvariable">f2</span> <span class="token punctuation">(</span><span class="token constant">Left</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>  <span class="token operator">=</span> <span class="token hvariable">f1</span> <span class="token hvariable">x</span>
<span class="token hvariable">decompose</span> <span class="token hvariable">f1</span> <span class="token hvariable">f2</span> <span class="token punctuation">(</span><span class="token constant">Right</span> <span class="token hvariable">y</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f2</span> <span class="token hvariable">y</span> 


</code></pre></div><h2 id="haskell-applicative-in-terms-of-category-theory"><a href="#haskell-applicative-in-terms-of-category-theory" class="header-anchor">#</a> Haskell Applicative in terms of Category Theory</h2> <p>A Haskell's <code>Functor</code> allows one to map any type <code>a</code> (an object of <strong>Hask</strong>) to a type <code>F a</code> and also map a function <code>a -&gt; b</code> (a morphism of <strong>Hask</strong>) to a function with type <code>F a -&gt; F b</code>. This corresponds to a Category Theory definition in a sense that functor preserves basic category structure.</p> <p>A <strong>monoidal category</strong> is a category that has some <strong>additional</strong> structure:</p> <ul><li>A tensor product (see <a href="http://stackoverflow.com/documentation/haskell/2261/category-theory/14649/product-of-types-in-hask#t=201608041651141739494" target="_blank" rel="noopener noreferrer">Product of types in Hask<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>)</li> <li>A tensor unit (unit object)</li></ul> <p>Taking a pair as our product, this definition can be translated to Haskell in the following way:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">class</span> <span class="token constant">Functor</span> <span class="token hvariable">f</span> <span class="token operator">=&gt;</span> <span class="token constant">Monoidal</span> <span class="token hvariable">f</span> <span class="token keyword">where</span>
    <span class="token hvariable">mcat</span> <span class="token operator">::</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">)</span>
    <span class="token hvariable">munit</span> <span class="token operator">::</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre></div><p>The <code>Applicative</code> class is equivalent to this <code>Monoidal</code> one and thus can be implemented in terms of it:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">instance</span> <span class="token constant">Monoidal</span> <span class="token hvariable">f</span> <span class="token operator">=&gt;</span> <span class="token constant">Applicative</span> <span class="token hvariable">f</span> <span class="token keyword">where</span>
    <span class="token hvariable">pure</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token builtin">const</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token hvariable">munit</span>
    <span class="token hvariable">f</span> <span class="token operator">&lt;*&gt;</span> <span class="token hvariable">fa</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token punctuation">(</span><span class="token hvariable">f</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">mcat</span> <span class="token hvariable">f</span> <span class="token hvariable">fa</span><span class="token punctuation">)</span>

</code></pre></div></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/devtut/generate/edit/master/docs/haskell/category-theory.md" target="_blank" rel="noopener noreferrer">Edit this page on GitHub</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/haskell/monoid.html" class="prev">
        Monoid
      </a></span> <span class="next"><a href="/haskell/lists.html">
        Lists
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.ced448ab.js" defer></script><script src="/assets/js/3.f1d73125.js" defer></script><script src="/assets/js/1169.8142c409.js" defer></script>
  </body>
</html>
