<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Haskell - Functor</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="description" content="Class Definition of Functor and Laws, Common instances of Functor, Replacing all elements of a Functor with a single value, Polynomial functors, Functors in Category Theory, Deriving Functor">
    <meta property="og:site_name" content="DevTut">
    <meta property="og:title" content="Haskell - Functor">
    <meta property="og:description" content="Class Definition of Functor and Laws, Common instances of Functor, Replacing all elements of a Functor with a single value, Polynomial functors, Functors in Category Theory, Deriving Functor">
    <meta property="og:type" content="article">
    <meta property="og:url" content="/haskell/functor.html">
    <meta property="og:image" content="/logo.png">
    <meta name="twitter:title" content="Haskell - Functor">
    <meta name="twitter:description" content="Class Definition of Functor and Laws, Common instances of Functor, Replacing all elements of a Functor with a single value, Polynomial functors, Functors in Category Theory, Deriving Functor">
    <meta name="twitter:url" content="/haskell/functor.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="/logo.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/mstile-150x150.png">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="google-site-verification" content="76_rKXgwMVIjd-axJC_1zPV9OS4mEjvtgjYOWVkAdnQ">
    <link rel="preload" href="/assets/css/0.styles.8b877eb8.css" as="style"><link rel="preload" href="/assets/js/app.ced448ab.js" as="script"><link rel="preload" href="/assets/js/3.f1d73125.js" as="script"><link rel="preload" href="/assets/js/1187.5820b415.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.8b877eb8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">DevTut</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Haskell</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/haskell/" class="sidebar-link">Disclaimer</a></li><li><a href="/haskell/getting-started-with-haskell-language.html" class="sidebar-link">Getting started with Haskell Language</a></li><li><a href="/haskell/overloaded-literals.html" class="sidebar-link">Overloaded Literals</a></li><li><a href="/haskell/foldable.html" class="sidebar-link">Foldable</a></li><li><a href="/haskell/traversable.html" class="sidebar-link">Traversable</a></li><li><a href="/haskell/lens.html" class="sidebar-link">Lens</a></li><li><a href="/haskell/quickcheck.html" class="sidebar-link">QuickCheck</a></li><li><a href="/haskell/common-ghc-language-extensions.html" class="sidebar-link">Common GHC Language Extensions</a></li><li><a href="/haskell/free-monads.html" class="sidebar-link">Free Monads</a></li><li><a href="/haskell/type-classes.html" class="sidebar-link">Type Classes</a></li><li><a href="/haskell/io.html" class="sidebar-link">IO</a></li><li><a href="/haskell/record-syntax.html" class="sidebar-link">Record Syntax</a></li><li><a href="/haskell/partial-application.html" class="sidebar-link">Partial Application</a></li><li><a href="/haskell/monoid.html" class="sidebar-link">Monoid</a></li><li><a href="/haskell/category-theory.html" class="sidebar-link">Category Theory</a></li><li><a href="/haskell/lists.html" class="sidebar-link">Lists</a></li><li><a href="/haskell/sorting-algorithms.html" class="sidebar-link">Sorting Algorithms</a></li><li><a href="/haskell/type-families.html" class="sidebar-link">Type Families</a></li><li><a href="/haskell/monads.html" class="sidebar-link">Monads</a></li><li><a href="/haskell/stack.html" class="sidebar-link">Stack</a></li><li><a href="/haskell/generalized-algebraic-data-types.html" class="sidebar-link">Generalized Algebraic Data Types</a></li><li><a href="/haskell/recursion-schemes.html" class="sidebar-link">Recursion Schemes</a></li><li><a href="/haskell/data-text.html" class="sidebar-link">Data.Text</a></li><li><a href="/haskell/using-ghci.html" class="sidebar-link">Using GHCi</a></li><li><a href="/haskell/strictness.html" class="sidebar-link">Strictness</a></li><li><a href="/haskell/syntax-in-functions.html" class="sidebar-link">Syntax in Functions</a></li><li><a href="/haskell/functor.html" class="active sidebar-link">Functor</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/haskell/functor.html#class-definition-of-functor-and-laws" class="sidebar-link">Class Definition of Functor and Laws</a></li><li class="sidebar-sub-header"><a href="/haskell/functor.html#common-instances-of-functor" class="sidebar-link">Common instances of Functor</a></li><li class="sidebar-sub-header"><a href="/haskell/functor.html#replacing-all-elements-of-a-functor-with-a-single-value" class="sidebar-link">Replacing all elements of a Functor with a single value</a></li><li class="sidebar-sub-header"><a href="/haskell/functor.html#polynomial-functors" class="sidebar-link">Polynomial functors</a></li><li class="sidebar-sub-header"><a href="/haskell/functor.html#functors-in-category-theory" class="sidebar-link">Functors in Category Theory</a></li><li class="sidebar-sub-header"><a href="/haskell/functor.html#deriving-functor" class="sidebar-link">Deriving Functor</a></li></ul></li><li><a href="/haskell/testing-with-tasty.html" class="sidebar-link">Testing with Tasty</a></li><li><a href="/haskell/creating-custom-data-types.html" class="sidebar-link">Creating Custom Data Types</a></li><li><a href="/haskell/reactive-banana.html" class="sidebar-link">Reactive-banana</a></li><li><a href="/haskell/optimization.html" class="sidebar-link">Optimization</a></li><li><a href="/haskell/concurrency.html" class="sidebar-link">Concurrency</a></li><li><a href="/haskell/function-composition.html" class="sidebar-link">Function composition</a></li><li><a href="/haskell/databases.html" class="sidebar-link">Databases</a></li><li><a href="/haskell/data-aeson-json-in-haskell.html" class="sidebar-link">Data.Aeson - JSON in Haskell</a></li><li><a href="/haskell/higher-order-functions.html" class="sidebar-link">Higher-order functions</a></li><li><a href="/haskell/containers-data-map.html" class="sidebar-link">Containers - Data.Map</a></li><li><a href="/haskell/fixity-declarations.html" class="sidebar-link">Fixity declarations</a></li><li><a href="/haskell/web-development.html" class="sidebar-link">Web Development</a></li><li><a href="/haskell/vectors.html" class="sidebar-link">Vectors</a></li><li><a href="/haskell/cabal.html" class="sidebar-link">Cabal</a></li><li><a href="/haskell/type-algebra.html" class="sidebar-link">Type algebra</a></li><li><a href="/haskell/arrows.html" class="sidebar-link">Arrows</a></li><li><a href="/haskell/typed-holes.html" class="sidebar-link">Typed holes</a></li><li><a href="/haskell/rewrite-rules-ghc.html" class="sidebar-link">Rewrite rules (GHC)</a></li><li><a href="/haskell/date-and-time.html" class="sidebar-link">Date and Time</a></li><li><a href="/haskell/list-comprehensions.html" class="sidebar-link">List Comprehensions</a></li><li><a href="/haskell/streaming-io.html" class="sidebar-link">Streaming IO</a></li><li><a href="/haskell/google-protocol-buffers.html" class="sidebar-link">Google Protocol Buffers</a></li><li><a href="/haskell/template-haskell-quasiquotes.html" class="sidebar-link">Template Haskell &amp; QuasiQuotes</a></li><li><a href="/haskell/phantom-types.html" class="sidebar-link">Phantom types</a></li><li><a href="/haskell/modules.html" class="sidebar-link">Modules</a></li><li><a href="/haskell/tuples-pairs-triples.html" class="sidebar-link">Tuples (Pairs, Triples, ...)</a></li><li><a href="/haskell/graphics-with-gloss.html" class="sidebar-link">Graphics with Gloss</a></li><li><a href="/haskell/state-monad.html" class="sidebar-link">State Monad</a></li><li><a href="/haskell/pipes.html" class="sidebar-link">Pipes</a></li><li><a href="/haskell/infix-operators.html" class="sidebar-link">Infix operators</a></li><li><a href="/haskell/parallelism.html" class="sidebar-link">Parallelism</a></li><li><a href="/haskell/parsing-html-with-taggy-lens-and-lens.html" class="sidebar-link">Parsing HTML with taggy-lens and lens</a></li><li><a href="/haskell/foreign-function-interface.html" class="sidebar-link">Foreign Function Interface</a></li><li><a href="/haskell/gtk3.html" class="sidebar-link">Gtk3</a></li><li><a href="/haskell/monad-transformers.html" class="sidebar-link">Monad Transformers</a></li><li><a href="/haskell/bifunctor.html" class="sidebar-link">Bifunctor</a></li><li><a href="/haskell/proxies.html" class="sidebar-link">Proxies</a></li><li><a href="/haskell/applicative-functor.html" class="sidebar-link">Applicative Functor</a></li><li><a href="/haskell/common-monads-as-free-monads.html" class="sidebar-link">Common monads as free monads</a></li><li><a href="/haskell/common-functors-as-the-base-of-cofree-comonads.html" class="sidebar-link">Common functors as the base of cofree comonads</a></li><li><a href="/haskell/arithmetic.html" class="sidebar-link">Arithmetic</a></li><li><a href="/haskell/role.html" class="sidebar-link">Role</a></li><li><a href="/haskell/arbitrary-rank-polymorphism-with-rankntypes.html" class="sidebar-link">Arbitrary-rank polymorphism with RankNTypes</a></li><li><a href="/haskell/ghcjs.html" class="sidebar-link">GHCJS</a></li><li><a href="/haskell/xml.html" class="sidebar-link">XML</a></li><li><a href="/haskell/reader-readert.html" class="sidebar-link">Reader / ReaderT</a></li><li><a href="/haskell/function-call-syntax.html" class="sidebar-link">Function call syntax</a></li><li><a href="/haskell/logging.html" class="sidebar-link">Logging</a></li><li><a href="/haskell/attoparsec.html" class="sidebar-link">Attoparsec</a></li><li><a href="/haskell/zipwithm.html" class="sidebar-link">zipWithM</a></li><li><a href="/haskell/profunctor.html" class="sidebar-link">Profunctor</a></li><li><a href="/haskell/type-application.html" class="sidebar-link">Type Application</a></li><li><a href="/haskell/contributors.html" class="sidebar-link">The Contributors</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="functor"><a href="#functor" class="header-anchor">#</a> Functor</h1> <h2 id="class-definition-of-functor-and-laws"><a href="#class-definition-of-functor-and-laws" class="header-anchor">#</a> Class Definition of Functor and Laws</h2> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">class</span> <span class="token constant">Functor</span> <span class="token hvariable">f</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>

</code></pre></div><p>One way of looking at it is that <code>fmap</code> <strong>lifts</strong> a function of values into a function of values in a context <code>f</code>.</p> <p>A correct instance of <code>Functor</code> should satisfy the <strong>functor laws</strong>, though these are not enforced by the compiler:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token builtin">fmap</span> <span class="token builtin">id</span> <span class="token operator">=</span> <span class="token builtin">id</span>                    <span class="token comment">-- identity</span>
<span class="token builtin">fmap</span> <span class="token hvariable">f</span><span class="token operator"> . </span><span class="token builtin">fmap</span> <span class="token hvariable">g</span> <span class="token operator">=</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token hvariable">f</span><span class="token operator"> . </span><span class="token hvariable">g</span><span class="token punctuation">)</span>  <span class="token comment">-- composition</span>

</code></pre></div><p>There's a commonly-used infix alias for <code>fmap</code> called <code>&lt;$&gt;</code>.</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">infixl</span> <span class="token number">4</span> <span class="token operator">&lt;$&gt;</span>
<span class="token punctuation">(</span><span class="token operator">&lt;$&gt;</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Functor</span> <span class="token hvariable">f</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>
<span class="token punctuation">(</span><span class="token operator">&lt;$&gt;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">fmap</span>

</code></pre></div><h2 id="common-instances-of-functor"><a href="#common-instances-of-functor" class="header-anchor">#</a> Common instances of Functor</h2> <h3 id="maybe"><a href="#maybe" class="header-anchor">#</a> Maybe</h3> <p><code>Maybe</code> is a <code>Functor</code> containing a possibly-absent value:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token constant">Maybe</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token constant">Nothing</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>

</code></pre></div><p><code>Maybe</code>'s instance of <code>Functor</code> applies a function to a value wrapped in a <code>Just</code>. If the computation has previously failed (so the <code>Maybe</code> value is a <code>Nothing</code>), then there's no value to apply the function to, so <code>fmap</code> is a no-op.</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token number">6</span>
<span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token builtin">length</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token string">&quot;mousetrap&quot;</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token number">9</span>
<span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token builtin">sqrt</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>

</code></pre></div><p>We can check the functor laws for this instance using equational reasoning. For the identity law,</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token builtin">fmap</span> <span class="token builtin">id</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>  <span class="token comment">-- definition of fmap</span>
<span class="token builtin">id</span> <span class="token constant">Nothing</span>  <span class="token comment">-- definition of id</span>

<span class="token builtin">fmap</span> <span class="token builtin">id</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token builtin">id</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>  <span class="token comment">-- definition of fmap</span>
<span class="token constant">Just</span> <span class="token hvariable">x</span>  <span class="token comment">-- definition of id</span>
<span class="token builtin">id</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>  <span class="token comment">-- definition of id</span>

</code></pre></div><p>For the composition law,</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token hvariable">f</span><span class="token operator"> . </span><span class="token builtin">fmap</span> <span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token constant">Nothing</span>
<span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token hvariable">g</span> <span class="token constant">Nothing</span><span class="token punctuation">)</span>  <span class="token comment">-- definition of (.)</span>
<span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token constant">Nothing</span>  <span class="token comment">-- definition of fmap</span>
<span class="token constant">Nothing</span>  <span class="token comment">-- definition of fmap</span>
<span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token hvariable">f</span><span class="token operator"> . </span><span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token constant">Nothing</span>  <span class="token comment">-- because Nothing = fmap f Nothing, for all f</span>

<span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token hvariable">f</span><span class="token operator"> . </span><span class="token builtin">fmap</span> <span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
<span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token hvariable">g</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">-- definition of (.)</span>
<span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">-- definition of fmap</span>
<span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">-- definition of fmap</span>
<span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token hvariable">f</span><span class="token operator"> . </span><span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>  <span class="token comment">-- definition of (.)</span>
<span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token hvariable">f</span><span class="token operator"> . </span><span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>  <span class="token comment">-- definition of fmap</span>

</code></pre></div><h3 id="lists"><a href="#lists" class="header-anchor">#</a> Lists</h3> <p>Lists' instance of <code>Functor</code> applies the function to every value in the list in place.</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token hvariable">xs</span>

</code></pre></div><p>This could alternatively be written as a list comprehension: <code>fmap f xs = [f x | x &lt;- xs]</code>.</p> <p>This example shows that <code>fmap</code> generalises <code>map</code>. <code>map</code> only operates on lists, whereas <code>fmap</code> works on an arbitrary <code>Functor</code>.</p> <p>The identity law can be shown to hold by induction:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token comment">-- base case</span>
<span class="token builtin">fmap</span> <span class="token builtin">id</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment">-- definition of fmap</span>
<span class="token builtin">id</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment">-- definition of id</span>

<span class="token comment">-- inductive step</span>
<span class="token builtin">fmap</span> <span class="token builtin">id</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span>
<span class="token builtin">id</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token builtin">fmap</span> <span class="token builtin">id</span> <span class="token hvariable">xs</span>  <span class="token comment">-- definition of fmap</span>
<span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token builtin">fmap</span> <span class="token builtin">id</span> <span class="token hvariable">xs</span>  <span class="token comment">-- definition of id</span>
<span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token builtin">id</span> <span class="token hvariable">xs</span>  <span class="token comment">-- by the inductive hypothesis</span>
<span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token hvariable">xs</span>  <span class="token comment">-- definition of id</span>
<span class="token builtin">id</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>  <span class="token comment">-- definition of id</span>

</code></pre></div><p>and similarly, the composition law:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token comment">-- base case</span>
<span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token hvariable">f</span><span class="token operator"> . </span><span class="token builtin">fmap</span> <span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token hvariable">g</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">-- definition of (.)</span>
<span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment">-- definition of fmap</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment">-- definition of fmap</span>
<span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token hvariable">f</span><span class="token operator"> . </span><span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment">-- because [] = fmap f [], for all f</span>

<span class="token comment">-- inductive step</span>
<span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token hvariable">f</span><span class="token operator"> . </span><span class="token builtin">fmap</span> <span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span>
<span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token hvariable">g</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">-- definition of (.)</span>
<span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token builtin">fmap</span> <span class="token hvariable">g</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>  <span class="token comment">-- definition of fmap</span>
<span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token hvariable">g</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>  <span class="token comment">-- definition of fmap</span>
<span class="token punctuation">(</span><span class="token hvariable">f</span><span class="token operator"> . </span><span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token hvariable">g</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>  <span class="token comment">-- definition of (.)</span>
<span class="token punctuation">(</span><span class="token hvariable">f</span><span class="token operator"> . </span><span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token hvariable">f</span><span class="token operator"> . </span><span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token hvariable">xs</span>  <span class="token comment">-- by the inductive hypothesis</span>
<span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token hvariable">f</span><span class="token operator"> . </span><span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token hvariable">xs</span>  <span class="token comment">-- definition of fmap</span>

</code></pre></div><h3 id="functions"><a href="#functions" class="header-anchor">#</a> Functions</h3> <p>Not every <code>Functor</code> looks like a container. Functions' instance of <code>Functor</code> applies a function to the return value of another function.</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">-&gt;</span><span class="token punctuation">)</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token hvariable">g</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>

</code></pre></div><p>Note that this definition is equivalent to <code>fmap = (.)</code>. So <code>fmap</code> generalises function composition.</p> <p>Once more checking the identity law:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token builtin">fmap</span> <span class="token builtin">id</span> <span class="token hvariable">g</span>
<span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token builtin">id</span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>  <span class="token comment">-- definition of fmap</span>
<span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">g</span> <span class="token hvariable">x</span>  <span class="token comment">-- definition of id</span>
<span class="token hvariable">g</span>  <span class="token comment">-- eta-reduction</span>
<span class="token builtin">id</span> <span class="token hvariable">g</span>  <span class="token comment">-- definition of id</span>

</code></pre></div><p>and the composition law:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token hvariable">f</span><span class="token operator"> . </span><span class="token builtin">fmap</span> <span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token hvariable">h</span>
<span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token hvariable">g</span> <span class="token hvariable">h</span><span class="token punctuation">)</span>  <span class="token comment">-- definition of (.)</span>
<span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">g</span> <span class="token punctuation">(</span><span class="token hvariable">h</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">-- definition of fmap</span>
<span class="token operator">\</span><span class="token hvariable">y</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">g</span> <span class="token punctuation">(</span><span class="token hvariable">h</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>  <span class="token comment">-- definition of fmap</span>
<span class="token operator">\</span><span class="token hvariable">y</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token punctuation">(</span><span class="token hvariable">h</span> <span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">-- beta-reduction</span>
<span class="token operator">\</span><span class="token hvariable">y</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">f</span><span class="token operator"> . </span><span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">h</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>  <span class="token comment">-- definition of (.)</span>
<span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token hvariable">f</span><span class="token operator"> . </span><span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token hvariable">h</span>  <span class="token comment">-- definition of fmap</span>

</code></pre></div><h2 id="replacing-all-elements-of-a-functor-with-a-single-value"><a href="#replacing-all-elements-of-a-functor-with-a-single-value" class="header-anchor">#</a> Replacing all elements of a Functor with a single value</h2> <p>The <code>Data.Functor</code> module contains two combinators, <code>&lt;$</code> and <code>$&gt;</code>, which ignore all of the values contained in a functor, replacing them all with a single constant value.</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">infixl</span> <span class="token number">4</span> <span class="token operator">&lt;$</span><span class="token punctuation">,</span> <span class="token operator">$&gt;</span>

<span class="token operator">&lt;$</span> <span class="token operator">::</span> <span class="token constant">Functor</span> <span class="token hvariable">f</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span>
<span class="token punctuation">(</span><span class="token operator">&lt;$</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">fmap</span><span class="token operator"> . </span><span class="token builtin">const</span>

<span class="token operator">$&gt;</span> <span class="token operator">::</span> <span class="token constant">Functor</span> <span class="token hvariable">f</span> <span class="token operator">=&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>
<span class="token punctuation">(</span><span class="token operator">$&gt;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">flip</span> <span class="token punctuation">(</span><span class="token operator">&lt;$</span><span class="token punctuation">)</span>

</code></pre></div><p><code>void</code> ignores the return value of a computation.</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">void</span> <span class="token operator">::</span> <span class="token constant">Functor</span> <span class="token hvariable">f</span> <span class="token operator">=&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">void</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;$</span><span class="token punctuation">)</span>

</code></pre></div><h2 id="polynomial-functors"><a href="#polynomial-functors" class="header-anchor">#</a> Polynomial functors</h2> <p>There's a useful set of type combinators for building big <code>Functor</code>s out of smaller ones. These are instructive as example instances of <code>Functor</code>, and they're also useful as a technique for generic programming, because they can be used to represent a large class of common functors.</p> <h3 id="the-identity-functor"><a href="#the-identity-functor" class="header-anchor">#</a> The identity functor</h3> <p>The identity functor simply wraps up its argument. It's a type-level implementation of the <code>I</code> combinator from SKI calculus.</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">newtype</span> <span class="token constant">I</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">I</span> <span class="token hvariable">a</span>

<span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token constant">I</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">I</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">I</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>

</code></pre></div><p><code>I</code> can be found, under the name of <code>Identity</code>, in <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Functor-Identity.html" target="_blank" rel="noopener noreferrer">the <code>Data.Functor.Identity</code> module<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>.</p> <h3 id="the-constant-functor"><a href="#the-constant-functor" class="header-anchor">#</a> The constant functor</h3> <p>The constant functor ignores its second argument, containing only a constant value. It's a type-level analogue of <code>const</code>, the <code>K</code> combinator from SKI calculus.</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">newtype</span> <span class="token constant">K</span> <span class="token hvariable">c</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">K</span> <span class="token hvariable">c</span>

</code></pre></div><p>Note that <code>K c a</code> doesn't contain any <code>a</code>-values; <code>K ()</code> is isomorphic to <a href="http://stackoverflow.com/documentation/haskell/8025/proxies#t=201611271824312213601" target="_blank" rel="noopener noreferrer"><code>Proxy</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>. This means that <code>K</code>'s implementation of <code>fmap</code> doesn't do any mapping at all!</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token punctuation">(</span><span class="token constant">K</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">_</span> <span class="token punctuation">(</span><span class="token constant">K</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">K</span> <span class="token hvariable">c</span>

</code></pre></div><p><code>K</code> is otherwise known as <code>Const</code>, from <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Functor-Const.html" target="_blank" rel="noopener noreferrer"><code>Data.Functor.Const</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>.</p> <p>The remaining functors in this example combine smaller functors into bigger ones.</p> <h3 id="functor-products"><a href="#functor-products" class="header-anchor">#</a> Functor products</h3> <p>The functor product takes a pair of functors and packs them up. It's analogous to a tuple, except that while <code>(,) :: * -&gt; * -&gt; *</code> operates on <code>types</code> <code>*</code>, <code>(:*:) :: (* -&gt; *) -&gt; (* -&gt; *) -&gt; (* -&gt; *)</code> operates on <code>functors</code> <code>* -&gt; *</code>.</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">infixl</span> <span class="token number">7</span> <span class="token operator">:*:</span>
<span class="token keyword">data</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token operator">:*:</span> <span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">:*:</span> <span class="token hvariable">g</span> <span class="token hvariable">a</span>

<span class="token keyword">instance</span> <span class="token punctuation">(</span><span class="token constant">Functor</span> <span class="token hvariable">f</span><span class="token punctuation">,</span> <span class="token constant">Functor</span> <span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Functor</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token operator">:*:</span> <span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">fx</span> <span class="token operator">:*:</span> <span class="token hvariable">gy</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token hvariable">fx</span> <span class="token operator">:*:</span> <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token hvariable">gy</span>

</code></pre></div><p>This type can be found, under the name <code>Product</code>, in <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Functor-Product.html" target="_blank" rel="noopener noreferrer">the <code>Data.Functor.Product</code> module<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>.</p> <h3 id="functor-coproducts"><a href="#functor-coproducts" class="header-anchor">#</a> Functor coproducts</h3> <p>Just like <code>:*:</code> is analogous to <code>(,)</code>, <code>:+:</code> is the functor-level analogue of <code>Either</code>.</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">infixl</span> <span class="token number">6</span> <span class="token operator">:+:</span>
<span class="token keyword">data</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token operator">:+:</span> <span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">InL</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token constant">InR</span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>

<span class="token keyword">instance</span> <span class="token punctuation">(</span><span class="token constant">Functor</span> <span class="token hvariable">f</span><span class="token punctuation">,</span> <span class="token constant">Functor</span> <span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Functor</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token operator">:+:</span> <span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">InL</span> <span class="token hvariable">fx</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">InL</span> <span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token hvariable">fx</span><span class="token punctuation">)</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">InR</span> <span class="token hvariable">gy</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">InR</span> <span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token hvariable">gy</span><span class="token punctuation">)</span>

</code></pre></div><p><code>:+:</code> can be found under the name <code>Sum</code>, in <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Functor-Sum.html" target="_blank" rel="noopener noreferrer">the <code>Data.Functor.Sum</code> module<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>.</p> <h3 id="functor-composition"><a href="#functor-composition" class="header-anchor">#</a> Functor composition</h3> <p>Finally, <code>:.:</code> works like a type-level <code>(.)</code>, taking the output of one functor and plumbing it into the input of another.</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">infixr</span> <span class="token number">9</span> <span class="token operator">:.:</span>
<span class="token keyword">newtype</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token operator">:.:</span> <span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Cmp</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token hvariable">a</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">instance</span> <span class="token punctuation">(</span><span class="token constant">Functor</span> <span class="token hvariable">f</span><span class="token punctuation">,</span> <span class="token constant">Functor</span> <span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Functor</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token operator">:.:</span> <span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Cmp</span> <span class="token hvariable">fgx</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Cmp</span> <span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token hvariable">fgx</span><span class="token punctuation">)</span>

</code></pre></div><p>The <code>Compose</code> type can be found in <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/Data-Functor-Compose.html" target="_blank" rel="noopener noreferrer"><code>Data.Functor.Compose</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="polynomial-functors-for-generic-programming"><a href="#polynomial-functors-for-generic-programming" class="header-anchor">#</a> Polynomial functors for generic programming</h3> <p><code>I</code>, <code>K</code>, <code>:*:</code>, <code>:+:</code> and <code>:.:</code> can be thought of as a kit of building blocks for a certain class of simple datatypes. The kit becomes especially powerful when you combine it with <a href="http://stackoverflow.com/documentation/haskell/2984/recursion-schemes/10136/fixed-points#t=201611271723029746936" target="_blank" rel="noopener noreferrer">fixed points<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> because datatypes built with these combinators are automatically instances of <code>Functor</code>. You use the kit to build a template type, marking recursive points using <code>I</code>, and then plug it into <code>Fix</code> to get a type that can be used with the standard zoo of recursion schemes.</p> <table><thead><tr><th>Name</th> <th>As a datatype</th> <th>Using the functor kit</th></tr></thead> <tbody><tr><td>Pairs of values</td> <td><code>data Pair a = Pair a a</code></td> <td><code>type Pair = I :*: I</code></td></tr> <tr><td>Two-by-two grids</td> <td><code>type Grid a = Pair (Pair a)</code></td> <td><code>type Grid = Pair :.: Pair</code></td></tr> <tr><td>Natural numbers</td> <td><code>data Nat = Zero | Succ Nat</code></td> <td><code>type Nat = Fix (K () :+: I)</code></td></tr> <tr><td>Lists</td> <td><code>data List a = Nil | Cons a (List a)</code></td> <td><code>type List a = Fix (K () :+: K a :*: I)</code></td></tr> <tr><td>Binary trees</td> <td><code>data Tree a = Leaf | Node (Tree a) a (Tree a)</code></td> <td><code>type Tree a = Fix (K () :+: I :*: K a :*: I)</code></td></tr> <tr><td>Rose trees</td> <td><code>data Rose a = Rose a (List (Rose a))</code></td> <td><code>type Rose a = Fix (K a :*: List :.: I)</code></td></tr></tbody></table> <p>This &quot;kit&quot; approach to designing datatypes is the idea behind <strong>generic programming</strong> libraries such as <a href="https://hackage.haskell.org/package/generics-sop" target="_blank" rel="noopener noreferrer"><code>generics-sop</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>. The idea is to write generic operations using a kit like the one presented above, and then use a type class to convert arbitrary datatypes to and from their generic representation:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">class</span> <span class="token constant">Generic</span> <span class="token hvariable">a</span> <span class="token keyword">where</span>
    <span class="token keyword">type</span> <span class="token constant">Rep</span> <span class="token hvariable">a</span>  <span class="token comment">-- a generic representation built using a kit</span>
    <span class="token hvariable">to</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Rep</span> <span class="token hvariable">a</span>
    <span class="token hvariable">from</span> <span class="token operator">::</span> <span class="token constant">Rep</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>

</code></pre></div><h2 id="functors-in-category-theory"><a href="#functors-in-category-theory" class="header-anchor">#</a> Functors in Category Theory</h2> <p>A Functor is defined in category theory as a structure-preserving map (a 'homomorphism') between categories. Specifically, (all) objects are mapped to objects, and (all) arrows are mapped to arrows, such that the category laws are preserved.</p> <p>The category in which objects are Haskell types and morphisms are Haskell functions is called <strong>Hask</strong>. So a functor from <strong>Hask</strong> to <strong>Hask</strong> would consist of a mapping of types to types and a mapping from functions to functions.</p> <p>The relationship that this category theoretic concept bears to the Haskell programming construct <code>Functor</code> is rather direct. The mapping from types to types takes the form of a type <code>f :: * -&gt; *</code>, and the mapping from functions to functions takes the form of a function <code>fmap :: (a -&gt; b) -&gt; (f a -&gt; f b)</code>. Putting those together in a class,</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">class</span> <span class="token constant">Functor</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token operator">::</span> <span class="token operator">*</span> <span class="token operator">-&gt;</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>

</code></pre></div><p><code>fmap</code> is an operation that takes a function (a type of morphism), <code>:: a -&gt; b</code>, and maps it to another function, <code>:: f a -&gt; f b</code>. It is assumed (but left to the programmer to ensure) that instances of <code>Functor</code> are indeed mathematical functors, preserving <strong>Hask</strong>'s categorical structure:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token builtin">id</span> <span class="token comment">{- :: a -&gt; a -}</span><span class="token punctuation">)</span>  <span class="token operator">==</span>  <span class="token builtin">id</span> <span class="token comment">{- :: f a -&gt; f a -}</span>
<span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token hvariable">h</span><span class="token operator"> . </span><span class="token hvariable">g</span><span class="token punctuation">)</span>               <span class="token operator">==</span>  <span class="token builtin">fmap</span> <span class="token hvariable">h</span><span class="token operator"> . </span><span class="token builtin">fmap</span> <span class="token hvariable">g</span>

</code></pre></div><p><code>fmap</code> lifts a function <code>:: a -&gt; b</code> into a subcategory of <strong>Hask</strong> in a way that preserves both the existence of any identity arrows, and the associativity of composition.</p> <p>The <code>Functor</code> class only encodes <strong>endo</strong>functors on <strong>Hask</strong>. But in mathematics, functors can map between arbitrary categories. A more faithful encoding of this concept would look like this:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">class</span> <span class="token constant">Category</span> <span class="token hvariable">c</span> <span class="token keyword">where</span>
    <span class="token builtin">id</span>  <span class="token operator">::</span> <span class="token hvariable">c</span> <span class="token hvariable">i</span> <span class="token hvariable">i</span>
    <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">c</span> <span class="token hvariable">j</span> <span class="token hvariable">k</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span> <span class="token hvariable">i</span> <span class="token hvariable">j</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span> <span class="token hvariable">i</span> <span class="token hvariable">k</span>

<span class="token keyword">class</span> <span class="token punctuation">(</span><span class="token constant">Category</span> <span class="token hvariable">c1</span><span class="token punctuation">,</span> <span class="token constant">Category</span> <span class="token hvariable">c2</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">CFunctor</span> <span class="token hvariable">c1</span> <span class="token hvariable">c2</span> <span class="token hvariable">f</span> <span class="token keyword">where</span>
    <span class="token hvariable">cfmap</span> <span class="token operator">::</span> <span class="token hvariable">c1</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c2</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">b</span><span class="token punctuation">)</span>

</code></pre></div><p>The standard Functor class is a special case of this class in which the source and target categories are both <strong>Hask</strong>. For example,</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">instance</span> <span class="token constant">Category</span> <span class="token punctuation">(</span><span class="token operator">-&gt;</span><span class="token punctuation">)</span> <span class="token keyword">where</span>        <span class="token comment">-- Hask</span>
    <span class="token builtin">id</span>    <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span>
    <span class="token hvariable">f</span><span class="token operator"> . </span><span class="token hvariable">g</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>

<span class="token keyword">instance</span> <span class="token constant">CFunctor</span> <span class="token punctuation">(</span><span class="token operator">-&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">-&gt;</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">where</span>
    <span class="token hvariable">cfmap</span> <span class="token operator">=</span> <span class="token builtin">fmap</span>

</code></pre></div><h2 id="deriving-functor"><a href="#deriving-functor" class="header-anchor">#</a> Deriving Functor</h2> <p>The <code>DeriveFunctor</code> language extension allows GHC to generate instances of <code>Functor</code> automatically.</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token comment">{-# LANGUAGE DeriveFunctor #-}</span>

<span class="token keyword">data</span> <span class="token constant">List</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Nil</span> <span class="token operator">|</span> <span class="token constant">Cons</span> <span class="token hvariable">a</span> <span class="token punctuation">(</span><span class="token constant">List</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">deriving</span> <span class="token constant">Functor</span>

<span class="token comment">-- instance Functor List where            -- automatically defined</span>
<span class="token comment">--   fmap f Nil = Nil</span>
<span class="token comment">--   fmap f (Cons x xs) = Cons (f x) (fmap f xs)</span>

<span class="token builtin">map</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">List</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">List</span> <span class="token hvariable">b</span>
<span class="token builtin">map</span> <span class="token operator">=</span> <span class="token builtin">fmap</span>

</code></pre></div><h4 id="remarks"><a href="#remarks" class="header-anchor">#</a> Remarks</h4> <p>A Functor can be thought of as a container for some value, or a computation context. Examples are <code>Maybe a</code> or <code>[a]</code>. The <a href="https://wiki.haskell.org/Typeclassopedia#Functor" target="_blank" rel="noopener noreferrer">Typeclassopedia<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> article has a good write-up of the concepts behind Functors.</p> <p>To be considered a real Functor, an instance has to respect the 2 following laws:</p> <h3 id="identity"><a href="#identity" class="header-anchor">#</a> Identity</h3> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token builtin">fmap</span> <span class="token builtin">id</span> <span class="token operator">==</span> <span class="token builtin">id</span>

</code></pre></div><h3 id="composition"><a href="#composition" class="header-anchor">#</a> Composition</h3> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token hvariable">f</span><span class="token operator"> . </span><span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token hvariable">f</span><span class="token punctuation">)</span><span class="token operator"> . </span><span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token hvariable">g</span><span class="token punctuation">)</span>

</code></pre></div></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/devtut/generate/edit/master/docs/haskell/functor.md" target="_blank" rel="noopener noreferrer">Edit this page on GitHub</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      
      <a href="/haskell/syntax-in-functions.html" class="prev">
        Syntax in Functions
      </a></span> <span class="next"><a href="/haskell/testing-with-tasty.html">
        Testing with Tasty
      </a>
      
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.ced448ab.js" defer></script><script src="/assets/js/3.f1d73125.js" defer></script><script src="/assets/js/1187.5820b415.js" defer></script>
  </body>
</html>
