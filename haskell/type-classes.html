<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Haskell - Type Classes</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="description" content="Eq, Ord, Monoid, Num, Maybe and the Functor Class, Type class inheritance: Ord type class">
    <meta property="og:site_name" content="DevTut">
    <meta property="og:title" content="Haskell - Type Classes">
    <meta property="og:description" content="Eq, Ord, Monoid, Num, Maybe and the Functor Class, Type class inheritance: Ord type class">
    <meta property="og:type" content="article">
    <meta property="og:url" content="/haskell/type-classes.html">
    <meta property="og:image" content="/logo.png">
    <meta name="twitter:title" content="Haskell - Type Classes">
    <meta name="twitter:description" content="Eq, Ord, Monoid, Num, Maybe and the Functor Class, Type class inheritance: Ord type class">
    <meta name="twitter:url" content="/haskell/type-classes.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="/logo.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/mstile-150x150.png">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="google-site-verification" content="76_rKXgwMVIjd-axJC_1zPV9OS4mEjvtgjYOWVkAdnQ">
    
    <link rel="preload" href="/assets/css/0.styles.60619e34.css" as="style"><link rel="preload" href="/assets/js/app.1779e102.js" as="script"><link rel="preload" href="/assets/js/3.2cfa8016.js" as="script"><link rel="preload" href="/assets/js/1235.3921c660.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.60619e34.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">DevTut</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Haskell</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/haskell/" aria-current="page" class="sidebar-link">Disclaimer</a></li><li><a href="/haskell/getting-started-with-haskell-language.html" class="sidebar-link">Getting started with Haskell Language</a></li><li><a href="/haskell/overloaded-literals.html" class="sidebar-link">Overloaded Literals</a></li><li><a href="/haskell/foldable.html" class="sidebar-link">Foldable</a></li><li><a href="/haskell/traversable.html" class="sidebar-link">Traversable</a></li><li><a href="/haskell/lens.html" class="sidebar-link">Lens</a></li><li><a href="/haskell/quickcheck.html" class="sidebar-link">QuickCheck</a></li><li><a href="/haskell/common-ghc-language-extensions.html" class="sidebar-link">Common GHC Language Extensions</a></li><li><a href="/haskell/free-monads.html" class="sidebar-link">Free Monads</a></li><li><a href="/haskell/type-classes.html" aria-current="page" class="active sidebar-link">Type Classes</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/haskell/type-classes.html#eq" class="sidebar-link">Eq</a></li><li class="sidebar-sub-header"><a href="/haskell/type-classes.html#ord" class="sidebar-link">Ord</a></li><li class="sidebar-sub-header"><a href="/haskell/type-classes.html#monoid" class="sidebar-link">Monoid</a></li><li class="sidebar-sub-header"><a href="/haskell/type-classes.html#num" class="sidebar-link">Num</a></li><li class="sidebar-sub-header"><a href="/haskell/type-classes.html#maybe-and-the-functor-class" class="sidebar-link">Maybe and the Functor Class</a></li><li class="sidebar-sub-header"><a href="/haskell/type-classes.html#type-class-inheritance-ord-type-class" class="sidebar-link">Type class inheritance: Ord type class</a></li></ul></li><li><a href="/haskell/io.html" class="sidebar-link">IO</a></li><li><a href="/haskell/record-syntax.html" class="sidebar-link">Record Syntax</a></li><li><a href="/haskell/partial-application.html" class="sidebar-link">Partial Application</a></li><li><a href="/haskell/monoid.html" class="sidebar-link">Monoid</a></li><li><a href="/haskell/category-theory.html" class="sidebar-link">Category Theory</a></li><li><a href="/haskell/lists.html" class="sidebar-link">Lists</a></li><li><a href="/haskell/sorting-algorithms.html" class="sidebar-link">Sorting Algorithms</a></li><li><a href="/haskell/type-families.html" class="sidebar-link">Type Families</a></li><li><a href="/haskell/monads.html" class="sidebar-link">Monads</a></li><li><a href="/haskell/stack.html" class="sidebar-link">Stack</a></li><li><a href="/haskell/generalized-algebraic-data-types.html" class="sidebar-link">Generalized Algebraic Data Types</a></li><li><a href="/haskell/recursion-schemes.html" class="sidebar-link">Recursion Schemes</a></li><li><a href="/haskell/data-text.html" class="sidebar-link">Data.Text</a></li><li><a href="/haskell/using-ghci.html" class="sidebar-link">Using GHCi</a></li><li><a href="/haskell/strictness.html" class="sidebar-link">Strictness</a></li><li><a href="/haskell/syntax-in-functions.html" class="sidebar-link">Syntax in Functions</a></li><li><a href="/haskell/functor.html" class="sidebar-link">Functor</a></li><li><a href="/haskell/testing-with-tasty.html" class="sidebar-link">Testing with Tasty</a></li><li><a href="/haskell/creating-custom-data-types.html" class="sidebar-link">Creating Custom Data Types</a></li><li><a href="/haskell/reactive-banana.html" class="sidebar-link">Reactive-banana</a></li><li><a href="/haskell/optimization.html" class="sidebar-link">Optimization</a></li><li><a href="/haskell/concurrency.html" class="sidebar-link">Concurrency</a></li><li><a href="/haskell/function-composition.html" class="sidebar-link">Function composition</a></li><li><a href="/haskell/databases.html" class="sidebar-link">Databases</a></li><li><a href="/haskell/data-aeson-json-in-haskell.html" class="sidebar-link">Data.Aeson - JSON in Haskell</a></li><li><a href="/haskell/higher-order-functions.html" class="sidebar-link">Higher-order functions</a></li><li><a href="/haskell/containers-data-map.html" class="sidebar-link">Containers - Data.Map</a></li><li><a href="/haskell/fixity-declarations.html" class="sidebar-link">Fixity declarations</a></li><li><a href="/haskell/web-development.html" class="sidebar-link">Web Development</a></li><li><a href="/haskell/vectors.html" class="sidebar-link">Vectors</a></li><li><a href="/haskell/cabal.html" class="sidebar-link">Cabal</a></li><li><a href="/haskell/type-algebra.html" class="sidebar-link">Type algebra</a></li><li><a href="/haskell/arrows.html" class="sidebar-link">Arrows</a></li><li><a href="/haskell/typed-holes.html" class="sidebar-link">Typed holes</a></li><li><a href="/haskell/rewrite-rules-ghc.html" class="sidebar-link">Rewrite rules (GHC)</a></li><li><a href="/haskell/date-and-time.html" class="sidebar-link">Date and Time</a></li><li><a href="/haskell/list-comprehensions.html" class="sidebar-link">List Comprehensions</a></li><li><a href="/haskell/streaming-io.html" class="sidebar-link">Streaming IO</a></li><li><a href="/haskell/google-protocol-buffers.html" class="sidebar-link">Google Protocol Buffers</a></li><li><a href="/haskell/template-haskell-quasiquotes.html" class="sidebar-link">Template Haskell &amp; QuasiQuotes</a></li><li><a href="/haskell/phantom-types.html" class="sidebar-link">Phantom types</a></li><li><a href="/haskell/modules.html" class="sidebar-link">Modules</a></li><li><a href="/haskell/tuples-pairs-triples.html" class="sidebar-link">Tuples (Pairs, Triples, ...)</a></li><li><a href="/haskell/graphics-with-gloss.html" class="sidebar-link">Graphics with Gloss</a></li><li><a href="/haskell/state-monad.html" class="sidebar-link">State Monad</a></li><li><a href="/haskell/pipes.html" class="sidebar-link">Pipes</a></li><li><a href="/haskell/infix-operators.html" class="sidebar-link">Infix operators</a></li><li><a href="/haskell/parallelism.html" class="sidebar-link">Parallelism</a></li><li><a href="/haskell/parsing-html-with-taggy-lens-and-lens.html" class="sidebar-link">Parsing HTML with taggy-lens and lens</a></li><li><a href="/haskell/foreign-function-interface.html" class="sidebar-link">Foreign Function Interface</a></li><li><a href="/haskell/gtk3.html" class="sidebar-link">Gtk3</a></li><li><a href="/haskell/monad-transformers.html" class="sidebar-link">Monad Transformers</a></li><li><a href="/haskell/bifunctor.html" class="sidebar-link">Bifunctor</a></li><li><a href="/haskell/proxies.html" class="sidebar-link">Proxies</a></li><li><a href="/haskell/applicative-functor.html" class="sidebar-link">Applicative Functor</a></li><li><a href="/haskell/common-monads-as-free-monads.html" class="sidebar-link">Common monads as free monads</a></li><li><a href="/haskell/common-functors-as-the-base-of-cofree-comonads.html" class="sidebar-link">Common functors as the base of cofree comonads</a></li><li><a href="/haskell/arithmetic.html" class="sidebar-link">Arithmetic</a></li><li><a href="/haskell/role.html" class="sidebar-link">Role</a></li><li><a href="/haskell/arbitrary-rank-polymorphism-with-rankntypes.html" class="sidebar-link">Arbitrary-rank polymorphism with RankNTypes</a></li><li><a href="/haskell/ghcjs.html" class="sidebar-link">GHCJS</a></li><li><a href="/haskell/xml.html" class="sidebar-link">XML</a></li><li><a href="/haskell/reader-readert.html" class="sidebar-link">Reader / ReaderT</a></li><li><a href="/haskell/function-call-syntax.html" class="sidebar-link">Function call syntax</a></li><li><a href="/haskell/logging.html" class="sidebar-link">Logging</a></li><li><a href="/haskell/attoparsec.html" class="sidebar-link">Attoparsec</a></li><li><a href="/haskell/zipwithm.html" class="sidebar-link">zipWithM</a></li><li><a href="/haskell/profunctor.html" class="sidebar-link">Profunctor</a></li><li><a href="/haskell/type-application.html" class="sidebar-link">Type Application</a></li><li><a href="/haskell/contributors.html" class="sidebar-link">The Contributors</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="type-classes"><a href="#type-classes" class="header-anchor">#</a> Type Classes</h1> <p>Typeclasses in Haskell are a means of defining the behaviour associated with a type separately from that type's definition. Whereas, say, in Java, you'd define the behaviour as part of the type's definition -- i.e. in an interface, abstract class or concrete class -- Haskell keeps these two things separate.</p> <p>There are a number of typeclasses already defined in Haskell's <code>base</code> package. The relationship between these is illustrated in the Remarks section below.</p> <h2 id="eq"><a href="#eq" class="header-anchor">#</a> Eq</h2> <p>All basic datatypes (like <code>Int</code>, <code>String</code>, <code>Eq a =&gt; [a]</code>) from Prelude except for functions and <code>IO</code> have instances of <code>Eq</code>. If a type instantiates <code>Eq</code> it means that we know how to compare two values for <strong>value</strong> or <strong>structural</strong> equality.</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token operator">&gt;</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">2</span> 
<span class="token constant">False</span>
<span class="token operator">&gt;</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">3</span>
<span class="token constant">True</span>

</code></pre></div><h3 id="required-methods"><a href="#required-methods" class="header-anchor">#</a> Required methods</h3> <ul><li><code>(==) :: Eq a =&gt; a -&gt; a -&gt; Boolean</code> or <code>(/=) :: Eq a =&gt; a -&gt; a -&gt; Boolean</code> (if only one is implemented, the other defaults to the negation of the defined one)</li></ul> <h3 id="defines"><a href="#defines" class="header-anchor">#</a> Defines</h3> <ul><li><code>(==) :: Eq a =&gt; a -&gt; a -&gt; Boolean</code></li> <li><code>(/=) :: Eq a =&gt; a -&gt; a -&gt; Boolean</code></li></ul> <h3 id="direct-superclasses"><a href="#direct-superclasses" class="header-anchor">#</a> Direct superclasses</h3> <p>None</p> <h3 id="notable-subclasses"><a href="#notable-subclasses" class="header-anchor">#</a> Notable subclasses</h3> <ul><li><a href="https://stackoverflow.com/documentation/haskell/1879/type-classes/7440/ord" target="_blank" rel="noopener noreferrer"><code>Ord</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="ord"><a href="#ord" class="header-anchor">#</a> Ord</h2> <p>Types instantiating <code>Ord</code> include, e.g., <code>Int</code>, <code>String</code>, and <code>[a]</code> (for types <code>a</code> where there's an <code>Ord a</code> instance). If a type instantiates <code>Ord</code> it means that we know a “natural” ordering of values of that type. Note, there are often many possible choices of the “natural” ordering of a type and <code>Ord</code> forces us to favor one.</p> <p><code>Ord</code> provides the standard <code>(&lt;=)</code>, <code>(&lt;)</code>, <code>(&gt;)</code>, <code>(&gt;=)</code> operators but interestingly defines them all using a custom algebraic data type</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">data</span> <span class="token constant">Ordering</span> <span class="token operator">=</span> <span class="token constant">LT</span> <span class="token operator">|</span> <span class="token constant">EQ</span> <span class="token operator">|</span> <span class="token constant">GT</span>

<span class="token builtin">compare</span> <span class="token operator">::</span> <span class="token constant">Ord</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Ordering</span>

</code></pre></div><h3 id="required-methods-2"><a href="#required-methods-2" class="header-anchor">#</a> Required methods</h3> <ul><li><code>compare :: Ord a =&gt; a -&gt; a -&gt; Ordering</code> or <code>(&lt;=) :: Ord a =&gt; a -&gt; a -&gt; Boolean</code> (the standard’s default <code>compare</code> method uses <code>(&lt;=)</code> in its implementation)</li></ul> <h3 id="defines-2"><a href="#defines-2" class="header-anchor">#</a> Defines</h3> <ul><li><code>compare :: Ord a =&gt; a -&gt; a -&gt; Ordering</code></li> <li><code>(&lt;=) :: Ord a =&gt; a -&gt; a -&gt; Boolean</code></li> <li><code>(&lt;) :: Ord a =&gt; a -&gt; a -&gt; Boolean</code></li> <li><code>(&gt;=) :: Ord a =&gt; a -&gt; a -&gt; Boolean</code></li> <li><code>(&gt;) :: Ord a =&gt; a -&gt; a -&gt; Boolean</code></li> <li><code>min :: Ord a =&gt; a -&gt; a -&gt; a</code></li> <li><code>max :: Ord a =&gt; a -&gt; a -&gt; a</code></li></ul> <h3 id="direct-superclasses-2"><a href="#direct-superclasses-2" class="header-anchor">#</a> Direct superclasses</h3> <ul><li><a href="https://stackoverflow.com/documentation/haskell/1879/type-classes/7439/eq" target="_blank" rel="noopener noreferrer"><code>Eq</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="monoid"><a href="#monoid" class="header-anchor">#</a> Monoid</h2> <p>Types instantiating <a href="http://stackoverflow.com/documentation/haskell/2211/monoid#t=201607241111111418916" target="_blank" rel="noopener noreferrer"><code>Monoid</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> include lists, numbers, and functions with <code>Monoid</code> return values, among others. To instantiate <code>Monoid</code> a type must support an associative binary operation (<code>mappend</code> or <code>(&lt;&gt;)</code>) which combines its values, and have  a special &quot;zero&quot; value (<code>mempty</code>) such that combining a value with it does not change that value:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">mempty</span>  <span class="token operator">&lt;&gt;</span>  <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">x</span>
<span class="token hvariable">x</span> <span class="token operator">&lt;&gt;</span>  <span class="token hvariable">mempty</span>  <span class="token operator">==</span> <span class="token hvariable">x</span>

<span class="token hvariable">x</span> <span class="token operator">&lt;&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">y</span> <span class="token operator">&lt;&gt;</span> <span class="token hvariable">z</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">&lt;&gt;</span> <span class="token hvariable">y</span><span class="token punctuation">)</span> <span class="token operator">&lt;&gt;</span> <span class="token hvariable">z</span>

</code></pre></div><p>Intuitively, <code>Monoid</code> types are &quot;list-like&quot; in that they support appending values together. Alternatively, <code>Monoid</code> types can be thought of as sequences of values for which we care about the order but not the grouping. For instance, a binary tree is a <code>Monoid</code>, but using the <code>Monoid</code> operations we cannot witness its branching structure, only a traversal of its values (see <code>Foldable</code> and <code>Traversable</code>).</p> <h3 id="required-methods-3"><a href="#required-methods-3" class="header-anchor">#</a> Required methods</h3> <ul><li><code>mempty :: Monoid m =&gt; m</code></li> <li><code>mappend :: Monoid m =&gt; m -&gt; m -&gt; m</code></li></ul> <h3 id="direct-superclasses-3"><a href="#direct-superclasses-3" class="header-anchor">#</a> Direct superclasses</h3> <p>None</p> <h2 id="num"><a href="#num" class="header-anchor">#</a> Num</h2> <p>The most general class for number types, more precisely for <a href="https://en.wikipedia.org/wiki/Ring_(mathematics)" target="_blank" rel="noopener noreferrer">rings<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, i.e. numbers that can be added and subtracted and multiplied in the usual sense, but not necessarily divided.</p> <p>This class contains both integral types (<code>Int</code>, <code>Integer</code>, <code>Word32</code> etc.) and fractional types (<code>Double</code>, <code>Rational</code>, also complex numbers etc.). In case of finite types, the semantics are generally understood as <strong>modular arithmetic</strong>, i.e. with over- and underflow<sup>†</sup>.</p> <p>Note that the rules for the numerical classes are much less strictly obeyed than the <a href="http://stackoverflow.com/documentation/haskell/2968/monads/6144/monad-laws-and-the-maybe-monad#t=201610010024186706477" target="_blank" rel="noopener noreferrer">monad<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> or monoid laws, or those for <a href="http://stackoverflow.com/documentation/haskell/2264/standard-and-popular-type-classes/7439/eq" target="_blank" rel="noopener noreferrer">equality comparison<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>. In particular, floating-point numbers generally obey laws only in a approximate sense.</p> <h3 id="the-methods"><a href="#the-methods" class="header-anchor">#</a> The methods</h3> <li>
`fromInteger :: Num a =&gt; Integer -&gt; a`. convert an integer to the general number type (wrapping around the range, if necessary). Haskell [number literals](http://stackoverflow.com/documentation/haskell/369/overloaded-literals/1243/integer-numeral) can be understood as a monomorphic `Integer` literal with the general conversion around it, so you can use the literal `5` in both an `Int` context and a `Complex Double` setting.
</li> <li>
`(+) :: Num a =&gt; a -&gt; a -&gt; a`. Standard addition, generally understood as associative and commutative, i.e.,
<div class="language-hs extra-class"><pre class="language-hs"><code>  <span class="token hvariable">a</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token hvariable">b</span> <span class="token operator">+</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> ≡ <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">+</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token hvariable">c</span>
  <span class="token hvariable">a</span> <span class="token operator">+</span> <span class="token hvariable">b</span> ≡ <span class="token hvariable">b</span> <span class="token operator">+</span> <span class="token hvariable">a</span>

</code></pre></div></li> <li>
`(-) :: Num a =&gt; a -&gt; a -&gt; a`. Subtraction, which is the inverse of addition:
<div class="language-hs extra-class"><pre class="language-hs"><code>  <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token hvariable">b</span> ≡ <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">+</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token hvariable">b</span> ≡ <span class="token hvariable">a</span>

</code></pre></div></li> <li>
`(*) :: Num a =&gt; a -&gt; a -&gt; a`. Multiplication, an associative operation that's distributive over addition:
<div class="language-hs extra-class"><pre class="language-hs"><code>  <span class="token hvariable">a</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token hvariable">b</span> <span class="token operator">*</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> ≡ <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">*</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token hvariable">c</span>
  <span class="token hvariable">a</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token hvariable">b</span> <span class="token operator">+</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> ≡ <span class="token hvariable">a</span> <span class="token operator">*</span> <span class="token hvariable">b</span> <span class="token operator">+</span> <span class="token hvariable">a</span> <span class="token operator">*</span> <span class="token hvariable">c</span>

</code></pre></div><p>for the most common instances, multiplication is also commutative, but this is definitely not a requirement.
</p></li> <li><code>negate :: Num a =&gt; a -&gt; a</code>. The full name of the unary negation operator. <code>-1</code> is syntactic sugar for <code>negate 1</code>.<p></p> <div class="language-hs extra-class"><pre class="language-hs"><code>  <span class="token operator">-</span><span class="token hvariable">a</span> ≡ <span class="token builtin">negate</span> <span class="token hvariable">a</span> ≡ <span class="token number">0</span> <span class="token operator">-</span> <span class="token hvariable">a</span>

</code></pre></div></li> <li>
`abs :: Num a =&gt; a -&gt; a`. The absolute-value function always gives a non-negative result of the same magnitude
<div class="language-hs extra-class"><pre class="language-hs"><code>  <span class="token builtin">abs</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token hvariable">a</span><span class="token punctuation">)</span> ≡ <span class="token builtin">abs</span> <span class="token hvariable">a</span>
  <span class="token builtin">abs</span> <span class="token punctuation">(</span><span class="token builtin">abs</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> ≡ <span class="token builtin">abs</span> <span class="token hvariable">a</span>

</code></pre></div><p><code>abs a ≡ 0</code> should only happen if <code>a ≡ 0</code>.
For <a href="http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#t:Real" target="_blank" rel="noopener noreferrer">real<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> types it's clear what non-negative means: you always have <code>abs a &gt;= 0</code>. Complex etc. types don't have a well-defined ordering, however the result of <code>abs</code> should always lie in the real subset<sup>‡</sup> (i.e. give a number that could also be written as a single number literal without negation).
</p></li> <li><code>signum :: Num a =&gt; a -&gt; a</code>. The sign function, according to the name, yields only <code>-1</code> or <code>1</code>, depending on the sign of the argument. Actually, that's only true for nonzero real numbers; in general <code>signum</code> is better understood as the <strong>normalising</strong> function:<p></p> <div class="language-hs extra-class"><pre class="language-hs"><code>  <span class="token builtin">abs</span> <span class="token punctuation">(</span><span class="token builtin">signum</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> ≡ <span class="token number">1</span>   <span class="token comment">-- unless a≡0</span>
  <span class="token builtin">signum</span> <span class="token hvariable">a</span> <span class="token operator">*</span> <span class="token builtin">abs</span> <span class="token hvariable">a</span> ≡ <span class="token hvariable">a</span> <span class="token comment">-- This is required to be true for all Num instances</span>

</code></pre></div><p>Note that <a href="https://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1390006.4.4" target="_blank" rel="noopener noreferrer">section 6.4.4 of the Haskell 2010 Report<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> explicitly requires this last equality to hold for any valid <code>Num</code> instance.
</p></li><p></p> <p>Some libraries, notably <a href="http://hackage.haskell.org/package/linear" target="_blank" rel="noopener noreferrer">linear<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> and <a href="http://hackage.haskell.org/package/hmatrix" target="_blank" rel="noopener noreferrer">hmatrix<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, have a much laxer understanding of what the <code>Num</code> class is for: they treat it just as <strong>a way to overload the arithmetic operators</strong>. While this is pretty straightforward for <code>+</code> and <code>-</code>, it already becomes troublesome with <code>*</code> and more so with the other methods. For instance, <strong>should <code>*</code> mean matrix multiplication or element-wise multiplication?</strong> <br>
It is arguably a bad idea to define such non-number instances; please consider dedicated classes such as <a href="http://hackage.haskell.org/package/vector-space-0.10.2/docs/Data-VectorSpace.html" target="_blank" rel="noopener noreferrer"><code>VectorSpace</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <p><sup>†</sup> <sub>In particular, the “negatives” of unsigned types are wrapped around to large positive, e.g. <code>(-4 :: Word32) == 4294967292</code>.</sub></p> <p><sup>‡</sup> <sub>This is widely <strong>not</strong> fulfilled: vector types do not have a real subset. The controversial <code>Num</code>-instances for such types generally define <code>abs</code> and <code>signum</code> element-wise, which mathematically speaking doesn't really make sense.</sub></p> <h2 id="maybe-and-the-functor-class"><a href="#maybe-and-the-functor-class" class="header-anchor">#</a> Maybe and the Functor Class</h2> <p>In Haskell, data types can have arguments just like functions. Take the <code>Maybe</code> type for example.</p> <p><code>Maybe</code> is a very useful type which allows us to represent the idea of failure, or the possiblity thereof. In other words, if there is a possibility that a computation will fail, we use the <code>Maybe</code> type there. <code>Maybe</code> acts kind of like a wrapper for other types, giving them additional functionality.</p> <p>Its actual declaration is fairly simple.</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token constant">Maybe</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token hvariable">a</span> <span class="token operator">|</span> <span class="token constant">Nothing</span>

</code></pre></div><p>What this tells is that a <code>Maybe</code> comes in two forms, a <code>Just</code>, which represents success, and a <code>Nothing</code>, which represents failure. <code>Just</code> takes one argument which determines the type of the <code>Maybe</code>, and <code>Nothing</code> takes none. For example, the value <code>Just &quot;foo&quot;</code> will have type <code>Maybe String</code>, which is a string type wrapped with the additional <code>Maybe</code> functionality. The value <code>Nothing</code> has type <code>Maybe a</code> where <code>a</code> can be any type.</p> <p>This idea of wrapping types to give them additional functionality is a very useful one, and is applicable to more than just <code>Maybe</code>. Other examples include the <code>Either</code>, <code>IO</code> and list types, each providing different functionality.  However, there are some actions and abilities which are common to all of these wrapper types. The most notable of these is the ability to modify the encapsulated value.</p> <p>It is common to think of these kinds of types as boxes which can have values placed in them. Different boxes hold different values and do different things, but none are useful without being able to access the contents within.</p> <p>To encapsulate this idea, Haskell comes with a standard typeclass, named <code>Functor</code>. It is defined as follows.</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">class</span> <span class="token constant">Functor</span> <span class="token hvariable">f</span> <span class="token keyword">where</span>
  <span class="token builtin">fmap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>

</code></pre></div><p>As can be seen, the class has a single function, <code>fmap</code>, of two arguments. The first argument is a function from one type, <code>a</code>, to another, <code>b</code>. The second argument is a functor (wrapper type) containing a value of type <code>a</code>. It returns a functor (wrapper type) containing a value of type <code>b</code>.</p> <p>In simple terms, <code>fmap</code> takes a function and applies to the value inside of a functor. It is the only function necessary for a type to be a member of the <code>Functor</code> class, but it is extremely useful. Functions operating on functors that have more specific applications can be found in the <code>Applicative</code> and <code>Monad</code> typeclasses.</p> <h2 id="type-class-inheritance-ord-type-class"><a href="#type-class-inheritance-ord-type-class" class="header-anchor">#</a> Type class inheritance: Ord type class</h2> <p>Haskell supports a notion of class extension. For example, the class <code>Ord</code> inherits all of the operations in <code>Eq</code>, but in addition has a <code>compare</code> function that returns an <code>Ordering</code> between values. <code>Ord</code> may also contain the common order comparison operators, as well as a <code>min</code> method and a <code>max</code> method.</p> <p>The <code>=&gt;</code> notation has the same meaning as it does in a function signature and requires type <code>a</code> to implement <code>Eq</code>, in order to implement <code>Ord</code>.</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">data</span> <span class="token constant">Ordering</span> <span class="token operator">=</span> <span class="token constant">EQ</span> <span class="token operator">|</span> <span class="token constant">LT</span> <span class="token operator">|</span> <span class="token constant">GT</span>

<span class="token keyword">class</span> <span class="token constant">Eq</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token constant">Ord</span> <span class="token hvariable">a</span> <span class="token keyword">where</span>
    <span class="token builtin">compare</span> <span class="token operator">::</span> <span class="token constant">Ord</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Ordering</span>
    <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token punctuation">)</span>     <span class="token operator">::</span> <span class="token constant">Ord</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
    <span class="token punctuation">(</span><span class="token operator">&lt;=</span><span class="token punctuation">)</span>    <span class="token operator">::</span> <span class="token constant">Ord</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
    <span class="token punctuation">(</span><span class="token operator">&gt;</span><span class="token punctuation">)</span>     <span class="token operator">::</span> <span class="token constant">Ord</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
    <span class="token punctuation">(</span><span class="token operator">&gt;=</span><span class="token punctuation">)</span>    <span class="token operator">::</span> <span class="token constant">Ord</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
    <span class="token builtin">min</span>     <span class="token operator">::</span> <span class="token constant">Ord</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
    <span class="token builtin">max</span>     <span class="token operator">::</span> <span class="token constant">Ord</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>

</code></pre></div><p>All of the methods following <code>compare</code> can be derived from it in a number of ways:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">x</span> <span class="token operator">&lt;</span> <span class="token hvariable">y</span>   <span class="token operator">=</span> <span class="token builtin">compare</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">==</span> <span class="token constant">LT</span>
<span class="token hvariable">x</span> <span class="token operator">&lt;=</span> <span class="token hvariable">y</span>  <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">&lt;</span> <span class="token hvariable">y</span> <span class="token operator">||</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">y</span> <span class="token comment">-- Note the use of (==) inherited from Eq</span>
<span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token hvariable">y</span>   <span class="token operator">=</span> <span class="token builtin">not</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">&lt;=</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>
<span class="token hvariable">x</span> <span class="token operator">&gt;=</span> <span class="token hvariable">y</span>  <span class="token operator">=</span> <span class="token builtin">not</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">&lt;</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>

<span class="token builtin">min</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token keyword">case</span> <span class="token builtin">compare</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token keyword">of</span>
               <span class="token constant">EQ</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span>
               <span class="token constant">LT</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span>
               <span class="token constant">GT</span> <span class="token operator">-&gt;</span> <span class="token hvariable">y</span>

<span class="token builtin">max</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token keyword">case</span> <span class="token builtin">compare</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token keyword">of</span>
               <span class="token constant">EQ</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span>
               <span class="token constant">LT</span> <span class="token operator">-&gt;</span> <span class="token hvariable">y</span>
               <span class="token constant">GT</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span>

</code></pre></div><p>Type classes that themselves extend <code>Ord</code> must implement at least either the <code>compare</code> method or the <code>(&lt;=)</code>  method themselves, which builds up the directed inheritance lattice.</p> <h4 id="remarks"><a href="#remarks" class="header-anchor">#</a> Remarks</h4> <p>The following diagram taken from the <a href="https://wiki.haskell.org/Typeclassopedia" target="_blank" rel="noopener noreferrer">Typeclassopedia<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> article shows the relationship between the various typeclasses in Haskell.</p> <p><a href="https://i.stack.imgur.com/Fph6t.png" target="_blank" rel="noopener noreferrer"><img src="https://i.stack.imgur.com/Fph6t.png" alt="Relationships among standard Haskell type classes, Figure 1 as published in Typeclassopedia."><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/devtut/generate/edit/master/docs/haskell/type-classes.md" target="_blank" rel="noopener noreferrer">Edit this page on GitHub</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/haskell/free-monads.html" class="prev">
        Free Monads
      </a></span> <span class="next"><a href="/haskell/io.html">
        IO
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.1779e102.js" defer></script><script src="/assets/js/3.2cfa8016.js" defer></script><script src="/assets/js/1235.3921c660.js" defer></script>
  </body>
</html>
