<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Haskell - Lens</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="description" content="Lenses for records, Manipulating tuples with Lens, Lens and Prism, Stateful Lenses, Lenses compose, Writing a lens without Template Haskell, Traversals, Classy Lenses, Fields with makeFields">
    <meta property="og:site_name" content="DevTut">
    <meta property="og:title" content="Haskell - Lens">
    <meta property="og:description" content="Lenses for records, Manipulating tuples with Lens, Lens and Prism, Stateful Lenses, Lenses compose, Writing a lens without Template Haskell, Traversals, Classy Lenses, Fields with makeFields">
    <meta property="og:type" content="article">
    <meta property="og:url" content="/haskell/lens.html">
    <meta property="og:image" content="/logo.png">
    <meta name="twitter:title" content="Haskell - Lens">
    <meta name="twitter:description" content="Lenses for records, Manipulating tuples with Lens, Lens and Prism, Stateful Lenses, Lenses compose, Writing a lens without Template Haskell, Traversals, Classy Lenses, Fields with makeFields">
    <meta name="twitter:url" content="/haskell/lens.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="/logo.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/mstile-150x150.png">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="google-site-verification" content="76_rKXgwMVIjd-axJC_1zPV9OS4mEjvtgjYOWVkAdnQ">
    
    <link rel="preload" href="/assets/css/0.styles.60619e34.css" as="style"><link rel="preload" href="/assets/js/app.1779e102.js" as="script"><link rel="preload" href="/assets/js/3.2cfa8016.js" as="script"><link rel="preload" href="/assets/js/1199.b60e08fa.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.60619e34.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">DevTut</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Haskell</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/haskell/" aria-current="page" class="sidebar-link">Disclaimer</a></li><li><a href="/haskell/getting-started-with-haskell-language.html" class="sidebar-link">Getting started with Haskell Language</a></li><li><a href="/haskell/overloaded-literals.html" class="sidebar-link">Overloaded Literals</a></li><li><a href="/haskell/foldable.html" class="sidebar-link">Foldable</a></li><li><a href="/haskell/traversable.html" class="sidebar-link">Traversable</a></li><li><a href="/haskell/lens.html" aria-current="page" class="active sidebar-link">Lens</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/haskell/lens.html#lenses-for-records" class="sidebar-link">Lenses for records</a></li><li class="sidebar-sub-header"><a href="/haskell/lens.html#manipulating-tuples-with-lens" class="sidebar-link">Manipulating tuples with Lens</a></li><li class="sidebar-sub-header"><a href="/haskell/lens.html#lens-and-prism" class="sidebar-link">Lens and Prism</a></li><li class="sidebar-sub-header"><a href="/haskell/lens.html#stateful-lenses" class="sidebar-link">Stateful Lenses</a></li><li class="sidebar-sub-header"><a href="/haskell/lens.html#lenses-compose" class="sidebar-link">Lenses compose</a></li><li class="sidebar-sub-header"><a href="/haskell/lens.html#writing-a-lens-without-template-haskell" class="sidebar-link">Writing a lens without Template Haskell</a></li><li class="sidebar-sub-header"><a href="/haskell/lens.html#traversals" class="sidebar-link">Traversals</a></li><li class="sidebar-sub-header"><a href="/haskell/lens.html#classy-lenses" class="sidebar-link">Classy Lenses</a></li><li class="sidebar-sub-header"><a href="/haskell/lens.html#fields-with-makefields" class="sidebar-link">Fields with makeFields</a></li></ul></li><li><a href="/haskell/quickcheck.html" class="sidebar-link">QuickCheck</a></li><li><a href="/haskell/common-ghc-language-extensions.html" class="sidebar-link">Common GHC Language Extensions</a></li><li><a href="/haskell/free-monads.html" class="sidebar-link">Free Monads</a></li><li><a href="/haskell/type-classes.html" class="sidebar-link">Type Classes</a></li><li><a href="/haskell/io.html" class="sidebar-link">IO</a></li><li><a href="/haskell/record-syntax.html" class="sidebar-link">Record Syntax</a></li><li><a href="/haskell/partial-application.html" class="sidebar-link">Partial Application</a></li><li><a href="/haskell/monoid.html" class="sidebar-link">Monoid</a></li><li><a href="/haskell/category-theory.html" class="sidebar-link">Category Theory</a></li><li><a href="/haskell/lists.html" class="sidebar-link">Lists</a></li><li><a href="/haskell/sorting-algorithms.html" class="sidebar-link">Sorting Algorithms</a></li><li><a href="/haskell/type-families.html" class="sidebar-link">Type Families</a></li><li><a href="/haskell/monads.html" class="sidebar-link">Monads</a></li><li><a href="/haskell/stack.html" class="sidebar-link">Stack</a></li><li><a href="/haskell/generalized-algebraic-data-types.html" class="sidebar-link">Generalized Algebraic Data Types</a></li><li><a href="/haskell/recursion-schemes.html" class="sidebar-link">Recursion Schemes</a></li><li><a href="/haskell/data-text.html" class="sidebar-link">Data.Text</a></li><li><a href="/haskell/using-ghci.html" class="sidebar-link">Using GHCi</a></li><li><a href="/haskell/strictness.html" class="sidebar-link">Strictness</a></li><li><a href="/haskell/syntax-in-functions.html" class="sidebar-link">Syntax in Functions</a></li><li><a href="/haskell/functor.html" class="sidebar-link">Functor</a></li><li><a href="/haskell/testing-with-tasty.html" class="sidebar-link">Testing with Tasty</a></li><li><a href="/haskell/creating-custom-data-types.html" class="sidebar-link">Creating Custom Data Types</a></li><li><a href="/haskell/reactive-banana.html" class="sidebar-link">Reactive-banana</a></li><li><a href="/haskell/optimization.html" class="sidebar-link">Optimization</a></li><li><a href="/haskell/concurrency.html" class="sidebar-link">Concurrency</a></li><li><a href="/haskell/function-composition.html" class="sidebar-link">Function composition</a></li><li><a href="/haskell/databases.html" class="sidebar-link">Databases</a></li><li><a href="/haskell/data-aeson-json-in-haskell.html" class="sidebar-link">Data.Aeson - JSON in Haskell</a></li><li><a href="/haskell/higher-order-functions.html" class="sidebar-link">Higher-order functions</a></li><li><a href="/haskell/containers-data-map.html" class="sidebar-link">Containers - Data.Map</a></li><li><a href="/haskell/fixity-declarations.html" class="sidebar-link">Fixity declarations</a></li><li><a href="/haskell/web-development.html" class="sidebar-link">Web Development</a></li><li><a href="/haskell/vectors.html" class="sidebar-link">Vectors</a></li><li><a href="/haskell/cabal.html" class="sidebar-link">Cabal</a></li><li><a href="/haskell/type-algebra.html" class="sidebar-link">Type algebra</a></li><li><a href="/haskell/arrows.html" class="sidebar-link">Arrows</a></li><li><a href="/haskell/typed-holes.html" class="sidebar-link">Typed holes</a></li><li><a href="/haskell/rewrite-rules-ghc.html" class="sidebar-link">Rewrite rules (GHC)</a></li><li><a href="/haskell/date-and-time.html" class="sidebar-link">Date and Time</a></li><li><a href="/haskell/list-comprehensions.html" class="sidebar-link">List Comprehensions</a></li><li><a href="/haskell/streaming-io.html" class="sidebar-link">Streaming IO</a></li><li><a href="/haskell/google-protocol-buffers.html" class="sidebar-link">Google Protocol Buffers</a></li><li><a href="/haskell/template-haskell-quasiquotes.html" class="sidebar-link">Template Haskell &amp; QuasiQuotes</a></li><li><a href="/haskell/phantom-types.html" class="sidebar-link">Phantom types</a></li><li><a href="/haskell/modules.html" class="sidebar-link">Modules</a></li><li><a href="/haskell/tuples-pairs-triples.html" class="sidebar-link">Tuples (Pairs, Triples, ...)</a></li><li><a href="/haskell/graphics-with-gloss.html" class="sidebar-link">Graphics with Gloss</a></li><li><a href="/haskell/state-monad.html" class="sidebar-link">State Monad</a></li><li><a href="/haskell/pipes.html" class="sidebar-link">Pipes</a></li><li><a href="/haskell/infix-operators.html" class="sidebar-link">Infix operators</a></li><li><a href="/haskell/parallelism.html" class="sidebar-link">Parallelism</a></li><li><a href="/haskell/parsing-html-with-taggy-lens-and-lens.html" class="sidebar-link">Parsing HTML with taggy-lens and lens</a></li><li><a href="/haskell/foreign-function-interface.html" class="sidebar-link">Foreign Function Interface</a></li><li><a href="/haskell/gtk3.html" class="sidebar-link">Gtk3</a></li><li><a href="/haskell/monad-transformers.html" class="sidebar-link">Monad Transformers</a></li><li><a href="/haskell/bifunctor.html" class="sidebar-link">Bifunctor</a></li><li><a href="/haskell/proxies.html" class="sidebar-link">Proxies</a></li><li><a href="/haskell/applicative-functor.html" class="sidebar-link">Applicative Functor</a></li><li><a href="/haskell/common-monads-as-free-monads.html" class="sidebar-link">Common monads as free monads</a></li><li><a href="/haskell/common-functors-as-the-base-of-cofree-comonads.html" class="sidebar-link">Common functors as the base of cofree comonads</a></li><li><a href="/haskell/arithmetic.html" class="sidebar-link">Arithmetic</a></li><li><a href="/haskell/role.html" class="sidebar-link">Role</a></li><li><a href="/haskell/arbitrary-rank-polymorphism-with-rankntypes.html" class="sidebar-link">Arbitrary-rank polymorphism with RankNTypes</a></li><li><a href="/haskell/ghcjs.html" class="sidebar-link">GHCJS</a></li><li><a href="/haskell/xml.html" class="sidebar-link">XML</a></li><li><a href="/haskell/reader-readert.html" class="sidebar-link">Reader / ReaderT</a></li><li><a href="/haskell/function-call-syntax.html" class="sidebar-link">Function call syntax</a></li><li><a href="/haskell/logging.html" class="sidebar-link">Logging</a></li><li><a href="/haskell/attoparsec.html" class="sidebar-link">Attoparsec</a></li><li><a href="/haskell/zipwithm.html" class="sidebar-link">zipWithM</a></li><li><a href="/haskell/profunctor.html" class="sidebar-link">Profunctor</a></li><li><a href="/haskell/type-application.html" class="sidebar-link">Type Application</a></li><li><a href="/haskell/contributors.html" class="sidebar-link">The Contributors</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="lens"><a href="#lens" class="header-anchor">#</a> Lens</h1> <p><a href="https://hackage.haskell.org/package/lens" target="_blank" rel="noopener noreferrer">Lens<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> is a library for Haskell that provides lenses, isomorphisms, folds, traversals, getters and setters, which exposes a uniform interface for querying and manipulating arbitrary structures, not unlike Java's accessor and mutator concepts.</p> <h2 id="lenses-for-records"><a href="#lenses-for-records" class="header-anchor">#</a> Lenses for records</h2> <h3 id="simple-record"><a href="#simple-record" class="header-anchor">#</a> Simple record</h3> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token comment">{-# LANGUAGE TemplateHaskell #-}</span>
<span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Lens</span>

<span class="token keyword">data</span> <span class="token constant">Point</span> <span class="token operator">=</span> <span class="token constant">Point</span> <span class="token punctuation">{</span>
    <span class="token hvariable">_x</span> <span class="token operator">::</span> <span class="token constant">Float</span><span class="token punctuation">,</span>
    <span class="token hvariable">_y</span> <span class="token operator">::</span> <span class="token constant">Float</span>
<span class="token punctuation">}</span>
<span class="token hvariable">makeLenses</span> ''<span class="token constant">Point</span>

</code></pre></div><p>Lenses <code>x</code> and <code>y</code> are created.</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">let</span> <span class="token hvariable">p</span> <span class="token operator">=</span> <span class="token constant">Point</span> <span class="token number">5.0</span> <span class="token number">6.0</span> 
<span class="token hvariable">p</span> <span class="token operator">^.</span> <span class="token hvariable">x</span>     <span class="token comment">-- returns 5.0</span>
<span class="token hvariable">set</span> <span class="token hvariable">x</span> <span class="token number">10</span> <span class="token hvariable">p</span> <span class="token comment">-- returns Point { _x = 10.0, _y = 6.0 }</span>
<span class="token hvariable">p</span> <span class="token operator">&amp;</span> <span class="token hvariable">x</span> <span class="token operator">+~</span> <span class="token number">1</span> <span class="token comment">-- returns Point { _x = 6.0, _y = 6.0 }</span>

</code></pre></div><h3 id="managing-records-with-repeating-fields-names"><a href="#managing-records-with-repeating-fields-names" class="header-anchor">#</a> Managing records with repeating fields names</h3> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">data</span> <span class="token constant">Person</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token punctuation">{</span> <span class="token hvariable">_personName</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token punctuation">}</span>
<span class="token hvariable">makeFields</span> ''<span class="token constant">Person</span>

</code></pre></div><p>Creates a type class <code>HasName</code>, lens <code>name</code> for <code>Person</code>, and makes <code>Person</code> an instance of <code>HasName</code>. Subsequent records will be added to the class as well:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">data</span> <span class="token constant">Entity</span> <span class="token operator">=</span> <span class="token constant">Entity</span> <span class="token punctuation">{</span> <span class="token hvariable">_entityName</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token punctuation">}</span>
<span class="token hvariable">makeFields</span> ''<span class="token constant">Entity</span>

</code></pre></div><p>The Template Haskell extension is required for <code>makeFields</code> to work. Technically, it's entirely possible to create the lenses made this way via other means, e.g. by hand.</p> <h2 id="manipulating-tuples-with-lens"><a href="#manipulating-tuples-with-lens" class="header-anchor">#</a> Manipulating tuples with Lens</h2> <p>Getting</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">^.</span> <span class="token hvariable">_1</span> <span class="token comment">-- returns &quot;a&quot;</span>
<span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">^.</span> <span class="token hvariable">_2</span> <span class="token comment">-- returns 1</span>

</code></pre></div><p>Setting</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token hvariable">_1</span> <span class="token operator">.~</span> <span class="token string">&quot;b&quot;</span> <span class="token comment">-- returns (&quot;b&quot;, 1)</span>

</code></pre></div><p>Modifying</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token punctuation">(</span><span class="token string">&quot;a&quot;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token hvariable">_2</span> <span class="token operator">%~</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">-- returns (&quot;a&quot;, 2)</span>

</code></pre></div><p><code>both</code> Traversal</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token hvariable">both</span> <span class="token operator">*~</span> <span class="token number">2</span> <span class="token comment">-- returns (2, 4)</span>

</code></pre></div><h2 id="lens-and-prism"><a href="#lens-and-prism" class="header-anchor">#</a> Lens and Prism</h2> <p>A <code>Lens' s a</code> means that you can <strong>always</strong> find an <code>a</code> within any <code>s</code>. A <code>Prism' s a</code> means that you can <strong>sometimes</strong> find that <code>s</code> actually just <strong>is</strong> <code>a</code> but sometimes it's something else.</p> <p>To be more clear, we have <code>_1 :: Lens' (a, b) a</code>  because any tuple <strong>always</strong> has a first element. We have <code>_Just :: Prism' (Maybe a) a</code> because <strong>sometimes</strong> <code>Maybe a</code> is actually an <code>a</code> value wrapped in <code>Just</code> but <strong>sometimes</strong> it's <code>Nothing</code>.</p> <p>With this intuition, some standard combinators can be interpreted parallel to one another</p> <ul><li><code>view :: Lens' s a -&gt; (s -&gt; a)</code> &quot;gets&quot; the <code>a</code> out of the <code>s</code></li> <li><code>set :: Lens' s a -&gt; (a -&gt; s -&gt; s)</code> &quot;sets&quot; the <code>a</code> slot in <code>s</code></li> <li><code>review :: Prism' s a -&gt; (a -&gt; s)</code> &quot;realizes&quot; that an <code>a</code> could be an <code>s</code></li> <li><code>preview :: Prism' s a -&gt; (s -&gt; Maybe a)</code> &quot;attempts&quot; to turn an <code>s</code> into an <code>a</code>.</li></ul> <p>Another way to think about it is that a value of type <code>Lens' s a</code> demonstrates that <code>s</code> has the same structure as <code>(r, a)</code> for some unknown <code>r</code>. On the other hand, <code>Prism' s a</code> demonstrates that <code>s</code> has the same structure as <code>Either r a</code> for some <code>r</code>. We can write those four functions above with this knowledge:</p> <h2 id="stateful-lenses"><a href="#stateful-lenses" class="header-anchor">#</a> Stateful Lenses</h2> <p>Lens operators have useful variants that operate in stateful contexts. They are obtained by replacing <code>~</code> with <code>=</code> in the operator name.</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token punctuation">(</span><span class="token operator">+~</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Num</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token constant">ASetter</span> <span class="token hvariable">s</span> <span class="token hvariable">t</span> <span class="token hvariable">a</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token hvariable">t</span>
<span class="token punctuation">(</span><span class="token operator">+=</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">MonadState</span> <span class="token hvariable">s</span> <span class="token hvariable">m</span><span class="token punctuation">,</span> <span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">ASetter'</span> <span class="token hvariable">s</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre></div><blockquote></blockquote> <p>Note: The stateful variants aren't expected to change the type, so they have the <code>Lens'</code> or <code>Simple Lens'</code> signatures.</p> <h3 id="getting-rid-of-chains"><a href="#getting-rid-of-chains" class="header-anchor">#</a> Getting rid of <code>&amp;</code> chains</h3> <p>If lens-ful operations need to be chained, it often looks like this:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">change</span> <span class="token operator">::</span> <span class="token constant">A</span> <span class="token operator">-&gt;</span> <span class="token constant">A</span>
<span class="token hvariable">change</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token hvariable">a</span> <span class="token operator">&amp;</span> <span class="token hvariable">lensA</span> <span class="token operator">%~</span> <span class="token hvariable">operationA</span>
             <span class="token operator">&amp;</span> <span class="token hvariable">lensB</span> <span class="token operator">%~</span> <span class="token hvariable">operationB</span>
             <span class="token operator">&amp;</span> <span class="token hvariable">lensC</span> <span class="token operator">%~</span> <span class="token hvariable">operationC</span>

</code></pre></div><p>This works thanks to the associativity of <code>&amp;</code>. The stateful version is clearer, though.</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">change</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token builtin">flip</span> <span class="token hvariable">execState</span> <span class="token hvariable">a</span> <span class="token operator">$</span> <span class="token keyword">do</span>
    <span class="token hvariable">lensA</span> <span class="token operator">%=</span> <span class="token hvariable">operationA</span>
    <span class="token hvariable">lensB</span> <span class="token operator">%=</span> <span class="token hvariable">operationB</span>
    <span class="token hvariable">lensC</span> <span class="token operator">%=</span> <span class="token hvariable">operationC</span>

</code></pre></div><p>If <code>lensX</code> is actually <code>id</code>, the whole operation can of course be executed directly by just lifting it with <code>modify</code>.</p> <h3 id="imperative-code-with-structured-state"><a href="#imperative-code-with-structured-state" class="header-anchor">#</a> Imperative code with structured state</h3> <p>Assuming this example state:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">data</span> <span class="token constant">Point</span> <span class="token operator">=</span> <span class="token constant">Point</span> <span class="token punctuation">{</span> <span class="token hvariable">_x</span> <span class="token operator">::</span> <span class="token constant">Float</span><span class="token punctuation">,</span> <span class="token hvariable">_y</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token punctuation">}</span>
<span class="token keyword">data</span> <span class="token constant">Entity</span> <span class="token operator">=</span> <span class="token constant">Entity</span> <span class="token punctuation">{</span> <span class="token hvariable">_position</span> <span class="token operator">::</span> <span class="token constant">Point</span><span class="token punctuation">,</span> <span class="token hvariable">_direction</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token punctuation">}</span>
<span class="token keyword">data</span> <span class="token constant">World</span> <span class="token operator">=</span> <span class="token constant">World</span> <span class="token punctuation">{</span> <span class="token hvariable">_entities</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Entity</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>

<span class="token hvariable">makeLenses</span> ''<span class="token constant">Point</span>
<span class="token hvariable">makeLenses</span> ''<span class="token constant">Entity</span>
<span class="token hvariable">makeLenses</span> ''<span class="token constant">World</span>

</code></pre></div><p>We can write code that resembles classic imperative languages, while still allowing us to use benefits of Haskell:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">updateWorld</span> <span class="token operator">::</span> <span class="token constant">MonadState</span> <span class="token constant">World</span> <span class="token hvariable">m</span> <span class="token operator">=&gt;</span> <span class="token hvariable">m</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">updateWorld</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token comment">-- move the first entity</span>
    <span class="token hvariable">entities</span> <span class="token operator">.</span> <span class="token hvariable">ix</span> <span class="token number">0</span> <span class="token operator">.</span> <span class="token hvariable">position</span> <span class="token operator">.</span> <span class="token hvariable">x</span> <span class="token operator">+=</span> <span class="token number">1</span>

    <span class="token comment">-- do some operation on all of them</span>
    <span class="token hvariable">entities</span> <span class="token operator">.</span> <span class="token hvariable">traversed</span> <span class="token operator">.</span> <span class="token hvariable">position</span> <span class="token operator">%=</span> <span class="token operator">\</span><span class="token hvariable">p</span> <span class="token operator">-&gt;</span> <span class="token hvariable">p</span> <span class="token operator">`pointAdd`</span> <span class="token operator">...</span>

    <span class="token comment">-- or only on a subset</span>
    <span class="token hvariable">entities</span> <span class="token operator">.</span> <span class="token hvariable">traversed</span> <span class="token operator">.</span> <span class="token hvariable">filtered</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">e</span> <span class="token operator">-&gt;</span> <span class="token hvariable">e</span> <span class="token operator">^.</span> <span class="token hvariable">position</span><span class="token punctuation">.</span><span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">%=</span> <span class="token operator">...</span>

</code></pre></div><h2 id="lenses-compose"><a href="#lenses-compose" class="header-anchor">#</a> Lenses compose</h2> <p>If you have a <code>f :: Lens' a b</code> and a <code>g :: Lens' b c</code> then <code>f . g</code> is a <code>Lens' a c</code> gotten by following <code>f</code> first and then <code>g</code>. Notably:</p> <ul><li>Lenses compose as functions (really they just <strong>are</strong> functions)</li> <li>If you think of the <code>view</code> functionality of <code>Lens</code>, it seems like data flows &quot;left to right&quot;—this might feel backwards to your normal intuition for function composition. On the other hand, it ought to feel natural if you think of <code>.</code>-notation like how it happens in OO languages.</li></ul> <p>More than just composing <code>Lens</code> with <code>Lens</code>, <code>(.)</code> can be used to compose nearly any &quot;<code>Lens</code>-like&quot; type together. It's not always easy to see what the result is since the type becomes tougher to follow, but you can use <a href="https://hackage.haskell.org/package/lens" target="_blank" rel="noopener noreferrer">the <code>lens</code> chart<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> to figure it out. The composition <code>x . y</code> has the type of the least-upper-bound of the types of both <code>x</code> and <code>y</code> in that chart.</p> <h2 id="writing-a-lens-without-template-haskell"><a href="#writing-a-lens-without-template-haskell" class="header-anchor">#</a> Writing a lens without Template Haskell</h2> <p>To demystify Template Haskell, suppose you have</p> <p>then</p> <p>produces (more or less)</p> <p>There's nothing particularly magical going on, though. You can write these yourself:</p> <p>Essentially, you want to &quot;visit&quot; your lens' &quot;focus&quot; with the <code>wrap</code> function and then rebuild the &quot;entire&quot; type.</p> <h2 id="traversals"><a href="#traversals" class="header-anchor">#</a> Traversals</h2> <p>A <code>Traversal' s a</code> shows that <code>s</code> has 0-to-many <code>a</code>s inside of it.</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token hvariable">toListOf</span> <span class="token operator">::</span> <span class="token constant">Traversal'</span> <span class="token hvariable">s</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

</code></pre></div><p>Any type <code>t</code> which is <code>Traversable</code> automatically has that <code>traverse :: Traversal (t a) a</code>.</p> <p>We can use a <code>Traversal</code> to set or map over all of these <code>a</code> values</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token operator">&gt;</span> <span class="token hvariable">set</span> <span class="token hvariable">traverse</span> <span class="token number">1</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">10</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>

<span class="token operator">&gt;</span> <span class="token hvariable">over</span> <span class="token hvariable">traverse</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">10</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">]</span>

</code></pre></div><p>A <code>f :: Lens' s a</code> says there's exactly one <code>a</code> inside of <code>s</code>. A <code>g :: Prism' a b</code> says there are either 0 or 1 <code>b</code>s in <code>a</code>. Composing <code>f . g</code> gives us a <code>Traversal' s b</code> because following <code>f</code> and then <code>g</code> shows how there there are 0-to-1 <code>b</code>s in <code>s</code>.</p> <h2 id="classy-lenses"><a href="#classy-lenses" class="header-anchor">#</a> Classy Lenses</h2> <p>In addition to the standard <code>makeLenses</code> function for generating <code>Lens</code>es, <code>Control.Lens.TH</code> also offers the <code>makeClassy</code> function. <code>makeClassy</code> has the same type and works in essentially the same way as <code>makeLenses</code>, with one key difference. In addition to generating the standard lenses and traversals, if the type has no arguments, it will also create a class describing all the datatypes which possess the type as a field. For example</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">data</span> <span class="token constant">Foo</span> <span class="token operator">=</span> <span class="token constant">Foo</span> <span class="token punctuation">{</span> <span class="token hvariable">_fooX</span><span class="token punctuation">,</span> <span class="token hvariable">_fooY</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token punctuation">}</span>
  <span class="token hvariable">makeClassy</span> ''<span class="token constant">Foo</span>

</code></pre></div><p>will create</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token keyword">class</span> <span class="token constant">HasFoo</span> <span class="token hvariable">t</span> <span class="token keyword">where</span>
   <span class="token hvariable">foo</span> <span class="token operator">::</span> <span class="token constant">Simple</span> <span class="token constant">Lens</span> <span class="token hvariable">t</span> <span class="token constant">Foo</span>

<span class="token keyword">instance</span> <span class="token constant">HasFoo</span> <span class="token constant">Foo</span> <span class="token keyword">where</span> <span class="token hvariable">foo</span> <span class="token operator">=</span> <span class="token builtin">id</span>

<span class="token hvariable">fooX</span><span class="token punctuation">,</span> <span class="token hvariable">fooY</span> <span class="token operator">::</span> <span class="token constant">HasFoo</span> <span class="token hvariable">t</span> <span class="token operator">=&gt;</span> <span class="token constant">Simple</span> <span class="token constant">Lens</span> <span class="token hvariable">t</span> <span class="token constant">Int</span>

</code></pre></div><h2 id="fields-with-makefields"><a href="#fields-with-makefields" class="header-anchor">#</a> Fields with makeFields</h2> <p>(This example copied from <a href="http://stackoverflow.com/a/34624414/163177" target="_blank" rel="noopener noreferrer">this StackOverflow answer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>)</p> <p>Let's say you have a number of different data types that all ought to have a lens with the same name, in this case <code>capacity</code>.  The <code>makeFields</code> slice will create a class that accomplish this without namespace conflicts.</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token comment">{-# LANGUAGE FunctionalDependencies
           , MultiParamTypeClasses
           , TemplateHaskell
  #-}</span>

<span class="token keyword">module</span> <span class="token constant">Foo</span>
<span class="token keyword">where</span>

<span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Lens</span>

<span class="token keyword">data</span> <span class="token constant">Foo</span>
  <span class="token operator">=</span> <span class="token constant">Foo</span> <span class="token punctuation">{</span> <span class="token hvariable">fooCapacity</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token punctuation">}</span>
  <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Show</span><span class="token punctuation">)</span>
<span class="token operator">$</span><span class="token punctuation">(</span><span class="token hvariable">makeFields</span> ''<span class="token constant">Foo</span><span class="token punctuation">)</span>

<span class="token keyword">data</span> <span class="token constant">Bar</span>
  <span class="token operator">=</span> <span class="token constant">Bar</span> <span class="token punctuation">{</span> <span class="token hvariable">barCapacity</span> <span class="token operator">::</span> <span class="token constant">Double</span> <span class="token punctuation">}</span>
  <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Show</span><span class="token punctuation">)</span>
<span class="token operator">$</span><span class="token punctuation">(</span><span class="token hvariable">makeFields</span> ''<span class="token constant">Bar</span><span class="token punctuation">)</span>

</code></pre></div><p>Then in ghci:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token operator">*</span><span class="token constant">Foo</span>
λ <span class="token keyword">let</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token constant">Foo</span> <span class="token number">3</span>
<span class="token operator">|</span>     <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token constant">Bar</span> <span class="token number">7</span>
<span class="token operator">|</span> 
<span class="token hvariable">b</span> <span class="token operator">::</span> <span class="token constant">Bar</span>
<span class="token hvariable">f</span> <span class="token operator">::</span> <span class="token constant">Foo</span>

<span class="token operator">*</span><span class="token constant">Foo</span>
λ <span class="token hvariable">fooCapacity</span> <span class="token hvariable">f</span>
<span class="token number">3</span>
<span class="token hvariable">it</span> <span class="token operator">::</span> <span class="token constant">Int</span>

<span class="token operator">*</span><span class="token constant">Foo</span>
λ <span class="token hvariable">barCapacity</span> <span class="token hvariable">b</span>
<span class="token number">7.0</span>
<span class="token hvariable">it</span> <span class="token operator">::</span> <span class="token constant">Double</span>

<span class="token operator">*</span><span class="token constant">Foo</span>
λ <span class="token hvariable">f</span> <span class="token operator">^.</span> <span class="token hvariable">capacity</span>
<span class="token number">3</span>
<span class="token hvariable">it</span> <span class="token operator">::</span> <span class="token constant">Int</span>

<span class="token operator">*</span><span class="token constant">Foo</span>
λ <span class="token hvariable">b</span> <span class="token operator">^.</span> <span class="token hvariable">capacity</span>
<span class="token number">7.0</span>
<span class="token hvariable">it</span> <span class="token operator">::</span> <span class="token constant">Double</span>

λ <span class="token operator">:</span><span class="token hvariable">info</span> <span class="token constant">HasCapacity</span> 
<span class="token keyword">class</span> <span class="token constant">HasCapacity</span> <span class="token hvariable">s</span> <span class="token hvariable">a</span> <span class="token operator">|</span> <span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token keyword">where</span>
  <span class="token hvariable">capacity</span> <span class="token operator">::</span> <span class="token constant">Lens'</span> <span class="token hvariable">s</span> <span class="token hvariable">a</span>
    <span class="token comment">-- Defined at Foo.hs:14:3</span>
<span class="token keyword">instance</span> <span class="token constant">HasCapacity</span> <span class="token constant">Foo</span> <span class="token constant">Int</span> <span class="token comment">-- Defined at Foo.hs:14:3</span>
<span class="token keyword">instance</span> <span class="token constant">HasCapacity</span> <span class="token constant">Bar</span> <span class="token constant">Double</span> <span class="token comment">-- Defined at Foo.hs:19:3</span>

</code></pre></div><p>So what it's actually done is declared a class <code>HasCapacity s a</code>, where capacity is a <code>Lens'</code> from <code>s</code> to <code>a</code> (<code>a</code> is fixed once s is known). It figured out the name &quot;capacity&quot; by stripping off the (lowercased) name of the data type from the field; I find it pleasant not to have to use an underscore on either the field name or the lens name, since sometimes record syntax is actually what you want. You can use makeFieldsWith and the various lensRules to have some different options for calculating the lens names.</p> <p>In case it helps, using ghci -ddump-splices Foo.hs:</p> <div class="language-hs extra-class"><pre class="language-hs"><code><span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">of</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token constant">Compiling</span> <span class="token constant">Foo</span>              <span class="token punctuation">(</span> <span class="token hvariable">Foo<span class="token punctuation">.</span>hs</span><span class="token punctuation">,</span> <span class="token hvariable">interpreted</span> <span class="token punctuation">)</span>
<span class="token hvariable">Foo<span class="token punctuation">.</span>hs</span><span class="token operator">:</span><span class="token number">14</span><span class="token operator">:</span><span class="token number">3</span><span class="token operator">-</span><span class="token number">18</span><span class="token operator">:</span> <span class="token constant">Splicing</span> <span class="token hvariable">declarations</span>
    <span class="token hvariable">makeFields</span> ''<span class="token constant">Foo</span>
  <span class="token operator">======&gt;</span>
    <span class="token keyword">class</span> <span class="token constant">HasCapacity</span> <span class="token hvariable">s</span> <span class="token hvariable">a</span> <span class="token operator">|</span> <span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token keyword">where</span>
      <span class="token hvariable">capacity</span> <span class="token operator">::</span> <span class="token constant">Lens'</span> <span class="token hvariable">s</span> <span class="token hvariable">a</span>
    <span class="token keyword">instance</span> <span class="token constant">HasCapacity</span> <span class="token constant">Foo</span> <span class="token constant">Int</span> <span class="token keyword">where</span>
      <span class="token comment">{-# INLINE capacity #-}</span>
      <span class="token hvariable">capacity</span> <span class="token operator">=</span> <span class="token hvariable">iso</span> <span class="token punctuation">(</span><span class="token operator">\</span> <span class="token punctuation">(</span><span class="token constant">Foo</span> <span class="token hvariable">x_a7fG</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x_a7fG</span><span class="token punctuation">)</span> <span class="token constant">Foo</span>
<span class="token hvariable">Foo<span class="token punctuation">.</span>hs</span><span class="token operator">:</span><span class="token number">19</span><span class="token operator">:</span><span class="token number">3</span><span class="token operator">-</span><span class="token number">18</span><span class="token operator">:</span> <span class="token constant">Splicing</span> <span class="token hvariable">declarations</span>
    <span class="token hvariable">makeFields</span> ''<span class="token constant">Bar</span>
  <span class="token operator">======&gt;</span>
    <span class="token keyword">instance</span> <span class="token constant">HasCapacity</span> <span class="token constant">Bar</span> <span class="token constant">Double</span> <span class="token keyword">where</span>
      <span class="token comment">{-# INLINE capacity #-}</span>
      <span class="token hvariable">capacity</span> <span class="token operator">=</span> <span class="token hvariable">iso</span> <span class="token punctuation">(</span><span class="token operator">\</span> <span class="token punctuation">(</span><span class="token constant">Bar</span> <span class="token hvariable">x_a7ne</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x_a7ne</span><span class="token punctuation">)</span> <span class="token constant">Bar</span>
<span class="token constant">Ok</span><span class="token punctuation">,</span> <span class="token hvariable">modules</span> <span class="token hvariable">loaded</span><span class="token operator">:</span> <span class="token constant">Foo</span><span class="token punctuation">.</span>

</code></pre></div><p>So the first splice made the class <code>HasCapcity</code> and added an instance for Foo; the second used the existing class and made an instance for Bar.</p> <p>This also works if you import the <code>HasCapcity</code> class from another module; <code>makeFields</code> can add more instances to the existing class and spread your types out across multiple modules. But if you use it again in another module where you haven't imported the class, it'll make a new class (with the same name), and you'll have two separate overloaded capacity lenses that are not compatible.</p> <h4 id="remarks"><a href="#remarks" class="header-anchor">#</a> Remarks</h4> <h3 id="what-is-a-lens"><a href="#what-is-a-lens" class="header-anchor">#</a> What is a Lens?</h3> <p>Lenses (and other optics) allow us to separate describing <strong>how</strong> we want to access some data from <strong>what</strong> we want to do with it. It is important to distinguish between the abstract notion of a lens and the concrete implementation. Understanding abstractly makes programming with <code>lens</code> much easier in the long run. There are many isomorphic representations of lenses so for this discussion we will avoid
any concrete implementation discussion and instead give a high-level overview of the concepts.</p> <h3 id="focusing"><a href="#focusing" class="header-anchor">#</a> Focusing</h3> <p>An important concept in understanding abstractly is the notion of <strong>focusing</strong>. Important optics <strong>focus</strong> on a specific part of a larger data structure without forgetting about the larger context. For example, the lens <code>_1</code> focuses on the first
element of a tuple but doesn't forget about what was in the second field.</p> <p>Once we have focus, we can then talk about which operations we are allowed to perform with a lens. Given a <code>Lens s a</code> which when given a datatype of type <code>s</code> focuses on a specific <code>a</code>, we can either</p> <ol><li>Extract the <code>a</code> by forgetting about the additional context or</li> <li>Replace the <code>a</code> by providing a new value</li></ol> <p>These correspond to the well-known <code>get</code> and <code>set</code> operations which are usually used to characterise a lens.</p> <h3 id="other-optics"><a href="#other-optics" class="header-anchor">#</a> Other Optics</h3> <p>We can talk about other optics in a similar fashion.</p> <table><thead><tr><th>Optic</th> <th>Focuses on...</th></tr></thead> <tbody><tr><td>Lens</td> <td>One part of a product</td></tr> <tr><td>Prism</td> <td>One part of a sum</td></tr> <tr><td>Traversal</td> <td>Zero or more parts of a data structure</td></tr> <tr><td>Isomorphism</td> <td>...</td></tr></tbody></table> <p>Each optic focuses in a different way, as such, depending on which type of optic
we have we can perform different operations.</p> <h3 id="composition"><a href="#composition" class="header-anchor">#</a> Composition</h3> <p>What's more, we can compose any of the two optics we have so-far discussed in order
to specify complex data accesses. The four types of optics we have discussed form a lattice, the result of composing two optics together is their upper bound.</p> <p><a href="https://i.stack.imgur.com/nPIlo.png" target="_blank" rel="noopener noreferrer"><img src="https://i.stack.imgur.com/nPIlo.png" alt="enter image description here"><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>For example, if we compose together a lens and a prism, we get a traversal. The reason for this is that by their (vertical) composition, we first focus on one part of a product and then on one part of a sum. The result being an optic which focuses on precisely zero or one parts of our data which is a special case of a traversal. (This is also sometimes called an affine traversal).</p> <h3 id="in-haskell"><a href="#in-haskell" class="header-anchor">#</a> In Haskell</h3> <p>The reason for the popularity in Haskell is that there is a very succinct representation of optics. All optics are just functions of a certain form which can
be composed together using function composition. This leads to a very light-weight
embedding which makes it easy to integrate optics into your programs. Further to this, due to the particulars of the encoding, function composition also automatically computes the upper bound of two optics we compose. This means that
we can reuse the same combinators for different optics without explicit casting.</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/devtut/generate/edit/master/docs/haskell/lens.md" target="_blank" rel="noopener noreferrer">Edit this page on GitHub</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/haskell/traversable.html" class="prev">
        Traversable
      </a></span> <span class="next"><a href="/haskell/quickcheck.html">
        QuickCheck
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.1779e102.js" defer></script><script src="/assets/js/3.2cfa8016.js" defer></script><script src="/assets/js/1199.b60e08fa.js" defer></script>
  </body>
</html>
