<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C - Undefined behavior</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="description" content="Dereferencing a pointer to variable beyond its lifetime, Copying overlapping memory, Signed integer overflow, Use of an uninitialized variable, Data race, Read value of pointer that was freed, Modify string literal, Using incorrect format specifier in printf, Modifying any object more than once between two sequence points, Passing a null pointer to printf %s conversion, Freeing memory twice, Bit shifting using negative counts or beyond the width of the type, Accessing memory beyond allocated chunk, Returning from a function that's declared with `_Noreturn` or `noreturn` function specifier, Dereferencing a null pointer, Reading an uninitialized object  that is not backed by memory, Addition or subtraction of pointer not properly bounded, Modifying a const variable using a pointer, Using fflush on an input stream, Missing return statement in value returning function, Division by zero, Inconsistent linkage of identifiers, Conversion between pointer types produces incorrectly aligned result, Modifying the string returned by getenv, strerror, and setlocale functions">
    <meta property="og:site_name" content="DevTut">
    <meta property="og:title" content="C - Undefined behavior">
    <meta property="og:description" content="Dereferencing a pointer to variable beyond its lifetime, Copying overlapping memory, Signed integer overflow, Use of an uninitialized variable, Data race, Read value of pointer that was freed, Modify string literal, Using incorrect format specifier in printf, Modifying any object more than once between two sequence points, Passing a null pointer to printf %s conversion, Freeing memory twice, Bit shifting using negative counts or beyond the width of the type, Accessing memory beyond allocated chunk, Returning from a function that's declared with `_Noreturn` or `noreturn` function specifier, Dereferencing a null pointer, Reading an uninitialized object  that is not backed by memory, Addition or subtraction of pointer not properly bounded, Modifying a const variable using a pointer, Using fflush on an input stream, Missing return statement in value returning function, Division by zero, Inconsistent linkage of identifiers, Conversion between pointer types produces incorrectly aligned result, Modifying the string returned by getenv, strerror, and setlocale functions">
    <meta property="og:type" content="article">
    <meta property="og:url" content="/c/undefined-behavior.html">
    <meta property="og:image" content="/logo.png">
    <meta name="twitter:title" content="C - Undefined behavior">
    <meta name="twitter:description" content="Dereferencing a pointer to variable beyond its lifetime, Copying overlapping memory, Signed integer overflow, Use of an uninitialized variable, Data race, Read value of pointer that was freed, Modify string literal, Using incorrect format specifier in printf, Modifying any object more than once between two sequence points, Passing a null pointer to printf %s conversion, Freeing memory twice, Bit shifting using negative counts or beyond the width of the type, Accessing memory beyond allocated chunk, Returning from a function that's declared with `_Noreturn` or `noreturn` function specifier, Dereferencing a null pointer, Reading an uninitialized object  that is not backed by memory, Addition or subtraction of pointer not properly bounded, Modifying a const variable using a pointer, Using fflush on an input stream, Missing return statement in value returning function, Division by zero, Inconsistent linkage of identifiers, Conversion between pointer types produces incorrectly aligned result, Modifying the string returned by getenv, strerror, and setlocale functions">
    <meta name="twitter:url" content="/c/undefined-behavior.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="/logo.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/mstile-150x150.png">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="google-site-verification" content="76_rKXgwMVIjd-axJC_1zPV9OS4mEjvtgjYOWVkAdnQ">
    <link rel="preload" href="/assets/css/0.styles.8b877eb8.css" as="style"><link rel="preload" href="/assets/js/app.ced448ab.js" as="script"><link rel="preload" href="/assets/js/3.f1d73125.js" as="script"><link rel="preload" href="/assets/js/602.efbad421.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.8b877eb8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">DevTut</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>C</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/c/" class="sidebar-link">Disclaimer</a></li><li><a href="/c/getting-started-with-c-language.html" class="sidebar-link">Getting started with C Language</a></li><li><a href="/c/comments.html" class="sidebar-link">Comments</a></li><li><a href="/c/data-types.html" class="sidebar-link">Data Types</a></li><li><a href="/c/operators.html" class="sidebar-link">Operators</a></li><li><a href="/c/boolean.html" class="sidebar-link">Boolean</a></li><li><a href="/c/strings.html" class="sidebar-link">Strings</a></li><li><a href="/c/literals-for-numbers-characters-and-strings.html" class="sidebar-link">Literals for numbers, characters and strings</a></li><li><a href="/c/compound-literals.html" class="sidebar-link">Compound Literals</a></li><li><a href="/c/bit-fields.html" class="sidebar-link">Bit-fields</a></li><li><a href="/c/arrays.html" class="sidebar-link">Arrays</a></li><li><a href="/c/linked-lists.html" class="sidebar-link">Linked lists</a></li><li><a href="/c/enumerations.html" class="sidebar-link">Enumerations</a></li><li><a href="/c/structs.html" class="sidebar-link">Structs</a></li><li><a href="/c/standard-math.html" class="sidebar-link">Standard Math</a></li><li><a href="/c/iteration-statements-loops-for-while-do-while.html" class="sidebar-link">Iteration Statements/Loops: for, while, do-while</a></li><li><a href="/c/selection-statements.html" class="sidebar-link">Selection Statements</a></li><li><a href="/c/initialization.html" class="sidebar-link">Initialization</a></li><li><a href="/c/declaration-vs-definition.html" class="sidebar-link">Declaration vs Definition</a></li><li><a href="/c/files-and-i-o-streams.html" class="sidebar-link">Files and I/O streams</a></li><li><a href="/c/formatted-input-output.html" class="sidebar-link">Formatted Input/Output</a></li><li><a href="/c/pointers.html" class="sidebar-link">Pointers</a></li><li><a href="/c/sequence-points.html" class="sidebar-link">Sequence points</a></li><li><a href="/c/function-pointers.html" class="sidebar-link">Function Pointers</a></li><li><a href="/c/function-parameters.html" class="sidebar-link">Function Parameters</a></li><li><a href="/c/pass-2d-arrays-to-functions.html" class="sidebar-link">Pass 2D-arrays to functions</a></li><li><a href="/c/error-handling.html" class="sidebar-link">Error handling</a></li><li><a href="/c/undefined-behavior.html" class="active sidebar-link">Undefined behavior</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/c/undefined-behavior.html#dereferencing-a-pointer-to-variable-beyond-its-lifetime" class="sidebar-link">Dereferencing a pointer to variable beyond its lifetime</a></li><li class="sidebar-sub-header"><a href="/c/undefined-behavior.html#copying-overlapping-memory" class="sidebar-link">Copying overlapping memory</a></li><li class="sidebar-sub-header"><a href="/c/undefined-behavior.html#signed-integer-overflow" class="sidebar-link">Signed integer overflow</a></li><li class="sidebar-sub-header"><a href="/c/undefined-behavior.html#use-of-an-uninitialized-variable" class="sidebar-link">Use of an uninitialized variable</a></li><li class="sidebar-sub-header"><a href="/c/undefined-behavior.html#data-race" class="sidebar-link">Data race</a></li><li class="sidebar-sub-header"><a href="/c/undefined-behavior.html#read-value-of-pointer-that-was-freed" class="sidebar-link">Read value of pointer that was freed</a></li><li class="sidebar-sub-header"><a href="/c/undefined-behavior.html#modify-string-literal" class="sidebar-link">Modify string literal</a></li><li class="sidebar-sub-header"><a href="/c/undefined-behavior.html#using-incorrect-format-specifier-in-printf" class="sidebar-link">Using incorrect format specifier in printf</a></li><li class="sidebar-sub-header"><a href="/c/undefined-behavior.html#modifying-any-object-more-than-once-between-two-sequence-points" class="sidebar-link">Modifying any object more than once between two sequence points</a></li><li class="sidebar-sub-header"><a href="/c/undefined-behavior.html#passing-a-null-pointer-to-printf-s-conversion" class="sidebar-link">Passing a null pointer to printf %s conversion</a></li><li class="sidebar-sub-header"><a href="/c/undefined-behavior.html#freeing-memory-twice" class="sidebar-link">Freeing memory twice</a></li><li class="sidebar-sub-header"><a href="/c/undefined-behavior.html#bit-shifting-using-negative-counts-or-beyond-the-width-of-the-type" class="sidebar-link">Bit shifting using negative counts or beyond the width of the type</a></li><li class="sidebar-sub-header"><a href="/c/undefined-behavior.html#accessing-memory-beyond-allocated-chunk" class="sidebar-link">Accessing memory beyond allocated chunk</a></li><li class="sidebar-sub-header"><a href="/c/undefined-behavior.html#returning-from-a-function-that-s-declared-with-noreturn-or-noreturn-function-specifier" class="sidebar-link">Returning from a function that's declared with _Noreturn or noreturn function specifier</a></li><li class="sidebar-sub-header"><a href="/c/undefined-behavior.html#dereferencing-a-null-pointer" class="sidebar-link">Dereferencing a null pointer</a></li><li class="sidebar-sub-header"><a href="/c/undefined-behavior.html#reading-an-uninitialized-object-that-is-not-backed-by-memory" class="sidebar-link">Reading an uninitialized object  that is not backed by memory</a></li><li class="sidebar-sub-header"><a href="/c/undefined-behavior.html#addition-or-subtraction-of-pointer-not-properly-bounded" class="sidebar-link">Addition or subtraction of pointer not properly bounded</a></li><li class="sidebar-sub-header"><a href="/c/undefined-behavior.html#modifying-a-const-variable-using-a-pointer" class="sidebar-link">Modifying a const variable using a pointer</a></li><li class="sidebar-sub-header"><a href="/c/undefined-behavior.html#using-fflush-on-an-input-stream" class="sidebar-link">Using fflush on an input stream</a></li><li class="sidebar-sub-header"><a href="/c/undefined-behavior.html#missing-return-statement-in-value-returning-function" class="sidebar-link">Missing return statement in value returning function</a></li><li class="sidebar-sub-header"><a href="/c/undefined-behavior.html#division-by-zero" class="sidebar-link">Division by zero</a></li><li class="sidebar-sub-header"><a href="/c/undefined-behavior.html#inconsistent-linkage-of-identifiers" class="sidebar-link">Inconsistent linkage of identifiers</a></li><li class="sidebar-sub-header"><a href="/c/undefined-behavior.html#conversion-between-pointer-types-produces-incorrectly-aligned-result" class="sidebar-link">Conversion between pointer types produces incorrectly aligned result</a></li><li class="sidebar-sub-header"><a href="/c/undefined-behavior.html#modifying-the-string-returned-by-getenv-strerror-and-setlocale-functions" class="sidebar-link">Modifying the string returned by getenv, strerror, and setlocale functions</a></li></ul></li><li><a href="/c/random-number-generation.html" class="sidebar-link">Random Number Generation</a></li><li><a href="/c/preprocessor-and-macros.html" class="sidebar-link">Preprocessor and Macros</a></li><li><a href="/c/signal-handling.html" class="sidebar-link">Signal handling</a></li><li><a href="/c/variable-arguments.html" class="sidebar-link">Variable arguments</a></li><li><a href="/c/assertion.html" class="sidebar-link">Assertion</a></li><li><a href="/c/generic-selection.html" class="sidebar-link">Generic selection</a></li><li><a href="/c/x-macros.html" class="sidebar-link">X-macros</a></li><li><a href="/c/aliasing-and-effective-type.html" class="sidebar-link">Aliasing and effective type</a></li><li><a href="/c/compilation.html" class="sidebar-link">Compilation</a></li><li><a href="/c/identifier-scope.html" class="sidebar-link">Identifier Scope</a></li><li><a href="/c/common-pitfalls.html" class="sidebar-link">Common pitfalls</a></li><li><a href="/c/implicit-and-explicit-conversions.html" class="sidebar-link">Implicit and Explicit Conversions</a></li><li><a href="/c/type-qualifiers.html" class="sidebar-link">Type Qualifiers</a></li><li><a href="/c/valgrind.html" class="sidebar-link">Valgrind</a></li><li><a href="/c/typedef.html" class="sidebar-link">Typedef</a></li><li><a href="/c/storage-classes.html" class="sidebar-link">Storage Classes</a></li><li><a href="/c/declarations.html" class="sidebar-link">Declarations</a></li><li><a href="/c/inline-assembly.html" class="sidebar-link">Inline assembly</a></li><li><a href="/c/threads-native.html" class="sidebar-link">Threads (native)</a></li><li><a href="/c/structure-padding-and-packing.html" class="sidebar-link">Structure Padding and Packing</a></li><li><a href="/c/memory-management.html" class="sidebar-link">Memory management</a></li><li><a href="/c/implementation-defined-behaviour.html" class="sidebar-link">Implementation-defined behaviour</a></li><li><a href="/c/atomics.html" class="sidebar-link">Atomics</a></li><li><a href="/c/jump-statements.html" class="sidebar-link">Jump Statements</a></li><li><a href="/c/create-and-include-header-files.html" class="sidebar-link">Create and include header files</a></li><li><a href="/c/testing-frameworks.html" class="sidebar-link">Testing frameworks</a></li><li><a href="/c/ctype-h-character-classification-conversion.html" class="sidebar-link">— character classification &amp; conversion</a></li><li><a href="/c/side-effects.html" class="sidebar-link">Side Effects</a></li><li><a href="/c/multi-character-character-sequence.html" class="sidebar-link">Multi-Character Character Sequence</a></li><li><a href="/c/constraints.html" class="sidebar-link">Constraints</a></li><li><a href="/c/inlining.html" class="sidebar-link">Inlining</a></li><li><a href="/c/unions.html" class="sidebar-link">Unions</a></li><li><a href="/c/threads-native.html" class="sidebar-link">Threads (native)</a></li><li><a href="/c/multithreading.html" class="sidebar-link">Multithreading</a></li><li><a href="/c/interprocess-communication-ipc.html" class="sidebar-link">Interprocess Communication (IPC)</a></li><li><a href="/c/testing-frameworks.html" class="sidebar-link">Testing frameworks</a></li><li><a href="/c/valgrind.html" class="sidebar-link">Valgrind</a></li><li><a href="/c/common-c-programming-idioms-and-developer-practices.html" class="sidebar-link">Common C programming idioms and developer practices</a></li><li><a href="/c/common-pitfalls.html" class="sidebar-link">Common pitfalls</a></li><li><a href="/c/contributors.html" class="sidebar-link">The Contributors</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="undefined-behavior"><a href="#undefined-behavior" class="header-anchor">#</a> Undefined behavior</h1> <p>In C, some expressions yield <strong>undefined behavior</strong>. The standard explicitly chooses to not define how a compiler should behave if it encounters such an expression. As a result, a compiler is free to do whatever it sees fit and may produce useful results, unexpected  results, or even crash.</p> <p>Code that invokes UB may work as intended on a specific system with a specific compiler, but will likely not work on another system, or with a different compiler, compiler version or compiler settings.</p> <h2 id="dereferencing-a-pointer-to-variable-beyond-its-lifetime"><a href="#dereferencing-a-pointer-to-variable-beyond-its-lifetime" class="header-anchor">#</a> Dereferencing a pointer to variable beyond its lifetime</h2> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span><span class="token operator">*</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> bar<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> baz <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>
    baz <span class="token operator">+=</span> bar<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">&amp;</span>baz<span class="token punctuation">;</span> <span class="token comment">/* (&amp;baz) copied to new memory location outside of foo. */</span>
<span class="token punctuation">}</span> <span class="token comment">/* (1) The lifetime of baz and bar end here as they have automatic storage   
   * duration (local variables), thus the returned pointer is not valid! */</span>

<span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">;</span>

    p <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* (2) this expression's behavior is undefined */</span>
    <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">*</span>p <span class="token operator">-</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token comment">/* (3) Undefined behaviour here */</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Some compilers helpfully point this out. For example, <code>gcc</code> warns with:</p> <div class="language-c extra-class"><pre class="language-c"><code>warning<span class="token operator">:</span> function returns address of local variable <span class="token punctuation">[</span><span class="token operator">-</span>Wreturn<span class="token operator">-</span>local<span class="token operator">-</span>addr<span class="token punctuation">]</span>

</code></pre></div><p>and <code>clang</code> warns with:</p> <div class="language-c extra-class"><pre class="language-c"><code>warning<span class="token operator">:</span> address of stack memory associated with local variable <span class="token string">'baz'</span> returned 
<span class="token punctuation">[</span><span class="token operator">-</span>Wreturn<span class="token operator">-</span>stack<span class="token operator">-</span>address<span class="token punctuation">]</span>

</code></pre></div><p>for the above code. But compilers may not be able to help in complex code.</p> <p>(1) Returning reference to variable declared <code>static</code> is defined behaviour, as the variable is not destroyed after leaving current scope.</p> <p>(2) According to ISO/IEC 9899:2011 6.2.4 §2, &quot;The value of a pointer becomes indeterminate when the object it points to reaches the end of its lifetime.&quot;</p> <p>(3) Dereferencing the pointer returned by the function <code>foo</code> is undefined behaviour as the memory it references holds an indeterminate value.</p> <h2 id="copying-overlapping-memory"><a href="#copying-overlapping-memory" class="header-anchor">#</a> Copying overlapping memory</h2> <p>A wide variety of standard library functions have among their effects copying byte sequences from one memory region to another.  Most of these functions have undefined behavior when the source and destination regions overlap.</p> <p>For example, this ...</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span> </span><span class="token comment">/* for memcpy() */</span>

<span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;This is an example&quot;</span><span class="token punctuation">;</span>
<span class="token function">memcpy</span><span class="token punctuation">(</span>str <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">,</span> str<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>... attempts to copy 10 bytes where the source and destination memory areas overlap by three bytes. To visualize:</p> <div class="language- extra-class"><pre class="language-text"><code>
              overlapping area
               |
               _ _
              |   |
              v   v
T h i s   i s   a n   e x a m p l e \0
^             ^
|             |
|             destination
|
source

</code></pre></div><p>Because of the overlap, the resulting behavior is undefined.</p> <p>Among the standard library functions with a limitation of this kind are <code>memcpy()</code>, <code>strcpy()</code>, <code>strcat()</code>, <code>sprintf()</code>, and <code>sscanf()</code>.  The standard says of these and several other functions:</p> <blockquote></blockquote> <p>If copying takes place between objects that overlap, the behavior
is undefined.</p> <p>The <code>memmove()</code> function is the principal exception to this rule.  Its definition specifies that the function behaves as if the source data were first copied into a temporary buffer and then written to the destination address.  There is no exception for overlapping source and destination regions, nor any need for one, so <code>memmove()</code> has well-defined behavior in such cases.</p> <p>The distinction reflects an efficiency <strong>vs</strong>. generality tradeoff.  Copying such as these functions perform usually occurs between disjoint regions of memory, and often it is possible to know at development time whether a particular instance of memory copying will be in that category.  Assuming non-overlap affords comparatively more efficient implementations that do not reliably produce correct results when the assumption does not hold.  Most C library functions are allowed the more efficient implementations, and <code>memmove()</code> fills in the gaps, serving the cases where the source and destination may or do overlap.  To produce the correct effect in all cases, however, it must perform additional tests and / or employ a comparatively less efficient implementation.</p> <h2 id="signed-integer-overflow"><a href="#signed-integer-overflow" class="header-anchor">#</a> Signed integer overflow</h2> <p>Per paragraph 6.5/5 of both C99 and C11, evaluation of an expression produces undefined behavior if the result is not a representable value of the expression's type.  For arithmetic types, that's called an <strong>overflow</strong>.  Unsigned integer arithmetic does not overflow because paragraph 6.2.5/9 applies, causing any unsigned result that otherwise would be out of range to be reduced to an in-range value.  There is no analogous provision for <strong>signed</strong> integer types, however; these can and do overflow, producing undefined behavior.  For example,</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;limits.h&gt;</span>      </span><span class="token comment">/* to get INT_MAX */</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> INT_MAX <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">/* Overflow happens here */</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Most instances of this type of undefined behavior are more difficult to recognize or predict.  Overflow can in principle arise from any addition, subtraction, or multiplication operation on signed integers (subject to the usual arithmetic conversions) where there are not effective bounds on or a relationship between the operands to prevent it.  For example, this function:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">square</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">*</span> x<span class="token punctuation">;</span>  <span class="token comment">/* overflows for some values of x */</span>
<span class="token punctuation">}</span>

</code></pre></div><p>is reasonable, and it does the right thing for small enough argument values, but its behavior is undefined for larger argument values.  You cannot judge from the function alone whether programs that call it exhibit undefined behavior as a result.  It depends on what arguments they pass to it.</p> <p>On the other hand, consider this trivial example of overflow-safe signed integer arithmetic:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">zero</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">-</span> x<span class="token punctuation">;</span>  <span class="token comment">/* Cannot overflow */</span>
<span class="token punctuation">}</span>

</code></pre></div><p>The relationship between the operands of the subtraction operator ensures that the subtraction never overflows.  Or consider this somewhat more practical example:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">sizeDelta</span><span class="token punctuation">(</span>FILE <span class="token operator">*</span>f1<span class="token punctuation">,</span> FILE <span class="token operator">*</span>f2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> count1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> count2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">fgetc</span><span class="token punctuation">(</span>f1<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">EOF</span><span class="token punctuation">)</span> count1<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment">/* might overflow */</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">fgetc</span><span class="token punctuation">(</span>f2<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">EOF</span><span class="token punctuation">)</span> count2<span class="token operator">++</span><span class="token punctuation">;</span>  <span class="token comment">/* might overflow */</span>

    <span class="token keyword">return</span> count1 <span class="token operator">-</span> count2<span class="token punctuation">;</span> <span class="token comment">/* provided no UB to this point, will not overflow */</span>
<span class="token punctuation">}</span>

</code></pre></div><p>As long as that the counters do not overflow individually, the operands of the final subtraction will both be non-negative.  All differences between any two such values are representable as <code>int</code>.</p> <h2 id="use-of-an-uninitialized-variable"><a href="#use-of-an-uninitialized-variable" class="header-anchor">#</a> Use of an uninitialized variable</h2> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> a<span class="token punctuation">;</span> 
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>The variable <code>a</code> is an <code>int</code> with automatic storage duration. The example code above is trying to print the value of an uninitialized variable (<code>a</code> was never initialized). Automatic variables which are not initialized have indeterminate values; accessing these can lead to undefined behavior.</p> <p><strong>Note:</strong> Variables with static or thread local storage, including <a href="http://stackoverflow.com/a/16016164" target="_blank" rel="noopener noreferrer">global variables<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> without the <code>static</code> keyword, are initialized to either zero, or their initialized value. Hence the following is legal.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> b<span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>A very common mistake is to not initialize the variables that serve as counters to 0. You add values to them, but since the initial value is garbage, you will invoke <strong>Undefined Behavior</strong>, such as in the question <a href="http://stackoverflow.com/questions/38881622/" target="_blank" rel="noopener noreferrer">Compilation on terminal gives off pointer warning and strange symbols<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>.</p> <p>Example:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> counter<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
        counter <span class="token operator">+=</span> i<span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\n&quot;</span><span class="token punctuation">,</span> counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Output:</p> <div class="language-c extra-class"><pre class="language-c"><code>C02QT2UBFVH6<span class="token operator">-</span>lm<span class="token operator">:</span><span class="token operator">~</span> gsamaras$ gcc main<span class="token punctuation">.</span>c <span class="token operator">-</span>Wall <span class="token operator">-</span>o main
main<span class="token punctuation">.</span>c<span class="token operator">:</span><span class="token number">6</span><span class="token operator">:</span><span class="token number">9</span><span class="token operator">:</span> warning<span class="token operator">:</span> variable <span class="token string">'counter'</span> is uninitialized when used here <span class="token punctuation">[</span><span class="token operator">-</span>Wuninitialized<span class="token punctuation">]</span>
        counter <span class="token operator">+=</span> i<span class="token punctuation">;</span>
        <span class="token operator">^</span><span class="token operator">~</span><span class="token operator">~</span><span class="token operator">~</span><span class="token operator">~</span><span class="token operator">~</span><span class="token operator">~</span>
main<span class="token punctuation">.</span>c<span class="token operator">:</span><span class="token number">4</span><span class="token operator">:</span><span class="token number">19</span><span class="token operator">:</span> note<span class="token operator">:</span> initialize the variable <span class="token string">'counter'</span> to silence this warning
    <span class="token keyword">int</span> i<span class="token punctuation">,</span> counter<span class="token punctuation">;</span>
                  <span class="token operator">^</span>
                   <span class="token operator">=</span> <span class="token number">0</span>
<span class="token number">1</span> warning generated<span class="token punctuation">.</span>
C02QT2UBFVH6<span class="token operator">-</span>lm<span class="token operator">:</span><span class="token operator">~</span> gsamaras$ <span class="token punctuation">.</span><span class="token operator">/</span>main
<span class="token number">32812</span>

</code></pre></div><p>The above rules are applicable for pointers as well. For example, the following results in undefined behavior</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
    p<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// Trying to increment an uninitialized pointer.</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Note that the above code on its own might not cause an error or segmentation fault, but trying to dereference this pointer later would cause the undefined behavior.</p> <h2 id="data-race"><a href="#data-race" class="header-anchor">#</a> Data race</h2> <p>C11 introduced support for multiple threads of execution, which affords the possibility of data races.  A program contains a data race if an object in it is  accessed<sup>1</sup> by two different threads, where at least one of the accesses is non-atomic, at least one modifies the object, and program semantics fail to ensure that the two accesses cannot overlap temporally.<sup>2</sup>  Note well that actual concurrency of the accesses involved is not a condition for a data race; data races cover a broader class of issues arising from (allowed) inconsistencies in different threads' views of memory.</p> <p>Consider this example:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;threads.h&gt;</span></span>

<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">Function</span><span class="token punctuation">(</span> <span class="token keyword">void</span><span class="token operator">*</span> ignore <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    thrd_t id<span class="token punctuation">;</span>
    <span class="token function">thrd_create</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>id <span class="token punctuation">,</span> Function <span class="token punctuation">,</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>

    <span class="token function">thrd_join</span><span class="token punctuation">(</span> id <span class="token punctuation">,</span> <span class="token constant">NULL</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>The main thread calls <code>thrd_create</code> to start a new thread running function <code>Function</code>.  The second thread modifies <code>a</code>, and the main thread reads <code>a</code>. Neither of those access is atomic, and the two threads do nothing either individually or jointly to ensure that they do not overlap, so there is a data race.</p> <p>Among the ways this program could avoid the data race are</p> <ul><li>the main thread could perform its read of <code>a</code> before starting the other thread;</li> <li>the main thread could perform its read of <code>a</code> after ensuring via <code>thrd_join</code> that the other has terminated;</li> <li>the threads could synchronize their accesses via a mutex, each one locking that mutex before accessing <code>a</code> and unlocking it afterward.</li></ul> <p>As the mutex option demonstrates, avoiding a data race does not require ensuring a specific order of operations, such as the child thread modifying <code>a</code> before the main thread reads it; it is sufficient (for avoiding a data race) to ensure that  for a given execution, one access will happen before the other.</p> <p><sup>1</sup> Modifying or reading an object.</p> <p><sup>2</sup> (Quoted from ISO:IEC 9889:201x, section 5.1.2.4 &quot;Multi-threaded executions and data races&quot;)<br>
The execution of a program contains a data race if it contains two conflicting actions in different threads, at least one of which is not atomic, and neither happens before the other. Any such data race results in undefined behavior.</p> <h2 id="read-value-of-pointer-that-was-freed"><a href="#read-value-of-pointer-that-was-freed" class="header-anchor">#</a> Read value of pointer that was freed</h2> <p>Even just <strong>reading</strong> the value of a pointer that was freed (i.e. without trying to dereference the pointer) is undefined behavior(UB), e.g.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">/* NOTE: even without dereferencing, this may have UB */</span>
<span class="token punctuation">{</span>

<span class="token punctuation">}</span>

</code></pre></div><p>Quoting <strong>ISO/IEC 9899:2011</strong>, section 6.2.4 §2:</p> <blockquote></blockquote> <p>[…] The value of a pointer becomes indeterminate when the object it points
to (or just past) reaches the end of its lifetime.</p> <p>The use of indeterminate memory for anything, including apparently harmless comparison or arithmetic, can have undefined behavior if the value can be a trap representation for the type.</p> <h2 id="modify-string-literal"><a href="#modify-string-literal" class="header-anchor">#</a> Modify string literal</h2> <p>In this code example, the char pointer <code>p</code> is initialized to the address of a string literal. Attempting to modify the string literal has undefined behavior.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token string">&quot;hello world&quot;</span><span class="token punctuation">;</span>
p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'H'</span><span class="token punctuation">;</span> <span class="token comment">// Undefined behavior</span>

</code></pre></div><p>However, modifying a mutable array of <code>char</code> directly, or through a pointer is naturally not undefined behavior, even if its initializer is a literal string. The following is fine:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;hello, world&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>p <span class="token operator">=</span> a<span class="token punctuation">;</span>

a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'H'</span><span class="token punctuation">;</span>
p<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'W'</span><span class="token punctuation">;</span>

</code></pre></div><p>That's because the string literal is effectively copied to the array each time the array is initialized (once for variables with static duration, each time the array is created for variables with automatic or thread duration — variables with allocated duration aren't initialized), and it is fine to modify array contents.</p> <h2 id="using-incorrect-format-specifier-in-printf"><a href="#using-incorrect-format-specifier-in-printf" class="header-anchor">#</a> Using incorrect format specifier in printf</h2> <p>Using an incorrect format specifier in the first argument to <code>printf</code> invokes undefined behavior.
For example, the code below invokes undefined behavior:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">long</span> z <span class="token operator">=</span> <span class="token string">'B'</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%c\n&quot;</span><span class="token punctuation">,</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>Here is another example</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%f\n&quot;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>Above line of code is undefined behavior. <code>%f</code> expects double. However 0 is of type <code>int</code>.</p> <p>Note that your compiler usually can help you avoid cases like these, if you turn on the proper flags during compiling (<code>-Wformat</code> in <code>clang</code> and <code>gcc</code>). From the last example:</p> <div class="language-c extra-class"><pre class="language-c"><code>warning<span class="token operator">:</span> format specifies type <span class="token string">'double'</span> but the argument has type
      <span class="token string">'int'</span> <span class="token punctuation">[</span><span class="token operator">-</span>Wformat<span class="token punctuation">]</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%f\n&quot;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">~</span><span class="token operator">~</span>    <span class="token operator">^</span>
            <span class="token operator">%</span>d

</code></pre></div><h2 id="modifying-any-object-more-than-once-between-two-sequence-points"><a href="#modifying-any-object-more-than-once-between-two-sequence-points" class="header-anchor">#</a> Modifying any object more than once between two sequence points</h2> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
i <span class="token operator">=</span> i<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">/* Assignment changes variable, post-increment as well */</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> i<span class="token operator">++</span> <span class="token operator">+</span> i<span class="token operator">--</span><span class="token punctuation">;</span>

</code></pre></div><p>Code like this often leads to speculations about the &quot;resulting value&quot; of <code>i</code>.  Rather than specifying an outcome, however, the C standards specify that evaluating such an expression produces <strong>undefined behavior</strong>.  Prior to C2011, the standard formalized these rules in terms of so-called <strong>sequence points</strong>:</p> <blockquote></blockquote> <p>Between the previous and next sequence point a scalar object shall have its stored value modified at most once by the evaluation of an expression. Furthermore, the prior value shall be read only to determine the value to be stored.</p> <p>(C99 standard, section 6.5, paragraph 2)</p> <p>That scheme proved to be a little too coarse, resulting in some expressions exhibiting undefined behavior with respect to C99 that plausibly should not do.  C2011 retains sequence points, but introduces a more nuanced approach to this area based on <strong>sequencing</strong> and a relationship it calls &quot;sequenced before&quot;:</p> <blockquote></blockquote> <p>If  a  side  effect  on  a  scalar  object  is  unsequenced  relative  to either  a  different  side  effect on  the  same  scalar  object  or  a  value  computation  using  the  value  of  the  same  scalar object,  the  behavior  is  undefined.   If  there  are  multiple  allowable  orderings  of  the subexpressions  of  an  expression,  the  behavior  is  undefined  if  such  an  unsequenced  side effect occurs in any of the orderings.</p> <p>(C2011 standard, section 6.5, paragraph 2)</p> <p>The full details of the &quot;sequenced before&quot; relation are too long to describe here, but they supplement sequence points rather than supplanting them, so they have the effect of defining behavior for some evaluations whose behavior previously was undefined.  In particular, if there is a sequence point between two evaluations, then the one before the sequence point is &quot;sequenced before&quot; the one after.</p> <p>The following example has well-defined behaviour:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
i <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token operator">++</span><span class="token punctuation">,</span> i<span class="token operator">+</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* The comma-operator creates a sequence point */</span>

</code></pre></div><p>The following example has undefined behaviour:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d %d\n&quot;</span><span class="token punctuation">,</span> i<span class="token operator">++</span><span class="token punctuation">,</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* commas as separator of function arguments are not comma-operators */</span>

</code></pre></div><p>As with any form of undefined behavior, observing the actual behavior of evaluating expressions that violate the sequencing rules is not informative, except in a retrospective sense.  The language standard provides no basis for expecting such observations to be predictive even of the future behavior of the same program.</p> <h2 id="passing-a-null-pointer-to-printf-s-conversion"><a href="#passing-a-null-pointer-to-printf-s-conversion" class="header-anchor">#</a> Passing a null pointer to printf %s conversion</h2> <p>The <code>%s</code> conversion of <code>printf</code> states that the corresponding argument <strong>a pointer to the initial element of an array of character type</strong>. A null pointer does not point to the initial element of any array of character type, and thus the behavior of the following is undefined:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">char</span> <span class="token operator">*</span>foo <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s&quot;</span><span class="token punctuation">,</span> foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* undefined behavior */</span>

</code></pre></div><p>However, the undefined behavior does not always mean that the program crashes — some systems take steps to avoid the crash that normally happens when a null pointer is dereferenced. For example Glibc is known to print</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token punctuation">(</span>null<span class="token punctuation">)</span>

</code></pre></div><p>for the code above. However, add (just) a newline to the format string and you will get a crash:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">char</span> <span class="token operator">*</span>foo <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s\n&quot;</span><span class="token punctuation">,</span> foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* undefined behavior */</span>

</code></pre></div><p>In this case, it happens because GCC has an optimization that turns <code>printf(&quot;%s\n&quot;, argument);</code> into a call to <code>puts</code> with <code>puts(argument)</code>, and <code>puts</code> in Glibc does not handle null pointers. All this behavior is standard conforming.</p> <p>Note that <strong>null pointer</strong> is different from an <strong>empty string</strong>. So, the following is valid and has no undefined behaviour. It'll just print a <strong>newline</strong>:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">char</span> <span class="token operator">*</span>foo <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s\n&quot;</span><span class="token punctuation">,</span> foo<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><h2 id="freeing-memory-twice"><a href="#freeing-memory-twice" class="header-anchor">#</a> Freeing memory twice</h2> <p>Freeing memory twice is undefined behavior, e.g.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token operator">*</span> x <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">*</span>x <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
<span class="token function">free</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">free</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>Quote from standard(7.20.3.2. The free function of C99 ):</p> <blockquote></blockquote> <p>Otherwise, if the argument does not match a pointer earlier returned
by the calloc, malloc, or realloc function, or if the space has been
deallocated by a call to free or realloc, the behavior is undefined.</p> <h2 id="bit-shifting-using-negative-counts-or-beyond-the-width-of-the-type"><a href="#bit-shifting-using-negative-counts-or-beyond-the-width-of-the-type" class="header-anchor">#</a> Bit shifting using negative counts or beyond the width of the type</h2> <p>If the <strong>shift count</strong> value is a <strong>negative value</strong> then both <strong>left shift</strong> and <strong>right shift</strong> operations are undefined<sup>1</sup>:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">/* undefined */</span>
<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">&gt;&gt;</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">/* undefined */</span>

</code></pre></div><p>If <strong>left shift</strong> is performed on a <strong>negative value</strong>, it's undefined:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">5</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">/* undefined */</span>

</code></pre></div><p>If <strong>left shift</strong> is performed on a <strong>positive value</strong> and result of the mathematical value is <strong>not</strong> representable in the type, it's undefined<sup>1</sup>:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">/* Assuming an int is 32-bits wide, the value '5 * 2^72' doesn't fit 
 * in an int. So, this is undefined. */</span>
       
<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">&lt;&lt;</span> <span class="token number">72</span><span class="token punctuation">;</span>

</code></pre></div><p>Note that <strong>right shift</strong> on a <strong>negative value</strong>  (.e.g <code>-5 &gt;&gt; 3</code>) is <strong>not</strong> undefined but <strong>implementation-defined</strong>.</p> <p><sup>1</sup> Quoting <strong>ISO/IEC 9899:201x</strong>, section 6.5.7:</p> <blockquote></blockquote> <p>If the value of the right operand is negative or is greater than or equal to the width of the promoted left operand, the behavior is undefined.</p> <h2 id="accessing-memory-beyond-allocated-chunk"><a href="#accessing-memory-beyond-allocated-chunk" class="header-anchor">#</a> Accessing memory beyond allocated chunk</h2> <p>A a pointer to a piece of memory containing <code>n</code> elements may only be dereferenced if it is in the range <code>memory</code> and <code>memory + (n - 1)</code>. Dereferencing a pointer outside of that range results in undefined behavior. As an example, consider the following code:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>beyond_array <span class="token operator">=</span> array <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token operator">*</span>beyond_array <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/* Accesses memory that has not been allocated. */</span>

</code></pre></div><p>The third line accesses the 4th element in an array that is only 3 elements long, leading to undefined behavior. Similarly, the behavior of the second line in the following code fragment is also not well defined:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

</code></pre></div><p>Note that pointing past the last element of an array is not undefined behavior (<code>beyond_array = array + 3</code> is well defined here), but dereferencing it is (<code>*beyond_array</code> is undefined behavior). This rule also holds for dynamically allocated memory (such as buffers created through <code>malloc</code>).</p> <h2 id="returning-from-a-function-that-s-declared-with-noreturn-or-noreturn-function-specifier"><a href="#returning-from-a-function-that-s-declared-with-noreturn-or-noreturn-function-specifier" class="header-anchor">#</a> Returning from a function that's declared with <code>_Noreturn</code> or <code>noreturn</code> function specifier</h2> <p>The function specifier <code>_Noreturn</code> was introduced in C11. The header <code>&lt;stdnoreturn.h&gt;</code> provides a macro <code>noreturn</code> which expands to <code>_Noreturn</code>. So using <code>_Noreturn</code> or <code>noreturn</code> from <code>&lt;stdnoreturn.h&gt;</code> is fine and equivalent.</p> <p>A function that's declared with <code>_Noreturn</code> (or <code>noreturn</code>) is not allowed to return to its caller. If such a function <strong>does</strong> return to its caller, the behavior is undefined.</p> <p>In the following example, <code>func()</code> is declared with <code>noreturn</code> specifier but it returns to its caller.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdnoreturn.h&gt;</span></span>

noreturn <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;In func()...\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">/* Undefined behavior as func() returns */</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p><code>gcc</code> and <code>clang</code> produce warnings for the above program:</p> <div class="language-c extra-class"><pre class="language-c"><code>$ gcc test<span class="token punctuation">.</span>c
test<span class="token punctuation">.</span>c<span class="token operator">:</span> In function ‘func’<span class="token operator">:</span>
test<span class="token punctuation">.</span>c<span class="token operator">:</span><span class="token number">9</span><span class="token operator">:</span><span class="token number">1</span><span class="token operator">:</span> warning<span class="token operator">:</span> ‘noreturn’ function does <span class="token keyword">return</span>
 <span class="token punctuation">}</span>
 <span class="token operator">^</span>
$ clang test<span class="token punctuation">.</span>c
test<span class="token punctuation">.</span>c<span class="token operator">:</span><span class="token number">9</span><span class="token operator">:</span><span class="token number">1</span><span class="token operator">:</span> warning<span class="token operator">:</span> function declared <span class="token string">'noreturn'</span> should not <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">-</span>Winvalid<span class="token operator">-</span>noreturn<span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token operator">^</span>

</code></pre></div><p>An example using <code>noreturn</code> that has well-defined behavior:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdnoreturn.h&gt;</span></span>

noreturn <span class="token keyword">void</span> <span class="token function">my_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/* calls exit() and doesn't return to its caller. */</span>
<span class="token keyword">void</span> <span class="token function">my_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Exiting...\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token function">my_exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h2 id="dereferencing-a-null-pointer"><a href="#dereferencing-a-null-pointer" class="header-anchor">#</a> Dereferencing a null pointer</h2> <p>This is an example of dereferencing a NULL pointer, causing undefined behavior.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token operator">*</span> pointer <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token operator">*</span>pointer<span class="token punctuation">;</span> <span class="token comment">/* Dereferencing happens here */</span>

</code></pre></div><p>A <code>NULL</code> pointer is guaranteed by the C standard to compare unequal to any pointer to a valid object, and dereferencing it invokes undefined behavior.</p> <h2 id="reading-an-uninitialized-object-that-is-not-backed-by-memory"><a href="#reading-an-uninitialized-object-that-is-not-backed-by-memory" class="header-anchor">#</a> Reading an uninitialized object  that is not backed by memory</h2> <p>Reading an object will cause undefined behavior, if the object is<sup>1</sup>:</p> <ul><li>uninitialized</li> <li>defined with automatic storage duration</li> <li>it's address is never taken</li></ul> <p>The variable a in the below example satisfies all those conditions:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">Function</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span> 

</code></pre></div><p><sup>1</sup> (Quoted from: ISO:IEC 9899:201X 6.3.2.1 Lvalues, arrays, and function designators 2)<br>
If the lvalue designates an object of automatic storage duration that could have been declared with the register storage class (never had its address taken), and that object is uninitialized (not declared with an initializer and no assignment to it has been performed prior to use), the behavior is undefined.</p> <h2 id="addition-or-subtraction-of-pointer-not-properly-bounded"><a href="#addition-or-subtraction-of-pointer-not-properly-bounded" class="header-anchor">#</a> Addition or subtraction of pointer not properly bounded</h2> <p>The following code has undefined behavior:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>ptr1 <span class="token operator">=</span> buffer <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">/* undefined behavior */</span>
<span class="token keyword">char</span> <span class="token operator">*</span>ptr2 <span class="token operator">=</span> buffer <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">;</span>  <span class="token comment">/* OK, pointing to the '\0' inside the array */</span>
<span class="token keyword">char</span> <span class="token operator">*</span>ptr3 <span class="token operator">=</span> buffer <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">;</span>  <span class="token comment">/* OK, pointing to just beyond */</span>
<span class="token keyword">char</span> <span class="token operator">*</span>ptr4 <span class="token operator">=</span> buffer <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span>  <span class="token comment">/* undefined behavior */</span>

</code></pre></div><p>According to C11, if addition or subtraction of a pointer into, or just beyond, an array object and an integer type produces a result that does not point into, or just beyond, the same array object, the behavior is undefined (6.5.6).</p> <p>Additionally it is naturally undefined behavior to <strong>dereference</strong> a pointer that points to just beyond the array:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> <span class="token operator">*</span>ptr3 <span class="token operator">=</span> buffer <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">;</span>  <span class="token comment">/* OK, pointing to just beyond */</span>
<span class="token keyword">char</span> value <span class="token operator">=</span> <span class="token operator">*</span>ptr3<span class="token punctuation">;</span>       <span class="token comment">/* undefined behavior */</span>

</code></pre></div><h2 id="modifying-a-const-variable-using-a-pointer"><a href="#modifying-a-const-variable-using-a-pointer" class="header-anchor">#</a> Modifying a const variable using a pointer</h2> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> foo_readonly <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>foo_ptr<span class="token punctuation">;</span>

    foo_ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>foo_readonly<span class="token punctuation">;</span> <span class="token comment">/* (1) This casts away the const qualifier */</span>
    <span class="token operator">*</span>foo_ptr <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span> <span class="token comment">/* This is undefined behavior */</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Quoting <strong>ISO/IEC 9899:201x</strong>, section 6.7.3 §2:</p> <blockquote></blockquote> <p>If an attempt is made to modify an object defined with a const-qualified type through use
of  an  lvalue  with  non-const-qualified  type,  the  behavior  is  undefined. [...]</p> <p><sup>(1)</sup> In GCC this can throw the following warning: <code>warning: assignment discards ‘const’ qualifier from pointer target type [-Wdiscarded-qualifiers]</code></p> <h2 id="using-fflush-on-an-input-stream"><a href="#using-fflush-on-an-input-stream" class="header-anchor">#</a> Using fflush on an input stream</h2> <p>The POSIX and C standards explicitly state that using <code>fflush</code> on an input stream is undefined behavior. The <code>fflush</code> is defined only for output streams.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">char</span> input<span class="token punctuation">[</span><span class="token number">4096</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">&quot;%i&quot;</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fflush</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;-- undefined behavior</span>
    <span class="token function">gets</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>There is no standard way to discard unread characters from an input stream. On the other hand, some implementations uses <code>fflush</code> to clear <code>stdin</code> buffer. Microsoft defines the behavior of <code>fflush</code> on an input stream: If the stream is open for input, <code>fflush</code> clears the contents of the buffer. According to POSIX.1-2008, the behavior of <code>fflush</code> is undefined unless the input file is seekable.</p> <p>See <a href="http://stackoverflow.com/questions/2979209/using-fflushstdin" target="_blank" rel="noopener noreferrer">Using <code>fflush(stdin)</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> for many more details.</p> <h2 id="missing-return-statement-in-value-returning-function"><a href="#missing-return-statement-in-value-returning-function" class="header-anchor">#</a> Missing return statement in value returning function</h2> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* do stuff */</span>
  <span class="token comment">/* no return here */</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* Trying to use the (not) returned value causes UB */</span>
  <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>When a function is declared to return a value then it has to do so on every possible code path through it. Undefined behavior occurs as soon as the caller (which is expecting a return value) tries to use the return value<sup>1</sup>.</p> <p>Note that the undefined behaviour happens <strong>only if</strong> the caller attempts to use/access the value from the function. For example,</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* do stuff */</span>
  <span class="token comment">/* no return here */</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* The value (not) returned from foo() is unused. So, this program
   * doesn't cause *undefined behaviour*. */</span>
  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>The <code>main()</code> function is an exception to this rule in that it is possible for it to be terminated without a return statement because an assumed return value of <code>0</code> will automatically be used in this case<sup>2</sup>.</p> <p><sup>1</sup> (<strong>ISO/IEC 9899:201x</strong>, 6.9.1/12)</p> <blockquote></blockquote> <p>If the } that terminates a function is reached, and the value of the function call is used by the caller, the behavior is undefined.</p> <p><sup>2</sup> (<strong>ISO/IEC 9899:201x</strong>, 5.1.2.2.3/1)</p> <blockquote></blockquote> <p>reaching the } that terminates the main function returns a value of 0.</p> <h2 id="division-by-zero"><a href="#division-by-zero" class="header-anchor">#</a> Division by zero</h2> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">/</span> x<span class="token punctuation">;</span>  <span class="token comment">/* integer division */</span>

</code></pre></div><p>or</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">double</span> x <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token number">5.0</span> <span class="token operator">/</span> x<span class="token punctuation">;</span>  <span class="token comment">/* floating point division */</span>

</code></pre></div><p>or</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">%</span> x<span class="token punctuation">;</span>  <span class="token comment">/* modulo operation */</span>

</code></pre></div><p>For the second line in each example, where the value of the second operand (x) is zero, the behaviour is undefined.</p> <p>Note that most <a href="http://stackoverflow.com/documentation/c/4832/implementation-defined-behaviour#t=201609301837209070127&amp;a=remarks-overview-0" target="_blank" rel="noopener noreferrer">implementations<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> of floating point math will <a href="http://stackoverflow.com/a/12617974/1462295" target="_blank" rel="noopener noreferrer">follow a standard<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> (e.g. IEEE 754), in which case operations like divide-by-zero will have consistent results (e.g., <code>INFINITY</code>) even though the C standard says the operation is undefined.</p> <h2 id="inconsistent-linkage-of-identifiers"><a href="#inconsistent-linkage-of-identifiers" class="header-anchor">#</a> Inconsistent linkage of identifiers</h2> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">extern</span> <span class="token keyword">int</span> var<span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> var<span class="token punctuation">;</span> <span class="token comment">/* Undefined behaviour */</span>

</code></pre></div><p><strong>C11, §6.2.2, 7</strong> says:</p> <blockquote></blockquote> <p>If, within a translation unit, the same identiﬁer appears with both
internal and external linkage, the behavior is undeﬁned.</p> <p>Note that if an prior declaration of an identifier is visible then it'll have the prior declaration's linkage. <strong>C11, §6.2.2, 4</strong> allows it:</p> <blockquote></blockquote> <p>For an identiﬁer declared with the storage-class speciﬁer extern in a
scope in which a prior declaration of that identiﬁer is visible,31) if
the prior declaration speciﬁes internal or external linkage, the
linkage of the identiﬁer at the later declaration is the same as the
linkage speciﬁed at the prior declaration. If no prior declaration is
visible, or if the prior declaration speciﬁes no linkage, then the
identiﬁer has external linkage.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">/* 1. This is NOT undefined */</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> var<span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> var<span class="token punctuation">;</span> 


<span class="token comment">/* 2. This is NOT undefined */</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> var<span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> var<span class="token punctuation">;</span> 

<span class="token comment">/* 3. This is NOT undefined */</span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> var<span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> var<span class="token punctuation">;</span> 

</code></pre></div><h2 id="conversion-between-pointer-types-produces-incorrectly-aligned-result"><a href="#conversion-between-pointer-types-produces-incorrectly-aligned-result" class="header-anchor">#</a> Conversion between pointer types produces incorrectly aligned result</h2> <p>The following <strong>might</strong> have undefined behavior due to incorrect pointer alignment:</p> <div class="language- extra-class"><pre class="language-text"><code>
char *memory_block = calloc(sizeof(uint32_t) + 1, 1);
 uint32_t *intptr = (uint32_t*)(memory_block + 1);  /* possible undefined behavior */
 uint32_t mvalue = *intptr;

</code></pre></div><p>The undefined behavior happens as the pointer is converted. According to C11, if a <strong>conversion between two pointer types produces a result that is incorrectly aligned (6.3.2.3), the behavior is undefined</strong>. Here an <code>uint32_t</code> could require alignment of 2 or 4 for example.</p> <p><code>calloc</code> on the other hand is required to return a pointer that is suitably aligned for any object type; thus <code>memory_block</code> is properly aligned to contain an <code>uint32_t</code> in its initial part.  Then, on a system where <code>uint32_t</code> has required alignment of 2 or 4, <code>memory_block + 1</code> will be an <strong>odd</strong> address and thus not properly aligned.</p> <p>Observe that the C standard requests that already the cast operation is undefined. This is imposed because on platforms where addresses are segmented, the byte address <code>memory_block + 1</code> may not even have a proper representation as an integer pointer.</p> <p>Casting <code>char *</code> to pointers to other types without any concern to alignment requirements is sometimes incorrectly used for decoding packed structures such as file headers or network packets.</p> <p>You can avoid the undefined behavior arising from misaligned pointer conversion by using <code>memcpy</code>:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mvalue<span class="token punctuation">,</span> memory_block <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> mvalue<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>Here no pointer conversion to <code>uint32_t*</code> takes place and the bytes are copied one by one.</p> <p>This copy operation for our example only leads to valid value of <code>mvalue</code> because:</p> <ul><li>We used <code>calloc</code>, so the bytes are properly initialized. In our case all bytes have value <code>0</code>, but any other proper initialization would do.</li> <li><code>uint32_t</code> is an exact width type and has no padding bits</li> <li>Any arbitrary bit pattern is a valid representation for any unsigned type.</li></ul> <h2 id="modifying-the-string-returned-by-getenv-strerror-and-setlocale-functions"><a href="#modifying-the-string-returned-by-getenv-strerror-and-setlocale-functions" class="header-anchor">#</a> Modifying the string returned by getenv, strerror, and setlocale functions</h2> <p>Modifying the strings returned by the standard functions <code>getenv()</code>, <code>strerror()</code> and <code>setlocale()</code> is undefined. So, implementations may use static storage for these strings.</p> <p><strong>The getenv() function, C11, §7.22.4.7, 4</strong>, says:</p> <blockquote></blockquote> <p>The getenv function returns a pointer to a string associated with the
matched list member. The string pointed to shall not be modified by the
program, but may be overwritten by a subsequent call to the getenv
function.</p> <p><strong>The strerror() function, C11, §7.23.6.3, 4</strong> says:</p> <blockquote></blockquote> <p>The strerror function returns a pointer to the string, the contents of
which are localespeciﬁc. The array pointed to shall not be modified by
the program, but may be overwritten by a subsequent call to the
strerror function.</p> <p><strong>The setlocale() function, C11, §7.11.1.1, 8</strong> says:</p> <blockquote></blockquote> <p>The pointer to string returned by the setlocale function is such that
a subsequent call with that string value and its associated category
will restore that part of the program’s locale. The string pointed to
shall not be modified by the program, but may be overwritten by a
subsequent call to the setlocale function.</p> <p>Similarly the <code>localeconv()</code> function returns a pointer to <code>struct lconv</code> which shall not be modified.</p> <p><strong>The localeconv() function, C11, §7.11.2.1, 8</strong> says:</p> <blockquote></blockquote> <p>The localeconv function returns a pointer to the filled-in object. The
structure pointed to by the return value shall not be modified by the
program, but may be overwritten by a subsequent call to the localeconv
function.</p> <h4 id="remarks"><a href="#remarks" class="header-anchor">#</a> Remarks</h4> <p><strong>What is Undefined Behavior (UB)?</strong></p> <p><strong>Undefined behavior</strong> is a term used in the C standard. The C11 standard (ISO/IEC 9899:2011) defines the term undefined behavior as</p> <blockquote></blockquote> <p>behavior, upon use of a nonportable or erroneous program construct or of erroneous data, for which this International Standard imposes no requirements</p> <p><strong>What happens if there is UB in my code?</strong></p> <p>These are the results which can happen due to undefined behavior according to standard:</p> <blockquote></blockquote> <p>NOTE Possible undefined behavior ranges from ignoring the situation
completely with unpredictable results, to behaving during translation
or program execution in a documented manner characteristic of the
environment (with or without the issuance of a diagnostic message), to
terminating a translation or execution (with the issuance of a
diagnostic message).</p> <p>The following quote is often used to describe (less formally though) results happening from undefined behavior:</p> <blockquote></blockquote> <p>“When the compiler encounters [a given undefined construct] it is
legal for it to make demons fly out of your nose” (the implication is
that the compiler may choose any arbitrarily bizarre way to interpret
the code without violating the ANSI C standard)</p> <p><strong>Why does UB exist?</strong></p> <p>If it's so bad, why didn't they just define it or make it implementation-defined?</p> <p>Undefined behavior allows more opportunities for optimization; The compiler can justifiably assume that any code does not contain undefined behaviour, which can allow it to avoid run-time checks and perform optimizations whose validity would be costly or impossible to prove otherwise.</p> <p><strong>Why is UB hard to track down?</strong></p> <p>There are at least two reasons why undefined behavior creates bugs that are difficult to detect:</p> <ul><li>The compiler is not required to - and generally can't reliably - warn you about undefined behavior. In fact requiring it to do so would go directly against the reason for the existence of undefined behaviour.</li> <li>The unpredictable results might not start unfolding at the exact point of the operation where the construct whose behavior is undefined occurs; Undefined behaviour taints the whole execution and its effects may happen at any time: During, after, or even <strong>before</strong> the undefined construct.</li></ul> <p>Consider null-pointer dereference: the compiler is not required to diagnose null-pointer dereference, and even could not, as at run-time any pointer passed into a function, or in a global variable might be null. <strong>And when the null-pointer dereference occurs, the standard does not mandate that the program needs to crash.</strong> Rather, the program might crash earlier, later, or not crash at all; it could even behave as if the null pointer pointed to a valid object, and behave completely normally, only to crash under other circumstances.</p> <p>In the case of null-pointer dereference, C language differs from managed languages such as Java or C#, where the behavior of null-pointer dereference is <strong>defined</strong>: an exception is thrown, at the exact time (<code>NullPointerException</code> in Java, <code>NullReferenceException</code> in C#), thus those coming from Java or C# might <strong>incorrectly believe that in such a case, a C program must crash, with or without the issuance of a diagnostic message</strong>.</p> <p><strong>Additional information</strong></p> <p>There are several such situations that should be clearly distinguished:</p> <ul><li>Explicitly undefined behavior, that is where the C standard explicitly tells you that you are off limits.</li> <li>Implicitly undefined behavior, where there is simply no text in the standard that foresees a behavior for the situation you brought your program in.</li></ul> <p>Also have in mind that in many places the behavior of certain constructs is deliberately undefined by the C standard to leave room for compiler and library implementors to come up with their own definitions. A good example are signals and signal handlers, where extensions to C, such as the POSIX operating system standard, define much more elaborated rules. In such cases you just have to check the documentation of your platform; the C standard can't tell you anything.</p> <p>Also note that if undefined behavior occurs in program it doesn't mean that just the point where undefined behavior occurred is problematic, rather entire program becomes meaningless.</p> <p>Because of such concerns it is important (especially since compilers don't always warn us about UB) for person programming in C to be at least familiar with the kind of things that trigger undefined behavior.</p> <p>It should be noted there are some tools (e.g. static analysis tools such as PC-Lint) which aid in detecting undefined behavior, but again, they can't detect all occurrences of undefined behavior.</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/devtut/generate/edit/master/docs/c/undefined-behavior.md" target="_blank" rel="noopener noreferrer">Edit this page on GitHub</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/c/error-handling.html" class="prev">
        Error handling
      </a></span> <span class="next"><a href="/c/random-number-generation.html">
        Random Number Generation
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.ced448ab.js" defer></script><script src="/assets/js/3.f1d73125.js" defer></script><script src="/assets/js/602.efbad421.js" defer></script>
  </body>
</html>
