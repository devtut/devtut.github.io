<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C - Aliasing and effective type</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="description" content="Effective type, restrict qualification, Changing bytes, Character types cannot be accessed through non-character types., Violating the strict aliasing rules">
    <meta property="og:site_name" content="DevTut">
    <meta property="og:title" content="C - Aliasing and effective type">
    <meta property="og:description" content="Effective type, restrict qualification, Changing bytes, Character types cannot be accessed through non-character types., Violating the strict aliasing rules">
    <meta property="og:type" content="article">
    <meta property="og:url" content="/c/aliasing-and-effective-type.html">
    <meta property="og:image" content="/logo.png">
    <meta name="twitter:title" content="C - Aliasing and effective type">
    <meta name="twitter:description" content="Effective type, restrict qualification, Changing bytes, Character types cannot be accessed through non-character types., Violating the strict aliasing rules">
    <meta name="twitter:url" content="/c/aliasing-and-effective-type.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="/logo.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/mstile-150x150.png">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="google-site-verification" content="76_rKXgwMVIjd-axJC_1zPV9OS4mEjvtgjYOWVkAdnQ">
    <link rel="preload" href="/assets/css/0.styles.8b877eb8.css" as="style"><link rel="preload" href="/assets/js/app.ced448ab.js" as="script"><link rel="preload" href="/assets/js/3.f1d73125.js" as="script"><link rel="preload" href="/assets/js/543.a69af578.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.8b877eb8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">DevTut</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>C</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/c/" class="sidebar-link">Disclaimer</a></li><li><a href="/c/getting-started-with-c-language.html" class="sidebar-link">Getting started with C Language</a></li><li><a href="/c/comments.html" class="sidebar-link">Comments</a></li><li><a href="/c/data-types.html" class="sidebar-link">Data Types</a></li><li><a href="/c/operators.html" class="sidebar-link">Operators</a></li><li><a href="/c/boolean.html" class="sidebar-link">Boolean</a></li><li><a href="/c/strings.html" class="sidebar-link">Strings</a></li><li><a href="/c/literals-for-numbers-characters-and-strings.html" class="sidebar-link">Literals for numbers, characters and strings</a></li><li><a href="/c/compound-literals.html" class="sidebar-link">Compound Literals</a></li><li><a href="/c/bit-fields.html" class="sidebar-link">Bit-fields</a></li><li><a href="/c/arrays.html" class="sidebar-link">Arrays</a></li><li><a href="/c/linked-lists.html" class="sidebar-link">Linked lists</a></li><li><a href="/c/enumerations.html" class="sidebar-link">Enumerations</a></li><li><a href="/c/structs.html" class="sidebar-link">Structs</a></li><li><a href="/c/standard-math.html" class="sidebar-link">Standard Math</a></li><li><a href="/c/iteration-statements-loops-for-while-do-while.html" class="sidebar-link">Iteration Statements/Loops: for, while, do-while</a></li><li><a href="/c/selection-statements.html" class="sidebar-link">Selection Statements</a></li><li><a href="/c/initialization.html" class="sidebar-link">Initialization</a></li><li><a href="/c/declaration-vs-definition.html" class="sidebar-link">Declaration vs Definition</a></li><li><a href="/c/files-and-i-o-streams.html" class="sidebar-link">Files and I/O streams</a></li><li><a href="/c/formatted-input-output.html" class="sidebar-link">Formatted Input/Output</a></li><li><a href="/c/pointers.html" class="sidebar-link">Pointers</a></li><li><a href="/c/sequence-points.html" class="sidebar-link">Sequence points</a></li><li><a href="/c/function-pointers.html" class="sidebar-link">Function Pointers</a></li><li><a href="/c/function-parameters.html" class="sidebar-link">Function Parameters</a></li><li><a href="/c/pass-2d-arrays-to-functions.html" class="sidebar-link">Pass 2D-arrays to functions</a></li><li><a href="/c/error-handling.html" class="sidebar-link">Error handling</a></li><li><a href="/c/undefined-behavior.html" class="sidebar-link">Undefined behavior</a></li><li><a href="/c/random-number-generation.html" class="sidebar-link">Random Number Generation</a></li><li><a href="/c/preprocessor-and-macros.html" class="sidebar-link">Preprocessor and Macros</a></li><li><a href="/c/signal-handling.html" class="sidebar-link">Signal handling</a></li><li><a href="/c/variable-arguments.html" class="sidebar-link">Variable arguments</a></li><li><a href="/c/assertion.html" class="sidebar-link">Assertion</a></li><li><a href="/c/generic-selection.html" class="sidebar-link">Generic selection</a></li><li><a href="/c/x-macros.html" class="sidebar-link">X-macros</a></li><li><a href="/c/aliasing-and-effective-type.html" class="active sidebar-link">Aliasing and effective type</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/c/aliasing-and-effective-type.html#effective-type" class="sidebar-link">Effective type</a></li><li class="sidebar-sub-header"><a href="/c/aliasing-and-effective-type.html#restrict-qualification" class="sidebar-link">restrict qualification</a></li><li class="sidebar-sub-header"><a href="/c/aliasing-and-effective-type.html#changing-bytes" class="sidebar-link">Changing bytes</a></li><li class="sidebar-sub-header"><a href="/c/aliasing-and-effective-type.html#character-types-cannot-be-accessed-through-non-character-types" class="sidebar-link">Character types cannot be accessed through non-character types.</a></li><li class="sidebar-sub-header"><a href="/c/aliasing-and-effective-type.html#violating-the-strict-aliasing-rules" class="sidebar-link">Violating the strict aliasing rules</a></li></ul></li><li><a href="/c/compilation.html" class="sidebar-link">Compilation</a></li><li><a href="/c/identifier-scope.html" class="sidebar-link">Identifier Scope</a></li><li><a href="/c/common-pitfalls.html" class="sidebar-link">Common pitfalls</a></li><li><a href="/c/implicit-and-explicit-conversions.html" class="sidebar-link">Implicit and Explicit Conversions</a></li><li><a href="/c/type-qualifiers.html" class="sidebar-link">Type Qualifiers</a></li><li><a href="/c/valgrind.html" class="sidebar-link">Valgrind</a></li><li><a href="/c/typedef.html" class="sidebar-link">Typedef</a></li><li><a href="/c/storage-classes.html" class="sidebar-link">Storage Classes</a></li><li><a href="/c/declarations.html" class="sidebar-link">Declarations</a></li><li><a href="/c/inline-assembly.html" class="sidebar-link">Inline assembly</a></li><li><a href="/c/threads-native.html" class="sidebar-link">Threads (native)</a></li><li><a href="/c/structure-padding-and-packing.html" class="sidebar-link">Structure Padding and Packing</a></li><li><a href="/c/memory-management.html" class="sidebar-link">Memory management</a></li><li><a href="/c/implementation-defined-behaviour.html" class="sidebar-link">Implementation-defined behaviour</a></li><li><a href="/c/atomics.html" class="sidebar-link">Atomics</a></li><li><a href="/c/jump-statements.html" class="sidebar-link">Jump Statements</a></li><li><a href="/c/create-and-include-header-files.html" class="sidebar-link">Create and include header files</a></li><li><a href="/c/testing-frameworks.html" class="sidebar-link">Testing frameworks</a></li><li><a href="/c/ctype-h-character-classification-conversion.html" class="sidebar-link">— character classification &amp; conversion</a></li><li><a href="/c/side-effects.html" class="sidebar-link">Side Effects</a></li><li><a href="/c/multi-character-character-sequence.html" class="sidebar-link">Multi-Character Character Sequence</a></li><li><a href="/c/constraints.html" class="sidebar-link">Constraints</a></li><li><a href="/c/inlining.html" class="sidebar-link">Inlining</a></li><li><a href="/c/unions.html" class="sidebar-link">Unions</a></li><li><a href="/c/threads-native.html" class="sidebar-link">Threads (native)</a></li><li><a href="/c/multithreading.html" class="sidebar-link">Multithreading</a></li><li><a href="/c/interprocess-communication-ipc.html" class="sidebar-link">Interprocess Communication (IPC)</a></li><li><a href="/c/testing-frameworks.html" class="sidebar-link">Testing frameworks</a></li><li><a href="/c/valgrind.html" class="sidebar-link">Valgrind</a></li><li><a href="/c/common-c-programming-idioms-and-developer-practices.html" class="sidebar-link">Common C programming idioms and developer practices</a></li><li><a href="/c/common-pitfalls.html" class="sidebar-link">Common pitfalls</a></li><li><a href="/c/contributors.html" class="sidebar-link">The Contributors</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="aliasing-and-effective-type"><a href="#aliasing-and-effective-type" class="header-anchor">#</a> Aliasing and effective type</h1> <h2 id="effective-type"><a href="#effective-type" class="header-anchor">#</a> Effective type</h2> <p>The <strong>effective type</strong> of a data object is the last type information that was associated with it, if any.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">// a normal variable, effective type uint32_t, and this type never changes</span>
uint32_t a <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>

<span class="token comment">// effective type of *pa is uint32_t, too, simply</span>
<span class="token comment">// because *pa is the object a</span>
uint32_t<span class="token operator">*</span> pa <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>

<span class="token comment">// the object pointed to by q has no effective type, yet</span>
<span class="token keyword">void</span><span class="token operator">*</span> q <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span> uint32_t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// the object pointed to by q still has no effective type,</span>
<span class="token comment">// because nobody has written to it</span>
uint32_t<span class="token operator">*</span> qb <span class="token operator">=</span> q<span class="token punctuation">;</span>
<span class="token comment">// *qb now has effective type uint32_t because a uint32_t value was written</span>
<span class="token operator">*</span>qb <span class="token operator">=</span> <span class="token number">37</span><span class="token punctuation">;</span>

<span class="token comment">// the object pointed to by r has no effective type, yet, although</span>
<span class="token comment">// it is initialized</span>
<span class="token keyword">void</span><span class="token operator">*</span> r <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> uint32_t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// the object pointed to by r still has no effective type,</span>
<span class="token comment">// because nobody has written to or read from it</span>
uint32_t<span class="token operator">*</span> rc <span class="token operator">=</span> r<span class="token punctuation">;</span>
<span class="token comment">// *rc now has effective type uint32_t because a value is read</span>
<span class="token comment">// from it with that type. The read operation is valid because we used calloc.</span>
<span class="token comment">// Now the object pointed to by r (which is the same as *rc) has</span>
<span class="token comment">// gained an effective type, although we didn't change its value.</span>
uint32_t c <span class="token operator">=</span> <span class="token operator">*</span>rc<span class="token punctuation">;</span>

<span class="token comment">// the object pointed to by s has no effective type, yet.</span>
<span class="token keyword">void</span><span class="token operator">*</span> s <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span> uint32_t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// the object pointed to by s now has effective type uint32_t</span>
<span class="token comment">// because an uint32_t value is copied into it.</span>
<span class="token function">memcpy</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> uint32_t<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>Observe that for the latter, it was not necessary that we even have an
<code>uint32_t*</code> pointer to that object. The fact that we have copied another
<code>uint32_t</code> object is sufficient.</p> <h2 id="restrict-qualification"><a href="#restrict-qualification" class="header-anchor">#</a> restrict qualification</h2> <p>If we have two pointer arguments of the same type, the compiler can't make any assumption and will always have to assume that the change to <code>*e</code> may change <code>*f</code>:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token operator">*</span> e<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">*</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">float</span> a <span class="token operator">=</span> <span class="token operator">*</span>f
    <span class="token operator">*</span>e <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> b <span class="token operator">=</span> <span class="token operator">*</span>f<span class="token punctuation">;</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;is %g equal to %g?\n&quot;</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">float</span> fval <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">float</span> eval <span class="token operator">=</span> <span class="token number">77</span><span class="token punctuation">;</span>
 <span class="token function">fun</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>eval<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fval<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>all goes well and something like</p> <blockquote></blockquote> <p>is 4 equal to 4?</p> <p>is printed. If we pass the same pointer, the program will still do the right thing and print</p> <blockquote></blockquote> <p>is 4 equal to 22?</p> <p>This can turn out to be inefficient, if we <strong>know</strong> by some outside information that <code>e</code> and <code>f</code> will never point to the same data object. We can reflect that knowledge by adding <code>restrict</code> qualifiers to the pointer parameters:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">fan</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token operator">*</span>restrict e<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">*</span>restrict f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">float</span> a <span class="token operator">=</span> <span class="token operator">*</span>f
    <span class="token operator">*</span>e <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> b <span class="token operator">=</span> <span class="token operator">*</span>f<span class="token punctuation">;</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;is %g equal to %g?\n&quot;</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Then the compiler may always suppose that <code>e</code> and <code>f</code> point to different objects.</p> <h2 id="changing-bytes"><a href="#changing-bytes" class="header-anchor">#</a> Changing bytes</h2> <p>Once an object has an effective type, you should not attempt to modify it through a pointer of another type, unless that other type is a character type, <code>char</code>, <code>signed char</code> or <code>unsigned char</code>.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;inttypes.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  uint32_t a <span class="token operator">=</span> <span class="token number">57</span><span class="token punctuation">;</span>
  <span class="token comment">// conversion from incompatible types needs a cast !</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span> ap <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span> a<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* set each byte of a to 42 */</span>
    ap<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;a now has value %&quot;</span> PRIu32 <span class="token string">&quot;\n&quot;</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>This is a valid program that prints</p> <blockquote></blockquote> <p>a now has value 707406378</p> <p>This works because:</p> <ul><li>The access is made to the individual bytes seen with type <code>unsigned char</code> so each modification is well defined.</li> <li>The two views to the object, through <code>a</code> and through <code>*ap</code>, alias, but since <code>ap</code> is a pointer to a character type, the strict aliasing rule does not apply. Thus the compiler has to assume that the value of <code>a</code> may have been changed in the <code>for</code> loop. The modified value of <code>a</code> must be constructed from the bytes that have been changed.</li> <li>The type of <code>a</code>, <code>uint32_t</code> has no padding bits. All its bits of the representation count for the value,  here <code>707406378</code>, and there can be no trap representation.</li></ul> <h2 id="character-types-cannot-be-accessed-through-non-character-types"><a href="#character-types-cannot-be-accessed-through-non-character-types" class="header-anchor">#</a> Character types cannot be accessed through non-character types.</h2> <p>If an object is defined with static, thread, or automatic storage duration, and it has a character type, either: <code>char</code>, <code>unsigned char</code>, or <code>signed char</code>, it may not be accessed by a non-character type. In the below example a <code>char</code> array is reinterpreted as the type <code>int</code>, and the behavior is undefined on every dereference of the <code>int</code> pointer <code>b</code>.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">*</span> b <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">int</span><span class="token operator">*</span> <span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
    <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      

    <span class="token keyword">static</span> <span class="token keyword">char</span> c<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    b <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">int</span><span class="token operator">*</span> <span class="token punctuation">)</span><span class="token operator">&amp;</span>c<span class="token punctuation">;</span>
    <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

    <span class="token keyword">_Thread_local</span> <span class="token keyword">char</span> d<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    b <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token keyword">int</span><span class="token operator">*</span> <span class="token punctuation">)</span><span class="token operator">&amp;</span>d<span class="token punctuation">;</span>
    <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>This is undefined because it violates the &quot;effective type&quot; rule, no data object that has an effective type may be accessed through another type that is not a character type. Since the other type here is <code>int</code>, this is not allowed.</p> <p>Even if alignment and pointer sizes would be known to fit, this would not exempt from this rule, behavior would still be undefined.</p> <p>This means in particular that there is no way in standard C to reserve
a buffer object of character type that can be used through pointers
with different types, as you would use a buffer that was received by
<code>malloc</code> or similar function.</p> <p>A correct way to achieve the same goal as in the above example would
be to use a <code>union</code>.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">union</span> bufType bufType<span class="token punctuation">;</span>
<span class="token keyword">union</span> bufType <span class="token punctuation">{</span>
   <span class="token keyword">char</span> c<span class="token punctuation">[</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token keyword">int</span> i<span class="token punctuation">[</span><span class="token number">25</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    bufType a <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// reserve a buffer and initialize</span>
    <span class="token keyword">int</span><span class="token operator">*</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span>i<span class="token punctuation">;</span>      <span class="token comment">// no cast necessary</span>
    <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      

    <span class="token keyword">static</span> bufType a <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">*</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span>i<span class="token punctuation">;</span>
    <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

    <span class="token keyword">_Thread_local</span> bufType a <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">*</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span>i<span class="token punctuation">;</span>
    <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Here, the <code>union</code> ensures that the compiler knows from the start that the buffer could be
accessed through different views. This also has the advantage that now the buffer has a &quot;view&quot; <code>a.i</code> that already is of type <code>int</code> and no pointer conversion is needed.</p> <h2 id="violating-the-strict-aliasing-rules"><a href="#violating-the-strict-aliasing-rules" class="header-anchor">#</a> Violating the strict aliasing rules</h2> <p>In the following code let us assume for simplicity that <code>float</code> and <code>uint32_t</code> have the same size.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span>uint32_t<span class="token operator">*</span> u<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">*</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">float</span> a <span class="token operator">=</span> <span class="token operator">*</span>f
    <span class="token operator">*</span>u <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> b <span class="token operator">=</span> <span class="token operator">*</span>f<span class="token punctuation">;</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;%g should equal %g\n&quot;</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p><code>u</code> and <code>f</code> have different base type, and thus the compiler can assume that they point to different objects. There is no possibility that <code>*f</code> could have changed between the two initializations of <code>a</code> and <code>b</code>, and so the compiler may optimize the code to something equivalent to</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span>uint32_t<span class="token operator">*</span> u<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">*</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">float</span> a <span class="token operator">=</span> <span class="token operator">*</span>f
    <span class="token operator">*</span>u <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">;</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">&quot;%g should equal %g\n&quot;</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>That is, the second load operation of <code>*f</code> can be optimized out completely.</p> <p>If we call this function &quot;normally&quot;</p> <div class="language- extra-class"><pre class="language-text"><code>
float fval = 4;
 uint32_t uval = 77;
 fun(&amp;uval, &amp;fval);

</code></pre></div><p>all goes well and something like</p> <blockquote></blockquote> <p>4 should equal 4</p> <p>is printed. But if we cheat and pass the same pointer, after converting it,</p> <div class="language- extra-class"><pre class="language-text"><code>
float fval = 4;
 uint32_t* up = (uint32_t*)&amp;fval;
 fun(up, &amp;fval);

</code></pre></div><p>we violate the strict aliasing rule. Then the behavior becomes undefined. The output could be as above, if the compiler had optimized the second access, or something completely different, and so your program ends up in a completely unreliable state.</p> <h4 id="remarks"><a href="#remarks" class="header-anchor">#</a> Remarks</h4> <p>Violations of aliasing rules and of violating the effective type of an object are two different things and should not be confounded.</p> <li>
**Aliasing** is the property of two pointers `a` and `b` that refer to the same object, that is that `a == b`.
</li> <li>
The **effective type** of a data object is used by C to determine which operations can be done on that object. In particular the effective type is used to determine if two pointers can alias each other.
</li> <p>Aliasing can be a problem for optimization, because changing the object through one pointer, <code>a</code> say, can change the object that is visible through the other pointer, <code>b</code>. If your C compiler would have to assume that pointers could always alias each other, regardless of their type and provenance, many optimization opportunities would be lost, and many programs would run slower.</p> <p>C's strict aliasing rules refers to cases in the compiler <strong>may assume</strong> which objects do (or do not) alias each other. There are two rules of thumb that you always should have in mind for data pointers.</p> <blockquote></blockquote> <p>Unless said otherwise, two pointers with the same base type may alias.</p> <blockquote></blockquote> <p>Two pointers with different base type cannot alias, unless at least one of the two types is a character type.</p> <p>Here <strong>base type</strong> means that we put aside type qualifications such as <code>const</code>, e.g. If <code>a</code> is <code>double*</code> and <code>b</code> is <code>const double*</code>, the compiler <strong>must</strong> generally assume that a change of <code>*a</code> may change <code>*b</code>.</p> <p>Violating the second rule can have catastrophic results. Here violating the strict aliasing rule means that you present two pointers <code>a</code> and <code>b</code> of different type to the compiler which in reality point to the same object. The compiler then may always assume that the two point to different objects, and will not update its idea of <code>*b</code> if you changed the object through <code>*a</code>.</p> <p>If you do so the behavior of your program becomes undefined. Therefore, C puts quite severe restrictions on pointer conversions in order to help you to avoid such situation to occur accidentally.</p> <blockquote></blockquote> <p>Unless the source or target type is `void`, all pointer conversions
between pointers with different base type must be **explicit**.</p> <p>Or in other words, they need a <strong>cast</strong>, unless you do a conversion that just adds a qualifier such as <code>const</code> to the target type.</p> <p>Avoiding pointer conversions in general and casts in particular protects you from aliasing problems. Unless you really need them, and these cases are very special, you should avoid them as you can.</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/devtut/generate/edit/master/docs/c/aliasing-and-effective-type.md" target="_blank" rel="noopener noreferrer">Edit this page on GitHub</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/c/x-macros.html" class="prev">
        X-macros
      </a></span> <span class="next"><a href="/c/compilation.html">
        Compilation
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.ced448ab.js" defer></script><script src="/assets/js/3.f1d73125.js" defer></script><script src="/assets/js/543.a69af578.js" defer></script>
  </body>
</html>
