<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C - Memory management</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="description" content="Freeing Memory, Allocating Memory, Reallocating Memory, realloc(ptr, 0) is not equivalent to free(ptr), Multidimensional arrays of variable size, alloca: allocate memory on stack, User-defined memory management">
    <meta property="og:site_name" content="DevTut">
    <meta property="og:title" content="C - Memory management">
    <meta property="og:description" content="Freeing Memory, Allocating Memory, Reallocating Memory, realloc(ptr, 0) is not equivalent to free(ptr), Multidimensional arrays of variable size, alloca: allocate memory on stack, User-defined memory management">
    <meta property="og:type" content="article">
    <meta property="og:url" content="/c/memory-management.html">
    <meta property="og:image" content="/logo.png">
    <meta name="twitter:title" content="C - Memory management">
    <meta name="twitter:description" content="Freeing Memory, Allocating Memory, Reallocating Memory, realloc(ptr, 0) is not equivalent to free(ptr), Multidimensional arrays of variable size, alloca: allocate memory on stack, User-defined memory management">
    <meta name="twitter:url" content="/c/memory-management.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="/logo.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/mstile-150x150.png">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="google-site-verification" content="76_rKXgwMVIjd-axJC_1zPV9OS4mEjvtgjYOWVkAdnQ">
    <link rel="preload" href="/assets/css/0.styles.8b877eb8.css" as="style"><link rel="preload" href="/assets/js/app.ced448ab.js" as="script"><link rel="preload" href="/assets/js/3.f1d73125.js" as="script"><link rel="preload" href="/assets/js/581.bbbde52a.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.8b877eb8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">DevTut</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>C</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/c/" class="sidebar-link">Disclaimer</a></li><li><a href="/c/getting-started-with-c-language.html" class="sidebar-link">Getting started with C Language</a></li><li><a href="/c/comments.html" class="sidebar-link">Comments</a></li><li><a href="/c/data-types.html" class="sidebar-link">Data Types</a></li><li><a href="/c/operators.html" class="sidebar-link">Operators</a></li><li><a href="/c/boolean.html" class="sidebar-link">Boolean</a></li><li><a href="/c/strings.html" class="sidebar-link">Strings</a></li><li><a href="/c/literals-for-numbers-characters-and-strings.html" class="sidebar-link">Literals for numbers, characters and strings</a></li><li><a href="/c/compound-literals.html" class="sidebar-link">Compound Literals</a></li><li><a href="/c/bit-fields.html" class="sidebar-link">Bit-fields</a></li><li><a href="/c/arrays.html" class="sidebar-link">Arrays</a></li><li><a href="/c/linked-lists.html" class="sidebar-link">Linked lists</a></li><li><a href="/c/enumerations.html" class="sidebar-link">Enumerations</a></li><li><a href="/c/structs.html" class="sidebar-link">Structs</a></li><li><a href="/c/standard-math.html" class="sidebar-link">Standard Math</a></li><li><a href="/c/iteration-statements-loops-for-while-do-while.html" class="sidebar-link">Iteration Statements/Loops: for, while, do-while</a></li><li><a href="/c/selection-statements.html" class="sidebar-link">Selection Statements</a></li><li><a href="/c/initialization.html" class="sidebar-link">Initialization</a></li><li><a href="/c/declaration-vs-definition.html" class="sidebar-link">Declaration vs Definition</a></li><li><a href="/c/files-and-i-o-streams.html" class="sidebar-link">Files and I/O streams</a></li><li><a href="/c/formatted-input-output.html" class="sidebar-link">Formatted Input/Output</a></li><li><a href="/c/pointers.html" class="sidebar-link">Pointers</a></li><li><a href="/c/sequence-points.html" class="sidebar-link">Sequence points</a></li><li><a href="/c/function-pointers.html" class="sidebar-link">Function Pointers</a></li><li><a href="/c/function-parameters.html" class="sidebar-link">Function Parameters</a></li><li><a href="/c/pass-2d-arrays-to-functions.html" class="sidebar-link">Pass 2D-arrays to functions</a></li><li><a href="/c/error-handling.html" class="sidebar-link">Error handling</a></li><li><a href="/c/undefined-behavior.html" class="sidebar-link">Undefined behavior</a></li><li><a href="/c/random-number-generation.html" class="sidebar-link">Random Number Generation</a></li><li><a href="/c/preprocessor-and-macros.html" class="sidebar-link">Preprocessor and Macros</a></li><li><a href="/c/signal-handling.html" class="sidebar-link">Signal handling</a></li><li><a href="/c/variable-arguments.html" class="sidebar-link">Variable arguments</a></li><li><a href="/c/assertion.html" class="sidebar-link">Assertion</a></li><li><a href="/c/generic-selection.html" class="sidebar-link">Generic selection</a></li><li><a href="/c/x-macros.html" class="sidebar-link">X-macros</a></li><li><a href="/c/aliasing-and-effective-type.html" class="sidebar-link">Aliasing and effective type</a></li><li><a href="/c/compilation.html" class="sidebar-link">Compilation</a></li><li><a href="/c/identifier-scope.html" class="sidebar-link">Identifier Scope</a></li><li><a href="/c/common-pitfalls.html" class="sidebar-link">Common pitfalls</a></li><li><a href="/c/implicit-and-explicit-conversions.html" class="sidebar-link">Implicit and Explicit Conversions</a></li><li><a href="/c/type-qualifiers.html" class="sidebar-link">Type Qualifiers</a></li><li><a href="/c/valgrind.html" class="sidebar-link">Valgrind</a></li><li><a href="/c/typedef.html" class="sidebar-link">Typedef</a></li><li><a href="/c/storage-classes.html" class="sidebar-link">Storage Classes</a></li><li><a href="/c/declarations.html" class="sidebar-link">Declarations</a></li><li><a href="/c/inline-assembly.html" class="sidebar-link">Inline assembly</a></li><li><a href="/c/threads-native.html" class="sidebar-link">Threads (native)</a></li><li><a href="/c/structure-padding-and-packing.html" class="sidebar-link">Structure Padding and Packing</a></li><li><a href="/c/memory-management.html" class="active sidebar-link">Memory management</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/c/memory-management.html#freeing-memory" class="sidebar-link">Freeing Memory</a></li><li class="sidebar-sub-header"><a href="/c/memory-management.html#allocating-memory" class="sidebar-link">Allocating Memory</a></li><li class="sidebar-sub-header"><a href="/c/memory-management.html#reallocating-memory" class="sidebar-link">Reallocating Memory</a></li><li class="sidebar-sub-header"><a href="/c/memory-management.html#realloc-ptr-0-is-not-equivalent-to-free-ptr" class="sidebar-link">realloc(ptr, 0) is not equivalent to free(ptr)</a></li><li class="sidebar-sub-header"><a href="/c/memory-management.html#multidimensional-arrays-of-variable-size" class="sidebar-link">Multidimensional arrays of variable size</a></li><li class="sidebar-sub-header"><a href="/c/memory-management.html#alloca-allocate-memory-on-stack" class="sidebar-link">alloca: allocate memory on stack</a></li><li class="sidebar-sub-header"><a href="/c/memory-management.html#user-defined-memory-management" class="sidebar-link">User-defined memory management</a></li></ul></li><li><a href="/c/implementation-defined-behaviour.html" class="sidebar-link">Implementation-defined behaviour</a></li><li><a href="/c/atomics.html" class="sidebar-link">Atomics</a></li><li><a href="/c/jump-statements.html" class="sidebar-link">Jump Statements</a></li><li><a href="/c/create-and-include-header-files.html" class="sidebar-link">Create and include header files</a></li><li><a href="/c/testing-frameworks.html" class="sidebar-link">Testing frameworks</a></li><li><a href="/c/ctype-h-character-classification-conversion.html" class="sidebar-link">â€” character classification &amp; conversion</a></li><li><a href="/c/side-effects.html" class="sidebar-link">Side Effects</a></li><li><a href="/c/multi-character-character-sequence.html" class="sidebar-link">Multi-Character Character Sequence</a></li><li><a href="/c/constraints.html" class="sidebar-link">Constraints</a></li><li><a href="/c/inlining.html" class="sidebar-link">Inlining</a></li><li><a href="/c/unions.html" class="sidebar-link">Unions</a></li><li><a href="/c/threads-native.html" class="sidebar-link">Threads (native)</a></li><li><a href="/c/multithreading.html" class="sidebar-link">Multithreading</a></li><li><a href="/c/interprocess-communication-ipc.html" class="sidebar-link">Interprocess Communication (IPC)</a></li><li><a href="/c/testing-frameworks.html" class="sidebar-link">Testing frameworks</a></li><li><a href="/c/valgrind.html" class="sidebar-link">Valgrind</a></li><li><a href="/c/common-c-programming-idioms-and-developer-practices.html" class="sidebar-link">Common C programming idioms and developer practices</a></li><li><a href="/c/common-pitfalls.html" class="sidebar-link">Common pitfalls</a></li><li><a href="/c/contributors.html" class="sidebar-link">The Contributors</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="memory-management"><a href="#memory-management" class="header-anchor">#</a> Memory management</h1> <p>For managing dynamically allocated memory, the standard C library provides the functions <code>malloc()</code>, <code>calloc()</code>, <code>realloc()</code> and <code>free()</code>. In C99 and later, there is also <code>aligned_alloc()</code>.  Some systems also provide <code>alloca()</code>.</p> <h2 id="freeing-memory"><a href="#freeing-memory" class="header-anchor">#</a> Freeing Memory</h2> <p>It is possible to release dynamically allocated memory by calling <a href="http://linux.die.net/man/3/free" target="_blank" rel="noopener noreferrer">free()<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* allocation of memory */</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;malloc failed&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* release of memory */</span>
<span class="token comment">/* note that after free(p), even using the *value* of the pointer p
   has undefined behavior, until a new value is stored into it. */</span>

<span class="token comment">/* reusing/re-purposing the pointer itself */</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span> <span class="token comment">/* This is valid, has defined behaviour */</span>

</code></pre></div><p>The memory pointed to by <code>p</code> is reclaimed (either by the libc implementation or by the underlying OS) after the call to <code>free()</code>, so accessing that freed memory block via <code>p</code> will lead to <a href="http://stackoverflow.com/documentation/c/364/undefined-behavior#t=201607290847035891683" target="_blank" rel="noopener noreferrer">undefined behavior<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>. Pointers that reference memory elements that have been freed are commonly called <a href="https://en.wikipedia.org/wiki/Dangling_pointer" target="_blank" rel="noopener noreferrer">dangling pointers<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>, and present a security risk. Furthermore, the C standard states that even <a href="http://stackoverflow.com/documentation/c/364/undefined-behavior/2775/read-value-of-pointer-that-was-freed#t=201608050732042665317" target="_blank" rel="noopener noreferrer">accessing the value<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> of a dangling pointer has undefined behavior. Note that the pointer <code>p</code> itself can be re-purposed as shown above.</p> <p>Please note that you can only call <code>free()</code> on pointers that have directly been returned from the <code>malloc()</code>, <code>calloc()</code>, <code>realloc()</code> and <code>aligned_alloc()</code> functions, or where documentation tells you the memory has been allocated that way (functions like <code>strdup ()</code> are notable examples). Freeing a pointer that is,</p> <ul><li>obtained by using the <code>&amp;</code> operator on a variable, or</li> <li>in the middle of an allocated block,</li></ul> <p>is forbidden. Such an error will usually not be diagnosed by your compiler but will lead the program execution in an undefined state.</p> <p>There are two common strategies to prevent such instances of undefined behavior.</p> <p>The first and preferable is simple - have <code>p</code> itself cease to exist when it is no longer needed, for example:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">something_is_needed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>

    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;malloc failed&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* do whatever is needed with p */</span>

    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>By calling <code>free()</code> directly before the end of the containing block (i.e. the <code>}</code>), <code>p</code> itself ceases to exist. The compiler will give a compilation error on any attempt to use <code>p</code> after that.</p> <p>A second approach is to also invalidate the pointer itself after releasing the memory to which it points:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>     <span class="token comment">// you may also use 0 instead of NULL</span>

</code></pre></div><p>Arguments for this approach:</p> <li>
On many platforms, an attempt to dereference a null pointer will cause instant crash: Segmentation fault. Here, we get at least a stack trace pointing to the variable that was used after being freed.
Without setting pointer to `NULL` we have dangling pointer. The program will very likely still crash, but later, because the memory to which the pointer points will silently be corrupted. Such bugs are difficult to trace because they can result in a call stack that completely unrelated to the initial problem.
This approach hence follows the [fail-fast concept](https://en.wikipedia.org/wiki/Fail-fast).
</li> <li>
It is safe to free a null pointer. The [C Standard specifies](http://port70.net/%7Ensz/c/c89/c89-draft.html#4.10.3.2) that `free(NULL)` has no effect:
<blockquote>
The free function causes the space pointed to by ptr to be deallocated, that is, made available for further allocation. If ptr is a null pointer, no action occurs. Otherwise, if the argument does not match a pointer earlier returned by the `calloc`, `malloc`, or `realloc` function, or if the space has been deallocated by a call to `free` or `realloc`, the behavior is undefined.
</blockquote></li> <ul><li>Sometimes the first approach cannot be used (e.g. memory is allocated in one function, and deallocated much later in a completely different function)</li></ul> <h2 id="allocating-memory"><a href="#allocating-memory" class="header-anchor">#</a> Allocating Memory</h2> <h3 id="standard-allocation"><a href="#standard-allocation" class="header-anchor">#</a> Standard Allocation</h3> <p>The C dynamic memory allocation functions are defined in the <code>&lt;stdlib.h&gt;</code> header. If one wishes to allocate memory space for an object dynamically, the following code can be used:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;malloc() failed&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>This computes the number of bytes that ten <code>int</code>s occupy in memory, then requests that many bytes from <code>malloc</code> and assigns the result (i.e., the starting address of the memory chunk that was just created using <code>malloc</code>)  to a pointer named <code>p</code>.</p> <p>It is good practice to use <code>sizeof</code> to compute the amount of memory to request since the result of <code>sizeof</code> is implementation defined (except for <strong>character types</strong>, which are <code>char</code>, <code>signed char</code> and <code>unsigned char</code>, for which <code>sizeof</code> is defined to always give <code>1</code>).</p> <p><strong>Because <code>malloc</code> might not be able to service the request, it might return a null pointer. It is important to check for this to prevent later attempts to dereference the null pointer.</strong></p> <p>Memory dynamically allocated using <code>malloc()</code> may be resized using <code>realloc()</code> or, when no longer needed, released using <code>free()</code>.</p> <p>Alternatively, declaring <code>int array[10];</code> would allocate the same amount of memory.  However, if it is declared inside a function without the keyword <code>static</code>, it will only be usable within the function it is declared in and the functions it calls (because the array will be allocated on the stack and the space will be released for reuse when the function returns). Alternatively, if it is defined with <code>static</code> inside a function, or if it is defined outside any function, then its lifetime is the lifetime of the program. Pointers can also be returned from a function, however a function in C can not return an array.</p> <h3 id="zeroed-memory"><a href="#zeroed-memory" class="header-anchor">#</a> Zeroed Memory</h3> <p>The memory returned by <code>malloc</code> may not be initialized to a reasonable value, and care should be taken to zero the memory with <code>memset</code> or to immediately copy a suitable value into it. Alternatively, <code>calloc</code> returns a block of the desired size where all bits are initialized to <code>0</code>. This need not be the same as the representation of floating-point zero or a null pointer constant.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">calloc</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;calloc() failed&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p><sub><strong>A note on <code>calloc</code>:</strong> Most (commonly used) implementations will optimise <code>calloc()</code> for performance, so it will be <a href="http://stackoverflow.com/a/2688522/130580" target="_blank" rel="noopener noreferrer">faster<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> than calling <code>malloc()</code>, then <code>memset()</code>, even though the net effect is identical.</sub></p> <h3 id="aligned-memory"><a href="#aligned-memory" class="header-anchor">#</a> Aligned Memory</h3> <p>C11 introduced a new function <code>aligned_alloc()</code> which allocates space with the given alignment. It can be used if the memory to be allocated is needed to be aligned at certain boundaries which can't be satisfied by <code>malloc()</code> or <code>calloc()</code>. <code>malloc()</code> and <code>calloc()</code> functions allocate memory that's suitably aligned for <strong>any</strong> object type (i.e. the alignment is <code>alignof(max_align_t)</code>). But with <code>aligned_alloc()</code> greater alignments can be requested.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">/* Allocates 1024 bytes with 256 bytes alignment. */</span>
<span class="token keyword">char</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token function">aligned_alloc</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;aligned_alloc()&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>The C11 standard imposes two restrictions: 1) the <strong>size</strong> (second argument) requested must be an integral multiple of the <strong>alignment</strong> (first argument) and 2) the value of <strong>alignment</strong> should be a valid alignment supported by the implementation. Failure to meet either of them results in <a href="http://stackoverflow.com/documentation/c/364/undefined-behavior" target="_blank" rel="noopener noreferrer">undefined behavior<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>.</p> <h2 id="reallocating-memory"><a href="#reallocating-memory" class="header-anchor">#</a> Reallocating Memory</h2> <p>You may need to expand or shrink your pointer storage space after you have allocated memory to it.  The <code>void *realloc(void *ptr, size_t size)</code> function deallocates the old object pointed to by <code>ptr</code> and returns a pointer to an object that has the size specified by <code>size</code>. <code>ptr</code> is the pointer to a memory block previously allocated with <code>malloc</code>, <code>calloc</code> or <code>realloc</code> (or a null pointer) to be reallocated. The maximal possible contents of the original memory is preserved. If the new size is larger, any additional memory beyond the old size are uninitialized. If the new size is shorter, the contents of the shrunken part is lost. If <code>ptr</code> is NULL, a new block is allocated and a pointer to it is returned by the function.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> p<span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;malloc() failed&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> EXIT_FAILURE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
    p<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span>

    <span class="token comment">/* Reallocate array to a larger size, storing the result into a
     * temporary pointer in case realloc() fails. */</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">int</span> <span class="token operator">*</span>temporary <span class="token operator">=</span> <span class="token function">realloc</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> <span class="token number">1000000</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span> <span class="token operator">*</span>temporary<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* realloc() failed, the original allocation was not free'd yet. */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">NULL</span> <span class="token operator">==</span> temporary<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">&quot;realloc() failed&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Clean up. */</span>
            <span class="token keyword">return</span> EXIT_FAILURE<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>      

        p <span class="token operator">=</span> temporary<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* From here on, array can be used with the new size it was 
     * realloc'ed to, until it is free'd. */</span>

    <span class="token comment">/* The values of p[0] to p[9] are preserved, so this will print:
       42 15
    */</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d %d\n&quot;</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">free</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>The reallocated object may or may not have the same address as <code>*p</code>. Therefore it is important to capture the return value from <code>realloc</code> which contains the new address if the call is successful.</p> <p>Make sure you assign the return value of <code>realloc</code> to a <code>temporary</code> instead of the original <code>p</code>. <code>realloc</code> will return null in case of any failure, which would overwrite the pointer. This would lose your data and create a memory leak.</p> <h2 id="realloc-ptr-0-is-not-equivalent-to-free-ptr"><a href="#realloc-ptr-0-is-not-equivalent-to-free-ptr" class="header-anchor">#</a> realloc(ptr, 0) is not equivalent to free(ptr)</h2> <p><code>realloc</code> is <strong>conceptually equivalent</strong> to <code>malloc + memcpy + free</code> on the other pointer.</p> <p>If the size of the space requested is zero, the behavior of <code>realloc</code> is implementation-defined. This is similar for all memory allocation functions that receive a <code>size</code> parameter of value <code>0</code>. Such functions may in fact return a non-null pointer, but that must never be dereferenced.</p> <p>Thus, <code>realloc(ptr,0)</code> is not equivalent to <code>free(ptr)</code>. It may</p> <ul><li>be a &quot;lazy&quot; implementation and just return <code>ptr</code></li> <li><code>free(ptr)</code>, allocate a dummy element and return that</li> <li><code>free(ptr)</code> and return <code>0</code></li> <li>just return <code>0</code> for failure and do nothing else.</li></ul> <p>So in particular the latter two cases are indistinguishable by application code.</p> <p>This means <code>realloc(ptr,0)</code> may not really free/deallocate the memory, and thus it should never be used as a replacement for <code>free</code>.</p> <h2 id="multidimensional-arrays-of-variable-size"><a href="#multidimensional-arrays-of-variable-size" class="header-anchor">#</a> Multidimensional arrays of variable size</h2> <p>Since C99, C has variable length arrays, VLA, that model arrays with bounds that are only known at initialization time. While you have to be careful not to allocate too large VLA (they might smash your stack), using <strong>pointers to VLA</strong> and using them in <code>sizeof</code> expressions is fine.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">double</span> <span class="token function">sumAll</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">,</span> size_t m<span class="token punctuation">,</span> <span class="token keyword">double</span> A<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">double</span> ret <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
          ret <span class="token operator">+=</span> A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>
    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span>argc<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   size_t n <span class="token operator">=</span> argc<span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">;</span>
   size_t m <span class="token operator">=</span> argc<span class="token operator">*</span><span class="token number">8</span><span class="token punctuation">;</span>
   <span class="token keyword">double</span> <span class="token punctuation">(</span><span class="token operator">*</span>matrix<span class="token punctuation">)</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment">// initialize matrix somehow</span>
   <span class="token keyword">double</span> res <span class="token operator">=</span> <span class="token function">sumAll</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> m<span class="token punctuation">,</span> matrix<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;result is %g\n&quot;</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token function">free</span><span class="token punctuation">(</span>matrix<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Here <code>matrix</code> is a pointer to elements of type <code>double[m]</code>, and the <code>sizeof</code> expression with <code>double[n][m]</code> ensures that it contains space for <code>n</code> such elements.</p> <p>All this space is allocated contiguously and can thus be deallocated by a single call to <code>free</code>.</p> <p>The presence of VLA in the language also affects the possible declarations of arrays and pointers in function headers. Now, a general integer expression is permitted inside the <code>[]</code> of array parameters. For both functions the expressions in <code>[]</code> use parameters that have declared before in the parameter list. For <code>sumAll</code> these are the lengths that the user code expects for the matrix. As for all array function parameters in C the innermost dimension is rewritten to a pointer type, so this is equivalent to the declaration</p> <div class="language- extra-class"><pre class="language-text"><code>
 double sumAll(size_t n, size_t m, double (*A)[m]);

</code></pre></div><p>That is, <code>n</code> is not really part of the function interface, but the information can be useful for documentation and it could also be used by bounds checking compilers to warn about out-of-bounds access.</p> <p>Likwise, for <code>main</code>, the expression <code>argc+1</code> is the minimal length that the C standard prescribes for the <code>argv</code> argument.</p> <p>Note that officially VLA support is optional in C11, but we know of no compiler that implements C11 and that doesn't have them. You could test with the macro <code>__STDC_NO_VLA__</code> if you must.</p> <h2 id="alloca-allocate-memory-on-stack"><a href="#alloca-allocate-memory-on-stack" class="header-anchor">#</a> alloca: allocate memory on stack</h2> <p><strong>Caveat:</strong> <code>alloca</code> is only mentioned here for the sake of completeness. It is entirely non-portable (not covered by any of the common standards) and has a number of potentially dangerous features that make it un-safe for the unaware. Modern C code should replace it with <strong>Variable Length Arrays</strong> (VLA).</p> <p><a href="https://linux.die.net/man/3/alloca" target="_blank" rel="noopener noreferrer">Manual page<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;alloca.h&gt;</span></span>
<span class="token comment">// glibc version of stdlib.h include alloca.h by default</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>data <span class="token operator">=</span> <span class="token function">alloca</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/*
      function body;
    */</span>
    <span class="token comment">// data is automatically freed</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Allocate memory on the stack frame of the caller, the space referenced by the returned pointer is automatically <a href="https://linux.die.net/man/3/free" target="_blank" rel="noopener noreferrer">free<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>'d when the caller function finishes.</p> <p>While this function is convenient for automatic memory management, be aware that requesting large allocation could cause a stack overflow, and that you cannot use <a href="https://linux.die.net/man/3/free" target="_blank" rel="noopener noreferrer"><code>free</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> with memory allocated with <a href="https://linux.die.net/man/3/alloca" target="_blank" rel="noopener noreferrer"><code>alloca</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> (which could cause more issue with stack overflow).</p> <p>For these reason it is not recommended to use <a href="https://linux.die.net/man/3/alloca" target="_blank" rel="noopener noreferrer"><code>alloca</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> inside a loop nor a recursive function.</p> <p>And because the memory is <a href="https://linux.die.net/man/3/free" target="_blank" rel="noopener noreferrer"><code>free</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>'d upon function return you cannot return the pointer as a function result (<a href="http://stackoverflow.com/documentation/c/364/undefined-behavior" target="_blank" rel="noopener noreferrer">the behavior would be undefined<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>).</p> <h3 id="summary"><a href="#summary" class="header-anchor">#</a> Summary</h3> <ul><li>call identical to <a href="https://linux.die.net/man/3/malloc" target="_blank" rel="noopener noreferrer"><code>malloc</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>automatically free'd upon function return</li> <li>incompatible with <a href="https://linux.die.net/man/3/free" target="_blank" rel="noopener noreferrer"><code>free</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>,<a href="https://linux.die.net/man/3/realloc" target="_blank" rel="noopener noreferrer"><code>realloc</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> functions (<a href="http://stackoverflow.com/documentation/c/364/undefined-behavior" target="_blank" rel="noopener noreferrer">undefined behavior<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>)</li> <li>pointer cannot be returned as a function result (<a href="http://stackoverflow.com/documentation/c/364/undefined-behavior" target="_blank" rel="noopener noreferrer">undefined behavior<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>)</li> <li>allocation size limited by stack space, which (on most machines) is a lot smaller than the heap space available for use by <code>malloc()</code></li> <li>avoid using <code>alloca()</code> and VLAs (variable length arrays) in a single function</li> <li><code>alloca()</code> is not as portable as <code>malloc()</code> et al</li></ul> <h3 id="recommendation"><a href="#recommendation" class="header-anchor">#</a> Recommendation</h3> <ul><li>Do not use <code>alloca()</code> in new code</li></ul> <p>Modern alternative.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span> data<span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">/*
      function body;
    */</span>
    <span class="token comment">// data is automatically freed</span>
<span class="token punctuation">}</span>

</code></pre></div><p>This works where <code>alloca()</code> does, and works in places where <code>alloca()</code> doesn't (inside loops, for example).  It does assume either a C99 implementation or a C11 implementation that does not define <code>__STDC_NO_VLA__</code>.</p> <h2 id="user-defined-memory-management"><a href="#user-defined-memory-management" class="header-anchor">#</a> User-defined memory management</h2> <p><code>malloc()</code> often calls underlying operating system functions to obtain pages of memory. But there is nothing special about the function and it can be implemented in straight C by declaring a large static array and allocating from it (there is a slight difficulty in ensuring correct alignment, in practice aligning to 8 bytes is almost always adequate).</p> <p>To implement a simple scheme, a control block is stored in the region of memory immediately before the pointer to be returned from the call. This means that <code>free()</code> may be implemented by subtracting from the returned pointer and reading off the control information, which is typically the block size plus some information that allows it to be put back in the free list - a linked list of unallocated blocks.</p> <p>When the user requests an allocation, the free list is searched until a block of identical or larger size to the amount requested is found, then if necessary it is split. This can lead to memory fragmentation if the user is continually making many allocations and frees of unpredictable size and and at unpredictable intervals (not all real programs behave like that, the simple scheme is often adequate for small programs).</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">/* typical control block */</span>
<span class="token keyword">struct</span> <span class="token class-name">block</span>
<span class="token punctuation">{</span>
   size_t size<span class="token punctuation">;</span>         <span class="token comment">/* size of block */</span>
   <span class="token keyword">struct</span> <span class="token class-name">block</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>  <span class="token comment">/* next block in free list */</span> 
   <span class="token keyword">struct</span> <span class="token class-name">block</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span>  <span class="token comment">/* back pointer to previous block in memory */</span>
   <span class="token keyword">void</span> <span class="token operator">*</span>padding<span class="token punctuation">;</span>       <span class="token comment">/* need 16 bytes to make multiple of 8 */</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">block</span> arena<span class="token punctuation">[</span><span class="token number">10000</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* allocate from here */</span>
<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">block</span> <span class="token operator">*</span>firstfree<span class="token punctuation">;</span>

</code></pre></div><p>Many programs require large numbers of allocations of small objects of the same size. This is very easy to implement. Simply use a block with a next pointer. So if a block of 32 bytes is required:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">union</span> block
<span class="token punctuation">{</span>
   <span class="token keyword">union</span> block <span class="token operator">*</span> next<span class="token punctuation">;</span>
   <span class="token keyword">unsigned</span> <span class="token keyword">char</span> payload<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>  

<span class="token keyword">static</span> <span class="token keyword">union</span> block arena<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">union</span> block <span class="token operator">*</span> head<span class="token punctuation">;</span> 
<span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        arena<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token operator">&amp;</span>arena<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    arena<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/* last one, null */</span>
    head <span class="token operator">=</span> <span class="token operator">&amp;</span>block<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">block_alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>answer <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>answer<span class="token punctuation">)</span>
        head <span class="token operator">=</span> head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>
    <span class="token keyword">return</span> answer<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">block_free</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">union</span> block <span class="token operator">*</span>block <span class="token operator">=</span> ptr<span class="token punctuation">;</span>
    block<span class="token operator">-&gt;</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
    head <span class="token operator">-</span> block<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>This scheme is extremely fast and efficient, and can be made generic with a certain loss of clarity.</p> <h4 id="syntax"><a href="#syntax" class="header-anchor">#</a> Syntax</h4> <ul><li>void <em>aligned_alloc(size_t alignment, size_t size); /</em> Only since C11 */</li> <li>void *calloc(size_t nelements, size_t size);</li> <li>void free(void *ptr);</li> <li>void *malloc(size_t size);</li> <li>void *realloc(void *ptr, size_t size);</li> <li>void <em>alloca(size_t size); /</em> from alloca.h, not standard, not portable, dangerous. */</li></ul> <h4 id="parameters"><a href="#parameters" class="header-anchor">#</a> Parameters</h4> <table><thead><tr><th>name</th> <th>description</th></tr></thead> <tbody><tr><td>size (<code>malloc</code>, <code>realloc</code> and <code>aligned_alloc</code>)</td> <td>total size of the memory in bytes. For <code>aligned_alloc</code> the size must be a integral multiple of alignment.</td></tr> <tr><td>size (<code>calloc</code>)</td> <td>size of each element</td></tr> <tr><td>nelements</td> <td>number of elements</td></tr> <tr><td>ptr</td> <td>pointer to allocated memory previously returned by <code>malloc</code>, <code>calloc</code>, <code>realloc</code> or <code>aligned_alloc</code></td></tr> <tr><td>alignment</td> <td>alignment of allocated memory</td></tr></tbody></table> <h4 id="remarks"><a href="#remarks" class="header-anchor">#</a> Remarks</h4> <p>Note that <code>aligned_alloc()</code> is only defined for C11 or later.</p> <p>Systems such as those based on <a href="http://stackoverflow.com/documentation/posix" target="_blank" rel="noopener noreferrer">POSIX<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> provide other ways of allocating aligned memory (e.g. <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html" target="_blank" rel="noopener noreferrer"><code>posix_memalign()</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>), and also have other memory management options (e.g. <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/mmap.html" target="_blank" rel="noopener noreferrer"><code>mmap()</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>).</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/devtut/generate/edit/master/docs/c/memory-management.md" target="_blank" rel="noopener noreferrer">Edit this page on GitHub</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      â†
      <a href="/c/structure-padding-and-packing.html" class="prev">
        Structure Padding and Packing
      </a></span> <span class="next"><a href="/c/implementation-defined-behaviour.html">
        Implementation-defined behaviour
      </a>
      â†’
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.ced448ab.js" defer></script><script src="/assets/js/3.f1d73125.js" defer></script><script src="/assets/js/581.bbbde52a.js" defer></script>
  </body>
</html>
