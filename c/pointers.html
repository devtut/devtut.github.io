<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C - Pointers</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="description" content="Common errors, Introduction, Dereferencing a Pointer, Dereferencing a Pointer to a struct, Function pointers, Const Pointers, Polymorphic behaviour with void pointers, Initializing Pointers, Address-of Operator ( & ), Pointer Arithmetic, void* pointers as arguments and return values to standard functions, Same Asterisk, Different Meanings, Pointer to Pointer">
    <meta property="og:site_name" content="DevTut">
    <meta property="og:title" content="C - Pointers">
    <meta property="og:description" content="Common errors, Introduction, Dereferencing a Pointer, Dereferencing a Pointer to a struct, Function pointers, Const Pointers, Polymorphic behaviour with void pointers, Initializing Pointers, Address-of Operator ( & ), Pointer Arithmetic, void* pointers as arguments and return values to standard functions, Same Asterisk, Different Meanings, Pointer to Pointer">
    <meta property="og:type" content="article">
    <meta property="og:url" content="/c/pointers.html">
    <meta property="og:image" content="/logo.png">
    <meta name="twitter:title" content="C - Pointers">
    <meta name="twitter:description" content="Common errors, Introduction, Dereferencing a Pointer, Dereferencing a Pointer to a struct, Function pointers, Const Pointers, Polymorphic behaviour with void pointers, Initializing Pointers, Address-of Operator ( & ), Pointer Arithmetic, void* pointers as arguments and return values to standard functions, Same Asterisk, Different Meanings, Pointer to Pointer">
    <meta name="twitter:url" content="/c/pointers.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="/logo.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/mstile-150x150.png">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="google-site-verification" content="76_rKXgwMVIjd-axJC_1zPV9OS4mEjvtgjYOWVkAdnQ">
    
    <link rel="preload" href="/assets/css/0.styles.60619e34.css" as="style"><link rel="preload" href="/assets/js/app.1779e102.js" as="script"><link rel="preload" href="/assets/js/3.2cfa8016.js" as="script"><link rel="preload" href="/assets/js/588.18d1a88a.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.60619e34.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">DevTut</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>C</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/c/" aria-current="page" class="sidebar-link">Disclaimer</a></li><li><a href="/c/getting-started-with-c-language.html" class="sidebar-link">Getting started with C Language</a></li><li><a href="/c/comments.html" class="sidebar-link">Comments</a></li><li><a href="/c/data-types.html" class="sidebar-link">Data Types</a></li><li><a href="/c/operators.html" class="sidebar-link">Operators</a></li><li><a href="/c/boolean.html" class="sidebar-link">Boolean</a></li><li><a href="/c/strings.html" class="sidebar-link">Strings</a></li><li><a href="/c/literals-for-numbers-characters-and-strings.html" class="sidebar-link">Literals for numbers, characters and strings</a></li><li><a href="/c/compound-literals.html" class="sidebar-link">Compound Literals</a></li><li><a href="/c/bit-fields.html" class="sidebar-link">Bit-fields</a></li><li><a href="/c/arrays.html" class="sidebar-link">Arrays</a></li><li><a href="/c/linked-lists.html" class="sidebar-link">Linked lists</a></li><li><a href="/c/enumerations.html" class="sidebar-link">Enumerations</a></li><li><a href="/c/structs.html" class="sidebar-link">Structs</a></li><li><a href="/c/standard-math.html" class="sidebar-link">Standard Math</a></li><li><a href="/c/iteration-statements-loops-for-while-do-while.html" class="sidebar-link">Iteration Statements/Loops: for, while, do-while</a></li><li><a href="/c/selection-statements.html" class="sidebar-link">Selection Statements</a></li><li><a href="/c/initialization.html" class="sidebar-link">Initialization</a></li><li><a href="/c/declaration-vs-definition.html" class="sidebar-link">Declaration vs Definition</a></li><li><a href="/c/files-and-i-o-streams.html" class="sidebar-link">Files and I/O streams</a></li><li><a href="/c/formatted-input-output.html" class="sidebar-link">Formatted Input/Output</a></li><li><a href="/c/pointers.html" aria-current="page" class="active sidebar-link">Pointers</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/c/pointers.html#common-errors" class="sidebar-link">Common errors</a></li><li class="sidebar-sub-header"><a href="/c/pointers.html#introduction" class="sidebar-link">Introduction</a></li><li class="sidebar-sub-header"><a href="/c/pointers.html#dereferencing-a-pointer" class="sidebar-link">Dereferencing a Pointer</a></li><li class="sidebar-sub-header"><a href="/c/pointers.html#dereferencing-a-pointer-to-a-struct" class="sidebar-link">Dereferencing a Pointer to a struct</a></li><li class="sidebar-sub-header"><a href="/c/pointers.html#function-pointers" class="sidebar-link">Function pointers</a></li><li class="sidebar-sub-header"><a href="/c/pointers.html#const-pointers" class="sidebar-link">Const Pointers</a></li><li class="sidebar-sub-header"><a href="/c/pointers.html#polymorphic-behaviour-with-void-pointers" class="sidebar-link">Polymorphic behaviour with void pointers</a></li><li class="sidebar-sub-header"><a href="/c/pointers.html#initializing-pointers" class="sidebar-link">Initializing Pointers</a></li><li class="sidebar-sub-header"><a href="/c/pointers.html#address-of-operator" class="sidebar-link">Address-of Operator ( &amp; )</a></li><li class="sidebar-sub-header"><a href="/c/pointers.html#pointer-arithmetic" class="sidebar-link">Pointer Arithmetic</a></li><li class="sidebar-sub-header"><a href="/c/pointers.html#void-pointers-as-arguments-and-return-values-to-standard-functions" class="sidebar-link">void* pointers as arguments and return values to standard functions</a></li><li class="sidebar-sub-header"><a href="/c/pointers.html#same-asterisk-different-meanings" class="sidebar-link">Same Asterisk, Different Meanings</a></li><li class="sidebar-sub-header"><a href="/c/pointers.html#pointer-to-pointer-2" class="sidebar-link">Pointer to Pointer</a></li></ul></li><li><a href="/c/sequence-points.html" class="sidebar-link">Sequence points</a></li><li><a href="/c/function-pointers.html" class="sidebar-link">Function Pointers</a></li><li><a href="/c/function-parameters.html" class="sidebar-link">Function Parameters</a></li><li><a href="/c/pass-2d-arrays-to-functions.html" class="sidebar-link">Pass 2D-arrays to functions</a></li><li><a href="/c/error-handling.html" class="sidebar-link">Error handling</a></li><li><a href="/c/undefined-behavior.html" class="sidebar-link">Undefined behavior</a></li><li><a href="/c/random-number-generation.html" class="sidebar-link">Random Number Generation</a></li><li><a href="/c/preprocessor-and-macros.html" class="sidebar-link">Preprocessor and Macros</a></li><li><a href="/c/signal-handling.html" class="sidebar-link">Signal handling</a></li><li><a href="/c/variable-arguments.html" class="sidebar-link">Variable arguments</a></li><li><a href="/c/assertion.html" class="sidebar-link">Assertion</a></li><li><a href="/c/generic-selection.html" class="sidebar-link">Generic selection</a></li><li><a href="/c/x-macros.html" class="sidebar-link">X-macros</a></li><li><a href="/c/aliasing-and-effective-type.html" class="sidebar-link">Aliasing and effective type</a></li><li><a href="/c/compilation.html" class="sidebar-link">Compilation</a></li><li><a href="/c/identifier-scope.html" class="sidebar-link">Identifier Scope</a></li><li><a href="/c/common-pitfalls.html" class="sidebar-link">Common pitfalls</a></li><li><a href="/c/implicit-and-explicit-conversions.html" class="sidebar-link">Implicit and Explicit Conversions</a></li><li><a href="/c/type-qualifiers.html" class="sidebar-link">Type Qualifiers</a></li><li><a href="/c/valgrind.html" class="sidebar-link">Valgrind</a></li><li><a href="/c/typedef.html" class="sidebar-link">Typedef</a></li><li><a href="/c/storage-classes.html" class="sidebar-link">Storage Classes</a></li><li><a href="/c/declarations.html" class="sidebar-link">Declarations</a></li><li><a href="/c/inline-assembly.html" class="sidebar-link">Inline assembly</a></li><li><a href="/c/threads-native.html" class="sidebar-link">Threads (native)</a></li><li><a href="/c/structure-padding-and-packing.html" class="sidebar-link">Structure Padding and Packing</a></li><li><a href="/c/memory-management.html" class="sidebar-link">Memory management</a></li><li><a href="/c/implementation-defined-behaviour.html" class="sidebar-link">Implementation-defined behaviour</a></li><li><a href="/c/atomics.html" class="sidebar-link">Atomics</a></li><li><a href="/c/jump-statements.html" class="sidebar-link">Jump Statements</a></li><li><a href="/c/create-and-include-header-files.html" class="sidebar-link">Create and include header files</a></li><li><a href="/c/testing-frameworks.html" class="sidebar-link">Testing frameworks</a></li><li><a href="/c/ctype-h-character-classification-conversion.html" class="sidebar-link">— character classification &amp; conversion</a></li><li><a href="/c/side-effects.html" class="sidebar-link">Side Effects</a></li><li><a href="/c/multi-character-character-sequence.html" class="sidebar-link">Multi-Character Character Sequence</a></li><li><a href="/c/constraints.html" class="sidebar-link">Constraints</a></li><li><a href="/c/inlining.html" class="sidebar-link">Inlining</a></li><li><a href="/c/unions.html" class="sidebar-link">Unions</a></li><li><a href="/c/threads-native.html" class="sidebar-link">Threads (native)</a></li><li><a href="/c/multithreading.html" class="sidebar-link">Multithreading</a></li><li><a href="/c/interprocess-communication-ipc.html" class="sidebar-link">Interprocess Communication (IPC)</a></li><li><a href="/c/testing-frameworks.html" class="sidebar-link">Testing frameworks</a></li><li><a href="/c/valgrind.html" class="sidebar-link">Valgrind</a></li><li><a href="/c/common-c-programming-idioms-and-developer-practices.html" class="sidebar-link">Common C programming idioms and developer practices</a></li><li><a href="/c/common-pitfalls.html" class="sidebar-link">Common pitfalls</a></li><li><a href="/c/contributors.html" class="sidebar-link">The Contributors</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="pointers"><a href="#pointers" class="header-anchor">#</a> Pointers</h1> <p>A pointer is a type of variable which can store the address of another object or a function.</p> <h2 id="common-errors"><a href="#common-errors" class="header-anchor">#</a> Common errors</h2> <p>Improper use of pointers are frequently a source of bugs that can include security bugs or program crashes, most often due to segmentation faults.</p> <h3 id="not-checking-for-allocation-failures"><a href="#not-checking-for-allocation-failures" class="header-anchor">#</a> Not checking for allocation failures</h3> <p>Memory allocation is not guaranteed to succeed, and may instead return a <code>NULL</code> pointer. Using the returned value, without checking if the allocation is successful, invokes <a href="http://stackoverflow.com/documentation/c/364/undefined-behavior" target="_blank" rel="noopener noreferrer">undefined behavior<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>. This usually leads to a crash, but there is no guarantee that a crash will happen so relying on that can also lead to problems.</p> <p>For example, unsafe way:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">SomeStruct</span> <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span> <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
s<span class="token operator">-&gt;</span>someValue <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/* UNSAFE, because s might be a null pointer */</span>

</code></pre></div><p>Safe way:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">SomeStruct</span> <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span> <span class="token operator">*</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    s<span class="token operator">-&gt;</span>someValue <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/* This is safe, we have checked that s is valid */</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="using-literal-numbers-instead-of-sizeof-when-requesting-memory"><a href="#using-literal-numbers-instead-of-sizeof-when-requesting-memory" class="header-anchor">#</a> Using literal numbers instead of sizeof when requesting memory</h3> <p>For a given compiler/machine configuration, types have a known size; however, there isn't any standard which defines that the size of a given type (other than <code>char</code>) will be the same for all compiler/machine configurations. If the code uses 4 instead of <code>sizeof(int)</code> for memory allocation, it may work on the original machine, but the code isn't necessarily portable to other machines or compilers. Fixed sizes for types should be replaced by <code>sizeof(that_type)</code> or <code>sizeof(*var_ptr_to_that_type)</code>.</p> <p>Non-portable allocation:</p> <div class="language- extra-class"><pre class="language-text"><code>
int *intPtr = malloc(4*1000);    /* allocating storage for 1000 int */
 long *longPtr = malloc(8*1000);  /* allocating storage for 1000 long */

</code></pre></div><p>Portable allocation:</p> <div class="language- extra-class"><pre class="language-text"><code>
int *intPtr = malloc(sizeof(int)*1000);     /* allocating storage for 1000 int */
 long *longPtr = malloc(sizeof(long)*1000);  /* allocating storage for 1000 long */

</code></pre></div><p>Or, better still:</p> <div class="language- extra-class"><pre class="language-text"><code>
int *intPtr = malloc(sizeof(*intPtr)*1000);     /* allocating storage for 1000 int */
 long *longPtr = malloc(sizeof(*longPtr)*1000);  /* allocating storage for 1000 long */

</code></pre></div><h3 id="memory-leaks"><a href="#memory-leaks" class="header-anchor">#</a> Memory leaks</h3> <p>Failure to de-allocate memory using <code>free</code> leads to a buildup of non-reusable memory, which is no longer used by the program; this is called a <a href="https://en.wikipedia.org/wiki/Memory_leak" target="_blank" rel="noopener noreferrer">memory leak<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>. Memory leaks waste memory resources and can lead to allocation failures.</p> <h3 id="logical-errors"><a href="#logical-errors" class="header-anchor">#</a> Logical errors</h3> <p>All allocations must follow the same pattern:</p> <ol><li>Allocation using <code>malloc</code> (or <code>calloc</code>)</li> <li>Usage to store data</li> <li>De-allocation using <code>free</code></li></ol> <p>Failure to adhere to this pattern, such as using memory after a call to <code>free</code> (<a href="https://en.wikipedia.org/wiki/Dangling_pointer" target="_blank" rel="noopener noreferrer">dangling pointer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>) or before a call to <code>malloc</code> (<a href="http://stackoverflow.com/questions/2583656/what-is-the-meaning-of-wild-pointer-in-c" target="_blank" rel="noopener noreferrer">wild pointer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>), calling <code>free</code> twice (&quot;double free&quot;), etc., usually causes a segmentation fault and results in a crash of the program.</p> <p>These errors can be transient and hard to debug – for example, freed memory is usually not immediately reclaimed by the OS, and thus dangling pointers may persist for a while and appear to work.</p> <p>On systems where it works, <a href="http://valgrind.org/" target="_blank" rel="noopener noreferrer">Valgrind<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> is an invaluable tool for identifying what memory is leaked and where it was originally allocated.</p> <h3 id="creating-pointers-to-stack-variables"><a href="#creating-pointers-to-stack-variables" class="header-anchor">#</a> Creating pointers to stack variables</h3> <p>Creating a pointer does not extend the life of the variable being pointed to. For example:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span><span class="token operator">*</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Here, <code>x</code> has <strong>automatic storage duration</strong> (commonly known as <strong>stack</strong> allocation). Because it is allocated on the stack, its lifetime is only as long as <code>myFunction</code> is executing; after <code>myFunction</code> has exited, the variable <code>x</code> is destroyed. This function gets the address of <code>x</code> (using <code>&amp;x</code>), and returns it to the caller, leaving the caller with a pointer to a non-existent variable. Attempting to access this variable will then invoke <a href="http://stackoverflow.com/documentation/c/364/undefined-behavior" target="_blank" rel="noopener noreferrer">undefined behavior<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <p>Most compilers don't actually clear a stack frame after the function exits, thus dereferencing the returned pointer often gives you the expected data. When another function is called however, the memory being pointed to may be overwritten, and it appears that the data being pointed to has been corrupted.</p> <p>To resolve this, either <code>malloc</code> the storage for the variable to be returned, and return a pointer to the newly created storage, or require that a valid pointer is passed in to the function instead of returning one, for example:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">solution1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>x <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span> <span class="token operator">*</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">/* Something went wrong */</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token operator">*</span>x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">solution2</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>x<span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">/* NB: calling this function with an invalid or null pointer 
       causes undefined behaviour. */</span>

    <span class="token operator">*</span>x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token punctuation">{</span> 
        <span class="token comment">/* Use solution1() */</span>

        <span class="token keyword">int</span> <span class="token operator">*</span>foo <span class="token operator">=</span> <span class="token function">solution1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
        <span class="token keyword">if</span> <span class="token punctuation">(</span>foo <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment">/* Something went wrong */</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;The value set by solution1() is %i\n&quot;</span><span class="token punctuation">,</span> <span class="token operator">*</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/* Will output: &quot;The value set by solution1() is 10&quot; */</span>

        <span class="token function">free</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Tidy up */</span>
    <span class="token punctuation">}</span>

    <span class="token punctuation">{</span>
        <span class="token comment">/* Use solution2() */</span>

        <span class="token keyword">int</span> bar<span class="token punctuation">;</span>
        <span class="token function">solution2</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span> 

        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;The value set by solution2() is %i\n&quot;</span><span class="token punctuation">,</span> bar<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">/* Will output: &quot;The value set by solution2() is 10&quot; */</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="incrementing-decrementing-and-dereferencing"><a href="#incrementing-decrementing-and-dereferencing" class="header-anchor">#</a> Incrementing / decrementing and dereferencing</h3> <p>If you write <code>*p++</code> to increment what is pointed by <code>p</code>, you are wrong.</p> <p>Post incrementing / decrementing is executed before dereferencing.
Therefore, this expression will increment the pointer <code>p</code> itself and return what was pointed by <code>p</code> before incrementing without changing it.</p> <p>You should write <code>(*p)++</code> to increment what is pointed by <code>p</code>.</p> <p>This rule also applies to post decrementing: <code>*p--</code> will decrement the pointer <code>p</code> itself, not what is pointed by <code>p</code>.</p> <h2 id="introduction"><a href="#introduction" class="header-anchor">#</a> Introduction</h2> <p>A pointer is declared much like any other variable, except an asterisk (<code>*</code>) is placed between the type and the name of the variable to denote it is a pointer.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token operator">*</span>pointer<span class="token punctuation">;</span> <span class="token comment">/* inside a function, pointer is uninitialized and doesn't point to any valid object yet */</span>

</code></pre></div><p>To declare two pointer variables of the same type, in the same declaration, use the asterisk symbol before each identifier. For example,</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token operator">*</span>iptr1<span class="token punctuation">,</span> <span class="token operator">*</span>iptr2<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>iptr3<span class="token punctuation">,</span>  iptr4<span class="token punctuation">;</span>  <span class="token comment">/* iptr3 is a pointer variable, whereas iptr4 is misnamed and is an int */</span>

</code></pre></div><p>The address-of or reference operator denoted by an ampersand (<code>&amp;</code>) gives the address of a given variable which can be placed in a pointer of appropriate type.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
pointer <span class="token operator">=</span> <span class="token operator">&amp;</span>value<span class="token punctuation">;</span>

</code></pre></div><p>The indirection or dereference operator denoted by an asterisk (<code>*</code>) gets the contents of an object pointed to by a pointer.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Value of pointed to integer: %d\n&quot;</span><span class="token punctuation">,</span> <span class="token operator">*</span>pointer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* Value of pointed to integer: 1 */</span>

</code></pre></div><p>If the pointer points to a structure or union type then you can dereference it and access its members directly using the <code>-&gt;</code> operator:</p> <div class="language-c extra-class"><pre class="language-c"><code>SomeStruct <span class="token operator">*</span>s <span class="token operator">=</span> <span class="token operator">&amp;</span>someObject<span class="token punctuation">;</span>
s<span class="token operator">-&gt;</span>someMember <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">/* Equivalent to (*s).someMember = 5 */</span>

</code></pre></div><p>In C, a pointer is a distinct value type which can be reassigned and otherwise is treated as a variable in its own right. For example the following example prints the value of the pointer (variable) itself.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Value of the pointer itself: %p\n&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>pointer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* Value of the pointer itself: 0x7ffcd41b06e4 */</span>
<span class="token comment">/* This address will be different each time the program is executed */</span>

</code></pre></div><p>Because a pointer is a mutable variable, it is possible for it to not
point to a valid object, either by being set to null</p> <div class="language-c extra-class"><pre class="language-c"><code>pointer <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">/* or alternatively */</span>
pointer <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

</code></pre></div><p>or simply by containing an arbitrary bit pattern that isn't a valid
address. The latter is a very bad situation, because it cannot be
tested before the pointer is being dereferenced, there is only a test
for the case a pointer is null:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>pointer<span class="token punctuation">)</span> <span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>A pointer may only be dereferenced if it points to a <strong>valid</strong> object,
otherwise the behavior is undefined.
Many modern implementations may help you by
raising some kind of error such as a <a href="https://en.wikipedia.org/wiki/Segmentation_fault" target="_blank" rel="noopener noreferrer">segmentation fault<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> and
terminate execution, but others may just leave your program in an
invalid state.</p> <p>The value returned by the dereference operator is a mutable alias to the original variable, so it can be changed, modifying the original variable.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token operator">*</span>pointer <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Value of pointed to variable after change: %d\n&quot;</span><span class="token punctuation">,</span> <span class="token operator">*</span>pointer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* Value of pointed to variable after change: 2 */</span>

</code></pre></div><p>Pointers are also re-assignable. This means that a pointer pointing to an object can later be used to point to another object of the same type.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> value2 <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
pointer <span class="token operator">=</span> <span class="token operator">&amp;</span>value2<span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Value from pointer: %d\n&quot;</span><span class="token punctuation">,</span> <span class="token operator">*</span>pointer<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/* Value from pointer: 10 */</span>

</code></pre></div><p>Like any other variable, pointers have a specific type. You can't
assign the address of a <code>short int</code> to a pointer to a <code>long int</code>, for
instance. Such behavior is referred to as type punning and is forbidden in C, though there are a few exceptions.</p> <p>Although pointer must be of a specific type, the memory allocated for each type of pointer is equal to the memory used by the environment to store addresses, rather than the size of the type that is pointed to.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Size of int pointer: %zu\n&quot;</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">/* size 4 bytes */</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Size of int variable: %zu\n&quot;</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">/* size 4 bytes */</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Size of char pointer: %zu\n&quot;</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* size 4 bytes */</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Size of char variable: %zu\n&quot;</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* size 1 bytes */</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Size of short pointer: %zu\n&quot;</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span><span class="token keyword">short</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* size 4 bytes */</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Size of short variable: %zu\n&quot;</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span> <span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">/* size 2 bytes */</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p><strong>(NB: if you are using Microsoft Visual Studio, which does not support the C99 or C11 standards, you must use <a href="https://msdn.microsoft.com/en-us/library/tcxf1dw6.aspx" target="_blank" rel="noopener noreferrer"><code>%Iu</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><sup>1</sup> instead of <code>%zu</code> in the above sample.)</strong></p> <p>Note that the results above can vary from environment to environment in numbers but all environments would show equal sizes for different types of pointer.</p> <p>Extract based on information from <a href="https://www.cs.cf.ac.uk/Dave/C/node10.html" target="_blank" rel="noopener noreferrer">Cardiff University C Pointers Introduction<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="pointers-and-arrays"><a href="#pointers-and-arrays" class="header-anchor">#</a> Pointers and Arrays</h3> <p>Pointers and arrays are intimately connected in C. Arrays in C are always held in contiguous locations in memory. Pointer arithmetic is always scaled by the size of the item pointed to. So if we have an array of three doubles, and a pointer to the base, <code>*ptr</code> refers to the first double, <code>*(ptr + 1)</code> to the second, <code>*(ptr + 2)</code> to the third. A more convenient notation is to use array notation <code>[]</code>.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">double</span> point<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> point<span class="token punctuation">;</span>

<span class="token comment">/* prints x 0.0, y 1.0 z 2.0 */</span> 
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;x %f y %f z %f\n&quot;</span><span class="token punctuation">,</span> ptr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ptr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ptr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>So essentially ptr and the array name are interchangeable. This rule also means that an array decays to a pointer when passed to a subroutine.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">double</span> point<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;length of point is %s\n&quot;</span><span class="token punctuation">,</span> <span class="token function">length</span><span class="token punctuation">(</span>point<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/* get the distance of a 3D point from the origin */</span> 
<span class="token keyword">double</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token keyword">double</span> <span class="token operator">*</span>pt<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>pt<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> pt<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> pt<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> pt<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> pt<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">*</span> pt<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre></div><p>A pointer may point to any element in an array, or to the element beyond the last element. It is however an error to set a pointer to any other value, including the element before the array. (The reason is that on segmented architectures the address before the first element may cross a segment boundary, the compiler ensures that does not happen for the last element plus one).</p> <p><sup>Footnote 1: Microsoft format information can be found via <a href="https://msdn.microsoft.com/en-us/library/wc7014hz.aspx" target="_blank" rel="noopener noreferrer"><code>printf()</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> and <a href="https://msdn.microsoft.com/en-us/library/56e442dc.aspx" target="_blank" rel="noopener noreferrer">format specification syntax<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</sup></p> <h2 id="dereferencing-a-pointer"><a href="#dereferencing-a-pointer" class="header-anchor">#</a> Dereferencing a Pointer</h2> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>a_pointer <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>

</code></pre></div><p>To dereference <code>a_pointer</code> and change the value of a, we use the following operation</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token operator">*</span>a_pointer <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

</code></pre></div><p>This can be verified using the following print statements.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\n&quot;</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Prints 2 */</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\n&quot;</span><span class="token punctuation">,</span> <span class="token operator">*</span>a_pointer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Also prints 2 */</span>

</code></pre></div><p>However, one would be mistaken to dereference a <code>NULL</code> or otherwise invalid pointer. This</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token operator">*</span>p1<span class="token punctuation">,</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span>

p1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token number">0xbad</span><span class="token punctuation">;</span>
p2 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

<span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token operator">*</span>p1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>

</code></pre></div><p>is usually <a href="http://stackoverflow.com/documentation/c/364/undefined-behavior" target="_blank" rel="noopener noreferrer">undefined behavior<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>. <code>p1</code> may not be dereferenced because it points to an address <code>0xbad</code> which may not be a valid address. Who knows what's there? It might be operating system memory, or another program's memory. The only time code like this is used, is in embedded development, which stores particular information at hard-coded addresses. <code>p2</code> cannot be dereferenced because it is <code>NULL</code>, which is invalid.</p> <h2 id="dereferencing-a-pointer-to-a-struct"><a href="#dereferencing-a-pointer-to-a-struct" class="header-anchor">#</a> Dereferencing a Pointer to a struct</h2> <p>Let's say we have the following structure:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">MY_STRUCT</span> 
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> my_int<span class="token punctuation">;</span>
    <span class="token keyword">float</span> my_float<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>We can define <code>MY_STRUCT</code> to omit the <code>struct</code> keyword so we don't have to type <code>struct MY_STRUCT</code> each time we use it. This, however, is optional.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">MY_STRUCT</span> MY_STRUCT<span class="token punctuation">;</span>

</code></pre></div><p>If we then have a pointer to an instance of this struct</p> <div class="language-c extra-class"><pre class="language-c"><code>MY_STRUCT <span class="token operator">*</span>instance<span class="token punctuation">;</span>

</code></pre></div><p>If this statement appears at file scope, <code>instance</code> will be initialized with a null pointer when the program starts.  If this statement appears inside a function, its value is undefined.  The variable must be initialized to point to a valid <code>MY_STRUCT</code> variable, or to dynamically allocated space, before it can be dereferenced.  For example:</p> <div class="language-c extra-class"><pre class="language-c"><code>MY_STRUCT info <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3.141593F</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
MY_STRUCT <span class="token operator">*</span>instance <span class="token operator">=</span> <span class="token operator">&amp;</span>info<span class="token punctuation">;</span>

</code></pre></div><p>When the pointer is valid, we can dereference it to access its members using one of two different notations:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>instance<span class="token punctuation">)</span><span class="token punctuation">.</span>my_int<span class="token punctuation">;</span>
<span class="token keyword">float</span> b <span class="token operator">=</span> instance<span class="token operator">-&gt;</span>my_float<span class="token punctuation">;</span>

</code></pre></div><p>While both these methods work, it is better practice to use the arrow <code>-&gt;</code> operator rather than the combination of parentheses, the dereference <code>*</code> operator and the dot <code>.</code> operator because it is easier to read and understand, especially with nested uses.</p> <p>Another important difference is shown below:</p> <div class="language-c extra-class"><pre class="language-c"><code>MY_STRUCT copy <span class="token operator">=</span> <span class="token operator">*</span>instance<span class="token punctuation">;</span>
copy<span class="token punctuation">.</span>my_int    <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

</code></pre></div><p>In this case, <code>copy</code> contains a copy of the contents of <code>instance</code>. Changing <code>my_int</code> of <code>copy</code> will not change it in <code>instance</code>.</p> <div class="language-c extra-class"><pre class="language-c"><code>MY_STRUCT <span class="token operator">*</span>ref <span class="token operator">=</span> instance<span class="token punctuation">;</span>
ref<span class="token operator">-&gt;</span>my_int    <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

</code></pre></div><p>In this case, <code>ref</code> is a reference to <code>instance</code>. Changing <code>my_int</code> using the reference will change it in <code>instance</code>.</p> <p>It is common practice to use pointers to structs as parameters in functions, rather than the structs themselves. Using the structs as function parameters could cause the stack to overflow if the struct is large. Using a pointer to a struct only uses enough stack space for the pointer, but can cause side effects if the function changes the struct which is passed into the function.</p> <h2 id="function-pointers"><a href="#function-pointers" class="header-anchor">#</a> Function pointers</h2> <p>Pointers can also be used to point at functions.</p> <p>Let's take a basic function:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token function">return_type_of_func</span> <span class="token punctuation">(</span><span class="token operator">*</span>my_func_pointer<span class="token punctuation">)</span><span class="token punctuation">(</span>type_arg1<span class="token punctuation">,</span> type_arg2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>

</code></pre></div><p>We then must assign this pointer to the function:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">some_function</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token function">callback</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token function">callback</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="see-also"><a href="#see-also" class="header-anchor">#</a> See also</h3> <p><a href="http://stackoverflow.com/documentation/c/250/function-pointers#t=201701141235586038319" target="_blank" rel="noopener noreferrer">Function Pointers<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="const-pointers"><a href="#const-pointers" class="header-anchor">#</a> Const Pointers</h2> <h3 id="single-pointers"><a href="#single-pointers" class="header-anchor">#</a> Single Pointers</h3> <li>
Pointer to an `int`
The pointer can point to different integers and the `int`'s can be changed through the pointer. This sample of code assigns b to point to `int b` then changes `b`'s value to `100`.
<div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> b<span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">;</span>
p <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>    <span class="token comment">/* OK */</span>
<span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>  <span class="token comment">/* OK */</span>

</code></pre></div></li> <li>
Pointer to a `const int`
The pointer can point to different integers but the `int`'s value can't be changed through the pointer.
<div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> b<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">;</span>
p <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>    <span class="token comment">/* OK */</span>
<span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>  <span class="token comment">/* Compiler Error */</span>

</code></pre></div></li> <li>
`const` pointer to `int`
The pointer can only point to one `int` but the `int`'s value can be changed through the pointer.
<div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">*</span> <span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span> <span class="token comment">/* OK as initialisation, no assignment */</span>
<span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>  <span class="token comment">/* OK */</span>
p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>    <span class="token comment">/* Compiler Error */</span>

</code></pre></div></li> <li>
`const` pointer to `const int`
The pointer can only point to one `int` and the `int` can not be changed through the pointer.
<div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> <span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span> <span class="token comment">/* OK as initialisation, no assignment */</span>
p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>   <span class="token comment">/* Compiler Error */</span>
<span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">/* Compiler Error */</span>

</code></pre></div></li> <h3 id="pointer-to-pointer"><a href="#pointer-to-pointer" class="header-anchor">#</a> Pointer to Pointer</h3> <li>
Pointer to a pointer to an `int`
This code assigns the address of `p1` to the to double pointer `p` (which then points to `int* p1` (which points to `int`)).
Then changes `p1` to point to `int a`. Then changes the value of a to be 100.
<div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">;</span>
  <span class="token keyword">int</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span>
  <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>p<span class="token punctuation">;</span>
  p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span> <span class="token comment">/* OK */</span>
  p <span class="token operator">=</span> <span class="token operator">&amp;</span>p1<span class="token punctuation">;</span> <span class="token comment">/* OK */</span>
  <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment">/* OK */</span>
  <span class="token operator">*</span><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">/* OK */</span>
<span class="token punctuation">}</span>

</code></pre></div></li> <li>
Pointer to pointer to a `const int`
<div class="language-c extra-class"><pre class="language-c"><code> <span class="token keyword">void</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> b<span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>p<span class="token punctuation">;</span>
  p <span class="token operator">=</span> <span class="token operator">&amp;</span>p1<span class="token punctuation">;</span> <span class="token comment">/* OK */</span>
  <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span> <span class="token comment">/* OK */</span>
  <span class="token operator">*</span><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">/* error: assignment of read-only location ‘**p’ */</span>
<span class="token punctuation">}</span>

</code></pre></div></li> <li>
Pointer to `const` pointer to an `int`
<div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> b<span class="token punctuation">;</span>
  <span class="token keyword">int</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span>
  <span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
  p <span class="token operator">=</span> <span class="token operator">&amp;</span>p1<span class="token punctuation">;</span> <span class="token comment">/* OK */</span>
  <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span> <span class="token comment">/* error: assignment of read-only location ‘*p’ */</span>
  <span class="token operator">*</span><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">/* OK */</span>
<span class="token punctuation">}</span>

</code></pre></div></li> <li>
`const` pointer to pointer to `int`
<div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">f4</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> b<span class="token punctuation">;</span>
  <span class="token keyword">int</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span>
  <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span> <span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>p1<span class="token punctuation">;</span> <span class="token comment">/* OK as initialisation, not assignment */</span>
  p <span class="token operator">=</span> <span class="token operator">&amp;</span>p1<span class="token punctuation">;</span> <span class="token comment">/* error: assignment of read-only variable ‘p’ */</span>
  <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span> <span class="token comment">/* OK */</span>
  <span class="token operator">*</span><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">/* OK */</span>
<span class="token punctuation">}</span>

</code></pre></div></li> <li>
Pointer to `const` pointer to `const int`
<div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">f5</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> b<span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
  p <span class="token operator">=</span> <span class="token operator">&amp;</span>p1<span class="token punctuation">;</span> <span class="token comment">/* OK */</span>
  <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span> <span class="token comment">/* error: assignment of read-only location ‘*p’ */</span>
  <span class="token operator">*</span><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">/* error: assignment of read-only location ‘**p’ */</span>
<span class="token punctuation">}</span>

</code></pre></div></li> <li>
`const` pointer to pointer to `const int`
<div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">f6</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> b<span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span> <span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>p1<span class="token punctuation">;</span> <span class="token comment">/* OK as initialisation, not assignment */</span>
  p <span class="token operator">=</span> <span class="token operator">&amp;</span>p1<span class="token punctuation">;</span> <span class="token comment">/* error: assignment of read-only variable ‘p’ */</span>
  <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span> <span class="token comment">/* OK */</span>
  <span class="token operator">*</span><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">/* error: assignment of read-only location ‘**p’ */</span>
<span class="token punctuation">}</span>

</code></pre></div></li> <li>
`const` pointer to `const` pointer to `int`
<div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">f7</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">int</span> b<span class="token punctuation">;</span>
  <span class="token keyword">int</span> <span class="token operator">*</span>p1<span class="token punctuation">;</span>
  <span class="token keyword">int</span> <span class="token operator">*</span> <span class="token keyword">const</span> <span class="token operator">*</span> <span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>p1<span class="token punctuation">;</span> <span class="token comment">/* OK as initialisation, not assignment */</span>
  p <span class="token operator">=</span> <span class="token operator">&amp;</span>p1<span class="token punctuation">;</span> <span class="token comment">/* error: assignment of read-only variable ‘p’  */</span>
  <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span> <span class="token comment">/* error: assignment of read-only location ‘*p’ */</span>
  <span class="token operator">*</span><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">/* OK */</span>
<span class="token punctuation">}</span>

</code></pre></div></li> <h2 id="polymorphic-behaviour-with-void-pointers"><a href="#polymorphic-behaviour-with-void-pointers" class="header-anchor">#</a> Polymorphic behaviour with void pointers</h2> <p>The <a href="http://man7.org/linux/man-pages/man3/qsort.3.html" target="_blank" rel="noopener noreferrer"><code>qsort()</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> standard library function is a good example of how one can use void pointers to make a single function operate on a large variety of different types.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">qsort</span> <span class="token punctuation">(</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>base<span class="token punctuation">,</span>                                 <span class="token comment">/* Array to be sorted */</span>
    <span class="token class-name">size_t</span> num<span class="token punctuation">,</span>                                 <span class="token comment">/* Number of elements in array */</span>
    <span class="token class-name">size_t</span> size<span class="token punctuation">,</span>                                <span class="token comment">/* Size in bytes of each element */</span>
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>compar<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Comparison function for two elements */</span>

</code></pre></div><p>The array to be sorted is passed as a void pointer, so an array of any type of element can be operated on. The next two arguments tell <code>qsort()</code> how many elements it should expect in the array, and how large, in bytes, each element is.</p> <p>The last argument is a function pointer to a comparison function which itself takes two void pointers. By making the caller provide this function, <code>qsort()</code> can effectively sort elements of any type.</p> <p>Here's an example of such a comparison function, for comparing floats. Note that any comparison function passed to <code>qsort()</code> needs to have this type signature. The way it is made polymorphic is by casting the void pointer arguments to pointers of the type of element we wish to compare.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">compare_floats</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>b<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">float</span> fa <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token operator">*</span><span class="token punctuation">)</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> fb <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token operator">*</span><span class="token punctuation">)</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fa <span class="token operator">&lt;</span> fb<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>fa <span class="token operator">&gt;</span> fb<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Since we know that qsort will use this function to compare floats, we cast the void pointer arguments back to float pointers before dereferencing them.</p> <p>Now, the usage of the polymorphic function qsort on an array &quot;array&quot; with length &quot;len&quot; is very simple:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token function">qsort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> compare_floats<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><h2 id="initializing-pointers"><a href="#initializing-pointers" class="header-anchor">#</a> Initializing Pointers</h2> <p>Pointer initialization is a good way to avoid wild pointers. The initialization is simple and is no different from initialization of a variable.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stddef.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> 
    <span class="token keyword">char</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> <span class="token operator">*</span>p3 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

         <span class="token comment">/* NULL is a macro defined in stddef.h, stdio.h, stdlib.h, and string.h */</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>    

</code></pre></div><p>In most operating systems, inadvertently using a pointer that has been initialized to <code>NULL</code> will often result in the program crashing immediately, making it easy to identify the cause of the problem.  Using an uninitialized pointer can often cause hard-to-diagnose bugs.</p> <h3 id="caution"><a href="#caution" class="header-anchor">#</a> Caution:</h3> <p>The result of dereferencing a <code>NULL</code> pointer is undefined, so it <strong>will not necessarily cause a crash</strong> even if that is the natural behaviour of the operating system the program is running on.  Compiler optimizations may mask the crash, cause the crash to occur before or after the point in the source code at which the null pointer dereference occurred, or cause parts of the code that contains the null pointer dereference to be unexpectedly removed from the program. Debug builds will not usually exhibit these behaviours, but this is not guaranteed by the language standard.  Other unexpected and/or undesirable behaviour is also allowed.</p> <p>Because <code>NULL</code> never points to a variable, to allocated memory, or to a function, it is safe to use as a guard value.</p> <h3 id="caution-2"><a href="#caution-2" class="header-anchor">#</a> Caution:</h3> <p>Usually <code>NULL</code> is defined as <code>(void *)0</code>. But this does not imply that the assigned memory address is <code>0x0</code>.  For more clarification refer to <a href="http://c-faq.com/null/" target="_blank" rel="noopener noreferrer">C-faq for NULL pointers<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>Note that you can also initialize pointers to contain values other than NULL.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> i1<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
   <span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>i1<span class="token punctuation">;</span>
   <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token string">&quot;A constant string to point to&quot;</span><span class="token punctuation">;</span>
   <span class="token keyword">float</span> <span class="token operator">*</span>p3 <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h2 id="address-of-operator"><a href="#address-of-operator" class="header-anchor">#</a> Address-of Operator ( &amp; )</h2> <p>For any object (i.e, variable, array, union, struct, pointer or function) the unary address operator can be used to access the address of that object.</p> <p>Suppose that</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>              
<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>

</code></pre></div><p>So then a statement <code>p = &amp;i;</code>, copies the address of the variable <code>i</code> to the pointer <code>p</code>.</p> <p>It's expressed as <code>p</code> <strong><strong>points to</strong></strong> <code>i</code>.</p> <p><code>printf(&quot;%d\n&quot;, *p);</code> prints 1, which is the value of <code>i</code>.</p> <h2 id="pointer-arithmetic"><a href="#pointer-arithmetic" class="header-anchor">#</a> Pointer Arithmetic</h2> <p>Please see here: <a href="http://stackoverflow.com/documentation/c/256/operators/2205/pointer-arithmetic#t=201607261026480437786" target="_blank" rel="noopener noreferrer">Pointer Arithmetic<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="void-pointers-as-arguments-and-return-values-to-standard-functions"><a href="#void-pointers-as-arguments-and-return-values-to-standard-functions" class="header-anchor">#</a> void* pointers as arguments and return values to standard functions</h2> <p><code>void*</code> is a catch all type for pointers to object types. An example of this in use is with the <code>malloc</code> function, which is declared as</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>The pointer-to-void return type means that it is possible to assign the return value from <code>malloc</code> to a pointer to any other type of object:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span><span class="token operator">*</span> vector <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span> <span class="token operator">*</span>vector<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>It is generally considered good practice to <strong>not</strong> explicitly cast the values into and out of void pointers. In specific case of <code>malloc()</code> this is because with an explicit cast, the compiler may otherwise assume, but not warn about, an incorrect return type for <code>malloc()</code>, if you forget to include <code>stdlib.h</code>. It is also a case of using the correct behavior of void pointers to better conform to the DRY (don't repeat yourself) principle; compare the above to the following, wherein the following code contains several needless additional places where a typo could cause issues:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span><span class="token operator">*</span> vector <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>Similarly, functions such as</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">memcpy</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>restrict target<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token keyword">const</span> <span class="token operator">*</span>restrict source<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>have their arguments specified as <code>void *</code> because the address of any object, regardless of the type, can be passed in. Here also, a call should not use a cast</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">unsigned</span> <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">67</span><span class="token punctuation">;</span>
<span class="token function">memcpy</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token keyword">sizeof</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><h2 id="same-asterisk-different-meanings"><a href="#same-asterisk-different-meanings" class="header-anchor">#</a> Same Asterisk, Different Meanings</h2> <h3 id="premise"><a href="#premise" class="header-anchor">#</a> Premise</h3> <p>The most confusing thing surrounding pointer syntax in C and C++ is that there are actually two different meanings that apply when the pointer symbol, the asterisk (<code>*</code>), is used with a variable.</p> <h3 id="example"><a href="#example" class="header-anchor">#</a> Example</h3> <p>Firstly, you use <code>*</code> to <strong>declare</strong> a pointer variable.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token comment">/* 'p' is a pointer to an integer, initialized as NULL */</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token comment">/* '&amp;i' evaluates into address of 'i', which then assigned to 'p' */</span>
p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>
<span class="token comment">/* 'p' is now holding the address of 'i' */</span>

</code></pre></div><p>When you're not declaring (or multiplying), <code>*</code> is used to <strong>dereference</strong> a pointer variable:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token comment">/* 'p' was pointing to 'i', so this changes value of 'i' to 123 */</span>

</code></pre></div><p>When you want an existing pointer variable to hold address of other variable, you <strong>don't</strong> use <code>*</code>, but do it like this:</p> <div class="language-c extra-class"><pre class="language-c"><code>p <span class="token operator">=</span> <span class="token operator">&amp;</span>another_variable<span class="token punctuation">;</span>

</code></pre></div><p>A common confusion among C-programming newbies arises when they declare and initialize a pointer variable at the same time.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>

</code></pre></div><p>Since <code>int i = 5;</code> and <code>int i; i = 5;</code> give the same result, some of them might thought <code>int *p = &amp;i;</code> and <code>int *p; *p = &amp;i;</code> give the same result too. The fact is, no, <code>int *p; *p = &amp;i;</code> will attempt to deference an <strong>uninitialized</strong> pointer which will result in UB. Never use <code>*</code> when you're not declaring nor dereferencing a pointer.</p> <h3 id="conclusion"><a href="#conclusion" class="header-anchor">#</a> Conclusion</h3> <p>The asterisk (<code>*</code>) has two distinct meanings within C in relation to pointers, depending on where it's used. When used within a <strong>variable declaration</strong>, the value on the right hand side of the equals side should be a <strong><strong>pointer value</strong></strong> to an <strong><strong>address</strong></strong> in memory. When used with an already <strong>declared variable</strong>, the asterisk will <strong><strong>dereference</strong></strong> the pointer value, following it to the pointed-to place in memory, and allowing the value stored there to be assigned or retrieved.</p> <p>Takeaway</p> <p>It is important to mind your P's and Q's, so to speak, when dealing with pointers. Be mindful of when you're using the asterisk, and what it means when you use it there. Overlooking this tiny detail could result in buggy and/or undefined behavior that you really don't want to have to deal with.</p> <h2 id="pointer-to-pointer-2"><a href="#pointer-to-pointer-2" class="header-anchor">#</a> Pointer to Pointer</h2> <p>In C, a pointer can refer to another pointer.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> A <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span><span class="token operator">*</span> pA <span class="token operator">=</span> <span class="token operator">&amp;</span>A<span class="token punctuation">;</span>
  <span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">*</span> ppA <span class="token operator">=</span> <span class="token operator">&amp;</span>pA<span class="token punctuation">;</span>
  <span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> pppA <span class="token operator">=</span> <span class="token operator">&amp;</span>ppA<span class="token punctuation">;</span>

  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>pppA<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* prints 42 */</span>

  <span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>But, reference-and-reference directly is not allowed.</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> A <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span><span class="token operator">*</span> pA <span class="token operator">=</span> <span class="token operator">&amp;</span>A<span class="token punctuation">;</span>
  <span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">*</span> ppA <span class="token operator">=</span> <span class="token operator">&amp;&amp;</span>A<span class="token punctuation">;</span> <span class="token comment">/* Compilation error here! */</span>
  <span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span> pppA <span class="token operator">=</span> <span class="token operator">&amp;&amp;</span><span class="token operator">&amp;</span>A<span class="token punctuation">;</span>  <span class="token comment">/* Compilation error here! */</span>

  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

</code></pre></div><h4 id="syntax"><a href="#syntax" class="header-anchor">#</a> Syntax</h4> <ul><li><Data type=""> *<Variable name="">;
</Variable></Data></li> <li>int *ptrToInt;</li> <li>void <em>ptrToVoid; /</em> C89+ */</li> <li>struct someStruct *ptrToStruct;</li> <li>int **ptrToPtrToInt;</li> <li>int arr[length]; int <em>ptrToFirstElem = arr; /</em> For &lt;C99 'length' needs to be a compile time constant, for &gt;=C11 it might need to be one. */</li> <li>int <em>arrayOfPtrsToInt[length]; /</em> For &lt;C99 'length' needs to be a compile time constant, for &gt;=C11 it might need to be one. */</li></ul> <h4 id="remarks"><a href="#remarks" class="header-anchor">#</a> Remarks</h4> <p>The position of the asterisk does not affect the meaning of the definition:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">/* The * operator binds to right and therefore these are all equivalent. */</span>
<span class="token keyword">int</span> <span class="token operator">*</span>i<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span> i<span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">*</span> i<span class="token punctuation">;</span>

</code></pre></div><p>However, when defining multiple pointers at once, each requires its own asterisk:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token operator">*</span>i<span class="token punctuation">,</span> <span class="token operator">*</span>j<span class="token punctuation">;</span> <span class="token comment">/* i and j are both pointers */</span>
<span class="token keyword">int</span><span class="token operator">*</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>  <span class="token comment">/* i is a pointer, but j is an int not a pointer variable */</span>

</code></pre></div><p>An array of pointers is also possible, where an asterisk is given before the array variable's name:</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token operator">*</span>foo<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* foo is a array of pointers, can be accessed as *foo[0] and *foo[1] */</span>

</code></pre></div></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/devtut/generate/edit/master/docs/c/pointers.md" target="_blank" rel="noopener noreferrer">Edit this page on GitHub</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/c/formatted-input-output.html" class="prev">
        Formatted Input/Output
      </a></span> <span class="next"><a href="/c/sequence-points.html">
        Sequence points
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.1779e102.js" defer></script><script src="/assets/js/3.2cfa8016.js" defer></script><script src="/assets/js/588.18d1a88a.js" defer></script>
  </body>
</html>
