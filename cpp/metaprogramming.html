<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C++ | Metaprogramming</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="description" content="Calculating Factorials, Iterating over a parameter pack, Iterating with std::integer_sequence, Tag Dispatching, Detect Whether Expression is Valid, If-then-else, Calculating power with C++11 (and higher), Manual distinction of types when given any type T, Generic Min/Max with variable argument count">
    <meta property="og:site_name" content="DevTut">
    <meta property="og:title" content="C++ | Metaprogramming">
    <meta property="og:description" content="Calculating Factorials, Iterating over a parameter pack, Iterating with std::integer_sequence, Tag Dispatching, Detect Whether Expression is Valid, If-then-else, Calculating power with C++11 (and higher), Manual distinction of types when given any type T, Generic Min/Max with variable argument count">
    <meta property="og:type" content="article">
    <meta property="og:url" content="/cpp/metaprogramming.html">
    <meta property="og:image" content="/logo.png">
    <meta name="twitter:title" content="C++ | Metaprogramming">
    <meta name="twitter:description" content="Calculating Factorials, Iterating over a parameter pack, Iterating with std::integer_sequence, Tag Dispatching, Detect Whether Expression is Valid, If-then-else, Calculating power with C++11 (and higher), Manual distinction of types when given any type T, Generic Min/Max with variable argument count">
    <meta name="twitter:url" content="/cpp/metaprogramming.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="/logo.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/mstile-150x150.png">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="google-site-verification" content="76_rKXgwMVIjd-axJC_1zPV9OS4mEjvtgjYOWVkAdnQ">
    
    <link rel="preload" href="/assets/css/0.styles.60619e34.css" as="style"><link rel="preload" href="/assets/js/app.1779e102.js" as="script"><link rel="preload" href="/assets/js/3.2cfa8016.js" as="script"><link rel="preload" href="/assets/js/675.368a2d5f.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.60619e34.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">DevTut</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>C++</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/cpp/" aria-current="page" class="sidebar-link">Disclaimer</a></li><li><a href="/cpp/getting-started-with-cpp.html" class="sidebar-link">Getting started with C++</a></li><li><a href="/cpp/literals.html" class="sidebar-link">Literals</a></li><li><a href="/cpp/operator-precedence.html" class="sidebar-link">operator precedence</a></li><li><a href="/cpp/floating-point-arithmetic.html" class="sidebar-link">Floating Point Arithmetic</a></li><li><a href="/cpp/bit-operators.html" class="sidebar-link">Bit Operators</a></li><li><a href="/cpp/bit-manipulation.html" class="sidebar-link">Bit Manipulation</a></li><li><a href="/cpp/bit-fields.html" class="sidebar-link">Bit fields</a></li><li><a href="/cpp/arrays.html" class="sidebar-link">Arrays</a></li><li><a href="/cpp/iterators.html" class="sidebar-link">Iterators</a></li><li><a href="/cpp/basic-input-output-in-c.html" class="sidebar-link">Basic input/output in c++</a></li><li><a href="/cpp/loops.html" class="sidebar-link">Loops</a></li><li><a href="/cpp/file-i-o.html" class="sidebar-link">File I/O</a></li><li><a href="/cpp/cpp-streams.html" class="sidebar-link">C++ Streams</a></li><li><a href="/cpp/stream-manipulators.html" class="sidebar-link">Stream manipulators</a></li><li><a href="/cpp/flow-control.html" class="sidebar-link">Flow Control</a></li><li><a href="/cpp/metaprogramming.html" aria-current="page" class="active sidebar-link">Metaprogramming</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cpp/metaprogramming.html#calculating-factorials" class="sidebar-link">Calculating Factorials</a></li><li class="sidebar-sub-header"><a href="/cpp/metaprogramming.html#iterating-over-a-parameter-pack" class="sidebar-link">Iterating over a parameter pack</a></li><li class="sidebar-sub-header"><a href="/cpp/metaprogramming.html#iterating-with-std-integer-sequence" class="sidebar-link">Iterating with std::integer_sequence</a></li><li class="sidebar-sub-header"><a href="/cpp/metaprogramming.html#tag-dispatching" class="sidebar-link">Tag Dispatching</a></li><li class="sidebar-sub-header"><a href="/cpp/metaprogramming.html#detect-whether-expression-is-valid" class="sidebar-link">Detect Whether Expression is Valid</a></li><li class="sidebar-sub-header"><a href="/cpp/metaprogramming.html#if-then-else" class="sidebar-link">If-then-else</a></li><li class="sidebar-sub-header"><a href="/cpp/metaprogramming.html#calculating-power-with-c-11-and-higher" class="sidebar-link">Calculating power with C++11 (and higher)</a></li><li class="sidebar-sub-header"><a href="/cpp/metaprogramming.html#manual-distinction-of-types-when-given-any-type-t" class="sidebar-link">Manual distinction of types when given any type T</a></li><li class="sidebar-sub-header"><a href="/cpp/metaprogramming.html#generic-min-max-with-variable-argument-count" class="sidebar-link">Generic Min/Max with variable argument count</a></li></ul></li><li><a href="/cpp/const-keyword.html" class="sidebar-link">const keyword</a></li><li><a href="/cpp/mutable-keyword.html" class="sidebar-link">mutable keyword</a></li><li><a href="/cpp/friend-keyword.html" class="sidebar-link">Friend keyword</a></li><li><a href="/cpp/type-keywords.html" class="sidebar-link">Type Keywords</a></li><li><a href="/cpp/basic-type-keywords.html" class="sidebar-link">Basic Type Keywords</a></li><li><a href="/cpp/variable-declaration-keywords.html" class="sidebar-link">Variable Declaration Keywords</a></li><li><a href="/cpp/keywords.html" class="sidebar-link">Keywords</a></li><li><a href="/cpp/returning-several-values-from-a-function.html" class="sidebar-link">Returning several values from a function</a></li><li><a href="/cpp/polymorphism.html" class="sidebar-link">Polymorphism</a></li><li><a href="/cpp/references.html" class="sidebar-link">References</a></li><li><a href="/cpp/value-and-reference-semantics.html" class="sidebar-link">Value and Reference Semantics</a></li><li><a href="/cpp/c-function-call-by-value-vs-call-by-reference.html" class="sidebar-link">C++ function &quot;call by value&quot; vs. &quot;call by reference&quot;</a></li><li><a href="/cpp/copying-vs-assignment.html" class="sidebar-link">Copying vs Assignment</a></li><li><a href="/cpp/pointers.html" class="sidebar-link">Pointers</a></li><li><a href="/cpp/pointers-to-members.html" class="sidebar-link">Pointers to members</a></li><li><a href="/cpp/the-this-pointer.html" class="sidebar-link">The This Pointer</a></li><li><a href="/cpp/smart-pointers.html" class="sidebar-link">Smart Pointers</a></li><li><a href="/cpp/classes-structures.html" class="sidebar-link">Classes/Structures</a></li><li><a href="/cpp/function-overloading.html" class="sidebar-link">Function Overloading</a></li><li><a href="/cpp/operator-overloading.html" class="sidebar-link">Operator Overloading</a></li><li><a href="/cpp/function-template-overloading.html" class="sidebar-link">Function Template Overloading</a></li><li><a href="/cpp/virtual-member-functions.html" class="sidebar-link">Virtual Member Functions</a></li><li><a href="/cpp/inline-functions.html" class="sidebar-link">Inline functions</a></li><li><a href="/cpp/special-member-functions.html" class="sidebar-link">Special Member Functions</a></li><li><a href="/cpp/non-static-member-functions.html" class="sidebar-link">Non-Static Member Functions</a></li><li><a href="/cpp/constant-class-member-functions.html" class="sidebar-link">Constant class member functions</a></li><li><a href="/cpp/c-containers.html" class="sidebar-link">C++ Containers</a></li><li><a href="/cpp/namespaces.html" class="sidebar-link">Namespaces</a></li><li><a href="/cpp/header-files.html" class="sidebar-link">Header Files</a></li><li><a href="/cpp/using-declaration.html" class="sidebar-link">Using declaration</a></li><li><a href="/cpp/std-string.html" class="sidebar-link">std::string</a></li><li><a href="/cpp/std-array.html" class="sidebar-link">std::array</a></li><li><a href="/cpp/std-vector.html" class="sidebar-link">std::vector</a></li><li><a href="/cpp/std-map.html" class="sidebar-link">std::map</a></li><li><a href="/cpp/std-optional.html" class="sidebar-link">std::optional</a></li><li><a href="/cpp/std-function-to-wrap-any-element-that-is-callable.html" class="sidebar-link">std::function: To wrap any element that is callable</a></li><li><a href="/cpp/std-forward-list.html" class="sidebar-link">std::forward_list</a></li><li><a href="/cpp/std-pair.html" class="sidebar-link">std::pair</a></li><li><a href="/cpp/std-atomics.html" class="sidebar-link">std::atomics</a></li><li><a href="/cpp/std-variant.html" class="sidebar-link">std::variant</a></li><li><a href="/cpp/std-iomanip.html" class="sidebar-link">std::iomanip</a></li><li><a href="/cpp/std-any.html" class="sidebar-link">std::any</a></li><li><a href="/cpp/std-set-and-std-multiset.html" class="sidebar-link">std::set and std::multiset</a></li><li><a href="/cpp/std-integer-sequence.html" class="sidebar-link">std::integer_sequence</a></li><li><a href="/cpp/using-std-unordered-map.html" class="sidebar-link">Using std::unordered_map</a></li><li><a href="/cpp/standard-library-algorithms.html" class="sidebar-link">Standard Library Algorithms</a></li><li><a href="/cpp/the-iso-c-standard.html" class="sidebar-link">The ISO C++ Standard</a></li><li><a href="/cpp/inline-variables.html" class="sidebar-link">Inline variables</a></li><li><a href="/cpp/random-number-generation.html" class="sidebar-link">Random number generation</a></li><li><a href="/cpp/date-and-time-using-chrono-header.html" class="sidebar-link">Date and time using  header</a></li><li><a href="/cpp/sorting.html" class="sidebar-link">Sorting</a></li><li><a href="/cpp/enumeration.html" class="sidebar-link">Enumeration</a></li><li><a href="/cpp/iteration.html" class="sidebar-link">Iteration</a></li><li><a href="/cpp/regular-expressions.html" class="sidebar-link">Regular expressions</a></li><li><a href="/cpp/implementation-defined-behavior.html" class="sidebar-link">Implementation-defined behavior</a></li><li><a href="/cpp/exceptions.html" class="sidebar-link">Exceptions</a></li><li><a href="/cpp/lambdas.html" class="sidebar-link">Lambdas</a></li><li><a href="/cpp/value-categories.html" class="sidebar-link">Value Categories</a></li><li><a href="/cpp/preprocessor.html" class="sidebar-link">Preprocessor</a></li><li><a href="/cpp/data-structures-in-c.html" class="sidebar-link">Data Structures in C++</a></li><li><a href="/cpp/templates.html" class="sidebar-link">Templates</a></li><li><a href="/cpp/expression-templates.html" class="sidebar-link">Expression templates</a></li><li><a href="/cpp/curiously-recurring-template-pattern-crtp.html" class="sidebar-link">Curiously Recurring Template Pattern (CRTP)</a></li><li><a href="/cpp/threading.html" class="sidebar-link">Threading</a></li><li><a href="/cpp/thread-synchronization-structures.html" class="sidebar-link">Thread synchronization structures</a></li><li><a href="/cpp/the-rule-of-three-five-and-zero.html" class="sidebar-link">The Rule of Three, Five, And Zero</a></li><li><a href="/cpp/raii-resource-acquisition-is-initialization.html" class="sidebar-link">RAII: Resource Acquisition Is Initialization</a></li><li><a href="/cpp/rtti-run-time-type-information.html" class="sidebar-link">RTTI: Run-Time Type Information</a></li><li><a href="/cpp/mutexes.html" class="sidebar-link">Mutexes</a></li><li><a href="/cpp/recursive-mutex.html" class="sidebar-link">Recursive Mutex</a></li><li><a href="/cpp/semaphore.html" class="sidebar-link">Semaphore</a></li><li><a href="/cpp/futures-and-promises.html" class="sidebar-link">Futures and Promises</a></li><li><a href="/cpp/atomic-types.html" class="sidebar-link">Atomic Types</a></li><li><a href="/cpp/type-erasure.html" class="sidebar-link">Type Erasure</a></li><li><a href="/cpp/explicit-type-conversions.html" class="sidebar-link">Explicit type conversions</a></li><li><a href="/cpp/unnamed-types.html" class="sidebar-link">Unnamed types</a></li><li><a href="/cpp/type-traits.html" class="sidebar-link">Type Traits</a></li><li><a href="/cpp/return-type-covariance.html" class="sidebar-link">Return Type Covariance</a></li><li><a href="/cpp/layout-of-object-types.html" class="sidebar-link">Layout of object types</a></li><li><a href="/cpp/type-inference.html" class="sidebar-link">Type Inference</a></li><li><a href="/cpp/typedef-and-type-aliases.html" class="sidebar-link">Typedef and type aliases</a></li><li><a href="/cpp/type-deduction.html" class="sidebar-link">type deduction</a></li><li><a href="/cpp/trailing-return-type.html" class="sidebar-link">Trailing return type</a></li><li><a href="/cpp/alignment.html" class="sidebar-link">Alignment</a></li><li><a href="/cpp/perfect-forwarding.html" class="sidebar-link">Perfect Forwarding</a></li><li><a href="/cpp/decltype.html" class="sidebar-link">decltype</a></li><li><a href="/cpp/sfinae-substitution-failure-is-not-an-error.html" class="sidebar-link">SFINAE (Substitution Failure Is Not An Error)</a></li><li><a href="/cpp/undefined-behavior.html" class="sidebar-link">Undefined Behavior</a></li><li><a href="/cpp/overload-resolution.html" class="sidebar-link">Overload resolution</a></li><li><a href="/cpp/move-semantics.html" class="sidebar-link">Move Semantics</a></li><li><a href="/cpp/pimpl-idiom.html" class="sidebar-link">Pimpl Idiom</a></li><li><a href="/cpp/auto.html" class="sidebar-link">auto</a></li><li><a href="/cpp/copy-elision.html" class="sidebar-link">Copy Elision</a></li><li><a href="/cpp/fold-expressions.html" class="sidebar-link">Fold Expressions</a></li><li><a href="/cpp/unions.html" class="sidebar-link">Unions</a></li><li><a href="/cpp/design-pattern-implementation-in-c.html" class="sidebar-link">Design pattern implementation in C++</a></li><li><a href="/cpp/singleton-design-pattern.html" class="sidebar-link">Singleton Design Pattern</a></li><li><a href="/cpp/user-defined-literals.html" class="sidebar-link">User-Defined Literals</a></li><li><a href="/cpp/memory-management.html" class="sidebar-link">Memory management</a></li><li><a href="/cpp/c-11-memory-model.html" class="sidebar-link">C++11 Memory Model</a></li><li><a href="/cpp/scopes.html" class="sidebar-link">Scopes</a></li><li><a href="/cpp/static-assert.html" class="sidebar-link">static_assert</a></li><li><a href="/cpp/constexpr.html" class="sidebar-link">constexpr</a></li><li><a href="/cpp/one-definition-rule-odr.html" class="sidebar-link">One Definition Rule (ODR)</a></li><li><a href="/cpp/unspecified-behavior.html" class="sidebar-link">Unspecified behavior</a></li><li><a href="/cpp/argument-dependent-name-lookup.html" class="sidebar-link">Argument Dependent Name Lookup</a></li><li><a href="/cpp/attributes.html" class="sidebar-link">Attributes</a></li><li><a href="/cpp/recursion-in-c.html" class="sidebar-link">Recursion in C++</a></li><li><a href="/cpp/arithmitic-metaprogramming.html" class="sidebar-link">Arithmitic Metaprogramming</a></li><li><a href="/cpp/callable-objects.html" class="sidebar-link">Callable Objects</a></li><li><a href="/cpp/client-server-examples.html" class="sidebar-link">Client server examples</a></li><li><a href="/cpp/const-correctness.html" class="sidebar-link">Const Correctness</a></li><li><a href="/cpp/parameter-packs.html" class="sidebar-link">Parameter packs</a></li><li><a href="/cpp/build-systems.html" class="sidebar-link">Build Systems</a></li><li><a href="/cpp/concurrency-with-openmp.html" class="sidebar-link">Concurrency With OpenMP</a></li><li><a href="/cpp/resource-management.html" class="sidebar-link">Resource Management</a></li><li><a href="/cpp/storage-class-specifiers.html" class="sidebar-link">Storage class specifiers</a></li><li><a href="/cpp/linkage-specifications.html" class="sidebar-link">Linkage specifications</a></li><li><a href="/cpp/digit-separators.html" class="sidebar-link">Digit separators</a></li><li><a href="/cpp/c-incompatibilities.html" class="sidebar-link">C incompatibilities</a></li><li><a href="/cpp/side-by-side-comparisons-of-classic-c-examples-solved-via-c-vs-c-11-vs-c-14-vs-c-17.html" class="sidebar-link">Side by Side Comparisons of classic C++ examples solved via C++ vs C++11 vs C++14 vs C++17</a></li><li><a href="/cpp/compiling-and-building.html" class="sidebar-link">Compiling and Building</a></li><li><a href="/cpp/common-compile-linker-errors-gcc.html" class="sidebar-link">Common compile/linker errors (GCC)</a></li><li><a href="/cpp/more-undefined-behaviors-in-c.html" class="sidebar-link">More undefined behaviors in C++</a></li><li><a href="/cpp/unit-testing-in-c.html" class="sidebar-link">Unit Testing in C++</a></li><li><a href="/cpp/c-debugging-and-debug-prevention-tools-techniques.html" class="sidebar-link">C++ Debugging and Debug-prevention Tools &amp; Techniques</a></li><li><a href="/cpp/optimization-in-c.html" class="sidebar-link">Optimization in C++</a></li><li><a href="/cpp/optimization.html" class="sidebar-link">Optimization</a></li><li><a href="/cpp/profiling.html" class="sidebar-link">Profiling</a></li><li><a href="/cpp/refactoring-techniques.html" class="sidebar-link">Refactoring Techniques</a></li><li><a href="/cpp/internationalization-in-c.html" class="sidebar-link">Internationalization in C++</a></li><li><a href="/cpp/contributors.html" class="sidebar-link">The Contributors</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="metaprogramming"><a href="#metaprogramming" class="header-anchor">#</a> Metaprogramming</h1> <p>In C++ Metaprogramming refers to the use of macros or templates to generate code at compile-time.</p> <p>In general, macros are frowned upon in this role and templates are preferred, although they are not as generic.</p> <p>Template metaprogramming often makes use of compile-time computations, whether via templates or <code>constexpr</code> functions, to achieve its goals of generating code, however compile-time computations are not metaprogramming per se.</p> <h2 id="calculating-factorials"><a href="#calculating-factorials" class="header-anchor">#</a> Calculating Factorials</h2> <p>Factorials can be computed at compile-time using template metaprogramming techniques.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> n<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">factorial</span>
<span class="token punctuation">{</span>
    <span class="token keyword">enum</span>
    <span class="token punctuation">{</span>
        value <span class="token operator">=</span> n <span class="token operator">*</span> factorial<span class="token operator">&lt;</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">factorial</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
    <span class="token keyword">enum</span> <span class="token punctuation">{</span> value <span class="token operator">=</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> factorial<span class="token operator">&lt;</span><span class="token number">7</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token comment">// prints &quot;5040&quot;</span>
<span class="token punctuation">}</span>

</code></pre></div><p><code>factorial</code> is a struct, but in template metaprogramming it is treated as a template metafunction. By convention, template metafunctions are evaluated by checking a particular member, either <code>::type</code> for metafunctions that result in types, or <code>::value</code> for metafunctions that generate values.</p> <p>In the above code, we evaluate the <code>factorial</code> metafunction by instantiating the template with the parameters we want to pass, and using <code>::value</code> to get the result of the evaluation.</p> <p>The metafunction itself relies on recursively instantiating the same metafunction with smaller values. The <code>factorial&lt;0&gt;</code> specialization represents the terminating condition. Template metaprogramming has most of the restrictions of a <a href="https://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="noopener noreferrer">functional programming language<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, so recursion is the primary &quot;looping&quot; construct.</p> <p>Since template metafunctions execute at compile time, their results can be used in contexts that require compile-time values. For example:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> my_array<span class="token punctuation">[</span>factorial<span class="token operator">&lt;</span><span class="token number">5</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">]</span><span class="token punctuation">;</span>

</code></pre></div><p>Automatic arrays must have a compile-time defined size. And the result of a metafunction is a compile-time constant, so it can be used here.</p> <p><strong>Limitation</strong>: Most of the compilers won't allow recursion depth beyond a limit. For example, <code>g++</code> compiler by default limits recursion depeth to 256 levels. In case of <code>g++</code>, programmer can set recursion depth using <code>-ftemplate-depth-X</code> option.</p> <p>Since C++11, the <code>std::integral_constant</code> template can be used for this kind of template computation:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;type_traits&gt;</span></span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span> n<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">factorial</span> <span class="token operator">:</span>
  <span class="token base-clause">std<span class="token double-colon punctuation">::</span><span class="token class-name">integral_constant</span><span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token class-name">n</span> <span class="token operator">*</span> <span class="token class-name">factorial</span><span class="token operator">&lt;</span><span class="token class-name">n</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token class-name">value</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">factorial</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">&gt;</span> <span class="token operator">:</span>
  std<span class="token double-colon punctuation">::</span>integral_constant<span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> factorial<span class="token operator">&lt;</span><span class="token number">7</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>    <span class="token comment">// prints &quot;5040&quot;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Additionally, <code>constexpr</code> functions become a cleaner alternative.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">constexpr</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> n <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">char</span> test<span class="token punctuation">[</span><span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>The body of <code>factorial()</code> is written as a single statement because in C++11 <code>constexpr</code> functions can only use a quite limited subset of the language.</p> <p>Since C++14, many restrictions for <code>constexpr</code> functions have been dropped and they can now be written much more conveniently:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">constexpr</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">else</span>
    <span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Or even:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">constexpr</span> <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">long</span> <span class="token keyword">long</span> result <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    result <span class="token operator">*=</span> i<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Since c++17 one can use fold expression to calculate factorial:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;utility&gt;</span></span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> T N<span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">I</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>make_integer_sequence<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> N<span class="token operator">&gt;&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">factorial</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> T N<span class="token punctuation">,</span> T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Is<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">factorial</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span>N<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>index_sequence<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Is<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;&gt;</span> <span class="token punctuation">{</span>
   <span class="token keyword">static</span> <span class="token keyword">constexpr</span> T value <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">(</span>Is <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> factorial<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h2 id="iterating-over-a-parameter-pack"><a href="#iterating-over-a-parameter-pack" class="header-anchor">#</a> Iterating over a parameter pack</h2> <p>Often, we need to perform an operation over every element in a variadic template parameter pack. There are many ways to do this, and the solutions get easier to read and write with C++17. Suppose we simply want to print every element in a pack. The simplest solution is to recurse:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">print_all</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream<span class="token operator">&amp;</span> os<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// base case</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">print_all</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream<span class="token operator">&amp;</span> os<span class="token punctuation">,</span> T <span class="token keyword">const</span><span class="token operator">&amp;</span> first<span class="token punctuation">,</span> Ts <span class="token keyword">const</span><span class="token operator">&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> rest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    os <span class="token operator">&lt;&lt;</span> first<span class="token punctuation">;</span>
    
    <span class="token function">print_all</span><span class="token punctuation">(</span>os<span class="token punctuation">,</span> rest<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>We could instead use the expander trick, to perform all the streaming in a single function. This has the advantage of not needing a second overload, but has the disadvantage of less than stellar readability:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">print_all</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream<span class="token operator">&amp;</span> os<span class="token punctuation">,</span> Ts <span class="token keyword">const</span><span class="token operator">&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">using</span> expander <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>expander<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">(</span>os <span class="token operator">&lt;&lt;</span> args<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>For an explanation of how this works, see <a href="http://stackoverflow.com/a/25683817/2069064" target="_blank" rel="noopener noreferrer">T.C's excellent answer<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <p>With C++17, we get two powerful new tools in our arsenal for solving this problem. The first is a fold-expression:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">print_all</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream<span class="token operator">&amp;</span> os<span class="token punctuation">,</span> Ts <span class="token keyword">const</span><span class="token operator">&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">(</span><span class="token punctuation">(</span>os <span class="token operator">&lt;&lt;</span> args<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>And the second is <code>if constexpr</code>, which allows us to write our original recursive solution in a single function:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ts<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">print_all</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ostream<span class="token operator">&amp;</span> os<span class="token punctuation">,</span> T <span class="token keyword">const</span><span class="token operator">&amp;</span> first<span class="token punctuation">,</span> Ts <span class="token keyword">const</span><span class="token operator">&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> rest<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    os <span class="token operator">&lt;&lt;</span> first<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token keyword">constexpr</span> <span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>rest<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        
        <span class="token comment">// this line will only be instantiated if there are further</span>
        <span class="token comment">// arguments. if rest... is empty, there will be no call to</span>
        <span class="token comment">// print_all(os). </span>
        <span class="token function">print_all</span><span class="token punctuation">(</span>os<span class="token punctuation">,</span> rest<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><h2 id="iterating-with-std-integer-sequence"><a href="#iterating-with-std-integer-sequence" class="header-anchor">#</a> Iterating with std::integer_sequence</h2> <p>Since C++14, the standard provides the class template</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ints<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">integer_sequence</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Ints<span class="token operator">&gt;</span>
<span class="token keyword">using</span> index_sequence <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>integer_sequence<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">,</span> Ints<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

</code></pre></div><p>and a generating metafunction for it:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> T N<span class="token operator">&gt;</span>
<span class="token keyword">using</span> make_integer_sequence <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>integer_sequence<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token comment">/* a sequence 0, 1, 2, ..., N-1 */</span> <span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>size_t N<span class="token operator">&gt;</span>
<span class="token keyword">using</span> make_index_sequence <span class="token operator">=</span> make_integer_sequence<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">,</span> N<span class="token operator">&gt;</span><span class="token punctuation">;</span>

</code></pre></div><p>While this comes standard in C++14, this can be implemented using C++11 tools.</p> <p>We can use this tool to call a function with a <code>std::tuple</code> of arguments (standardized in C++17 as <code>std::apply</code>):</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">namespace</span> detail <span class="token punctuation">{</span>
    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">F</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Tuple</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Is<span class="token operator">&gt;</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token function">apply_impl</span><span class="token punctuation">(</span>F<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">,</span> Tuple<span class="token operator">&amp;&amp;</span> tpl<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>index_sequence<span class="token operator">&lt;</span>Is<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>F<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span>Is<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>Tuple<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>tpl<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">F</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Tuple</span><span class="token operator">&gt;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token function">apply</span><span class="token punctuation">(</span>F<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">,</span> Tuple<span class="token operator">&amp;&amp;</span> tpl<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> detail<span class="token double-colon punctuation">::</span><span class="token function">apply_impl</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>F<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span>
        std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>Tuple<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>tpl<span class="token punctuation">)</span><span class="token punctuation">,</span>
        std<span class="token double-colon punctuation">::</span>make_index_sequence<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>tuple_size<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>decay_t<span class="token operator">&lt;</span>Tuple<span class="token operator">&gt;&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token comment">// this will print 3</span>
<span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">auto</span> some_args <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">make_tuple</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">,</span> <span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> r <span class="token operator">=</span> <span class="token function">apply</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> some_args<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// calls f(42, 'x', 3.14)</span>

</code></pre></div><h2 id="tag-dispatching"><a href="#tag-dispatching" class="header-anchor">#</a> Tag Dispatching</h2> <p>A simple way of selecting between functions at compile time is to dispatch a function to an overloaded pair of functions that take a tag as one (usually the last) argument. For example, to implement <code>std::advance()</code>, we can dispatch on the iterator category:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">namespace</span> details <span class="token punctuation">{</span>
    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RAIter</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span><span class="token operator">&gt;</span>
    <span class="token keyword">void</span> <span class="token function">advance</span><span class="token punctuation">(</span>RAIter<span class="token operator">&amp;</span> it<span class="token punctuation">,</span> Distance n<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>random_access_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        it <span class="token operator">+=</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BidirIter</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span><span class="token operator">&gt;</span>
    <span class="token keyword">void</span> <span class="token function">advance</span><span class="token punctuation">(</span>BidirIter<span class="token operator">&amp;</span> it<span class="token punctuation">,</span> Distance n<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>bidirectional_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token operator">++</span>it<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">--</span>it<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">InputIter</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span><span class="token operator">&gt;</span>
    <span class="token keyword">void</span> <span class="token function">advance</span><span class="token punctuation">(</span>InputIter<span class="token operator">&amp;</span> it<span class="token punctuation">,</span> Distance n<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>input_iterator_tag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token operator">++</span>it<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>    
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Iter</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Distance</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">advance</span><span class="token punctuation">(</span>Iter<span class="token operator">&amp;</span> it<span class="token punctuation">,</span> Distance n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    details<span class="token double-colon punctuation">::</span><span class="token function">advance</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> n<span class="token punctuation">,</span> 
            <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>iterator_traits<span class="token operator">&lt;</span>Iter<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator_category<span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>The <code>std::XY_iterator_tag</code> arguments of the overloaded <code>details::advance</code> functions are unused function parameters. The actual implementation does not matter (actually it is completely empty). Their only purpose is to allow the compiler to select an overload based on which tag class <code>details::advance</code> is called with.</p> <p>In this example, <code>advance</code> uses the <code>iterator_traits&lt;T&gt;::iterator_category</code> metafunction which returns one of the <code>iterator_tag</code> classes, depending on the actual type of <code>Iter</code>. A default-constructed object of the <code>iterator_category&lt;Iter&gt;::type</code> then lets the compiler select one of the different overloads of <code>details::advance</code>.
(This function parameter is likely to be completely optimized away, as it is a default-constructed object of an empty <code>struct</code> and never used.)</p> <p>Tag dispatching can give you code that's much easier to read than the equivalents using SFINAE and <code>enable_if</code>.</p> <p><strong>Note: while C++17's <code>if constexpr</code> may simplify the implementation of <code>advance</code> in particular, it is not suitable for open implementations unlike tag dispatching.</strong></p> <h2 id="detect-whether-expression-is-valid"><a href="#detect-whether-expression-is-valid" class="header-anchor">#</a> Detect Whether Expression is Valid</h2> <p>It is possible to detect whether an operator or function can be called on a type. To test if a class has an overload of <code>std::hash</code>, one can do this:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span> <span class="token comment">// for std::hash</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;type_traits&gt;</span> <span class="token comment">// for std::false_type and std::true_type</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;utility&gt;</span> <span class="token comment">// for std::declval</span></span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token operator">=</span> <span class="token keyword">void</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">has_hash</span>
    <span class="token operator">:</span> <span class="token base-clause">std<span class="token double-colon punctuation">::</span><span class="token class-name">false_type</span></span>
<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">has_hash</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">hash</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">declval</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&gt;</span>
    <span class="token operator">:</span> std<span class="token double-colon punctuation">::</span>true_type
<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>Since C++17, <code>std::void_t</code> can be used to simplify this type of construct</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span> <span class="token comment">// for std::hash</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;type_traits&gt;</span> <span class="token comment">// for std::false_type, std::true_type, std::void_t</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;utility&gt;</span> <span class="token comment">// for std::declval</span></span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>void_t<span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">has_hash</span>
    <span class="token operator">:</span> <span class="token base-clause">std<span class="token double-colon punctuation">::</span><span class="token class-name">false_type</span></span>
<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">has_hash</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>void_t<span class="token operator">&lt;</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">hash</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">declval</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token operator">&gt;</span>
    <span class="token operator">:</span> std<span class="token double-colon punctuation">::</span>true_type
<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>where <code>std::void_t</code> is defined as:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">&gt;</span> <span class="token keyword">using</span> void_t <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">;</span>

</code></pre></div><p>For detecting if an operator, such as <code>operator&lt;</code> is defined, the syntax is almost the same:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token operator">=</span> <span class="token keyword">void</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">has_less_than</span>
    <span class="token operator">:</span> <span class="token base-clause">std<span class="token double-colon punctuation">::</span><span class="token class-name">false_type</span></span>
<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">has_less_than</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">declval</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">declval</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&gt;</span>
    <span class="token operator">:</span> std<span class="token double-colon punctuation">::</span>true_type
<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>These can be used to use a <code>std::unordered_map&lt;T&gt;</code> if <code>T</code> has an overload for <code>std::hash</code>, but otherwise attempt to use a <code>std::map&lt;T&gt;</code>:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">V</span><span class="token operator">&gt;</span>
<span class="token keyword">using</span> hash_invariant_map <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>conditional_t<span class="token operator">&lt;</span>
    has_hash<span class="token operator">&lt;</span>K<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">,</span>
    std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">&gt;</span><span class="token punctuation">,</span>
    std<span class="token double-colon punctuation">::</span>map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>    

</code></pre></div><h2 id="if-then-else"><a href="#if-then-else" class="header-anchor">#</a> If-then-else</h2> <p>The type <code>std::conditional</code> in the standard library header <code>&lt;type_traits&gt;</code> can select one type or the other, based on a compile-time boolean value:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">ValueOrPointer</span>
<span class="token punctuation">{</span>
    <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>conditional<span class="token operator">&lt;</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> T<span class="token operator">*</span><span class="token punctuation">,</span> T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type vop<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>This struct contains a pointer to <code>T</code> if <code>T</code> is larger than the size of a pointer, or <code>T</code> itself if it is smaller or equal to a pointer's size. Therefore <code>sizeof(ValueOrPointer)</code> will always be &lt;= <code>sizeof(void*)</code>.</p> <h2 id="calculating-power-with-c-11-and-higher"><a href="#calculating-power-with-c-11-and-higher" class="header-anchor">#</a> Calculating power with C++11 (and higher)</h2> <p>With C++11 and higher calculations at compile time can be much easier. For example calculating the power of a given number at compile time will be following:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">constexpr</span> T <span class="token function">calculatePower</span><span class="token punctuation">(</span>T value<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> power<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> power <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> value <span class="token operator">*</span> <span class="token function">calculatePower</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> power<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Keyword <code>constexpr</code> is responsible for calculating function in compilation time, then and only then, when all the requirements for this will be met (see more at constexpr keyword reference) for example all the arguments must be known at compile time.</p> <p>Note: In C++11 <code>constexpr</code> function must compose only from one return statement.</p> <p>Advantages: Comparing this to the standard way of compile time calculation, this method is also useful for runtime calculations. It means, that if the arguments of the function are not known at the compilation time (e.g. value and power are given as input via user), then function is run in a compilation time, so there's no need to duplicate a code (as we would be forced in older standards of C++).</p> <p>E.g.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">useExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">int</span> compileTimeCalculated <span class="token operator">=</span> <span class="token function">calculatePower</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// computes at compile time,</span>
                               <span class="token comment">// as both arguments are known at compilation time</span>
                               <span class="token comment">// and used for a constant expression.</span>
    <span class="token keyword">int</span> value<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cin <span class="token operator">&gt;&gt;</span> value<span class="token punctuation">;</span>
    <span class="token keyword">int</span> runtimeCalculated <span class="token operator">=</span> <span class="token function">calculatePower</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// runtime calculated,</span>
                                    <span class="token comment">// because value is known only at runtime.</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Another way to calculate power at compile time can make use of fold expression as follows:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;utility&gt;</span></span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> T V<span class="token punctuation">,</span> T N<span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">I</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>make_integer_sequence<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> N<span class="token operator">&gt;&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">power</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> T V<span class="token punctuation">,</span> T N<span class="token punctuation">,</span> T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Is<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">power</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> V<span class="token punctuation">,</span> N<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>integer_sequence<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Is<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;&gt;</span> <span class="token punctuation">{</span>
   <span class="token keyword">static</span> <span class="token keyword">constexpr</span> T value <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">*</span> <span class="token punctuation">(</span>V <span class="token operator">*</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>Is <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> power<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h2 id="manual-distinction-of-types-when-given-any-type-t"><a href="#manual-distinction-of-types-when-given-any-type-t" class="header-anchor">#</a> Manual distinction of types when given any type T</h2> <p>When implementing <a href="http://stackoverflow.com/documentation/c%2b%2b/1169/sfinae-substitution-failure-is-not-an-error#t=201607250635342308267" target="_blank" rel="noopener noreferrer">SFINAE<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> using <a href="http://stackoverflow.com/documentation/c%2b%2b/1169/sfinae-substitution-failure-is-not-an-error/3777/enable-if" target="_blank" rel="noopener noreferrer"><code>std::enable_if</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, it is often useful to have access to helper templates that determines if a given type <code>T</code> matches a set of criteria.</p> <p>To help us with that, the standard already provides two types analog to <code>true</code> and <code>false</code> which are <code>std::true_type</code> and <code>std::false_type</code>.</p> <p>The following example show how to detect if a type <code>T</code> is a pointer or not, the <code>is_pointer</code> template mimic the behavior of the standard <code>std::is_pointer</code> helper:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">is_pointer_</span><span class="token operator">:</span> <span class="token base-clause">std<span class="token double-colon punctuation">::</span><span class="token class-name">false_type</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">is_pointer_</span><span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token operator">&gt;</span><span class="token operator">:</span> std<span class="token double-colon punctuation">::</span>true_type <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">is_pointer</span><span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">is_pointer_</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> std<span class="token double-colon punctuation">::</span><span class="token class-name">remove_cv</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token class-name">type</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>

</code></pre></div><p>There are three steps in the above code (sometimes you only need two):</p> <li>
The first declaration of `is_pointer_` is the **default case**, and inherits from `std::false_type`. The **default** case should always inherit from `std::false_type` since it is analogous to a &quot;`false` condition&quot;.
</li> <li>
The second declaration specialize the `is_pointer_` template for pointer `T*` without caring about what `T` is really. This version inherits from `std::true_type`.
</li> <li>
The third declaration (the real one) simply remove any unnecessary information from `T` (in this case we remove `const` and `volatile` qualifiers) and then fall backs to one of the two previous declarations.
</li> <p>Since <code>is_pointer&lt;T&gt;</code> is a class, to access its value you need to either:</p> <ul><li>Use <code>::value</code>, e.g. <code>is_pointer&lt;int&gt;::value</code> – <code>value</code> is a static class member of type <code>bool</code> inherited from <code>std::true_type</code> or <code>std::false_type</code>;</li> <li>Construct an object of this type, e.g. <code>is_pointer&lt;int&gt;{}</code> – This works because <code>std::is_pointer</code> inherits its default constructor from <code>std::true_type</code> or <code>std::false_type</code> (which have <code>constexpr</code> constructors) and both <code>std::true_type</code> and <code>std::false_type</code> have <code>constexpr</code> conversion operators to <code>bool</code>.</li></ul> <p>It is a good habit to provides &quot;helper helper templates&quot; that let you directly access the value:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">constexpr</span> <span class="token keyword">bool</span> is_pointer_v <span class="token operator">=</span> is_pointer<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">;</span>

</code></pre></div><p>In C++17 and above, most helper templates already provide a <code>_v</code> version, e.g.:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">&gt;</span> <span class="token keyword">constexpr</span> <span class="token keyword">bool</span> is_pointer_v <span class="token operator">=</span> is_pointer<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">&gt;</span> <span class="token keyword">constexpr</span> <span class="token keyword">bool</span> is_reference_v <span class="token operator">=</span> is_reference<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">;</span>

</code></pre></div><h2 id="generic-min-max-with-variable-argument-count"><a href="#generic-min-max-with-variable-argument-count" class="header-anchor">#</a> Generic Min/Max with variable argument count</h2> <p>It's possible to write a generic function (for example <code>min</code>) which accepts various numerical types and arbitrary argument count by template meta-programming. This function declares a <code>min</code> for two arguments and recursively for more.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T2</span><span class="token operator">&gt;</span>
<span class="token keyword">auto</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token keyword">const</span> T1 <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> T2 <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> 
<span class="token operator">-&gt;</span> <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>common_type<span class="token operator">&lt;</span><span class="token keyword">const</span> T1<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> T2<span class="token operator">&amp;</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">&lt;</span> b <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T2</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">&gt;</span>
<span class="token keyword">auto</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token keyword">const</span> T1 <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> T2 <span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token keyword">const</span> Args<span class="token operator">&amp;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span>
<span class="token operator">-&gt;</span> <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>common_type<span class="token operator">&lt;</span><span class="token keyword">const</span> T1<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> T2<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> Args<span class="token operator">&amp;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token function">min</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">auto</span> minimum <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5.8f</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1.8</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1.1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><h4 id="remarks"><a href="#remarks" class="header-anchor">#</a> Remarks</h4> <p>Metaprogramming (or more specifically, Template Metaprogramming) is the practice of using <a href="http://stackoverflow.com/documentation/c%2B%2B/460/templates/3999/basic-class-template#t=201607281319383275025" target="_blank" rel="noopener noreferrer">templates<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> to create constants, functions, or data structures at compile-time. This allows computations to be performed once at compile time rather than at each run time.</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/devtut/generate/edit/master/docs/cpp/metaprogramming.md" target="_blank" rel="noopener noreferrer">Edit this page on GitHub</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/cpp/flow-control.html" class="prev">
        Flow Control
      </a></span> <span class="next"><a href="/cpp/const-keyword.html">
        const keyword
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.1779e102.js" defer></script><script src="/assets/js/3.2cfa8016.js" defer></script><script src="/assets/js/675.368a2d5f.js" defer></script>
  </body>
</html>
