<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C++ | Expression templates</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="description" content="A basic example illustrating expression templates, Basic expression templates on element-wise algebraic expressions">
    <meta property="og:site_name" content="DevTut">
    <meta property="og:title" content="C++ | Expression templates">
    <meta property="og:description" content="A basic example illustrating expression templates, Basic expression templates on element-wise algebraic expressions">
    <meta property="og:type" content="article">
    <meta property="og:url" content="/cpp/expression-templates.html">
    <meta property="og:image" content="/logo.png">
    <meta name="twitter:title" content="C++ | Expression templates">
    <meta name="twitter:description" content="A basic example illustrating expression templates, Basic expression templates on element-wise algebraic expressions">
    <meta name="twitter:url" content="/cpp/expression-templates.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="/logo.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/mstile-150x150.png">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="google-site-verification" content="76_rKXgwMVIjd-axJC_1zPV9OS4mEjvtgjYOWVkAdnQ">
    <link rel="preload" href="/assets/css/0.styles.8b877eb8.css" as="style"><link rel="preload" href="/assets/js/app.ced448ab.js" as="script"><link rel="preload" href="/assets/js/3.f1d73125.js" as="script"><link rel="preload" href="/assets/js/649.26e8fdde.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.8b877eb8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">DevTut</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>C++</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/cpp/" class="sidebar-link">Disclaimer</a></li><li><a href="/cpp/getting-started-with-cpp.html" class="sidebar-link">Getting started with C++</a></li><li><a href="/cpp/literals.html" class="sidebar-link">Literals</a></li><li><a href="/cpp/operator-precedence.html" class="sidebar-link">operator precedence</a></li><li><a href="/cpp/floating-point-arithmetic.html" class="sidebar-link">Floating Point Arithmetic</a></li><li><a href="/cpp/bit-operators.html" class="sidebar-link">Bit Operators</a></li><li><a href="/cpp/bit-manipulation.html" class="sidebar-link">Bit Manipulation</a></li><li><a href="/cpp/bit-fields.html" class="sidebar-link">Bit fields</a></li><li><a href="/cpp/arrays.html" class="sidebar-link">Arrays</a></li><li><a href="/cpp/iterators.html" class="sidebar-link">Iterators</a></li><li><a href="/cpp/basic-input-output-in-c.html" class="sidebar-link">Basic input/output in c++</a></li><li><a href="/cpp/loops.html" class="sidebar-link">Loops</a></li><li><a href="/cpp/file-i-o.html" class="sidebar-link">File I/O</a></li><li><a href="/cpp/cpp-streams.html" class="sidebar-link">C++ Streams</a></li><li><a href="/cpp/stream-manipulators.html" class="sidebar-link">Stream manipulators</a></li><li><a href="/cpp/flow-control.html" class="sidebar-link">Flow Control</a></li><li><a href="/cpp/metaprogramming.html" class="sidebar-link">Metaprogramming</a></li><li><a href="/cpp/const-keyword.html" class="sidebar-link">const keyword</a></li><li><a href="/cpp/mutable-keyword.html" class="sidebar-link">mutable keyword</a></li><li><a href="/cpp/friend-keyword.html" class="sidebar-link">Friend keyword</a></li><li><a href="/cpp/type-keywords.html" class="sidebar-link">Type Keywords</a></li><li><a href="/cpp/basic-type-keywords.html" class="sidebar-link">Basic Type Keywords</a></li><li><a href="/cpp/variable-declaration-keywords.html" class="sidebar-link">Variable Declaration Keywords</a></li><li><a href="/cpp/keywords.html" class="sidebar-link">Keywords</a></li><li><a href="/cpp/returning-several-values-from-a-function.html" class="sidebar-link">Returning several values from a function</a></li><li><a href="/cpp/polymorphism.html" class="sidebar-link">Polymorphism</a></li><li><a href="/cpp/references.html" class="sidebar-link">References</a></li><li><a href="/cpp/value-and-reference-semantics.html" class="sidebar-link">Value and Reference Semantics</a></li><li><a href="/cpp/c-function-call-by-value-vs-call-by-reference.html" class="sidebar-link">C++ function &quot;call by value&quot; vs. &quot;call by reference&quot;</a></li><li><a href="/cpp/copying-vs-assignment.html" class="sidebar-link">Copying vs Assignment</a></li><li><a href="/cpp/pointers.html" class="sidebar-link">Pointers</a></li><li><a href="/cpp/pointers-to-members.html" class="sidebar-link">Pointers to members</a></li><li><a href="/cpp/the-this-pointer.html" class="sidebar-link">The This Pointer</a></li><li><a href="/cpp/smart-pointers.html" class="sidebar-link">Smart Pointers</a></li><li><a href="/cpp/classes-structures.html" class="sidebar-link">Classes/Structures</a></li><li><a href="/cpp/function-overloading.html" class="sidebar-link">Function Overloading</a></li><li><a href="/cpp/operator-overloading.html" class="sidebar-link">Operator Overloading</a></li><li><a href="/cpp/function-template-overloading.html" class="sidebar-link">Function Template Overloading</a></li><li><a href="/cpp/virtual-member-functions.html" class="sidebar-link">Virtual Member Functions</a></li><li><a href="/cpp/inline-functions.html" class="sidebar-link">Inline functions</a></li><li><a href="/cpp/special-member-functions.html" class="sidebar-link">Special Member Functions</a></li><li><a href="/cpp/non-static-member-functions.html" class="sidebar-link">Non-Static Member Functions</a></li><li><a href="/cpp/constant-class-member-functions.html" class="sidebar-link">Constant class member functions</a></li><li><a href="/cpp/c-containers.html" class="sidebar-link">C++ Containers</a></li><li><a href="/cpp/namespaces.html" class="sidebar-link">Namespaces</a></li><li><a href="/cpp/header-files.html" class="sidebar-link">Header Files</a></li><li><a href="/cpp/using-declaration.html" class="sidebar-link">Using declaration</a></li><li><a href="/cpp/std-string.html" class="sidebar-link">std::string</a></li><li><a href="/cpp/std-array.html" class="sidebar-link">std::array</a></li><li><a href="/cpp/std-vector.html" class="sidebar-link">std::vector</a></li><li><a href="/cpp/std-map.html" class="sidebar-link">std::map</a></li><li><a href="/cpp/std-optional.html" class="sidebar-link">std::optional</a></li><li><a href="/cpp/std-function-to-wrap-any-element-that-is-callable.html" class="sidebar-link">std::function: To wrap any element that is callable</a></li><li><a href="/cpp/std-forward-list.html" class="sidebar-link">std::forward_list</a></li><li><a href="/cpp/std-pair.html" class="sidebar-link">std::pair</a></li><li><a href="/cpp/std-atomics.html" class="sidebar-link">std::atomics</a></li><li><a href="/cpp/std-variant.html" class="sidebar-link">std::variant</a></li><li><a href="/cpp/std-iomanip.html" class="sidebar-link">std::iomanip</a></li><li><a href="/cpp/std-any.html" class="sidebar-link">std::any</a></li><li><a href="/cpp/std-set-and-std-multiset.html" class="sidebar-link">std::set and std::multiset</a></li><li><a href="/cpp/std-integer-sequence.html" class="sidebar-link">std::integer_sequence</a></li><li><a href="/cpp/using-std-unordered-map.html" class="sidebar-link">Using std::unordered_map</a></li><li><a href="/cpp/standard-library-algorithms.html" class="sidebar-link">Standard Library Algorithms</a></li><li><a href="/cpp/the-iso-c-standard.html" class="sidebar-link">The ISO C++ Standard</a></li><li><a href="/cpp/inline-variables.html" class="sidebar-link">Inline variables</a></li><li><a href="/cpp/random-number-generation.html" class="sidebar-link">Random number generation</a></li><li><a href="/cpp/date-and-time-using-chrono-header.html" class="sidebar-link">Date and time using  header</a></li><li><a href="/cpp/sorting.html" class="sidebar-link">Sorting</a></li><li><a href="/cpp/enumeration.html" class="sidebar-link">Enumeration</a></li><li><a href="/cpp/iteration.html" class="sidebar-link">Iteration</a></li><li><a href="/cpp/regular-expressions.html" class="sidebar-link">Regular expressions</a></li><li><a href="/cpp/implementation-defined-behavior.html" class="sidebar-link">Implementation-defined behavior</a></li><li><a href="/cpp/exceptions.html" class="sidebar-link">Exceptions</a></li><li><a href="/cpp/lambdas.html" class="sidebar-link">Lambdas</a></li><li><a href="/cpp/value-categories.html" class="sidebar-link">Value Categories</a></li><li><a href="/cpp/preprocessor.html" class="sidebar-link">Preprocessor</a></li><li><a href="/cpp/data-structures-in-c.html" class="sidebar-link">Data Structures in C++</a></li><li><a href="/cpp/templates.html" class="sidebar-link">Templates</a></li><li><a href="/cpp/expression-templates.html" class="active sidebar-link">Expression templates</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cpp/expression-templates.html#a-basic-example-illustrating-expression-templates" class="sidebar-link">A basic example illustrating expression templates</a></li><li class="sidebar-sub-header"><a href="/cpp/expression-templates.html#basic-expression-templates-on-element-wise-algebraic-expressions" class="sidebar-link">Basic expression templates on element-wise algebraic expressions</a></li></ul></li><li><a href="/cpp/curiously-recurring-template-pattern-crtp.html" class="sidebar-link">Curiously Recurring Template Pattern (CRTP)</a></li><li><a href="/cpp/threading.html" class="sidebar-link">Threading</a></li><li><a href="/cpp/thread-synchronization-structures.html" class="sidebar-link">Thread synchronization structures</a></li><li><a href="/cpp/the-rule-of-three-five-and-zero.html" class="sidebar-link">The Rule of Three, Five, And Zero</a></li><li><a href="/cpp/raii-resource-acquisition-is-initialization.html" class="sidebar-link">RAII: Resource Acquisition Is Initialization</a></li><li><a href="/cpp/rtti-run-time-type-information.html" class="sidebar-link">RTTI: Run-Time Type Information</a></li><li><a href="/cpp/mutexes.html" class="sidebar-link">Mutexes</a></li><li><a href="/cpp/recursive-mutex.html" class="sidebar-link">Recursive Mutex</a></li><li><a href="/cpp/semaphore.html" class="sidebar-link">Semaphore</a></li><li><a href="/cpp/futures-and-promises.html" class="sidebar-link">Futures and Promises</a></li><li><a href="/cpp/atomic-types.html" class="sidebar-link">Atomic Types</a></li><li><a href="/cpp/type-erasure.html" class="sidebar-link">Type Erasure</a></li><li><a href="/cpp/explicit-type-conversions.html" class="sidebar-link">Explicit type conversions</a></li><li><a href="/cpp/unnamed-types.html" class="sidebar-link">Unnamed types</a></li><li><a href="/cpp/type-traits.html" class="sidebar-link">Type Traits</a></li><li><a href="/cpp/return-type-covariance.html" class="sidebar-link">Return Type Covariance</a></li><li><a href="/cpp/layout-of-object-types.html" class="sidebar-link">Layout of object types</a></li><li><a href="/cpp/type-inference.html" class="sidebar-link">Type Inference</a></li><li><a href="/cpp/typedef-and-type-aliases.html" class="sidebar-link">Typedef and type aliases</a></li><li><a href="/cpp/type-deduction.html" class="sidebar-link">type deduction</a></li><li><a href="/cpp/trailing-return-type.html" class="sidebar-link">Trailing return type</a></li><li><a href="/cpp/alignment.html" class="sidebar-link">Alignment</a></li><li><a href="/cpp/perfect-forwarding.html" class="sidebar-link">Perfect Forwarding</a></li><li><a href="/cpp/decltype.html" class="sidebar-link">decltype</a></li><li><a href="/cpp/sfinae-substitution-failure-is-not-an-error.html" class="sidebar-link">SFINAE (Substitution Failure Is Not An Error)</a></li><li><a href="/cpp/undefined-behavior.html" class="sidebar-link">Undefined Behavior</a></li><li><a href="/cpp/overload-resolution.html" class="sidebar-link">Overload resolution</a></li><li><a href="/cpp/move-semantics.html" class="sidebar-link">Move Semantics</a></li><li><a href="/cpp/pimpl-idiom.html" class="sidebar-link">Pimpl Idiom</a></li><li><a href="/cpp/auto.html" class="sidebar-link">auto</a></li><li><a href="/cpp/copy-elision.html" class="sidebar-link">Copy Elision</a></li><li><a href="/cpp/fold-expressions.html" class="sidebar-link">Fold Expressions</a></li><li><a href="/cpp/unions.html" class="sidebar-link">Unions</a></li><li><a href="/cpp/design-pattern-implementation-in-c.html" class="sidebar-link">Design pattern implementation in C++</a></li><li><a href="/cpp/singleton-design-pattern.html" class="sidebar-link">Singleton Design Pattern</a></li><li><a href="/cpp/user-defined-literals.html" class="sidebar-link">User-Defined Literals</a></li><li><a href="/cpp/memory-management.html" class="sidebar-link">Memory management</a></li><li><a href="/cpp/c-11-memory-model.html" class="sidebar-link">C++11 Memory Model</a></li><li><a href="/cpp/scopes.html" class="sidebar-link">Scopes</a></li><li><a href="/cpp/static-assert.html" class="sidebar-link">static_assert</a></li><li><a href="/cpp/constexpr.html" class="sidebar-link">constexpr</a></li><li><a href="/cpp/one-definition-rule-odr.html" class="sidebar-link">One Definition Rule (ODR)</a></li><li><a href="/cpp/unspecified-behavior.html" class="sidebar-link">Unspecified behavior</a></li><li><a href="/cpp/argument-dependent-name-lookup.html" class="sidebar-link">Argument Dependent Name Lookup</a></li><li><a href="/cpp/attributes.html" class="sidebar-link">Attributes</a></li><li><a href="/cpp/recursion-in-c.html" class="sidebar-link">Recursion in C++</a></li><li><a href="/cpp/arithmitic-metaprogramming.html" class="sidebar-link">Arithmitic Metaprogramming</a></li><li><a href="/cpp/callable-objects.html" class="sidebar-link">Callable Objects</a></li><li><a href="/cpp/client-server-examples.html" class="sidebar-link">Client server examples</a></li><li><a href="/cpp/const-correctness.html" class="sidebar-link">Const Correctness</a></li><li><a href="/cpp/parameter-packs.html" class="sidebar-link">Parameter packs</a></li><li><a href="/cpp/build-systems.html" class="sidebar-link">Build Systems</a></li><li><a href="/cpp/concurrency-with-openmp.html" class="sidebar-link">Concurrency With OpenMP</a></li><li><a href="/cpp/resource-management.html" class="sidebar-link">Resource Management</a></li><li><a href="/cpp/storage-class-specifiers.html" class="sidebar-link">Storage class specifiers</a></li><li><a href="/cpp/linkage-specifications.html" class="sidebar-link">Linkage specifications</a></li><li><a href="/cpp/digit-separators.html" class="sidebar-link">Digit separators</a></li><li><a href="/cpp/c-incompatibilities.html" class="sidebar-link">C incompatibilities</a></li><li><a href="/cpp/side-by-side-comparisons-of-classic-c-examples-solved-via-c-vs-c-11-vs-c-14-vs-c-17.html" class="sidebar-link">Side by Side Comparisons of classic C++ examples solved via C++ vs C++11 vs C++14 vs C++17</a></li><li><a href="/cpp/compiling-and-building.html" class="sidebar-link">Compiling and Building</a></li><li><a href="/cpp/common-compile-linker-errors-gcc.html" class="sidebar-link">Common compile/linker errors (GCC)</a></li><li><a href="/cpp/more-undefined-behaviors-in-c.html" class="sidebar-link">More undefined behaviors in C++</a></li><li><a href="/cpp/unit-testing-in-c.html" class="sidebar-link">Unit Testing in C++</a></li><li><a href="/cpp/c-debugging-and-debug-prevention-tools-techniques.html" class="sidebar-link">C++ Debugging and Debug-prevention Tools &amp; Techniques</a></li><li><a href="/cpp/optimization-in-c.html" class="sidebar-link">Optimization in C++</a></li><li><a href="/cpp/optimization.html" class="sidebar-link">Optimization</a></li><li><a href="/cpp/profiling.html" class="sidebar-link">Profiling</a></li><li><a href="/cpp/refactoring-techniques.html" class="sidebar-link">Refactoring Techniques</a></li><li><a href="/cpp/internationalization-in-c.html" class="sidebar-link">Internationalization in C++</a></li><li><a href="/cpp/contributors.html" class="sidebar-link">The Contributors</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="expression-templates"><a href="#expression-templates" class="header-anchor">#</a> Expression templates</h1> <h2 id="a-basic-example-illustrating-expression-templates"><a href="#a-basic-example-illustrating-expression-templates" class="header-anchor">#</a> A basic example illustrating expression templates</h2> <p>An expression template is a compile-time optimization technique used mostly in scientific computing. It's main purpose is to avoid unnecessary temporaries and optimize loop calculations using a single pass (typically when performing operations on numerical aggregates). Expression templates were initially devised in order to circumvent the inefficiencies of na√Øve operator overloading when implementing numerical <code>Array</code> or <code>Matrix</code> types. An equivalent terminology for expression templates has been introduced by Bjarne Stroustrup, who calls them &quot;fused operations&quot; in the latest version of his book,  &quot;The C++ Programming Language&quot;.</p> <p>Before actually diving into expression templates, you should understand why you need them in the first place. To illustrate this, consider the very simple Matrix class given below:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t COL<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t ROW<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Matrix</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">using</span> value_type <span class="token operator">=</span> T<span class="token punctuation">;</span>

    <span class="token function">Matrix</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">values</span><span class="token punctuation">(</span>COL <span class="token operator">*</span> ROW<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">static</span> size_t <span class="token function">cols</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> COL<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">static</span> size_t <span class="token function">rows</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> ROW<span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>size_t x<span class="token punctuation">,</span> size_t y<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> values<span class="token punctuation">[</span>y <span class="token operator">*</span> COL <span class="token operator">+</span> x<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>size_t x<span class="token punctuation">,</span> size_t y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> values<span class="token punctuation">[</span>y <span class="token operator">*</span> COL <span class="token operator">+</span> x<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> values<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t COL<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t ROW<span class="token operator">&gt;</span>
Matrix<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> COL<span class="token punctuation">,</span> ROW<span class="token operator">&gt;</span>
<span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> Matrix<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> COL<span class="token punctuation">,</span> ROW<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Matrix<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> COL<span class="token punctuation">,</span> ROW<span class="token operator">&gt;</span><span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Matrix<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> COL<span class="token punctuation">,</span> ROW<span class="token operator">&gt;</span> result<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> y <span class="token operator">!=</span> lhs<span class="token punctuation">.</span><span class="token function">rows</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">!=</span> lhs<span class="token punctuation">.</span><span class="token function">cols</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">result</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">lhs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">rhs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Given the previous class definition, you can now write Matrix expressions such as:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">const</span> std<span class="token operator">::</span>size_t cols <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> std<span class="token operator">::</span>size_t rows <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>

Matrix<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> cols<span class="token punctuation">,</span> rows<span class="token operator">&gt;</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>

<span class="token comment">// initialize a, b &amp; c</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>size_t y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> y <span class="token operator">!=</span> rows<span class="token punctuation">;</span> <span class="token operator">++</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>size_t x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">!=</span> cols<span class="token punctuation">;</span> <span class="token operator">++</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">a</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span>
        <span class="token function">b</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">2.0</span><span class="token punctuation">;</span>
        <span class="token function">c</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">3.0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>  

Matrix<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> cols<span class="token punctuation">,</span> rows<span class="token operator">&gt;</span> d <span class="token operator">=</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>  <span class="token comment">// d(x, y) = 6 </span>

</code></pre></div><p>As illustrated above, being able to overload <code>operator+()</code> provides you with a notation which mimics the natural mathematical notation for matrices.</p> <p>Unfortunately, the previous implementation is also highly inefficient compared to an equivalent &quot;hand-crafted&quot; version.</p> <p>To understand why, you have to consider what happens when you write an expression such as <code>Matrix d = a + b + c</code>. This in fact expands to <code>((a + b) + c)</code> or <code>operator+(operator+(a, b), c)</code>. In other words, the loop inside <code>operator+()</code> is executed twice, whereas it could have been easily performed in a single pass. This also results in 2 temporaries being created, which further degrades performance. In essence, by adding the flexibility to use a notation close to its mathematical counterpart, you have also made the <code>Matrix</code> class highly inefficient.</p> <p>For example, without operator overloading, you could implement a far more efficient Matrix summation using a single pass:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t COL<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t ROW<span class="token operator">&gt;</span>
Matrix<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> COL<span class="token punctuation">,</span> ROW<span class="token operator">&gt;</span> <span class="token function">add3</span><span class="token punctuation">(</span><span class="token keyword">const</span> Matrix<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> COL<span class="token punctuation">,</span> ROW<span class="token operator">&gt;</span><span class="token operator">&amp;</span> a<span class="token punctuation">,</span>
                         <span class="token keyword">const</span> Matrix<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> COL<span class="token punctuation">,</span> ROW<span class="token operator">&gt;</span><span class="token operator">&amp;</span> b<span class="token punctuation">,</span>
                         <span class="token keyword">const</span> Matrix<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> COL<span class="token punctuation">,</span> ROW<span class="token operator">&gt;</span><span class="token operator">&amp;</span> c<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Matrix<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> COL<span class="token punctuation">,</span> ROW<span class="token operator">&gt;</span> result<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> y <span class="token operator">!=</span> ROW<span class="token punctuation">;</span> <span class="token operator">++</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">!=</span> COL<span class="token punctuation">;</span> <span class="token operator">++</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">result</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">a</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">b</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">c</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>The previous example however has its own disadvantages because it creates a far more convoluted interface for the Matrix class (you would have to consider methods such as <code>Matrix::add2()</code>, <code>Matrix::AddMultiply()</code> and so on).</p> <p>Instead let us take a step back and see how we can adapt operator overloading to perform in a more efficient way</p> <p>The problem stems from the fact that the expression <code>Matrix d = a + b + c</code> is evaluated too &quot;eagerly&quot; before you have had an opportunity to build the entire expression tree. In other words, what you really want to achieve is to evaluate <code>a + b + c</code> in one pass and only once you actually need to assign the resulting expressing to <code>d</code>.</p> <p>This is the core idea behind expression templates: instead of having <code>operator+()</code> evaluate immediately the result of adding two Matrix instances, it will return an <strong>&quot;expression template&quot;</strong> for future evaluation once the entire expression tree has been built.</p> <p>For example, here is a possible implementation for an expression template corresponding to the summation of 2 types:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> LHS<span class="token punctuation">,</span> <span class="token keyword">typename</span> RHS<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">MatrixSum</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">using</span> value_type <span class="token operator">=</span> <span class="token keyword">typename</span> LHS<span class="token operator">::</span>value_type<span class="token punctuation">;</span>

    <span class="token function">MatrixSum</span><span class="token punctuation">(</span><span class="token keyword">const</span> LHS<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> RHS<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">rhs</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">lhs</span><span class="token punctuation">(</span>lhs<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    
    value_type <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token keyword">const</span>  <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">lhs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">rhs</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">const</span> LHS<span class="token operator">&amp;</span> lhs<span class="token punctuation">;</span>
    <span class="token keyword">const</span> RHS<span class="token operator">&amp;</span> rhs<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>And here is the updated version of <code>operator+()</code></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> LHS<span class="token punctuation">,</span> <span class="token keyword">typename</span> RHS<span class="token operator">&gt;</span>
MatrixSum<span class="token operator">&lt;</span>LHS<span class="token punctuation">,</span> RHS<span class="token operator">&gt;</span> <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> LHS<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> LHS<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> MatrixSum<span class="token operator">&lt;</span>LHS<span class="token punctuation">,</span> RHS<span class="token operator">&gt;</span><span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>As you can see, <code>operator+()</code> no longer returns an &quot;eager evaluation&quot; of the result of adding 2 Matrix instances (which would be another Matrix instance), but instead an expression template representing the addition operation. The most important point to keep in mind is that the expression has not been evaluated yet. It merely holds references to its operands.</p> <p>In fact, nothing stops you from instantiating the <code>MatrixSum&lt;&gt;</code> expression template as follows:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>MatrixSum<span class="token operator">&lt;</span>Matrix<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> Matrix<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> <span class="token operator">&gt;</span> <span class="token function">SumAB</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>You can however at a later stage, when you actually need the result of the summation, evaluate the expression <code>d = a + b</code> as follows:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>size_t y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> y <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">rows</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>size_t x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">cols</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">d</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">SumAB</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>As you can see, another benefit of using an expression template, is that you have basically managed to evaluate the sum of <code>a</code> and <code>b</code> and assign it to <code>d</code> in a single pass.</p> <p>Also, nothing stops you from combining multiple expression templates. For example,  <code>a + b + c</code> would result in the following expression template:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>MatrixSum<span class="token operator">&lt;</span>MatrixSum<span class="token operator">&lt;</span>Matrix<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> Matrix<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> <span class="token operator">&gt;</span><span class="token punctuation">,</span> Matrix<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> <span class="token operator">&gt;</span> <span class="token function">SumABC</span><span class="token punctuation">(</span>SumAB<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>And here again you can evaluate the final result using a single pass:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>size_t y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> y <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">rows</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>size_t x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">!=</span> a<span class="token punctuation">.</span><span class="token function">cols</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">d</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">SumABC</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Finally, the last piece of the puzzle is to actually plug your expression template into the <code>Matrix</code> class. This is essentially achieved by providing an implementation for  <code>Matrix::operator=()</code>, which takes the expression template as an argument and evaluates it in one pass, as you did &quot;manually&quot; before:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t COL<span class="token punctuation">,</span> std<span class="token operator">::</span>size_t ROW<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Matrix</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">using</span> value_type <span class="token operator">=</span> T<span class="token punctuation">;</span>

    <span class="token function">Matrix</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">values</span><span class="token punctuation">(</span>COL <span class="token operator">*</span> ROW<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token keyword">static</span> size_t <span class="token function">cols</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> COL<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">static</span> size_t <span class="token function">rows</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> ROW<span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>size_t x<span class="token punctuation">,</span> size_t y<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> values<span class="token punctuation">[</span>y <span class="token operator">*</span> COL <span class="token operator">+</span> x<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    T<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>size_t x<span class="token punctuation">,</span> size_t y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> values<span class="token punctuation">[</span>y <span class="token operator">*</span> COL <span class="token operator">+</span> x<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> E<span class="token operator">&gt;</span>
    Matrix<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> COL<span class="token punctuation">,</span> ROW<span class="token operator">&gt;</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> E<span class="token operator">&amp;</span> expression<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>size_t y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> y <span class="token operator">!=</span> <span class="token function">rows</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>y<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>size_t x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> x <span class="token operator">!=</span> <span class="token function">cols</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                values<span class="token punctuation">[</span>y <span class="token operator">*</span> COL <span class="token operator">+</span> x<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">expression</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> values<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><h2 id="basic-expression-templates-on-element-wise-algebraic-expressions"><a href="#basic-expression-templates-on-element-wise-algebraic-expressions" class="header-anchor">#</a> Basic expression templates on element-wise algebraic expressions</h2> <p><strong>Introduction and motivation</strong></p> <p><strong>Expression templates</strong> (denoted as <strong>ETs</strong> in the following) are a powerful template meta-programming technique, used to speed-up calculations of sometimes quite expensive expressions. It is widely used in different domains, for example in implementation of linear algebra libraries.</p> <p>For this example, consider the context of linear algebraic computations. More specifically, computations involving only <strong>element-wise operations</strong>. This kind of computations are the most basic applications of <strong>ETs</strong>, and they serve as a good introduction to how <strong>ETs</strong> work internally.</p> <p>Let's look at a motivating example. Consider the computation of the expression:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>Vector vec_1<span class="token punctuation">,</span> vec_2<span class="token punctuation">,</span> vec_3<span class="token punctuation">;</span>

<span class="token comment">// Initializing vec_1, vec_2 and vec_3.</span>

Vector result <span class="token operator">=</span> vec_1 <span class="token operator">+</span> vec_2<span class="token operator">*</span>vec_3<span class="token punctuation">;</span>

</code></pre></div><p>Here for the sake of simplicity, I'll assume that the class <code>Vector</code> and operation + (vector plus: element-wise plus operation) and operation * (here means vector inner product: also element-wise operation) are both correctly implemented, as how they should be, mathematically.</p> <p>In a conventional implementation without using <strong>ETs</strong> (or other similar techniques), <strong>at least five</strong> constructions of <code>Vector</code> instances take place in order to obtain the final <code>result</code>:</p> <ol><li>Three instances corresponding to <code>vec_1</code>, <code>vec_2</code> and <code>vec_3</code>.</li> <li>A temporary <code>Vector</code> instance <code>_tmp</code>, representing the result of <code>_tmp = vec_2*vec_3;</code>.</li> <li>Finally with proper use of <strong>return value optimization</strong>, the construction of final <code>result</code> in <code>result = vec_1 + _tmp;</code>.</li></ol> <p>Implementation using <strong>ETs</strong> can <strong>eliminate the creation of temporary</strong> <code>Vector _tmp</code> in 2, thus leaving only <strong>four</strong> constructions of <code>Vector</code> instances. More interestingly, consider the following expression which is more complex:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>Vector result <span class="token operator">=</span> vec_1 <span class="token operator">+</span> <span class="token punctuation">(</span>vec_2<span class="token operator">*</span>vec3 <span class="token operator">+</span> vec_1<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span>vec_2 <span class="token operator">+</span> vec_3<span class="token operator">*</span>vec_1<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>There will also be four constructions of <code>Vector</code> instances in total: <code>vec_1, vec_2, vec_3</code> and <code>result</code>. In other words, in this example, <strong>where only element-wise operations are involved</strong>, it is guaranteed that <strong>no temporary objects will be created from intermediate calculations</strong>.</p> <p><strong>How do ETs work</strong></p> <p>Basically speaking, <strong>ETs for any algebraic computations</strong> consist of two building blocks:</p> <ol><li><strong>Pure algebraic expressions</strong> (<strong>PAE</strong>): they are proxies / abstractions of algebraic expressions. A pure algebraic does not do actual computations, they are merely abstractions / modeling of the computation work-flow. A PAE can be a model of <strong>either the input or the output of any algebraic expressions</strong>. Instances of <strong>PAE</strong>s are often considered cheap to copy.</li> <li><strong>Lazy evaluations</strong>: which are implementation of real computations. In the following example, we will see that for expressions involving only element-wise operations, lazy evaluations can implement actual computations inside the indexed-access operation on the final result, thus creating a scheme of evaluation on-demand: a computation is not performed only if the final result is accessed / asked for.</li></ol> <p>So, specifically how do we implement <strong>ETs</strong> in this example? Let's walk through it now.</p> <p>Consider always the following code snippet:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>Vector vec_1<span class="token punctuation">,</span> vec_2<span class="token punctuation">,</span> vec_3<span class="token punctuation">;</span>

<span class="token comment">// Initializing vec_1, vec_2 and vec_3.</span>

Vector result <span class="token operator">=</span> vec_1 <span class="token operator">+</span> vec_2<span class="token operator">*</span>vec_3<span class="token punctuation">;</span>

</code></pre></div><p>The expression to compute result can be decomposed further into two sub-expressions:</p> <ol><li>A vector plus expression (denoted as <strong>plus_expr</strong>)</li> <li>A vector inner product expression (denoted as <strong>innerprod_expr</strong>).</li></ol> <p>What <strong>ETs</strong> do is the following:</p> <li>
Instead of compute right away each sub-expression, **ETs** first model the whole expression using a graphical structure. Each node in the graph represents a **PAE**. The edge connection of the nodes represent the actual computation flow. So for the above expression, we obtain the following graph:
<div class="language-cpp extra-class"><pre class="language-cpp"><code>       result <span class="token operator">=</span> <span class="token function">plus_expr</span><span class="token punctuation">(</span> vec_1<span class="token punctuation">,</span> <span class="token function">innerprod_expr</span><span class="token punctuation">(</span>vec_2<span class="token punctuation">,</span> vec_3<span class="token punctuation">)</span> <span class="token punctuation">)</span>
          <span class="token operator">/</span>   \
         <span class="token operator">/</span>     \
        <span class="token operator">/</span>       \
       <span class="token operator">/</span>   <span class="token function">innerprod_expr</span><span class="token punctuation">(</span> vec_2<span class="token punctuation">,</span> vec_3 <span class="token punctuation">)</span>
      <span class="token operator">/</span>         <span class="token operator">/</span>  \
     <span class="token operator">/</span>         <span class="token operator">/</span>    \
    <span class="token operator">/</span>         <span class="token operator">/</span>      \
 vec_1     vec_2    vec_3

</code></pre></div></li> <li>
The final computation is implemented by **looking through the graph hierarchy**: since here we are dealing with **only element-wise** operations, the computation of each indexed value in `result` **can be done independently**: the final evaluation of `result` can be lazily postponed to a **element-wise evaluation** of each element of `result`. In other words, since the computation of an element of `result`, `elem_res`, can be expressed using corresponding elements in `vec_1` (`elem_1`), `vec_2` (`elem_2`) and `vec_3` (`elem_3`) as:
<div class="language-cpp extra-class"><pre class="language-cpp"><code>elem_res <span class="token operator">=</span> elem_1 <span class="token operator">+</span> elem_2<span class="token operator">*</span>elem_3<span class="token punctuation">;</span>

</code></pre></div></li> <p>there is therefore no need to create a temporary <code>Vector</code> to store the result of intermediate inner product: <strong>the whole computation for one element can be done altogether, and be encoded inside the indexed-access operation</strong>.</p> <p><strong>Here are the example codes in action.</strong></p> <h3 id="file-vec-hh-wrapper-for-std-vector-used-to-show-log-when-a-construction-is-called"><a href="#file-vec-hh-wrapper-for-std-vector-used-to-show-log-when-a-construction-is-called" class="header-anchor">#</a> File vec.hh : wrapper for std::vector, used to show log when a construction is called.</h3> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">ifndef</span> EXPR_VEC</span>
<span class="token macro property"># <span class="token directive keyword">define</span> EXPR_VEC</span>

<span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt;cassert&gt;</span></span>
<span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt;utility&gt;</span></span>
<span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span>

<span class="token comment">///</span>
<span class="token comment">/// This is a wrapper for std::vector. It's only purpose is to print out a log when a</span>
<span class="token comment">/// vector constructions in called.</span>
<span class="token comment">/// It wraps the indexed access operator [] and the size() method, which are </span>
<span class="token comment">/// important for later ETs implementation.</span>
<span class="token comment">///</span>

<span class="token comment">// std::vector wrapper.</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> ScalarType<span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">Vector</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">explicit</span> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ctor called.\n&quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">explicit</span> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">_vec</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ctor called.\n&quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">explicit</span> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>ScalarType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>vec<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">_vec</span><span class="token punctuation">(</span>vec<span class="token punctuation">)</span>
  <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;ctor called.\n&quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  
  <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token keyword">const</span> Vector<span class="token operator">&lt;</span>ScalarType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span> vec<span class="token punctuation">)</span><span class="token operator">:</span> _vec<span class="token punctuation">{</span><span class="token function">vec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
  <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;copy ctor called.\n&quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token function">Vector</span><span class="token punctuation">(</span>Vector<span class="token operator">&lt;</span>ScalarType<span class="token operator">&gt;</span> <span class="token operator">&amp;&amp;</span> vec<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">_vec</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token function">vec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;move ctor called.\n&quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

  Vector<span class="token operator">&lt;</span>ScalarType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Vector<span class="token operator">&lt;</span>ScalarType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
  Vector<span class="token operator">&lt;</span>ScalarType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>Vector<span class="token operator">&lt;</span>ScalarType<span class="token operator">&gt;</span> <span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>

  <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> indx<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> _vec<span class="token punctuation">[</span>indx<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> indx<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> _vec<span class="token punctuation">[</span>indx<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

  <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>_vec<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>        
  <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">&amp;</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>_vec<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  
  Vector<span class="token operator">&lt;</span>ScalarType<span class="token operator">&gt;</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

  <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> _vec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  
<span class="token keyword">private</span><span class="token operator">:</span>
  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>ScalarType<span class="token operator">&gt;</span> _vec<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">///</span>
<span class="token comment">/// These are conventional overloads of operator + (the vector plus operation)</span>
<span class="token comment">/// and operator * (the vector inner product operation) without using the expression</span>
<span class="token comment">/// templates. They are later used for bench-marking purpose.</span>
<span class="token comment">///</span>

<span class="token comment">// + (vector plus) operator.</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> ScalarType<span class="token operator">&gt;</span>
<span class="token keyword">auto</span> <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> Vector<span class="token operator">&lt;</span>ScalarType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Vector<span class="token operator">&lt;</span>ScalarType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">lhs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">rhs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
         <span class="token string">&quot;error: ops plus -&gt; lhs and rhs size mismatch.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>ScalarType<span class="token operator">&gt;</span> _vec<span class="token punctuation">;</span>
  _vec<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token function">lhs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span><span class="token function">transform</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token function">lhs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token function">lhs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                 std<span class="token operator">::</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token function">rhs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>_vec<span class="token punctuation">)</span><span class="token punctuation">,</span>
                 std<span class="token operator">::</span>plus<span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> Vector<span class="token operator">&lt;</span>ScalarType<span class="token operator">&gt;</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>_vec<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// * (vector inner product) operator.</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> ScalarType<span class="token operator">&gt;</span>
<span class="token keyword">auto</span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Vector<span class="token operator">&lt;</span>ScalarType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Vector<span class="token operator">&lt;</span>ScalarType<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">lhs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">rhs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
         <span class="token string">&quot;error: ops multiplies -&gt; lhs and rhs size mismatch.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>ScalarType<span class="token operator">&gt;</span> _vec<span class="token punctuation">;</span>
  _vec<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span><span class="token function">lhs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span><span class="token function">transform</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token function">lhs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token function">lhs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                 std<span class="token operator">::</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token function">rhs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>_vec<span class="token punctuation">)</span><span class="token punctuation">,</span>
                 std<span class="token operator">::</span>multiplies<span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> Vector<span class="token operator">&lt;</span>ScalarType<span class="token operator">&gt;</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>_vec<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment">//!EXPR_VEC</span>

</code></pre></div><h3 id="file-expr-hh-implementation-of-expression-templates-for-element-wise-operations-vector-plus-and-vector-inner-product"><a href="#file-expr-hh-implementation-of-expression-templates-for-element-wise-operations-vector-plus-and-vector-inner-product" class="header-anchor">#</a> File expr.hh : implementation of expression templates for element-wise operations (vector plus and vector inner product)</h3> <p>Let's break it down to sections.</p> <ol><li>Section 1 implements a base class for all expressions. It employs the <strong>Curiously Recurring Template Pattern</strong> (<a href="http://stackoverflow.com/documentation/c%2B%2B/709/curiously-recurring-template-pattern-crtp#t=201607241604559383674" target="_blank" rel="noopener noreferrer">CRTP<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>).</li> <li>Section 2 implements the first <strong>PAE</strong>: a <strong>terminal</strong>, which is just a wrapper (const reference) of an input data structure containing real input value for computation.</li> <li>Section 3 implements the second <strong>PAE</strong>: <strong>binary_operation</strong>, which is a class template later used for vector_plus and vector_innerprod. It's parametrized by the <strong>type of operation</strong>, <strong>the left-hand-side PAE</strong> and <strong>the right-hand-side PAE</strong>. The actual computation is encoded in the indexed-access operator.</li> <li>Section 4 defines vector_plus and vector_innerprod operations as <strong>element-wise operation</strong>. It also overload operator + and * for <strong>PAE</strong>s: such that these two operations also return <strong>PAE</strong>.</li></ol> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">ifndef</span> EXPR_EXPR</span>
<span class="token macro property"># <span class="token directive keyword">define</span> EXPR_EXPR</span>
      

<span class="token comment">/// Fwd declaration.</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">Vector</span><span class="token punctuation">;</span>

<span class="token keyword">namespace</span> expr
<span class="token punctuation">{</span>


<span class="token comment">/// -----------------------------------------</span>
<span class="token comment">///</span>
<span class="token comment">/// Section 1.</span>
<span class="token comment">///</span>
<span class="token comment">/// The first section is a base class template for all kinds of expression. It         </span>
<span class="token comment">/// employs the Curiously Recurring Template Pattern, which enables its instantiation </span>
<span class="token comment">/// to any kind of expression structure inheriting from it.</span>
<span class="token comment">///</span>
<span class="token comment">/// -----------------------------------------</span>


  <span class="token comment">/// Base class for all expressions.</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Expr<span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">expr_base</span>
  <span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">const</span> Expr<span class="token operator">&amp;</span> <span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">const</span> Expr<span class="token operator">&amp;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    Expr<span class="token operator">&amp;</span> <span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span>Expr<span class="token operator">&amp;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

  <span class="token keyword">protected</span><span class="token operator">:</span>
    <span class="token keyword">explicit</span> <span class="token function">expr_base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size_impl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">auto</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> indx<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">at_impl</span><span class="token punctuation">(</span>indx<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">auto</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  

<span class="token comment">/// -----------------------------------------</span>
<span class="token comment">///</span>
<span class="token comment">/// The following section 2 &amp; 3 are abstractions of pure algebraic expressions (PAE).</span>
<span class="token comment">/// Any PAE can be converted to a real object instance using operator(): it is in </span>
<span class="token comment">/// this conversion process, where the real computations are done.</span>

<span class="token comment">///</span>
<span class="token comment">/// Section 2. Terminal</span>
<span class="token comment">///</span>
<span class="token comment">/// A terminal is an abstraction wrapping a const reference to the Vector data </span>
<span class="token comment">/// structure. It inherits from expr_base, therefore providing a unified interface</span>
<span class="token comment">/// wrapping a Vector into a PAE.</span>
<span class="token comment">///</span>
<span class="token comment">/// It provides the size() method, indexed access through at_impl() and a conversion</span>
<span class="token comment">/// to referenced object through () operator.</span>
<span class="token comment">/// </span>
<span class="token comment">/// It might no be necessary for user defined data structures to have a terminal </span>
<span class="token comment">/// wrapper, since user defined structure can inherit expr_base, therefore eliminates</span>
<span class="token comment">/// the need to provide such terminal wrapper. </span>
<span class="token comment">///</span>
<span class="token comment">/// -----------------------------------------</span>


  <span class="token comment">/// Generic wrapper for underlying data structure.</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> DataType<span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">terminal</span><span class="token operator">:</span> expr_base<span class="token operator">&lt;</span>terminal<span class="token operator">&lt;</span>DataType<span class="token operator">&gt;&gt;</span>
  <span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">using</span> base_type <span class="token operator">=</span> expr_base<span class="token operator">&lt;</span>terminal<span class="token operator">&lt;</span>DataType<span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>
    <span class="token keyword">using</span> base_type<span class="token operator">::</span>size<span class="token punctuation">;</span>
    <span class="token keyword">using</span> base_type<span class="token operator">::</span><span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">friend</span> base_type<span class="token punctuation">;</span>
    
    <span class="token keyword">explicit</span> <span class="token function">terminal</span><span class="token punctuation">(</span><span class="token keyword">const</span> DataType <span class="token operator">&amp;</span>val<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">_val</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">int</span> <span class="token function">size_impl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> _val<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> <span class="token function">at_impl</span><span class="token punctuation">(</span><span class="token keyword">int</span> indx<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> _val<span class="token punctuation">[</span>indx<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token punctuation">)</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">(</span>_val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    
  <span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">const</span> DataType <span class="token operator">&amp;</span>_val<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token comment">/// -----------------------------------------</span>
<span class="token comment">///</span>
<span class="token comment">/// Section 3. Binary operation expression.</span>
<span class="token comment">///</span>
<span class="token comment">/// This is a PAE abstraction of any binary expression. Similarly it inherits from </span>
<span class="token comment">/// expr_base.</span>
<span class="token comment">///</span>
<span class="token comment">/// It provides the size() method, indexed access through at_impl() and a conversion</span>
<span class="token comment">/// to referenced object through () operator. Each call to the at_impl() method is</span>
<span class="token comment">/// a element wise computation.</span>
<span class="token comment">/// </span>
<span class="token comment">/// -----------------------------------------</span>


  <span class="token comment">/// Generic wrapper for binary operations (that are element-wise).</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> Ops<span class="token punctuation">,</span> <span class="token keyword">typename</span> lExpr<span class="token punctuation">,</span> <span class="token keyword">typename</span> rExpr<span class="token operator">&gt;</span>
  <span class="token keyword">class</span> <span class="token class-name">binary_ops</span><span class="token operator">:</span> <span class="token keyword">public</span> expr_base<span class="token operator">&lt;</span>binary_ops<span class="token operator">&lt;</span>Ops<span class="token punctuation">,</span>lExpr<span class="token punctuation">,</span>rExpr<span class="token operator">&gt;&gt;</span>
  <span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">using</span> base_type <span class="token operator">=</span> expr_base<span class="token operator">&lt;</span>binary_ops<span class="token operator">&lt;</span>Ops<span class="token punctuation">,</span>lExpr<span class="token punctuation">,</span>rExpr<span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>
    <span class="token keyword">using</span> base_type<span class="token operator">::</span>size<span class="token punctuation">;</span>
    <span class="token keyword">using</span> base_type<span class="token operator">::</span><span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">friend</span> base_type<span class="token punctuation">;</span>
    
    <span class="token keyword">explicit</span> <span class="token function">binary_ops</span><span class="token punctuation">(</span><span class="token keyword">const</span> Ops <span class="token operator">&amp;</span>ops<span class="token punctuation">,</span> <span class="token keyword">const</span> lExpr <span class="token operator">&amp;</span>lxpr<span class="token punctuation">,</span> <span class="token keyword">const</span> rExpr <span class="token operator">&amp;</span>rxpr<span class="token punctuation">)</span>
      <span class="token operator">:</span> <span class="token function">_ops</span><span class="token punctuation">(</span>ops<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_lxpr</span><span class="token punctuation">(</span>lxpr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_rxpr</span><span class="token punctuation">(</span>rxpr<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token function">size_impl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> _lxpr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">/// This does the element-wise computation for index indx.</span>
    <span class="token keyword">auto</span> <span class="token function">at_impl</span><span class="token punctuation">(</span><span class="token keyword">int</span> indx<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">_ops</span><span class="token punctuation">(</span>_lxpr<span class="token punctuation">[</span>indx<span class="token punctuation">]</span><span class="token punctuation">,</span> _rxpr<span class="token punctuation">[</span>indx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">/// Conversion from arbitrary expr to concrete data type. It evaluates</span>
    <span class="token comment">/// element-wise computations for all indices.</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> DataType<span class="token operator">&gt;</span> <span class="token keyword">operator</span> <span class="token function">DataType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      DataType <span class="token function">_vec</span><span class="token punctuation">(</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> _ind <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> _ind <span class="token operator">&lt;</span> _vec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>_ind<span class="token punctuation">)</span>
        _vec<span class="token punctuation">[</span>_ind<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">[</span>_ind<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> _vec<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
  <span class="token keyword">private</span><span class="token operator">:</span> <span class="token comment">/// Ops and expr are assumed cheap to copy.</span>
    Ops   _ops<span class="token punctuation">;</span>
    lExpr _lxpr<span class="token punctuation">;</span>
    rExpr _rxpr<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token comment">/// -----------------------------------------</span>
<span class="token comment">/// Section 4.</span>
<span class="token comment">///</span>
<span class="token comment">/// The following two structs defines algebraic operations on PAEs: here only vector </span>
<span class="token comment">/// plus and vector inner product are implemented. </span>
<span class="token comment">///</span>
<span class="token comment">/// First, some element-wise operations are defined : in other words, vec_plus and </span>
<span class="token comment">/// vec_prod acts on elements in Vectors, but not whole Vectors. </span>
<span class="token comment">///</span>
<span class="token comment">/// Then, operator + &amp; * are overloaded on PAEs, such that: + &amp; * operations on PAEs         </span>
<span class="token comment">/// also return PAEs.</span>
<span class="token comment">///</span>
<span class="token comment">/// -----------------------------------------</span>


  <span class="token comment">/// Element-wise plus operation.</span>
  <span class="token keyword">struct</span> <span class="token class-name">vec_plus_t</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">explicit</span> <span class="token function">vec_plus_t</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span> 
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> LType<span class="token punctuation">,</span> <span class="token keyword">typename</span> RType<span class="token operator">&gt;</span>
    <span class="token keyword">auto</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> LType <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> RType <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">{</span> <span class="token keyword">return</span> lhs<span class="token operator">+</span>rhs<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  
  <span class="token comment">/// Element-wise inner product operation.</span>
  <span class="token keyword">struct</span> <span class="token class-name">vec_prod_t</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">explicit</span> <span class="token function">vec_prod_t</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span> 
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> LType<span class="token punctuation">,</span> <span class="token keyword">typename</span> RType<span class="token operator">&gt;</span>
    <span class="token keyword">auto</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> LType <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> RType <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token keyword">const</span>
    <span class="token punctuation">{</span> <span class="token keyword">return</span> lhs<span class="token operator">*</span>rhs<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  
  <span class="token comment">/// Constant plus and inner product operator objects.</span>
  <span class="token keyword">constexpr</span> vec_plus_t vec_plus<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">constexpr</span> vec_prod_t vec_prod<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  
  <span class="token comment">/// Plus operator overload on expressions: return binary expression.</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> lExpr<span class="token punctuation">,</span> <span class="token keyword">typename</span> rExpr<span class="token operator">&gt;</span>
  <span class="token keyword">auto</span> <span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> lExpr <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> rExpr <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
  <span class="token punctuation">{</span> <span class="token keyword">return</span> binary_ops<span class="token operator">&lt;</span>vec_plus_t<span class="token punctuation">,</span>lExpr<span class="token punctuation">,</span>rExpr<span class="token operator">&gt;</span><span class="token punctuation">(</span>vec_plus<span class="token punctuation">,</span>lhs<span class="token punctuation">,</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  
  <span class="token comment">/// Inner prod operator overload on expressions: return binary expression.</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> lExpr<span class="token punctuation">,</span> <span class="token keyword">typename</span> rExpr<span class="token operator">&gt;</span>
  <span class="token keyword">auto</span> <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> lExpr <span class="token operator">&amp;</span>lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> rExpr <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span>
  <span class="token punctuation">{</span> <span class="token keyword">return</span> binary_ops<span class="token operator">&lt;</span>vec_prod_t<span class="token punctuation">,</span>lExpr<span class="token punctuation">,</span>rExpr<span class="token operator">&gt;</span><span class="token punctuation">(</span>vec_prod<span class="token punctuation">,</span>lhs<span class="token punctuation">,</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  
<span class="token punctuation">}</span> <span class="token comment">//!expr</span>


<span class="token macro property">#<span class="token directive keyword">endif</span> </span><span class="token comment">//!EXPR_EXPR</span>

</code></pre></div><h3 id="file-main-cc-test-src-file"><a href="#file-main-cc-test-src-file" class="header-anchor">#</a> File main.cc : test src file</h3> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span>
<span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt;iomanip&gt;</span></span>
<span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&quot;vec.hh&quot;</span></span>
<span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&quot;expr.hh&quot;</span></span>
<span class="token macro property"># <span class="token directive keyword">include</span> <span class="token string">&quot;boost/core/demangle.hpp&quot;</span></span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">using</span> dtype <span class="token operator">=</span> <span class="token keyword">float</span><span class="token punctuation">;</span>
  <span class="token keyword">constexpr</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">5e7</span><span class="token punctuation">;</span>
  
  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>dtype<span class="token operator">&gt;</span> <span class="token function">_vec1</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>dtype<span class="token operator">&gt;</span> <span class="token function">_vec2</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>dtype<span class="token operator">&gt;</span> <span class="token function">_vec3</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// ... Initialize vectors' contents.</span>

  Vector<span class="token operator">&lt;</span>dtype<span class="token operator">&gt;</span> <span class="token function">vec1</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>_vec1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Vector<span class="token operator">&lt;</span>dtype<span class="token operator">&gt;</span> <span class="token function">vec2</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>_vec2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Vector<span class="token operator">&lt;</span>dtype<span class="token operator">&gt;</span> <span class="token function">vec3</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>_vec3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> start_ms_no_ets <span class="token operator">=</span>
    std<span class="token operator">::</span>chrono<span class="token operator">::</span>duration_cast<span class="token operator">&lt;</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span>milliseconds<span class="token operator">&gt;</span>
    <span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span>system_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">time_since_epoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;\nNo-ETs evaluation starts.\n&quot;</span><span class="token punctuation">;</span>
  
  Vector<span class="token operator">&lt;</span>dtype<span class="token operator">&gt;</span> result_no_ets <span class="token operator">=</span> vec1 <span class="token operator">+</span> <span class="token punctuation">(</span>vec2<span class="token operator">*</span>vec3<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> stop_ms_no_ets <span class="token operator">=</span>
    std<span class="token operator">::</span>chrono<span class="token operator">::</span>duration_cast<span class="token operator">&lt;</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span>milliseconds<span class="token operator">&gt;</span>
    <span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span>system_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">time_since_epoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span><span class="token function">setprecision</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>fixed
            <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;No-ETs. Time eclapses: &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>stop_ms_no_ets<span class="token operator">-</span>start_ms_no_ets<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">1000.0</span>
            <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; s.\n&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> start_ms_ets <span class="token operator">=</span>
    std<span class="token operator">::</span>chrono<span class="token operator">::</span>duration_cast<span class="token operator">&lt;</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span>milliseconds<span class="token operator">&gt;</span>
    <span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span>system_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">time_since_epoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Evaluation using ETs starts.\n&quot;</span><span class="token punctuation">;</span>
  
  expr<span class="token operator">::</span>terminal<span class="token operator">&lt;</span>Vector<span class="token operator">&lt;</span>dtype<span class="token operator">&gt;&gt;</span> <span class="token function">vec4</span><span class="token punctuation">(</span>vec1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  expr<span class="token operator">::</span>terminal<span class="token operator">&lt;</span>Vector<span class="token operator">&lt;</span>dtype<span class="token operator">&gt;&gt;</span> <span class="token function">vec5</span><span class="token punctuation">(</span>vec2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  expr<span class="token operator">::</span>terminal<span class="token operator">&lt;</span>Vector<span class="token operator">&lt;</span>dtype<span class="token operator">&gt;&gt;</span> <span class="token function">vec6</span><span class="token punctuation">(</span>vec3<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  Vector<span class="token operator">&lt;</span>dtype<span class="token operator">&gt;</span> result_ets <span class="token operator">=</span> <span class="token punctuation">(</span>vec4 <span class="token operator">+</span> vec5<span class="token operator">*</span>vec6<span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> stop_ms_ets <span class="token operator">=</span>
    std<span class="token operator">::</span>chrono<span class="token operator">::</span>duration_cast<span class="token operator">&lt;</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span>milliseconds<span class="token operator">&gt;</span>
    <span class="token punctuation">(</span>std<span class="token operator">::</span>chrono<span class="token operator">::</span>system_clock<span class="token operator">::</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">time_since_epoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span><span class="token function">setprecision</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>fixed
            <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;With ETs. Time eclapses: &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>stop_ms_ets<span class="token operator">-</span>start_ms_ets<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">1000.0</span>
            <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; s.\n&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
  
  <span class="token keyword">auto</span> ets_ret_type <span class="token operator">=</span> <span class="token punctuation">(</span>vec4 <span class="token operator">+</span> vec5<span class="token operator">*</span>vec6<span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;\nETs result's type:\n&quot;</span><span class="token punctuation">;</span>
  std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> boost<span class="token operator">::</span>core<span class="token operator">::</span><span class="token function">demangle</span><span class="token punctuation">(</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>ets_ret_type<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span> 

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Here's one possible output when compiled with <code>-O3 -std=c++14</code> using GCC 5.3:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>ctor called<span class="token punctuation">.</span>
ctor called<span class="token punctuation">.</span>
ctor called<span class="token punctuation">.</span>

No<span class="token operator">-</span>ETs evaluation starts<span class="token punctuation">.</span>
ctor called<span class="token punctuation">.</span>
ctor called<span class="token punctuation">.</span>
No<span class="token operator">-</span>ETs<span class="token punctuation">.</span> Time eclapses<span class="token operator">:</span> <span class="token number">0.571000</span> s<span class="token punctuation">.</span>

Evaluation <span class="token keyword">using</span> ETs starts<span class="token punctuation">.</span>
ctor called<span class="token punctuation">.</span>
With ETs<span class="token punctuation">.</span> Time eclapses<span class="token operator">:</span> <span class="token number">0.164000</span> s<span class="token punctuation">.</span>


ETs result<span class="token number">'</span>s type<span class="token operator">:</span>
expr<span class="token operator">::</span>binary_ops<span class="token operator">&lt;</span>expr<span class="token operator">::</span>vec_plus_t<span class="token punctuation">,</span> expr<span class="token operator">::</span>terminal<span class="token operator">&lt;</span>Vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span> <span class="token operator">&gt;</span><span class="token punctuation">,</span> expr<span class="token operator">::</span>binary_ops<span class="token operator">&lt;</span>expr<span class="token operator">::</span>vec_prod_t<span class="token punctuation">,</span> expr<span class="token operator">::</span>terminal<span class="token operator">&lt;</span>Vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span> <span class="token operator">&gt;</span><span class="token punctuation">,</span> expr<span class="token operator">::</span>terminal<span class="token operator">&lt;</span>Vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span> <span class="token operator">&gt;</span> <span class="token operator">&gt;</span> <span class="token operator">&gt;</span>

</code></pre></div><p>The observations are:</p> <ul><li>Using <strong>ETs</strong> achieves rather significant performance boost <strong>in this case</strong> ( &gt; 3x).</li> <li>Creation of temporary Vector object is eliminated. As in the <strong>ETs</strong> case, ctor is called only once.</li> <li>Boost::demangle was used to visualize the type of ETs return before conversion: it clearly constructed exactly the same expression graph demonstrated above.</li></ul> <p><strong>Draw-backs and caveats</strong></p> <li>
An obvious disadvantage of **ETs** is the learning curve, the complexity of implementation and code-maintenance difficulty. In the above example where only element-wise operations are considered, the implementation contains already enormous amount of boilerplates, let alone in real world, where more complex algebraic expressions occur in every computation and element-wise independence no longer hold (for example matrix multiplication), the difficulty will be exponential.
</li> <li>
Another caveat of using **ETs** is that they do play well with the `auto` keyword. As mentioned above, **PAE**s are essentially proxies: and proxies basically do not play well with `auto`. Consider the following example:
<div class="language-cpp extra-class"><pre class="language-cpp"><code> <span class="token keyword">auto</span> result <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>                <span class="token comment">// Some expensive expression: </span>
                                   <span class="token comment">// auto returns the expr graph, </span>
                                   <span class="token comment">// NOT the computed value.</span>
 <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
     ScalrType value <span class="token operator">=</span> result<span class="token operator">*</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">// Some other expensive computations using result.</span>

</code></pre></div></li> <p>Here <strong>in each iteration of the for loop, result will be re-evaluated</strong>, since the expression graph instead of the computed value is passed to the for loop.</p> <p>Existing libraries implementing <strong>ETs</strong></p> <ul><li><a href="http://www.boost.org/doc/libs/1_61_0/doc/html/proto.html" target="_blank" rel="noopener noreferrer"><strong>boost::proto</strong><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> is a powerful library letting you define your own rules &amp; grammars for your own expressions and execute using <strong>ETs</strong>.</li> <li><a href="http://eigen.tuxfamily.org/index.php?title=Main_Page" target="_blank" rel="noopener noreferrer"><strong>Eigen</strong><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> is a library for linear algebra that implements various algebraic computations efficiently using <strong>ETs</strong>.</li></ul></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/devtut/generate/edit/master/docs/cpp/expression-templates.md" target="_blank" rel="noopener noreferrer">Edit this page on GitHub</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ‚Üê
      <a href="/cpp/templates.html" class="prev">
        Templates
      </a></span> <span class="next"><a href="/cpp/curiously-recurring-template-pattern-crtp.html">
        Curiously Recurring Template Pattern (CRTP)
      </a>
      ‚Üí
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.ced448ab.js" defer></script><script src="/assets/js/3.f1d73125.js" defer></script><script src="/assets/js/649.26e8fdde.js" defer></script>
  </body>
</html>
