<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C++ | Optimization in C++</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="description" content="Introduction to performance, Empty Base Class Optimization, Optimizing by executing less code, Using efficient containers, Small Object Optimization">
    <meta property="og:site_name" content="DevTut">
    <meta property="og:title" content="C++ | Optimization in C++">
    <meta property="og:description" content="Introduction to performance, Empty Base Class Optimization, Optimizing by executing less code, Using efficient containers, Small Object Optimization">
    <meta property="og:type" content="article">
    <meta property="og:url" content="/cpp/optimization-in-c.html">
    <meta property="og:image" content="/logo.png">
    <meta name="twitter:title" content="C++ | Optimization in C++">
    <meta name="twitter:description" content="Introduction to performance, Empty Base Class Optimization, Optimizing by executing less code, Using efficient containers, Small Object Optimization">
    <meta name="twitter:url" content="/cpp/optimization-in-c.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="/logo.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/mstile-150x150.png">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="google-site-verification" content="76_rKXgwMVIjd-axJC_1zPV9OS4mEjvtgjYOWVkAdnQ">
    <link rel="preload" href="/assets/css/0.styles.8b877eb8.css" as="style"><link rel="preload" href="/assets/js/app.ced448ab.js" as="script"><link rel="preload" href="/assets/js/3.f1d73125.js" as="script"><link rel="preload" href="/assets/js/683.61b8f045.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.8b877eb8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">DevTut</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>C++</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/cpp/" class="sidebar-link">Disclaimer</a></li><li><a href="/cpp/getting-started-with-cpp.html" class="sidebar-link">Getting started with C++</a></li><li><a href="/cpp/literals.html" class="sidebar-link">Literals</a></li><li><a href="/cpp/operator-precedence.html" class="sidebar-link">operator precedence</a></li><li><a href="/cpp/floating-point-arithmetic.html" class="sidebar-link">Floating Point Arithmetic</a></li><li><a href="/cpp/bit-operators.html" class="sidebar-link">Bit Operators</a></li><li><a href="/cpp/bit-manipulation.html" class="sidebar-link">Bit Manipulation</a></li><li><a href="/cpp/bit-fields.html" class="sidebar-link">Bit fields</a></li><li><a href="/cpp/arrays.html" class="sidebar-link">Arrays</a></li><li><a href="/cpp/iterators.html" class="sidebar-link">Iterators</a></li><li><a href="/cpp/basic-input-output-in-c.html" class="sidebar-link">Basic input/output in c++</a></li><li><a href="/cpp/loops.html" class="sidebar-link">Loops</a></li><li><a href="/cpp/file-i-o.html" class="sidebar-link">File I/O</a></li><li><a href="/cpp/cpp-streams.html" class="sidebar-link">C++ Streams</a></li><li><a href="/cpp/stream-manipulators.html" class="sidebar-link">Stream manipulators</a></li><li><a href="/cpp/flow-control.html" class="sidebar-link">Flow Control</a></li><li><a href="/cpp/metaprogramming.html" class="sidebar-link">Metaprogramming</a></li><li><a href="/cpp/const-keyword.html" class="sidebar-link">const keyword</a></li><li><a href="/cpp/mutable-keyword.html" class="sidebar-link">mutable keyword</a></li><li><a href="/cpp/friend-keyword.html" class="sidebar-link">Friend keyword</a></li><li><a href="/cpp/type-keywords.html" class="sidebar-link">Type Keywords</a></li><li><a href="/cpp/basic-type-keywords.html" class="sidebar-link">Basic Type Keywords</a></li><li><a href="/cpp/variable-declaration-keywords.html" class="sidebar-link">Variable Declaration Keywords</a></li><li><a href="/cpp/keywords.html" class="sidebar-link">Keywords</a></li><li><a href="/cpp/returning-several-values-from-a-function.html" class="sidebar-link">Returning several values from a function</a></li><li><a href="/cpp/polymorphism.html" class="sidebar-link">Polymorphism</a></li><li><a href="/cpp/references.html" class="sidebar-link">References</a></li><li><a href="/cpp/value-and-reference-semantics.html" class="sidebar-link">Value and Reference Semantics</a></li><li><a href="/cpp/c-function-call-by-value-vs-call-by-reference.html" class="sidebar-link">C++ function &quot;call by value&quot; vs. &quot;call by reference&quot;</a></li><li><a href="/cpp/copying-vs-assignment.html" class="sidebar-link">Copying vs Assignment</a></li><li><a href="/cpp/pointers.html" class="sidebar-link">Pointers</a></li><li><a href="/cpp/pointers-to-members.html" class="sidebar-link">Pointers to members</a></li><li><a href="/cpp/the-this-pointer.html" class="sidebar-link">The This Pointer</a></li><li><a href="/cpp/smart-pointers.html" class="sidebar-link">Smart Pointers</a></li><li><a href="/cpp/classes-structures.html" class="sidebar-link">Classes/Structures</a></li><li><a href="/cpp/function-overloading.html" class="sidebar-link">Function Overloading</a></li><li><a href="/cpp/operator-overloading.html" class="sidebar-link">Operator Overloading</a></li><li><a href="/cpp/function-template-overloading.html" class="sidebar-link">Function Template Overloading</a></li><li><a href="/cpp/virtual-member-functions.html" class="sidebar-link">Virtual Member Functions</a></li><li><a href="/cpp/inline-functions.html" class="sidebar-link">Inline functions</a></li><li><a href="/cpp/special-member-functions.html" class="sidebar-link">Special Member Functions</a></li><li><a href="/cpp/non-static-member-functions.html" class="sidebar-link">Non-Static Member Functions</a></li><li><a href="/cpp/constant-class-member-functions.html" class="sidebar-link">Constant class member functions</a></li><li><a href="/cpp/c-containers.html" class="sidebar-link">C++ Containers</a></li><li><a href="/cpp/namespaces.html" class="sidebar-link">Namespaces</a></li><li><a href="/cpp/header-files.html" class="sidebar-link">Header Files</a></li><li><a href="/cpp/using-declaration.html" class="sidebar-link">Using declaration</a></li><li><a href="/cpp/std-string.html" class="sidebar-link">std::string</a></li><li><a href="/cpp/std-array.html" class="sidebar-link">std::array</a></li><li><a href="/cpp/std-vector.html" class="sidebar-link">std::vector</a></li><li><a href="/cpp/std-map.html" class="sidebar-link">std::map</a></li><li><a href="/cpp/std-optional.html" class="sidebar-link">std::optional</a></li><li><a href="/cpp/std-function-to-wrap-any-element-that-is-callable.html" class="sidebar-link">std::function: To wrap any element that is callable</a></li><li><a href="/cpp/std-forward-list.html" class="sidebar-link">std::forward_list</a></li><li><a href="/cpp/std-pair.html" class="sidebar-link">std::pair</a></li><li><a href="/cpp/std-atomics.html" class="sidebar-link">std::atomics</a></li><li><a href="/cpp/std-variant.html" class="sidebar-link">std::variant</a></li><li><a href="/cpp/std-iomanip.html" class="sidebar-link">std::iomanip</a></li><li><a href="/cpp/std-any.html" class="sidebar-link">std::any</a></li><li><a href="/cpp/std-set-and-std-multiset.html" class="sidebar-link">std::set and std::multiset</a></li><li><a href="/cpp/std-integer-sequence.html" class="sidebar-link">std::integer_sequence</a></li><li><a href="/cpp/using-std-unordered-map.html" class="sidebar-link">Using std::unordered_map</a></li><li><a href="/cpp/standard-library-algorithms.html" class="sidebar-link">Standard Library Algorithms</a></li><li><a href="/cpp/the-iso-c-standard.html" class="sidebar-link">The ISO C++ Standard</a></li><li><a href="/cpp/inline-variables.html" class="sidebar-link">Inline variables</a></li><li><a href="/cpp/random-number-generation.html" class="sidebar-link">Random number generation</a></li><li><a href="/cpp/date-and-time-using-chrono-header.html" class="sidebar-link">Date and time using  header</a></li><li><a href="/cpp/sorting.html" class="sidebar-link">Sorting</a></li><li><a href="/cpp/enumeration.html" class="sidebar-link">Enumeration</a></li><li><a href="/cpp/iteration.html" class="sidebar-link">Iteration</a></li><li><a href="/cpp/regular-expressions.html" class="sidebar-link">Regular expressions</a></li><li><a href="/cpp/implementation-defined-behavior.html" class="sidebar-link">Implementation-defined behavior</a></li><li><a href="/cpp/exceptions.html" class="sidebar-link">Exceptions</a></li><li><a href="/cpp/lambdas.html" class="sidebar-link">Lambdas</a></li><li><a href="/cpp/value-categories.html" class="sidebar-link">Value Categories</a></li><li><a href="/cpp/preprocessor.html" class="sidebar-link">Preprocessor</a></li><li><a href="/cpp/data-structures-in-c.html" class="sidebar-link">Data Structures in C++</a></li><li><a href="/cpp/templates.html" class="sidebar-link">Templates</a></li><li><a href="/cpp/expression-templates.html" class="sidebar-link">Expression templates</a></li><li><a href="/cpp/curiously-recurring-template-pattern-crtp.html" class="sidebar-link">Curiously Recurring Template Pattern (CRTP)</a></li><li><a href="/cpp/threading.html" class="sidebar-link">Threading</a></li><li><a href="/cpp/thread-synchronization-structures.html" class="sidebar-link">Thread synchronization structures</a></li><li><a href="/cpp/the-rule-of-three-five-and-zero.html" class="sidebar-link">The Rule of Three, Five, And Zero</a></li><li><a href="/cpp/raii-resource-acquisition-is-initialization.html" class="sidebar-link">RAII: Resource Acquisition Is Initialization</a></li><li><a href="/cpp/rtti-run-time-type-information.html" class="sidebar-link">RTTI: Run-Time Type Information</a></li><li><a href="/cpp/mutexes.html" class="sidebar-link">Mutexes</a></li><li><a href="/cpp/recursive-mutex.html" class="sidebar-link">Recursive Mutex</a></li><li><a href="/cpp/semaphore.html" class="sidebar-link">Semaphore</a></li><li><a href="/cpp/futures-and-promises.html" class="sidebar-link">Futures and Promises</a></li><li><a href="/cpp/atomic-types.html" class="sidebar-link">Atomic Types</a></li><li><a href="/cpp/type-erasure.html" class="sidebar-link">Type Erasure</a></li><li><a href="/cpp/explicit-type-conversions.html" class="sidebar-link">Explicit type conversions</a></li><li><a href="/cpp/unnamed-types.html" class="sidebar-link">Unnamed types</a></li><li><a href="/cpp/type-traits.html" class="sidebar-link">Type Traits</a></li><li><a href="/cpp/return-type-covariance.html" class="sidebar-link">Return Type Covariance</a></li><li><a href="/cpp/layout-of-object-types.html" class="sidebar-link">Layout of object types</a></li><li><a href="/cpp/type-inference.html" class="sidebar-link">Type Inference</a></li><li><a href="/cpp/typedef-and-type-aliases.html" class="sidebar-link">Typedef and type aliases</a></li><li><a href="/cpp/type-deduction.html" class="sidebar-link">type deduction</a></li><li><a href="/cpp/trailing-return-type.html" class="sidebar-link">Trailing return type</a></li><li><a href="/cpp/alignment.html" class="sidebar-link">Alignment</a></li><li><a href="/cpp/perfect-forwarding.html" class="sidebar-link">Perfect Forwarding</a></li><li><a href="/cpp/decltype.html" class="sidebar-link">decltype</a></li><li><a href="/cpp/sfinae-substitution-failure-is-not-an-error.html" class="sidebar-link">SFINAE (Substitution Failure Is Not An Error)</a></li><li><a href="/cpp/undefined-behavior.html" class="sidebar-link">Undefined Behavior</a></li><li><a href="/cpp/overload-resolution.html" class="sidebar-link">Overload resolution</a></li><li><a href="/cpp/move-semantics.html" class="sidebar-link">Move Semantics</a></li><li><a href="/cpp/pimpl-idiom.html" class="sidebar-link">Pimpl Idiom</a></li><li><a href="/cpp/auto.html" class="sidebar-link">auto</a></li><li><a href="/cpp/copy-elision.html" class="sidebar-link">Copy Elision</a></li><li><a href="/cpp/fold-expressions.html" class="sidebar-link">Fold Expressions</a></li><li><a href="/cpp/unions.html" class="sidebar-link">Unions</a></li><li><a href="/cpp/design-pattern-implementation-in-c.html" class="sidebar-link">Design pattern implementation in C++</a></li><li><a href="/cpp/singleton-design-pattern.html" class="sidebar-link">Singleton Design Pattern</a></li><li><a href="/cpp/user-defined-literals.html" class="sidebar-link">User-Defined Literals</a></li><li><a href="/cpp/memory-management.html" class="sidebar-link">Memory management</a></li><li><a href="/cpp/c-11-memory-model.html" class="sidebar-link">C++11 Memory Model</a></li><li><a href="/cpp/scopes.html" class="sidebar-link">Scopes</a></li><li><a href="/cpp/static-assert.html" class="sidebar-link">static_assert</a></li><li><a href="/cpp/constexpr.html" class="sidebar-link">constexpr</a></li><li><a href="/cpp/one-definition-rule-odr.html" class="sidebar-link">One Definition Rule (ODR)</a></li><li><a href="/cpp/unspecified-behavior.html" class="sidebar-link">Unspecified behavior</a></li><li><a href="/cpp/argument-dependent-name-lookup.html" class="sidebar-link">Argument Dependent Name Lookup</a></li><li><a href="/cpp/attributes.html" class="sidebar-link">Attributes</a></li><li><a href="/cpp/recursion-in-c.html" class="sidebar-link">Recursion in C++</a></li><li><a href="/cpp/arithmitic-metaprogramming.html" class="sidebar-link">Arithmitic Metaprogramming</a></li><li><a href="/cpp/callable-objects.html" class="sidebar-link">Callable Objects</a></li><li><a href="/cpp/client-server-examples.html" class="sidebar-link">Client server examples</a></li><li><a href="/cpp/const-correctness.html" class="sidebar-link">Const Correctness</a></li><li><a href="/cpp/parameter-packs.html" class="sidebar-link">Parameter packs</a></li><li><a href="/cpp/build-systems.html" class="sidebar-link">Build Systems</a></li><li><a href="/cpp/concurrency-with-openmp.html" class="sidebar-link">Concurrency With OpenMP</a></li><li><a href="/cpp/resource-management.html" class="sidebar-link">Resource Management</a></li><li><a href="/cpp/storage-class-specifiers.html" class="sidebar-link">Storage class specifiers</a></li><li><a href="/cpp/linkage-specifications.html" class="sidebar-link">Linkage specifications</a></li><li><a href="/cpp/digit-separators.html" class="sidebar-link">Digit separators</a></li><li><a href="/cpp/c-incompatibilities.html" class="sidebar-link">C incompatibilities</a></li><li><a href="/cpp/side-by-side-comparisons-of-classic-c-examples-solved-via-c-vs-c-11-vs-c-14-vs-c-17.html" class="sidebar-link">Side by Side Comparisons of classic C++ examples solved via C++ vs C++11 vs C++14 vs C++17</a></li><li><a href="/cpp/compiling-and-building.html" class="sidebar-link">Compiling and Building</a></li><li><a href="/cpp/common-compile-linker-errors-gcc.html" class="sidebar-link">Common compile/linker errors (GCC)</a></li><li><a href="/cpp/more-undefined-behaviors-in-c.html" class="sidebar-link">More undefined behaviors in C++</a></li><li><a href="/cpp/unit-testing-in-c.html" class="sidebar-link">Unit Testing in C++</a></li><li><a href="/cpp/c-debugging-and-debug-prevention-tools-techniques.html" class="sidebar-link">C++ Debugging and Debug-prevention Tools &amp; Techniques</a></li><li><a href="/cpp/optimization-in-c.html" class="active sidebar-link">Optimization in C++</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cpp/optimization-in-c.html#introduction-to-performance" class="sidebar-link">Introduction to performance</a></li><li class="sidebar-sub-header"><a href="/cpp/optimization-in-c.html#empty-base-class-optimization" class="sidebar-link">Empty Base Class Optimization</a></li><li class="sidebar-sub-header"><a href="/cpp/optimization-in-c.html#optimizing-by-executing-less-code" class="sidebar-link">Optimizing by executing less code</a></li><li class="sidebar-sub-header"><a href="/cpp/optimization-in-c.html#using-efficient-containers" class="sidebar-link">Using efficient containers</a></li><li class="sidebar-sub-header"><a href="/cpp/optimization-in-c.html#small-object-optimization" class="sidebar-link">Small Object Optimization</a></li></ul></li><li><a href="/cpp/optimization.html" class="sidebar-link">Optimization</a></li><li><a href="/cpp/profiling.html" class="sidebar-link">Profiling</a></li><li><a href="/cpp/refactoring-techniques.html" class="sidebar-link">Refactoring Techniques</a></li><li><a href="/cpp/internationalization-in-c.html" class="sidebar-link">Internationalization in C++</a></li><li><a href="/cpp/contributors.html" class="sidebar-link">The Contributors</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="optimization-in-c"><a href="#optimization-in-c" class="header-anchor">#</a> Optimization in C++</h1> <h2 id="introduction-to-performance"><a href="#introduction-to-performance" class="header-anchor">#</a> Introduction to performance</h2> <p>C and C++ are well known as high-performance languages - largely due to the heavy amount of code customization, allowing a user to specify performance by choice of structure.</p> <p>When optimizing it is important to benchmark relevant code and completely understand how the code will be used.</p> <p>Common optimization mistakes include:</p> <ul><li><strong>Premature optimization:</strong> Complex code may perform <strong>worse</strong> after optimization, wasting time and effort. First priority should be to write <strong>correct</strong> and <strong>maintainable</strong> code, rather than optimized code.</li> <li><strong>Optimization for the wrong use case:</strong> Adding overhead for the 1% might not be worth the slowdown for the other 99%</li> <li><strong>Micro-optimization:</strong> Compilers do this very efficiently and micro-optimization can even hurt the compilers ability to further optimize the code</li></ul> <p>Typical optimization goals are:</p> <ul><li>To do less work</li> <li>To use more efficient algorithms/structures</li> <li>To make better use of hardware</li></ul> <p>Optimized code can have negative side effects, including:</p> <ul><li>Higher memory usage</li> <li>Complex code -being difficult to read or maintain</li> <li>Compromised API and code design</li></ul> <h2 id="empty-base-class-optimization"><a href="#empty-base-class-optimization" class="header-anchor">#</a> Empty Base Class Optimization</h2> <p>An object cannot occupy less than 1 byte, as then the members of an array of this type would have the same address. Thus <code>sizeof(T)&gt;=1</code> always holds. It's also true that a derived class cannot be smaller than <strong>any of</strong> its base classes. However, when the base class is empty, its size is not necessarily added to the derived class:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token keyword">public</span> Base
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>In this case, it's not required to allocate a byte for <code>Base</code> within <code>Derived</code> to have a distinct address per type per object. If empty base class optimization is performed (and no padding is required), then <code>sizeof(Derived) == sizeof(int)</code>, that is, no additional allocation is done for the empty base. This is possible with multiple base classes as well (in C++, multiple bases cannot have the same type, so no issues arise from that).</p> <p>Note that this can only be performed if the first member of <code>Derived</code> differs in type from any of the base classes. This includes any direct or indirect common bases. If it's the same type as one of the bases (or there's a common base), at least allocating a single byte is required to ensure that no two distinct objects of the same type have the same address.</p> <h2 id="optimizing-by-executing-less-code"><a href="#optimizing-by-executing-less-code" class="header-anchor">#</a> Optimizing by executing less code</h2> <p>The most straightforward approach to optimizing is by executing less code. This approach usually gives a fixed speed-up without changing the time complexity of the code.</p> <p>Even though this approach gives you a clear speedup, this will only give noticable improvements when the code is called a lot.</p> <h3 id="removing-useless-code"><a href="#removing-useless-code" class="header-anchor">#</a> Removing useless code</h3> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">const</span> A <span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Some random function</span>

<span class="token comment">// useless memory allocation + deallocation for the instance</span>
<span class="token keyword">auto</span> a1 <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">func</span><span class="token punctuation">(</span>a1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

<span class="token comment">// making use of a stack object prevents </span>
<span class="token keyword">auto</span> a2 <span class="token operator">=</span> A<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">func</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a2<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>From C++14, compilers are allowed to optimize this code to remove the allocation and matching deallocation.</p> <h3 id="doing-code-only-once"><a href="#doing-code-only-once" class="header-anchor">#</a> Doing code only once</h3> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token operator">::</span>map<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token punctuation">,</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;&gt;</span> lookup<span class="token punctuation">;</span>
<span class="token comment">// Slow insertion/lookup</span>
<span class="token comment">// Within this function, we will traverse twice through the map lookup an element</span>
<span class="token comment">// and even a thirth time when it wasn't in</span>
<span class="token keyword">const</span> A <span class="token operator">*</span><span class="token function">lazyLookupSlow</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>lookup<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">!=</span> lookup<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        lookup<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> lookup<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Within this function, we will have the same noticeable effect as the slow variant while going at double speed as we only traverse once through the code</span>
<span class="token keyword">const</span> A <span class="token operator">*</span><span class="token function">lazyLookupSlow</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>string <span class="token operator">&amp;</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> <span class="token operator">&amp;</span>value <span class="token operator">=</span> lookup<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>value<span class="token punctuation">)</span>
        value <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> value<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>A similar approach to this optimization can be used to implement a stable version of <code>unique</code></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">&gt;</span> <span class="token function">stableUnique</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">&gt;</span> result<span class="token punctuation">;</span>
    std<span class="token operator">::</span>set<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">&gt;</span> checkUnique<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>s <span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// As insert returns if the insertion was successful, we can deduce if the element was already in or not</span>
        <span class="token comment">// This prevents an insertion, which will traverse through the map for every unique element</span>
        <span class="token comment">// As a result we can almost gain 50% if v would not contain any duplicates</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>checkUnique<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">)</span>
            result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="preventing-useless-reallocating-and-copying-moving"><a href="#preventing-useless-reallocating-and-copying-moving" class="header-anchor">#</a> Preventing useless reallocating and copying/moving</h3> <p>In the previous example, we already prevented lookups in the std::set, however the <code>std::vector</code> still contains a growing algorithm, in which it will have to realloc
its storage. This can be prevented by first reserving for the right size.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">&gt;</span> <span class="token function">stableUnique</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">&gt;</span> result<span class="token punctuation">;</span>
    <span class="token comment">// By reserving 'result', we can ensure that no copying or moving will be done in the vector</span>
    <span class="token comment">// as it will have capacity for the maximum number of elements we will be inserting</span>
    <span class="token comment">// If we make the assumption that no allocation occurs for size zero</span>
    <span class="token comment">// and allocating a large block of memory takes the same time as a small block of memory</span>
    <span class="token comment">// this will never slow down the program</span>
    <span class="token comment">// Side note: Compilers can even predict this and remove the checks the growing from the generated code</span>
    result<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>set<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">&gt;</span> checkUnique<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>s <span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// See example above</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>checkUnique<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">)</span>
            result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h2 id="using-efficient-containers"><a href="#using-efficient-containers" class="header-anchor">#</a> Using efficient containers</h2> <p>Optimizing by using the right data structures at the right time can change the time-complexity of the code.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// This variant of stableUnique contains a complexity of N log(N)</span>
<span class="token comment">// N &gt; number of elements in v</span>
<span class="token comment">// log(N) &gt; insert complexity of std::set</span>
std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">&gt;</span> <span class="token function">stableUnique</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">&gt;</span> result<span class="token punctuation">;</span>
    std<span class="token operator">::</span>set<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">&gt;</span> checkUnique<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>s <span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// See Optimizing by executing less code</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>checkUnique<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">)</span>
            result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>By using a container which uses a different implementation for storing its elements (hash container instead of tree), we can transform our implementation to complexity N.
As a side effect, we will call the comparison operator for std::string less, as it only has to be called when the inserted string should end up in the same bucket.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// This variant of stableUnique contains a complexity of N</span>
<span class="token comment">// N &gt; number of elements in v</span>
<span class="token comment">// 1 &gt; insert complexity of std::unordered_set</span>
std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">&gt;</span> <span class="token function">stableUnique</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">&gt;</span> result<span class="token punctuation">;</span>
    std<span class="token operator">::</span>unordered_set<span class="token operator">&lt;</span>std<span class="token operator">::</span>string<span class="token operator">&gt;</span> checkUnique<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>s <span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// See Optimizing by executing less code</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>checkUnique<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">)</span>
            result<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h2 id="small-object-optimization"><a href="#small-object-optimization" class="header-anchor">#</a> Small Object Optimization</h2> <p>Small object optimization is a technique which is used within low level data structures, for instance the <code>std::string</code> (Sometimes referred to as Short/Small String Optimization). It's meant to use stack space as a buffer instead of some allocated memory in case the content is small enough to fit within the reserved space.</p> <p>By adding extra memory overhead and extra calculations, it tries to prevent an expensive heap allocation. The benefits of this technique are dependent on the usage and can even hurt performance if incorrectly used.</p> <h3 id="example"><a href="#example" class="header-anchor">#</a> Example</h3> <p>A very naive way of implementing a string with this optimization would the following:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstring&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">string</span> final
<span class="token punctuation">{</span>
    <span class="token keyword">constexpr</span> <span class="token keyword">static</span> <span class="token keyword">auto</span> SMALL_BUFFER_SIZE <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>

    <span class="token keyword">bool</span> _isAllocated<span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                       <span class="token comment">///&lt; Remember if we allocated memory</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>_buffer<span class="token punctuation">{</span><span class="token keyword">nullptr</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                         <span class="token comment">///&lt; Pointer to the buffer we are using</span>
    <span class="token keyword">char</span> _smallBuffer<span class="token punctuation">[</span>SMALL_BUFFER_SIZE<span class="token punctuation">]</span><span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'\0'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment">///&lt; Stack space used for SMALL OBJECT OPTIMIZATION</span>

<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token operator">~</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>_isAllocated<span class="token punctuation">)</span>
            <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> _buffer<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>        

    <span class="token keyword">explicit</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>cStyleString<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">auto</span> stringSize <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">strlen</span><span class="token punctuation">(</span>cStyleString<span class="token punctuation">)</span><span class="token punctuation">;</span>
        _isAllocated <span class="token operator">=</span> <span class="token punctuation">(</span>stringSize <span class="token operator">&gt;</span> SMALL_BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>_isAllocated<span class="token punctuation">)</span>
            _buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>stringSize<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            _buffer <span class="token operator">=</span> <span class="token operator">&amp;</span>_smallBuffer<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        std<span class="token operator">::</span><span class="token function">strcpy</span><span class="token punctuation">(</span>_buffer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cStyleString<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">string</span><span class="token punctuation">(</span>string <span class="token operator">&amp;&amp;</span>rhs<span class="token punctuation">)</span>
       <span class="token operator">:</span> <span class="token function">_isAllocated</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>_isAllocated<span class="token punctuation">)</span>
       <span class="token punctuation">,</span> <span class="token function">_buffer</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>_buffer<span class="token punctuation">)</span>
       <span class="token punctuation">,</span> <span class="token function">_smallBuffer</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>_smallBuffer<span class="token punctuation">)</span> <span class="token comment">//&lt; Not needed if allocated</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>_isAllocated<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
           <span class="token comment">// Prevent double deletion of the memory</span>
           rhs<span class="token punctuation">.</span>_buffer <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span>
        <span class="token punctuation">{</span>
            <span class="token comment">// Copy over data</span>
            std<span class="token operator">::</span><span class="token function">strcpy</span><span class="token punctuation">(</span>_smallBuffer<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>_smallBuffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
            _buffer <span class="token operator">=</span> <span class="token operator">&amp;</span>_smallBuffer<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// Other methods, including other constructors, copy constructor,</span>
    <span class="token comment">// assignment operators have been omitted for readability</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>As you can see in the code above, some extra complexity has been added in order to prevent some <code>new</code> and <code>delete</code> operations. On top of this, the class has a larger memory footprint which might not be used except in a couple of cases.</p> <p>Often it is tried to encode the bool value <code>_isAllocated</code>, within the pointer <code>_buffer</code> with <a href="https://stackoverflow.com/documentation/c%2b%2b/3016/bit-manipulation" target="_blank" rel="noopener noreferrer">bit manipulation<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> to reduce the size of a single instance (intel 64 bit: Could reduce size by 8 byte). An optimization which is only possible when its known what the alignment rules of the platform is.</p> <h3 id="when-to-use"><a href="#when-to-use" class="header-anchor">#</a> When to use?</h3> <p>As this optimization adds a lot of complexity, it is not recommended to use this optimization on every single class. It will often be encountered in commonly used, low-level data structures. In common C++11 <code>standard library</code> implementations one can find usages in <a href="https://stackoverflow.com/documentation/c%2b%2b/488/stdstring" target="_blank" rel="noopener noreferrer"><code>std::basic_string&lt;&gt;</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> and <a href="https://stackoverflow.com/documentation/c%2b%2b/2294/stdfunction-to-wrap-any-element-that-is-callable" target="_blank" rel="noopener noreferrer"><code>std::function&lt;&gt;</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>.</p> <p>As this optimization only prevents memory allocations when the stored data is smaller than the buffer, it will only give benefits if the class is often used with small data.</p> <p>A final drawback of this optimization is that extra effort is required when moving the buffer, making the move-operation more expensive than when the buffer would not be used. This is especially true when the buffer contains a non-POD type.</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/devtut/generate/edit/master/docs/cpp/optimization-in-c.md" target="_blank" rel="noopener noreferrer">Edit this page on GitHub</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      
      <a href="/cpp/c-debugging-and-debug-prevention-tools-techniques.html" class="prev">
        C++ Debugging and Debug-prevention Tools &amp; Techniques
      </a></span> <span class="next"><a href="/cpp/optimization.html">
        Optimization
      </a>
      
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.ced448ab.js" defer></script><script src="/assets/js/3.f1d73125.js" defer></script><script src="/assets/js/683.61b8f045.js" defer></script>
  </body>
</html>
