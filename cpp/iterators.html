<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C++ | Iterators</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="description" content="Overview, Vector Iterator, Map Iterator, Reverse Iterators, Stream Iterators, C Iterators (Pointers), Write your own generator-backed iterator">
    <meta property="og:site_name" content="DevTut">
    <meta property="og:title" content="C++ | Iterators">
    <meta property="og:description" content="Overview, Vector Iterator, Map Iterator, Reverse Iterators, Stream Iterators, C Iterators (Pointers), Write your own generator-backed iterator">
    <meta property="og:type" content="article">
    <meta property="og:url" content="/cpp/iterators.html">
    <meta property="og:image" content="/logo.png">
    <meta name="twitter:title" content="C++ | Iterators">
    <meta name="twitter:description" content="Overview, Vector Iterator, Map Iterator, Reverse Iterators, Stream Iterators, C Iterators (Pointers), Write your own generator-backed iterator">
    <meta name="twitter:url" content="/cpp/iterators.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="/logo.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/mstile-150x150.png">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="google-site-verification" content="76_rKXgwMVIjd-axJC_1zPV9OS4mEjvtgjYOWVkAdnQ">
    <link rel="preload" href="/assets/css/0.styles.8b877eb8.css" as="style"><link rel="preload" href="/assets/js/app.ced448ab.js" as="script"><link rel="preload" href="/assets/js/3.f1d73125.js" as="script"><link rel="preload" href="/assets/js/665.9f04a9e6.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.8b877eb8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">DevTut</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>C++</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/cpp/" class="sidebar-link">Disclaimer</a></li><li><a href="/cpp/getting-started-with-cpp.html" class="sidebar-link">Getting started with C++</a></li><li><a href="/cpp/literals.html" class="sidebar-link">Literals</a></li><li><a href="/cpp/operator-precedence.html" class="sidebar-link">operator precedence</a></li><li><a href="/cpp/floating-point-arithmetic.html" class="sidebar-link">Floating Point Arithmetic</a></li><li><a href="/cpp/bit-operators.html" class="sidebar-link">Bit Operators</a></li><li><a href="/cpp/bit-manipulation.html" class="sidebar-link">Bit Manipulation</a></li><li><a href="/cpp/bit-fields.html" class="sidebar-link">Bit fields</a></li><li><a href="/cpp/arrays.html" class="sidebar-link">Arrays</a></li><li><a href="/cpp/iterators.html" class="active sidebar-link">Iterators</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cpp/iterators.html#overview" class="sidebar-link">Overview</a></li><li class="sidebar-sub-header"><a href="/cpp/iterators.html#vector-iterator" class="sidebar-link">Vector Iterator</a></li><li class="sidebar-sub-header"><a href="/cpp/iterators.html#map-iterator" class="sidebar-link">Map Iterator</a></li><li class="sidebar-sub-header"><a href="/cpp/iterators.html#reverse-iterators" class="sidebar-link">Reverse Iterators</a></li><li class="sidebar-sub-header"><a href="/cpp/iterators.html#stream-iterators" class="sidebar-link">Stream Iterators</a></li><li class="sidebar-sub-header"><a href="/cpp/iterators.html#c-iterators-pointers" class="sidebar-link">C Iterators (Pointers)</a></li><li class="sidebar-sub-header"><a href="/cpp/iterators.html#write-your-own-generator-backed-iterator" class="sidebar-link">Write your own generator-backed iterator</a></li></ul></li><li><a href="/cpp/basic-input-output-in-c.html" class="sidebar-link">Basic input/output in c++</a></li><li><a href="/cpp/loops.html" class="sidebar-link">Loops</a></li><li><a href="/cpp/file-i-o.html" class="sidebar-link">File I/O</a></li><li><a href="/cpp/cpp-streams.html" class="sidebar-link">C++ Streams</a></li><li><a href="/cpp/stream-manipulators.html" class="sidebar-link">Stream manipulators</a></li><li><a href="/cpp/flow-control.html" class="sidebar-link">Flow Control</a></li><li><a href="/cpp/metaprogramming.html" class="sidebar-link">Metaprogramming</a></li><li><a href="/cpp/const-keyword.html" class="sidebar-link">const keyword</a></li><li><a href="/cpp/mutable-keyword.html" class="sidebar-link">mutable keyword</a></li><li><a href="/cpp/friend-keyword.html" class="sidebar-link">Friend keyword</a></li><li><a href="/cpp/type-keywords.html" class="sidebar-link">Type Keywords</a></li><li><a href="/cpp/basic-type-keywords.html" class="sidebar-link">Basic Type Keywords</a></li><li><a href="/cpp/variable-declaration-keywords.html" class="sidebar-link">Variable Declaration Keywords</a></li><li><a href="/cpp/keywords.html" class="sidebar-link">Keywords</a></li><li><a href="/cpp/returning-several-values-from-a-function.html" class="sidebar-link">Returning several values from a function</a></li><li><a href="/cpp/polymorphism.html" class="sidebar-link">Polymorphism</a></li><li><a href="/cpp/references.html" class="sidebar-link">References</a></li><li><a href="/cpp/value-and-reference-semantics.html" class="sidebar-link">Value and Reference Semantics</a></li><li><a href="/cpp/c-function-call-by-value-vs-call-by-reference.html" class="sidebar-link">C++ function &quot;call by value&quot; vs. &quot;call by reference&quot;</a></li><li><a href="/cpp/copying-vs-assignment.html" class="sidebar-link">Copying vs Assignment</a></li><li><a href="/cpp/pointers.html" class="sidebar-link">Pointers</a></li><li><a href="/cpp/pointers-to-members.html" class="sidebar-link">Pointers to members</a></li><li><a href="/cpp/the-this-pointer.html" class="sidebar-link">The This Pointer</a></li><li><a href="/cpp/smart-pointers.html" class="sidebar-link">Smart Pointers</a></li><li><a href="/cpp/classes-structures.html" class="sidebar-link">Classes/Structures</a></li><li><a href="/cpp/function-overloading.html" class="sidebar-link">Function Overloading</a></li><li><a href="/cpp/operator-overloading.html" class="sidebar-link">Operator Overloading</a></li><li><a href="/cpp/function-template-overloading.html" class="sidebar-link">Function Template Overloading</a></li><li><a href="/cpp/virtual-member-functions.html" class="sidebar-link">Virtual Member Functions</a></li><li><a href="/cpp/inline-functions.html" class="sidebar-link">Inline functions</a></li><li><a href="/cpp/special-member-functions.html" class="sidebar-link">Special Member Functions</a></li><li><a href="/cpp/non-static-member-functions.html" class="sidebar-link">Non-Static Member Functions</a></li><li><a href="/cpp/constant-class-member-functions.html" class="sidebar-link">Constant class member functions</a></li><li><a href="/cpp/c-containers.html" class="sidebar-link">C++ Containers</a></li><li><a href="/cpp/namespaces.html" class="sidebar-link">Namespaces</a></li><li><a href="/cpp/header-files.html" class="sidebar-link">Header Files</a></li><li><a href="/cpp/using-declaration.html" class="sidebar-link">Using declaration</a></li><li><a href="/cpp/std-string.html" class="sidebar-link">std::string</a></li><li><a href="/cpp/std-array.html" class="sidebar-link">std::array</a></li><li><a href="/cpp/std-vector.html" class="sidebar-link">std::vector</a></li><li><a href="/cpp/std-map.html" class="sidebar-link">std::map</a></li><li><a href="/cpp/std-optional.html" class="sidebar-link">std::optional</a></li><li><a href="/cpp/std-function-to-wrap-any-element-that-is-callable.html" class="sidebar-link">std::function: To wrap any element that is callable</a></li><li><a href="/cpp/std-forward-list.html" class="sidebar-link">std::forward_list</a></li><li><a href="/cpp/std-pair.html" class="sidebar-link">std::pair</a></li><li><a href="/cpp/std-atomics.html" class="sidebar-link">std::atomics</a></li><li><a href="/cpp/std-variant.html" class="sidebar-link">std::variant</a></li><li><a href="/cpp/std-iomanip.html" class="sidebar-link">std::iomanip</a></li><li><a href="/cpp/std-any.html" class="sidebar-link">std::any</a></li><li><a href="/cpp/std-set-and-std-multiset.html" class="sidebar-link">std::set and std::multiset</a></li><li><a href="/cpp/std-integer-sequence.html" class="sidebar-link">std::integer_sequence</a></li><li><a href="/cpp/using-std-unordered-map.html" class="sidebar-link">Using std::unordered_map</a></li><li><a href="/cpp/standard-library-algorithms.html" class="sidebar-link">Standard Library Algorithms</a></li><li><a href="/cpp/the-iso-c-standard.html" class="sidebar-link">The ISO C++ Standard</a></li><li><a href="/cpp/inline-variables.html" class="sidebar-link">Inline variables</a></li><li><a href="/cpp/random-number-generation.html" class="sidebar-link">Random number generation</a></li><li><a href="/cpp/date-and-time-using-chrono-header.html" class="sidebar-link">Date and time using  header</a></li><li><a href="/cpp/sorting.html" class="sidebar-link">Sorting</a></li><li><a href="/cpp/enumeration.html" class="sidebar-link">Enumeration</a></li><li><a href="/cpp/iteration.html" class="sidebar-link">Iteration</a></li><li><a href="/cpp/regular-expressions.html" class="sidebar-link">Regular expressions</a></li><li><a href="/cpp/implementation-defined-behavior.html" class="sidebar-link">Implementation-defined behavior</a></li><li><a href="/cpp/exceptions.html" class="sidebar-link">Exceptions</a></li><li><a href="/cpp/lambdas.html" class="sidebar-link">Lambdas</a></li><li><a href="/cpp/value-categories.html" class="sidebar-link">Value Categories</a></li><li><a href="/cpp/preprocessor.html" class="sidebar-link">Preprocessor</a></li><li><a href="/cpp/data-structures-in-c.html" class="sidebar-link">Data Structures in C++</a></li><li><a href="/cpp/templates.html" class="sidebar-link">Templates</a></li><li><a href="/cpp/expression-templates.html" class="sidebar-link">Expression templates</a></li><li><a href="/cpp/curiously-recurring-template-pattern-crtp.html" class="sidebar-link">Curiously Recurring Template Pattern (CRTP)</a></li><li><a href="/cpp/threading.html" class="sidebar-link">Threading</a></li><li><a href="/cpp/thread-synchronization-structures.html" class="sidebar-link">Thread synchronization structures</a></li><li><a href="/cpp/the-rule-of-three-five-and-zero.html" class="sidebar-link">The Rule of Three, Five, And Zero</a></li><li><a href="/cpp/raii-resource-acquisition-is-initialization.html" class="sidebar-link">RAII: Resource Acquisition Is Initialization</a></li><li><a href="/cpp/rtti-run-time-type-information.html" class="sidebar-link">RTTI: Run-Time Type Information</a></li><li><a href="/cpp/mutexes.html" class="sidebar-link">Mutexes</a></li><li><a href="/cpp/recursive-mutex.html" class="sidebar-link">Recursive Mutex</a></li><li><a href="/cpp/semaphore.html" class="sidebar-link">Semaphore</a></li><li><a href="/cpp/futures-and-promises.html" class="sidebar-link">Futures and Promises</a></li><li><a href="/cpp/atomic-types.html" class="sidebar-link">Atomic Types</a></li><li><a href="/cpp/type-erasure.html" class="sidebar-link">Type Erasure</a></li><li><a href="/cpp/explicit-type-conversions.html" class="sidebar-link">Explicit type conversions</a></li><li><a href="/cpp/unnamed-types.html" class="sidebar-link">Unnamed types</a></li><li><a href="/cpp/type-traits.html" class="sidebar-link">Type Traits</a></li><li><a href="/cpp/return-type-covariance.html" class="sidebar-link">Return Type Covariance</a></li><li><a href="/cpp/layout-of-object-types.html" class="sidebar-link">Layout of object types</a></li><li><a href="/cpp/type-inference.html" class="sidebar-link">Type Inference</a></li><li><a href="/cpp/typedef-and-type-aliases.html" class="sidebar-link">Typedef and type aliases</a></li><li><a href="/cpp/type-deduction.html" class="sidebar-link">type deduction</a></li><li><a href="/cpp/trailing-return-type.html" class="sidebar-link">Trailing return type</a></li><li><a href="/cpp/alignment.html" class="sidebar-link">Alignment</a></li><li><a href="/cpp/perfect-forwarding.html" class="sidebar-link">Perfect Forwarding</a></li><li><a href="/cpp/decltype.html" class="sidebar-link">decltype</a></li><li><a href="/cpp/sfinae-substitution-failure-is-not-an-error.html" class="sidebar-link">SFINAE (Substitution Failure Is Not An Error)</a></li><li><a href="/cpp/undefined-behavior.html" class="sidebar-link">Undefined Behavior</a></li><li><a href="/cpp/overload-resolution.html" class="sidebar-link">Overload resolution</a></li><li><a href="/cpp/move-semantics.html" class="sidebar-link">Move Semantics</a></li><li><a href="/cpp/pimpl-idiom.html" class="sidebar-link">Pimpl Idiom</a></li><li><a href="/cpp/auto.html" class="sidebar-link">auto</a></li><li><a href="/cpp/copy-elision.html" class="sidebar-link">Copy Elision</a></li><li><a href="/cpp/fold-expressions.html" class="sidebar-link">Fold Expressions</a></li><li><a href="/cpp/unions.html" class="sidebar-link">Unions</a></li><li><a href="/cpp/design-pattern-implementation-in-c.html" class="sidebar-link">Design pattern implementation in C++</a></li><li><a href="/cpp/singleton-design-pattern.html" class="sidebar-link">Singleton Design Pattern</a></li><li><a href="/cpp/user-defined-literals.html" class="sidebar-link">User-Defined Literals</a></li><li><a href="/cpp/memory-management.html" class="sidebar-link">Memory management</a></li><li><a href="/cpp/c-11-memory-model.html" class="sidebar-link">C++11 Memory Model</a></li><li><a href="/cpp/scopes.html" class="sidebar-link">Scopes</a></li><li><a href="/cpp/static-assert.html" class="sidebar-link">static_assert</a></li><li><a href="/cpp/constexpr.html" class="sidebar-link">constexpr</a></li><li><a href="/cpp/one-definition-rule-odr.html" class="sidebar-link">One Definition Rule (ODR)</a></li><li><a href="/cpp/unspecified-behavior.html" class="sidebar-link">Unspecified behavior</a></li><li><a href="/cpp/argument-dependent-name-lookup.html" class="sidebar-link">Argument Dependent Name Lookup</a></li><li><a href="/cpp/attributes.html" class="sidebar-link">Attributes</a></li><li><a href="/cpp/recursion-in-c.html" class="sidebar-link">Recursion in C++</a></li><li><a href="/cpp/arithmitic-metaprogramming.html" class="sidebar-link">Arithmitic Metaprogramming</a></li><li><a href="/cpp/callable-objects.html" class="sidebar-link">Callable Objects</a></li><li><a href="/cpp/client-server-examples.html" class="sidebar-link">Client server examples</a></li><li><a href="/cpp/const-correctness.html" class="sidebar-link">Const Correctness</a></li><li><a href="/cpp/parameter-packs.html" class="sidebar-link">Parameter packs</a></li><li><a href="/cpp/build-systems.html" class="sidebar-link">Build Systems</a></li><li><a href="/cpp/concurrency-with-openmp.html" class="sidebar-link">Concurrency With OpenMP</a></li><li><a href="/cpp/resource-management.html" class="sidebar-link">Resource Management</a></li><li><a href="/cpp/storage-class-specifiers.html" class="sidebar-link">Storage class specifiers</a></li><li><a href="/cpp/linkage-specifications.html" class="sidebar-link">Linkage specifications</a></li><li><a href="/cpp/digit-separators.html" class="sidebar-link">Digit separators</a></li><li><a href="/cpp/c-incompatibilities.html" class="sidebar-link">C incompatibilities</a></li><li><a href="/cpp/side-by-side-comparisons-of-classic-c-examples-solved-via-c-vs-c-11-vs-c-14-vs-c-17.html" class="sidebar-link">Side by Side Comparisons of classic C++ examples solved via C++ vs C++11 vs C++14 vs C++17</a></li><li><a href="/cpp/compiling-and-building.html" class="sidebar-link">Compiling and Building</a></li><li><a href="/cpp/common-compile-linker-errors-gcc.html" class="sidebar-link">Common compile/linker errors (GCC)</a></li><li><a href="/cpp/more-undefined-behaviors-in-c.html" class="sidebar-link">More undefined behaviors in C++</a></li><li><a href="/cpp/unit-testing-in-c.html" class="sidebar-link">Unit Testing in C++</a></li><li><a href="/cpp/c-debugging-and-debug-prevention-tools-techniques.html" class="sidebar-link">C++ Debugging and Debug-prevention Tools &amp; Techniques</a></li><li><a href="/cpp/optimization-in-c.html" class="sidebar-link">Optimization in C++</a></li><li><a href="/cpp/optimization.html" class="sidebar-link">Optimization</a></li><li><a href="/cpp/profiling.html" class="sidebar-link">Profiling</a></li><li><a href="/cpp/refactoring-techniques.html" class="sidebar-link">Refactoring Techniques</a></li><li><a href="/cpp/internationalization-in-c.html" class="sidebar-link">Internationalization in C++</a></li><li><a href="/cpp/contributors.html" class="sidebar-link">The Contributors</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="iterators"><a href="#iterators" class="header-anchor">#</a> Iterators</h1> <h2 id="overview"><a href="#overview" class="header-anchor">#</a> Overview</h2> <h3 id="iterators-are-positions"><a href="#iterators-are-positions" class="header-anchor">#</a> Iterators are Positions</h3> <p>Iterators are a means of navigating and operating on a sequence of elements and are a generalized extension of pointers. Conceptually it is important to remember that iterators are positions, not elements. For example, take the following sequence:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>A B C

</code></pre></div><p>The sequence contains three elements and four positions</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>
<span class="token operator">|</span> A <span class="token operator">|</span> B <span class="token operator">|</span> C <span class="token operator">|</span>   <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>

</code></pre></div><p>Elements are things within a sequence. Positions are places where meaningful operations can happen to the sequence. For example, one inserts into a position, <strong>before</strong> or <strong>after</strong> element A, not into an element. Even deletion of an element (<code>erase(A)</code>) is done by first finding its position, then deleting it.</p> <h3 id="from-iterators-to-values"><a href="#from-iterators-to-values" class="header-anchor">#</a> From Iterators to Values</h3> <p>To convert from a position to a value, an iterator is <strong>dereferenced</strong>:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">auto</span> my_iterator <span class="token operator">=</span> my_vector<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// position</span>
<span class="token keyword">auto</span> my_value <span class="token operator">=</span> <span class="token operator">*</span>my_iterator<span class="token punctuation">;</span> <span class="token comment">// value</span>

</code></pre></div><p>One can think of an iterator as dereferencing to the value it refers to in the sequence. This is especially useful in understanding why you should never dereference the <code>end()</code> iterator in a sequence:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>
<span class="token operator">|</span> A <span class="token operator">|</span> B <span class="token operator">|</span> C <span class="token operator">|</span>   <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>
  ↑           ↑
  <span class="token operator">|</span>           <span class="token operator">+</span><span class="token operator">--</span> An iterator here has no value<span class="token punctuation">.</span> Do <span class="token operator">not</span> dereference it<span class="token operator">!</span>
  <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span> An iterator here dereferences to the value A<span class="token punctuation">.</span>

</code></pre></div><p>In all the sequences and containers found in the C++ standard library, <code>begin()</code> will return an iterator to the first position, and <code>end()</code> will return an iterator to one past the last position (<strong>not</strong> the last position!). Consequently, the names of these iterators in algorithms are oftentimes labelled <code>first</code> and <code>last</code>:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>
<span class="token operator">|</span> A <span class="token operator">|</span> B <span class="token operator">|</span> C <span class="token operator">|</span>   <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>
  ↑           ↑
  <span class="token operator">|</span>           <span class="token operator">|</span>
  <span class="token operator">+</span><span class="token operator">-</span> first    <span class="token operator">+</span><span class="token operator">-</span> last

</code></pre></div><p>It is also possible to obtain an iterator to <strong>any sequence</strong>, because even an empty sequence contains at least one position:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>
<span class="token operator">|</span>   <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>

</code></pre></div><p>In an empty sequence, <code>begin()</code> and <code>end()</code> will be the same position, and <strong>neither</strong> can be dereferenced:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>
<span class="token operator">|</span>   <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>
  ↑
  <span class="token operator">|</span>
  <span class="token operator">+</span><span class="token operator">-</span> empty_sequence<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token operator">|</span>
  <span class="token operator">+</span><span class="token operator">-</span> empty_sequence<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre></div><p>The alternative visualization of iterators is that they mark the positions <strong>between</strong> elements:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>
<span class="token operator">|</span> A <span class="token operator">|</span> B <span class="token operator">|</span> C <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>
↑   <span class="token operator">^</span>   <span class="token operator">^</span>   ↑
<span class="token operator">|</span>           <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">-</span> first    <span class="token operator">+</span><span class="token operator">-</span> last

</code></pre></div><p>and dereferencing an iterator returns a reference to the element coming after the iterator. Some situations where this view is particularly useful are:</p> <ul><li><code>insert</code> operations will insert elements into the position indicated by the iterator,</li> <li><code>erase</code> operations will return an iterator corresponding to the same position as the one passed in,</li> <li>an iterator and its corresponding <a href="https://stackoverflow.com/documentation/c%2B%2B/473/iterators/5101/reverse-iterators#t=201610021532190324666" target="_blank" rel="noopener noreferrer">reverse iterator<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> are located in the same .position between elements</li></ul> <h3 id="invalid-iterators"><a href="#invalid-iterators" class="header-anchor">#</a> Invalid Iterators</h3> <p>An iterator becomes <strong>invalidated</strong> if (say, in the course of an operation) its position is no longer a part of a sequence. An invalidated iterator cannot be dereferenced until it has been reassigned to a valid position. For example:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">::</span>iterator first<span class="token punctuation">;</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> foo<span class="token punctuation">;</span>
    first <span class="token operator">=</span> foo<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// first is now valid</span>
<span class="token punctuation">}</span> <span class="token comment">// foo falls out of scope and is destroyed</span>
<span class="token comment">// At this point first is now invalid</span>

</code></pre></div><p>The many algorithms and sequence member functions in the C++ standard library have rules governing when iterators are invalidated. Each algorithm is different in the way they treat (and invalidate) iterators.</p> <h3 id="navigating-with-iterators"><a href="#navigating-with-iterators" class="header-anchor">#</a> Navigating with Iterators</h3> <p>As we know, iterators are for navigating sequences. In order to do that an iterator must migrate its position throughout the sequence. Iterators can advance forward in the sequence and some can advance backwards:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">auto</span> first <span class="token operator">=</span> my_vector<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">++</span>first<span class="token punctuation">;</span>                                             <span class="token comment">// advance the iterator 1 position</span>
std<span class="token operator">::</span><span class="token function">advance</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                              <span class="token comment">// advance the iterator 1 position</span>
first <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">next</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">// returns iterator to the next element</span>
std<span class="token operator">::</span><span class="token function">advance</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                             <span class="token comment">// advance the iterator 1 position backwards</span>
first <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">next</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment">// returns iterator to the element 20 position forward</span>
first <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">prev</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">// returns iterator to the element 5 position backward</span>
<span class="token keyword">auto</span> dist <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">distance</span><span class="token punctuation">(</span>my_vector<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> first<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// returns distance between two iterators.</span>

</code></pre></div><p>Note, second argument of std::distance should be reachable from the first one(or, in other words <code>first</code> should be less or equal than <code>second</code>).</p> <p>Even though you can perform arithmetic operators with iterators, not all operations are defined for all types of iterators. <code>a = b + 3;</code> would work for Random Access Iterators, but wouldn't work for Forward or Bidirectional Iterators, which still can be advanced by 3 position with something like <code>b = a; ++b; ++b; ++b;</code>. So it is recommended to use special functions in case you are not sure what is iterator type (for example, in a template function accepting iterator).</p> <h3 id="iterator-concepts"><a href="#iterator-concepts" class="header-anchor">#</a> Iterator Concepts</h3> <p>The C++ standard describes several different iterator concepts. These are grouped according to how they behave in the sequences they refer to. If you know the concept an iterator <strong>models</strong> (behaves like), you can be assured of the behavior of that iterator <strong>regardless of the sequence to which it belongs</strong>. They are often described in order from the most to least restrictive (because the next iterator concept is a step better than its predecessor):</p> <ul><li>Input Iterators                    : Can be dereferenced <strong>only once</strong> per position. Can only advance, and only one position at a time.</li> <li>Forward Iterators                  : An input iterator that can be dereferenced any number of times.</li> <li>Bidirectional Iterators            : A forward iterator that can also advance <strong>backwards</strong> one position at a time.</li> <li>Random Access Iterators            : A bidirectional iterator that can advance forwards or backwards any number of positions at a time.</li> <li>Contiguous Iterators (since C++17) : A random access iterator that guaranties that underlying data is contiguous in memory.</li></ul> <p>Algorithms can vary depending on the concept modeled by the iterators they are given. For example, although <code>random_shuffle</code> can be implemented for forward iterators, a more efficient variant that requires random access iterators could be provided.</p> <h3 id="iterator-traits"><a href="#iterator-traits" class="header-anchor">#</a> Iterator traits</h3> <p>Iterator traits provide uniform interface to the properties of iterators. They allow you to retrieve value, difference, pointer, reference types and also category of iterator:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Iter</span><span class="token operator">&gt;</span>
Iter <span class="token function">find</span><span class="token punctuation">(</span>Iter first<span class="token punctuation">,</span> Iter last<span class="token punctuation">,</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>iterator_traits<span class="token operator">&lt;</span>Iter<span class="token operator">&gt;</span><span class="token operator">::</span>value_type val<span class="token punctuation">)</span>  <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> last<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>first <span class="token operator">==</span> val<span class="token punctuation">)</span>
            <span class="token keyword">return</span> first<span class="token punctuation">;</span>
        <span class="token operator">++</span>first<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> last<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Category of iterator can be used to specialize algorithms:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">BidirIt</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>BidirIt a<span class="token punctuation">,</span> std<span class="token operator">::</span>bidirectional_iterator_tag<span class="token punctuation">)</span>  <span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Bidirectional iterator is used&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">ForwIt</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>ForwIt a<span class="token punctuation">,</span> std<span class="token operator">::</span>forward_iterator_tag<span class="token punctuation">)</span>  <span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Forward iterator is used&quot;</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Iter</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>Iter a<span class="token punctuation">)</span>  <span class="token punctuation">{</span>
    <span class="token function">test</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>iterator_traits<span class="token operator">&lt;</span>Iter<span class="token operator">&gt;</span><span class="token operator">::</span><span class="token function">iterator_category</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Categories of iterators are basically iterators concepts, except Contiguous Iterators don't have their own tag, since it was found to break code.</p> <h2 id="vector-iterator"><a href="#vector-iterator" class="header-anchor">#</a> Vector Iterator</h2> <p><code>begin</code> returns an <code>iterator</code> to the first element in the sequence container.</p> <p><code>end</code> returns an <code>iterator</code> to the first element past the end.</p> <p>If the vector object is <code>const</code>, both <code>begin</code> and <code>end</code> return a <code>const_iterator</code>. If you want a <code>const_iterator</code> to be returned even if your vector is not <code>const</code>, you can use <code>cbegin</code> and <code>cend</code>.</p> <p>Example:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">//intialize vector using an initializer_list</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">::</span>iterator it <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Output:</p> <blockquote></blockquote> <p>1 2 3 4 5</p> <h2 id="map-iterator"><a href="#map-iterator" class="header-anchor">#</a> Map Iterator</h2> <p>An iterator to the first element in the container.</p> <p>If a map object is const-qualified, the function returns a <code>const_iterator</code>. Otherwise, it returns an <code>iterator</code>.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// Create a map and insert some values</span>
std<span class="token operator">::</span>map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;</span> mymap<span class="token punctuation">;</span>
mymap<span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
mymap<span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
mymap<span class="token punctuation">[</span><span class="token string">'c'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span>

<span class="token comment">// Iterate over all tuples</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>map<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">::</span>iterator it <span class="token operator">=</span> mymap<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> mymap<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> it<span class="token operator">-&gt;</span>first <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; =&gt; &quot;</span> <span class="token operator">&lt;&lt;</span> it<span class="token operator">-&gt;</span>second <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>

</code></pre></div><p>Output:</p> <blockquote></blockquote> <p>a =&gt; 200<br>
b =&gt; 100<br>
c =&gt; 300</p> <h2 id="reverse-iterators"><a href="#reverse-iterators" class="header-anchor">#</a> Reverse Iterators</h2> <p>If we want to iterate backwards through a list or vector we can use a <code>reverse_iterator</code>. A reverse iterator is made from a bidirectional, or random access iterator which it keeps as a member which can be accessed through <code>base()</code>.</p> <p>To iterate backwards use <code>rbegin()</code> and <code>rend()</code> as the iterators for the end of the collection, and the start of the collection respectively.</p> <p>For instance, to iterate backwards use:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">::</span>reverse_iterator it <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> it <span class="token operator">!=</span> v<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>it<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>it<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// prints 54321</span>

</code></pre></div><p>A reverse iterator can be converted to a forward iterator via the <code>base()</code> member function. The relationship is that the reverse iterator references one element past the <code>base()</code> iterator:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">::</span>reverse_iterator r <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">::</span>iterator i <span class="token operator">=</span> r<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token operator">*</span>r <span class="token operator">==</span> <span class="token operator">&amp;</span><span class="token operator">*</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// always true if r, (i-1) are dereferenceable</span>
                        <span class="token comment">// and are not proxy iterators</span>

 <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>
 <span class="token operator">|</span>   <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token number">3</span> <span class="token operator">|</span> <span class="token number">4</span> <span class="token operator">|</span> <span class="token number">5</span> <span class="token operator">|</span>   <span class="token operator">|</span>
 <span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">--</span><span class="token operator">-</span><span class="token operator">+</span>
   ↑   ↑               ↑   ↑
   <span class="token operator">|</span>   <span class="token operator">|</span>               <span class="token operator">|</span>   <span class="token operator">|</span>
<span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">|</span>         <span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
       <span class="token operator">|</span>                   <span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre></div><p>In the visualization where iterators mark positions between elements, the relationship is simpler:</p> <div class="language- extra-class"><pre class="language-text"><code>
 +---+---+---+---+---+
  | 1 | 2 | 3 | 4 | 5 |
  +---+---+---+---+---+
  ↑                   ↑
  |                   |
  |                 end()
  |                 rbegin()
begin()             rbegin().base()
rend()
rend().base()

</code></pre></div><h2 id="stream-iterators"><a href="#stream-iterators" class="header-anchor">#</a> Stream Iterators</h2> <p>Stream iterators are useful when we need to read a sequence or print formatted data from a container:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// Data stream. Any number of various whitespace characters will be OK.</span>
std<span class="token operator">::</span>istringstream <span class="token function">istr</span><span class="token punctuation">(</span><span class="token string">&quot;1\t 2     3 4&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>

<span class="token comment">// Constructing stream iterators and copying data from stream into vector.</span>
std<span class="token operator">::</span><span class="token function">copy</span><span class="token punctuation">(</span>
    <span class="token comment">// Iterator which will read stream data as integers.</span>
    std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>istr<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">// Default constructor produces end-of-stream iterator.</span>
    std<span class="token operator">::</span>istream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    std<span class="token operator">::</span><span class="token function">back_inserter</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Print vector contents.</span>
std<span class="token operator">::</span><span class="token function">copy</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token comment">//Will print values to standard output as integers delimeted by &quot; -- &quot;.</span>
    std<span class="token operator">::</span>ostream_iterator<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>std<span class="token operator">::</span>cout<span class="token punctuation">,</span> <span class="token string">&quot; -- &quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>The example program will print <code>1 -- 2 -- 3 -- 4 --</code> to standard output.</p> <h2 id="c-iterators-pointers"><a href="#c-iterators-pointers" class="header-anchor">#</a> C Iterators (Pointers)</h2> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// This creates an array with 5 values.</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token macro property">#<span class="token directive keyword">ifdef</span> BEFORE_CPP11</span>

<span class="token comment">// You can use `sizeof` to determine how many elements are in an array.</span>
<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> first <span class="token operator">=</span> array<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> afterLast <span class="token operator">=</span> first <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Then you can iterate over the array by incrementing a pointer until</span>
<span class="token comment">// it reaches past the end of our array.</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> i <span class="token operator">=</span> first<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> afterLast<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>i <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token macro property">#<span class="token directive keyword">else</span></span>

<span class="token comment">// With C++11, you can let the STL compute the start and end iterators:</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">begin</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> std<span class="token operator">::</span><span class="token function">end</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>i <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token macro property">#<span class="token directive keyword">endif</span></span>

</code></pre></div><p>This code would output the numbers 1 through 5, one on each line like this:</p> <blockquote></blockquote> <p>1<br>
2<br>
3<br>
4<br>
5</p> <h3 id="breaking-it-down"><a href="#breaking-it-down" class="header-anchor">#</a> Breaking It Down</h3> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>This line creates a new integer array with 5 values. C arrays are just pointers to memory where each value is stored together in a contiguous block.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> first <span class="token operator">=</span> array<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> afterLast <span class="token operator">=</span> first <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>These lines create two pointers. The first pointer is given the value of the array pointer, which is the address of the first element in the array. The <code>sizeof</code> operator when used on a C array returns the size of the array in bytes. Divided by the size of an element this gives the number of elements in the array. We can use this to find the address of the block <strong>after</strong> the array.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> i <span class="token operator">=</span> first<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> afterLast<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>

</code></pre></div><p>Here we create a pointer which we will use as an iterator. It is initialized with the address of the first element we want to iterate over, and we'll continue to iterate as long as <code>i</code> is less than <code>afterLast</code>, which means as long as <code>i</code> is pointing to an address within <code>array</code>.</p> <div class="language- extra-class"><pre class="language-text"><code>
   std::cout &lt;&lt; *i &lt;&lt; std::endl;

</code></pre></div><p>Finally, within the loop we can access the value our iterator <code>i</code> is pointing to by dereferencing it. Here the dereference operator <code>*</code> returns the value at the address in <code>i</code>.</p> <h2 id="write-your-own-generator-backed-iterator"><a href="#write-your-own-generator-backed-iterator" class="header-anchor">#</a> Write your own generator-backed iterator</h2> <p>A common pattern in other languages is having a function that produces a &quot;stream&quot; of objects, and being able to use loop-code to loop over it.</p> <p>We can model this in C++ as</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">generator_iterator</span> <span class="token punctuation">{</span>
  <span class="token keyword">using</span> difference_type<span class="token operator">=</span>std<span class="token operator">::</span>ptrdiff_t<span class="token punctuation">;</span>
  <span class="token keyword">using</span> value_type<span class="token operator">=</span>T<span class="token punctuation">;</span>
  <span class="token keyword">using</span> pointer<span class="token operator">=</span>T<span class="token operator">*</span><span class="token punctuation">;</span>
  <span class="token keyword">using</span> reference<span class="token operator">=</span>T<span class="token punctuation">;</span>
  <span class="token keyword">using</span> iterator_category<span class="token operator">=</span>std<span class="token operator">::</span>input_iterator_tag<span class="token punctuation">;</span>
  std<span class="token operator">::</span>optional<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> state<span class="token punctuation">;</span>
  std<span class="token operator">::</span>function<span class="token operator">&lt;</span> std<span class="token operator">::</span>optional<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> operation<span class="token punctuation">;</span>
  <span class="token comment">// we store the current element in &quot;state&quot; if we have one:</span>
  T <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">*</span>state<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// to advance, we invoke our operation.  If it returns a nullopt</span>
  <span class="token comment">// we have reached the end:</span>
  generator_iterator<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    state <span class="token operator">=</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>        
  <span class="token punctuation">}</span>
  generator_iterator <span class="token keyword">operator</span><span class="token operator">++</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> r <span class="token operator">=</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token operator">++</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> r<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// generator iterators are only equal if they are both in the &quot;end&quot; state:</span>
  <span class="token keyword">friend</span> <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span> generator_iterator <span class="token keyword">const</span><span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> generator_iterator <span class="token keyword">const</span><span class="token operator">&amp;</span> rhs <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>lhs<span class="token punctuation">.</span>state <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>rhs<span class="token punctuation">.</span>state<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">friend</span> <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span> generator_iterator <span class="token keyword">const</span><span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> generator_iterator <span class="token keyword">const</span><span class="token operator">&amp;</span> rhs <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span>lhs<span class="token operator">==</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// We implicitly construct from a std::function with the right signature:</span>
  <span class="token function">generator_iterator</span><span class="token punctuation">(</span> std<span class="token operator">::</span>function<span class="token operator">&lt;</span> std<span class="token operator">::</span>optional<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> f <span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">operation</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>operation<span class="token punctuation">)</span>
      state <span class="token operator">=</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// default all special member functions:</span>
  <span class="token function">generator_iterator</span><span class="token punctuation">(</span> generator_iterator <span class="token operator">&amp;&amp;</span> <span class="token punctuation">)</span> <span class="token operator">=</span><span class="token keyword">default</span><span class="token punctuation">;</span>
  <span class="token function">generator_iterator</span><span class="token punctuation">(</span> generator_iterator <span class="token keyword">const</span><span class="token operator">&amp;</span> <span class="token punctuation">)</span> <span class="token operator">=</span><span class="token keyword">default</span><span class="token punctuation">;</span>
  generator_iterator<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span> generator_iterator <span class="token operator">&amp;&amp;</span> <span class="token punctuation">)</span> <span class="token operator">=</span><span class="token keyword">default</span><span class="token punctuation">;</span>
  generator_iterator<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span> generator_iterator <span class="token keyword">const</span><span class="token operator">&amp;</span> <span class="token punctuation">)</span> <span class="token operator">=</span><span class="token keyword">default</span><span class="token punctuation">;</span>
  <span class="token function">generator_iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p><a href="http://coliru.stacked-crooked.com/a/cbb93f9ff193cdba" target="_blank" rel="noopener noreferrer">live example<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>.</p> <p>We store the generated element early so we can more easily detect if we are already at the end.</p> <p>As the function of an end generator iterator is never used, we can create a range of generator iterators by only copying the <code>std::function</code> once.  A default constructed generator iterator compares equal to itself, and to all other end-generator-iterators.</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/devtut/generate/edit/master/docs/cpp/iterators.md" target="_blank" rel="noopener noreferrer">Edit this page on GitHub</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/cpp/arrays.html" class="prev">
        Arrays
      </a></span> <span class="next"><a href="/cpp/basic-input-output-in-c.html">
        Basic input/output in c++
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.ced448ab.js" defer></script><script src="/assets/js/3.f1d73125.js" defer></script><script src="/assets/js/665.9f04a9e6.js" defer></script>
  </body>
</html>
