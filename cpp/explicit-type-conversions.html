<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C++ | Explicit type conversions</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="description" content="Casting away constness, C-style casting, Base to derived conversion, Conversion between pointer and integer, Type punning conversion, Conversion by explicit constructor or explicit conversion function, Implicit conversion, Enum conversions, Derived to base conversion for pointers to members, void* to T*">
    <meta property="og:site_name" content="DevTut">
    <meta property="og:title" content="C++ | Explicit type conversions">
    <meta property="og:description" content="Casting away constness, C-style casting, Base to derived conversion, Conversion between pointer and integer, Type punning conversion, Conversion by explicit constructor or explicit conversion function, Implicit conversion, Enum conversions, Derived to base conversion for pointers to members, void* to T*">
    <meta property="og:type" content="article">
    <meta property="og:url" content="/cpp/explicit-type-conversions.html">
    <meta property="og:image" content="/logo.png">
    <meta name="twitter:title" content="C++ | Explicit type conversions">
    <meta name="twitter:description" content="Casting away constness, C-style casting, Base to derived conversion, Conversion between pointer and integer, Type punning conversion, Conversion by explicit constructor or explicit conversion function, Implicit conversion, Enum conversions, Derived to base conversion for pointers to members, void* to T*">
    <meta name="twitter:url" content="/cpp/explicit-type-conversions.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="/logo.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/mstile-150x150.png">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="google-site-verification" content="76_rKXgwMVIjd-axJC_1zPV9OS4mEjvtgjYOWVkAdnQ">
    
    <link rel="preload" href="/assets/css/0.styles.60619e34.css" as="style"><link rel="preload" href="/assets/js/app.1779e102.js" as="script"><link rel="preload" href="/assets/js/3.2cfa8016.js" as="script"><link rel="preload" href="/assets/js/650.bef042b9.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.60619e34.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">DevTut</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>C++</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/cpp/" aria-current="page" class="sidebar-link">Disclaimer</a></li><li><a href="/cpp/getting-started-with-cpp.html" class="sidebar-link">Getting started with C++</a></li><li><a href="/cpp/literals.html" class="sidebar-link">Literals</a></li><li><a href="/cpp/operator-precedence.html" class="sidebar-link">operator precedence</a></li><li><a href="/cpp/floating-point-arithmetic.html" class="sidebar-link">Floating Point Arithmetic</a></li><li><a href="/cpp/bit-operators.html" class="sidebar-link">Bit Operators</a></li><li><a href="/cpp/bit-manipulation.html" class="sidebar-link">Bit Manipulation</a></li><li><a href="/cpp/bit-fields.html" class="sidebar-link">Bit fields</a></li><li><a href="/cpp/arrays.html" class="sidebar-link">Arrays</a></li><li><a href="/cpp/iterators.html" class="sidebar-link">Iterators</a></li><li><a href="/cpp/basic-input-output-in-c.html" class="sidebar-link">Basic input/output in c++</a></li><li><a href="/cpp/loops.html" class="sidebar-link">Loops</a></li><li><a href="/cpp/file-i-o.html" class="sidebar-link">File I/O</a></li><li><a href="/cpp/cpp-streams.html" class="sidebar-link">C++ Streams</a></li><li><a href="/cpp/stream-manipulators.html" class="sidebar-link">Stream manipulators</a></li><li><a href="/cpp/flow-control.html" class="sidebar-link">Flow Control</a></li><li><a href="/cpp/metaprogramming.html" class="sidebar-link">Metaprogramming</a></li><li><a href="/cpp/const-keyword.html" class="sidebar-link">const keyword</a></li><li><a href="/cpp/mutable-keyword.html" class="sidebar-link">mutable keyword</a></li><li><a href="/cpp/friend-keyword.html" class="sidebar-link">Friend keyword</a></li><li><a href="/cpp/type-keywords.html" class="sidebar-link">Type Keywords</a></li><li><a href="/cpp/basic-type-keywords.html" class="sidebar-link">Basic Type Keywords</a></li><li><a href="/cpp/variable-declaration-keywords.html" class="sidebar-link">Variable Declaration Keywords</a></li><li><a href="/cpp/keywords.html" class="sidebar-link">Keywords</a></li><li><a href="/cpp/returning-several-values-from-a-function.html" class="sidebar-link">Returning several values from a function</a></li><li><a href="/cpp/polymorphism.html" class="sidebar-link">Polymorphism</a></li><li><a href="/cpp/references.html" class="sidebar-link">References</a></li><li><a href="/cpp/value-and-reference-semantics.html" class="sidebar-link">Value and Reference Semantics</a></li><li><a href="/cpp/c-function-call-by-value-vs-call-by-reference.html" class="sidebar-link">C++ function &quot;call by value&quot; vs. &quot;call by reference&quot;</a></li><li><a href="/cpp/copying-vs-assignment.html" class="sidebar-link">Copying vs Assignment</a></li><li><a href="/cpp/pointers.html" class="sidebar-link">Pointers</a></li><li><a href="/cpp/pointers-to-members.html" class="sidebar-link">Pointers to members</a></li><li><a href="/cpp/the-this-pointer.html" class="sidebar-link">The This Pointer</a></li><li><a href="/cpp/smart-pointers.html" class="sidebar-link">Smart Pointers</a></li><li><a href="/cpp/classes-structures.html" class="sidebar-link">Classes/Structures</a></li><li><a href="/cpp/function-overloading.html" class="sidebar-link">Function Overloading</a></li><li><a href="/cpp/operator-overloading.html" class="sidebar-link">Operator Overloading</a></li><li><a href="/cpp/function-template-overloading.html" class="sidebar-link">Function Template Overloading</a></li><li><a href="/cpp/virtual-member-functions.html" class="sidebar-link">Virtual Member Functions</a></li><li><a href="/cpp/inline-functions.html" class="sidebar-link">Inline functions</a></li><li><a href="/cpp/special-member-functions.html" class="sidebar-link">Special Member Functions</a></li><li><a href="/cpp/non-static-member-functions.html" class="sidebar-link">Non-Static Member Functions</a></li><li><a href="/cpp/constant-class-member-functions.html" class="sidebar-link">Constant class member functions</a></li><li><a href="/cpp/c-containers.html" class="sidebar-link">C++ Containers</a></li><li><a href="/cpp/namespaces.html" class="sidebar-link">Namespaces</a></li><li><a href="/cpp/header-files.html" class="sidebar-link">Header Files</a></li><li><a href="/cpp/using-declaration.html" class="sidebar-link">Using declaration</a></li><li><a href="/cpp/std-string.html" class="sidebar-link">std::string</a></li><li><a href="/cpp/std-array.html" class="sidebar-link">std::array</a></li><li><a href="/cpp/std-vector.html" class="sidebar-link">std::vector</a></li><li><a href="/cpp/std-map.html" class="sidebar-link">std::map</a></li><li><a href="/cpp/std-optional.html" class="sidebar-link">std::optional</a></li><li><a href="/cpp/std-function-to-wrap-any-element-that-is-callable.html" class="sidebar-link">std::function: To wrap any element that is callable</a></li><li><a href="/cpp/std-forward-list.html" class="sidebar-link">std::forward_list</a></li><li><a href="/cpp/std-pair.html" class="sidebar-link">std::pair</a></li><li><a href="/cpp/std-atomics.html" class="sidebar-link">std::atomics</a></li><li><a href="/cpp/std-variant.html" class="sidebar-link">std::variant</a></li><li><a href="/cpp/std-iomanip.html" class="sidebar-link">std::iomanip</a></li><li><a href="/cpp/std-any.html" class="sidebar-link">std::any</a></li><li><a href="/cpp/std-set-and-std-multiset.html" class="sidebar-link">std::set and std::multiset</a></li><li><a href="/cpp/std-integer-sequence.html" class="sidebar-link">std::integer_sequence</a></li><li><a href="/cpp/using-std-unordered-map.html" class="sidebar-link">Using std::unordered_map</a></li><li><a href="/cpp/standard-library-algorithms.html" class="sidebar-link">Standard Library Algorithms</a></li><li><a href="/cpp/the-iso-c-standard.html" class="sidebar-link">The ISO C++ Standard</a></li><li><a href="/cpp/inline-variables.html" class="sidebar-link">Inline variables</a></li><li><a href="/cpp/random-number-generation.html" class="sidebar-link">Random number generation</a></li><li><a href="/cpp/date-and-time-using-chrono-header.html" class="sidebar-link">Date and time using  header</a></li><li><a href="/cpp/sorting.html" class="sidebar-link">Sorting</a></li><li><a href="/cpp/enumeration.html" class="sidebar-link">Enumeration</a></li><li><a href="/cpp/iteration.html" class="sidebar-link">Iteration</a></li><li><a href="/cpp/regular-expressions.html" class="sidebar-link">Regular expressions</a></li><li><a href="/cpp/implementation-defined-behavior.html" class="sidebar-link">Implementation-defined behavior</a></li><li><a href="/cpp/exceptions.html" class="sidebar-link">Exceptions</a></li><li><a href="/cpp/lambdas.html" class="sidebar-link">Lambdas</a></li><li><a href="/cpp/value-categories.html" class="sidebar-link">Value Categories</a></li><li><a href="/cpp/preprocessor.html" class="sidebar-link">Preprocessor</a></li><li><a href="/cpp/data-structures-in-c.html" class="sidebar-link">Data Structures in C++</a></li><li><a href="/cpp/templates.html" class="sidebar-link">Templates</a></li><li><a href="/cpp/expression-templates.html" class="sidebar-link">Expression templates</a></li><li><a href="/cpp/curiously-recurring-template-pattern-crtp.html" class="sidebar-link">Curiously Recurring Template Pattern (CRTP)</a></li><li><a href="/cpp/threading.html" class="sidebar-link">Threading</a></li><li><a href="/cpp/thread-synchronization-structures.html" class="sidebar-link">Thread synchronization structures</a></li><li><a href="/cpp/the-rule-of-three-five-and-zero.html" class="sidebar-link">The Rule of Three, Five, And Zero</a></li><li><a href="/cpp/raii-resource-acquisition-is-initialization.html" class="sidebar-link">RAII: Resource Acquisition Is Initialization</a></li><li><a href="/cpp/rtti-run-time-type-information.html" class="sidebar-link">RTTI: Run-Time Type Information</a></li><li><a href="/cpp/mutexes.html" class="sidebar-link">Mutexes</a></li><li><a href="/cpp/recursive-mutex.html" class="sidebar-link">Recursive Mutex</a></li><li><a href="/cpp/semaphore.html" class="sidebar-link">Semaphore</a></li><li><a href="/cpp/futures-and-promises.html" class="sidebar-link">Futures and Promises</a></li><li><a href="/cpp/atomic-types.html" class="sidebar-link">Atomic Types</a></li><li><a href="/cpp/type-erasure.html" class="sidebar-link">Type Erasure</a></li><li><a href="/cpp/explicit-type-conversions.html" aria-current="page" class="active sidebar-link">Explicit type conversions</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cpp/explicit-type-conversions.html#casting-away-constness" class="sidebar-link">Casting away constness</a></li><li class="sidebar-sub-header"><a href="/cpp/explicit-type-conversions.html#c-style-casting" class="sidebar-link">C-style casting</a></li><li class="sidebar-sub-header"><a href="/cpp/explicit-type-conversions.html#base-to-derived-conversion" class="sidebar-link">Base to derived conversion</a></li><li class="sidebar-sub-header"><a href="/cpp/explicit-type-conversions.html#conversion-between-pointer-and-integer" class="sidebar-link">Conversion between pointer and integer</a></li><li class="sidebar-sub-header"><a href="/cpp/explicit-type-conversions.html#type-punning-conversion" class="sidebar-link">Type punning conversion</a></li><li class="sidebar-sub-header"><a href="/cpp/explicit-type-conversions.html#conversion-by-explicit-constructor-or-explicit-conversion-function" class="sidebar-link">Conversion by explicit constructor or explicit conversion function</a></li><li class="sidebar-sub-header"><a href="/cpp/explicit-type-conversions.html#implicit-conversion" class="sidebar-link">Implicit conversion</a></li><li class="sidebar-sub-header"><a href="/cpp/explicit-type-conversions.html#enum-conversions" class="sidebar-link">Enum conversions</a></li><li class="sidebar-sub-header"><a href="/cpp/explicit-type-conversions.html#derived-to-base-conversion-for-pointers-to-members" class="sidebar-link">Derived to base conversion for pointers to members</a></li><li class="sidebar-sub-header"><a href="/cpp/explicit-type-conversions.html#void-to-t" class="sidebar-link">void to T</a></li></ul></li><li><a href="/cpp/unnamed-types.html" class="sidebar-link">Unnamed types</a></li><li><a href="/cpp/type-traits.html" class="sidebar-link">Type Traits</a></li><li><a href="/cpp/return-type-covariance.html" class="sidebar-link">Return Type Covariance</a></li><li><a href="/cpp/layout-of-object-types.html" class="sidebar-link">Layout of object types</a></li><li><a href="/cpp/type-inference.html" class="sidebar-link">Type Inference</a></li><li><a href="/cpp/typedef-and-type-aliases.html" class="sidebar-link">Typedef and type aliases</a></li><li><a href="/cpp/type-deduction.html" class="sidebar-link">type deduction</a></li><li><a href="/cpp/trailing-return-type.html" class="sidebar-link">Trailing return type</a></li><li><a href="/cpp/alignment.html" class="sidebar-link">Alignment</a></li><li><a href="/cpp/perfect-forwarding.html" class="sidebar-link">Perfect Forwarding</a></li><li><a href="/cpp/decltype.html" class="sidebar-link">decltype</a></li><li><a href="/cpp/sfinae-substitution-failure-is-not-an-error.html" class="sidebar-link">SFINAE (Substitution Failure Is Not An Error)</a></li><li><a href="/cpp/undefined-behavior.html" class="sidebar-link">Undefined Behavior</a></li><li><a href="/cpp/overload-resolution.html" class="sidebar-link">Overload resolution</a></li><li><a href="/cpp/move-semantics.html" class="sidebar-link">Move Semantics</a></li><li><a href="/cpp/pimpl-idiom.html" class="sidebar-link">Pimpl Idiom</a></li><li><a href="/cpp/auto.html" class="sidebar-link">auto</a></li><li><a href="/cpp/copy-elision.html" class="sidebar-link">Copy Elision</a></li><li><a href="/cpp/fold-expressions.html" class="sidebar-link">Fold Expressions</a></li><li><a href="/cpp/unions.html" class="sidebar-link">Unions</a></li><li><a href="/cpp/design-pattern-implementation-in-c.html" class="sidebar-link">Design pattern implementation in C++</a></li><li><a href="/cpp/singleton-design-pattern.html" class="sidebar-link">Singleton Design Pattern</a></li><li><a href="/cpp/user-defined-literals.html" class="sidebar-link">User-Defined Literals</a></li><li><a href="/cpp/memory-management.html" class="sidebar-link">Memory management</a></li><li><a href="/cpp/c-11-memory-model.html" class="sidebar-link">C++11 Memory Model</a></li><li><a href="/cpp/scopes.html" class="sidebar-link">Scopes</a></li><li><a href="/cpp/static-assert.html" class="sidebar-link">static_assert</a></li><li><a href="/cpp/constexpr.html" class="sidebar-link">constexpr</a></li><li><a href="/cpp/one-definition-rule-odr.html" class="sidebar-link">One Definition Rule (ODR)</a></li><li><a href="/cpp/unspecified-behavior.html" class="sidebar-link">Unspecified behavior</a></li><li><a href="/cpp/argument-dependent-name-lookup.html" class="sidebar-link">Argument Dependent Name Lookup</a></li><li><a href="/cpp/attributes.html" class="sidebar-link">Attributes</a></li><li><a href="/cpp/recursion-in-c.html" class="sidebar-link">Recursion in C++</a></li><li><a href="/cpp/arithmitic-metaprogramming.html" class="sidebar-link">Arithmitic Metaprogramming</a></li><li><a href="/cpp/callable-objects.html" class="sidebar-link">Callable Objects</a></li><li><a href="/cpp/client-server-examples.html" class="sidebar-link">Client server examples</a></li><li><a href="/cpp/const-correctness.html" class="sidebar-link">Const Correctness</a></li><li><a href="/cpp/parameter-packs.html" class="sidebar-link">Parameter packs</a></li><li><a href="/cpp/build-systems.html" class="sidebar-link">Build Systems</a></li><li><a href="/cpp/concurrency-with-openmp.html" class="sidebar-link">Concurrency With OpenMP</a></li><li><a href="/cpp/resource-management.html" class="sidebar-link">Resource Management</a></li><li><a href="/cpp/storage-class-specifiers.html" class="sidebar-link">Storage class specifiers</a></li><li><a href="/cpp/linkage-specifications.html" class="sidebar-link">Linkage specifications</a></li><li><a href="/cpp/digit-separators.html" class="sidebar-link">Digit separators</a></li><li><a href="/cpp/c-incompatibilities.html" class="sidebar-link">C incompatibilities</a></li><li><a href="/cpp/side-by-side-comparisons-of-classic-c-examples-solved-via-c-vs-c-11-vs-c-14-vs-c-17.html" class="sidebar-link">Side by Side Comparisons of classic C++ examples solved via C++ vs C++11 vs C++14 vs C++17</a></li><li><a href="/cpp/compiling-and-building.html" class="sidebar-link">Compiling and Building</a></li><li><a href="/cpp/common-compile-linker-errors-gcc.html" class="sidebar-link">Common compile/linker errors (GCC)</a></li><li><a href="/cpp/more-undefined-behaviors-in-c.html" class="sidebar-link">More undefined behaviors in C++</a></li><li><a href="/cpp/unit-testing-in-c.html" class="sidebar-link">Unit Testing in C++</a></li><li><a href="/cpp/c-debugging-and-debug-prevention-tools-techniques.html" class="sidebar-link">C++ Debugging and Debug-prevention Tools &amp; Techniques</a></li><li><a href="/cpp/optimization-in-c.html" class="sidebar-link">Optimization in C++</a></li><li><a href="/cpp/optimization.html" class="sidebar-link">Optimization</a></li><li><a href="/cpp/profiling.html" class="sidebar-link">Profiling</a></li><li><a href="/cpp/refactoring-techniques.html" class="sidebar-link">Refactoring Techniques</a></li><li><a href="/cpp/internationalization-in-c.html" class="sidebar-link">Internationalization in C++</a></li><li><a href="/cpp/contributors.html" class="sidebar-link">The Contributors</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="explicit-type-conversions"><a href="#explicit-type-conversions" class="header-anchor">#</a> Explicit type conversions</h1> <p>An expression can be <strong>explicitly converted</strong> or <strong>cast</strong> to type <code>T</code> using <code>dynamic_cast&lt;T&gt;</code>, <code>static_cast&lt;T&gt;</code>, <code>reinterpret_cast&lt;T&gt;</code>, or <code>const_cast&lt;T&gt;</code>, depending on what type of cast is intended.</p> <p>C++ also supports function-style cast notation, <code>T(expr)</code>, and C-style cast notation, <code>(T)expr</code>.</p> <h2 id="casting-away-constness"><a href="#casting-away-constness" class="header-anchor">#</a> Casting away constness</h2> <p>A pointer to a const object can be converted to a pointer to non-const object using the <code>const_cast</code> <a href="http://stackoverflow.com/documentation/c%2b%2b/4891/keywords" target="_blank" rel="noopener noreferrer">keyword<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>. Here we use <code>const_cast</code> to call a function that is not const-correct. It only accepts a non-const <code>char*</code> argument even though it never writes through the pointer:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">bad_strlen</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s <span class="token operator">=</span> <span class="token string">&quot;hello, world!&quot;</span><span class="token punctuation">;</span>
<span class="token function">bad_strlen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// compile error</span>
<span class="token function">bad_strlen</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK, but it's better to make bad_strlen accept const char*</span>

</code></pre></div><p><code>const_cast</code> to reference type can be used to convert a const-qualified lvalue into a non-const-qualified value.</p> <p><code>const_cast</code> is dangerous because it makes it impossible for the C++ type system to prevent you from trying to modify a const object. Doing so results in undefined behavior.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> mutable_x <span class="token operator">=</span> <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
mutable_x <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span> <span class="token comment">// may compile, but produces *undefined behavior*</span>

</code></pre></div><h2 id="c-style-casting"><a href="#c-style-casting" class="header-anchor">#</a> C-style casting</h2> <p>C-Style casting can be considered 'Best effort' casting and is named so as it is the only cast which could be used in C. The syntax for this cast is <code>(NewType)variable</code>.</p> <p>Whenever this cast is used, it uses one of the following c++ casts (in order):</p> <ul><li><code>const_cast&lt;NewType&gt;(variable)</code></li> <li><code>static_cast&lt;NewType&gt;(variable)</code></li> <li><code>const_cast&lt;NewType&gt;(static_cast&lt;const NewType&gt;(variable))</code></li> <li><code>reinterpret_cast&lt;const NewType&gt;(variable)</code></li> <li><code>const_cast&lt;NewType&gt;(reinterpret_cast&lt;const NewType&gt;(variable))</code></li></ul> <p>Functional casting is very similar, though as a few restrictions as the result of its syntax: <code>NewType(expression)</code>. As a result, only types without spaces can be cast to.</p> <p>It's better to use new c++ cast, because s more readable and can be spotted easily anywhere inside a C++ source code and errors will be detected in compile-time, instead in run-time.</p> <p>As this cast can result in unintended <code>reinterpret_cast</code>, it is often considered dangerous.</p> <h2 id="base-to-derived-conversion"><a href="#base-to-derived-conversion" class="header-anchor">#</a> Base to derived conversion</h2> <p>A pointer to base class can be converted to a pointer to derived class using <code>static_cast</code>. <code>static_cast</code> does not do any run-time checking and can lead to undefined behaviour when the pointer does not actually point to the desired type.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">Base</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Derived d<span class="token punctuation">;</span>
Base<span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>d<span class="token punctuation">;</span>
Derived<span class="token operator">*</span> p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span>                        <span class="token comment">// error; cast required</span>
Derived<span class="token operator">*</span> p3 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Derived<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK; p2 now points to Derived object</span>
Base b<span class="token punctuation">;</span>
Base<span class="token operator">*</span> p4 <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>
Derived<span class="token operator">*</span> p5 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Derived<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>p4<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined behaviour since p4 does not</span>
                                         <span class="token comment">// point to a Derived object</span>

</code></pre></div><p>Likewise, a reference to base class can be converted to a reference to derived class using <code>static_cast</code>.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">Base</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Derived d<span class="token punctuation">;</span>
Base<span class="token operator">&amp;</span> r1 <span class="token operator">=</span> d<span class="token punctuation">;</span>
Derived<span class="token operator">&amp;</span> r2 <span class="token operator">=</span> r1<span class="token punctuation">;</span>                        <span class="token comment">// error; cast required</span>
Derived<span class="token operator">&amp;</span> r3 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Derived<span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>r1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK; r3 now refers to Derived object</span>

</code></pre></div><p>If the source type is polymorphic, <code>dynamic_cast</code> can be used to perform a base to derived conversion. It performs a run-time check and failure is recoverable instead of producing undefined behaviour. In the pointer case, a null pointer is returned upon failure. In the reference case, an exception is thrown upon failure of type <code>std::bad_cast</code> (or a class derived from <code>std::bad_cast</code>).</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span> <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// Base is polymorphic</span>
<span class="token keyword">struct</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">Base</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Base<span class="token operator">*</span> b1 <span class="token operator">=</span> <span class="token keyword">new</span> Derived<span class="token punctuation">;</span>
Derived<span class="token operator">*</span> d1 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Derived<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>b1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK; d1 points to Derived object</span>
Base<span class="token operator">*</span> b2 <span class="token operator">=</span> <span class="token keyword">new</span> Base<span class="token punctuation">;</span>
Derived<span class="token operator">*</span> d2 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Derived<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// d2 is a null pointer</span>

</code></pre></div><h2 id="conversion-between-pointer-and-integer"><a href="#conversion-between-pointer-and-integer" class="header-anchor">#</a> Conversion between pointer and integer</h2> <p>An object pointer (including <code>void*</code>) or function pointer can be converted to an integer type using <code>reinterpret_cast</code>. This will only compile if the destination type is long enough. The result is implementation-defined and typically yields the numeric address of the byte in memory that the pointer pointers to.</p> <p>Typically, <code>long</code> or <code>unsigned long</code> is long enough to hold any pointer value, but this is not guaranteed by the standard.</p> <p>If the types <code>std::intptr_t</code> and <code>std::uintptr_t</code> exist, they are guaranteed to be long enough to hold a <code>void*</code> (and hence any pointer to object type). However, they are not guaranteed to be long enough to hold a function pointer.</p> <p>Similarly, <code>reinterpret_cast</code> can be used to convert an integer type into a pointer type. Again the result is implementation-defined, but a pointer value is guaranteed to be unchanged by a round trip through an integer type. The standard does not guarantee that the value zero is converted to a null pointer.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">register_callback</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>fp<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// probably a C API</span>
<span class="token keyword">void</span> <span class="token function">my_callback</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;the value is: &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">long</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// will probably compile</span>
<span class="token punctuation">}</span>
<span class="token keyword">long</span> x<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cin <span class="token operator">&gt;&gt;</span> x<span class="token punctuation">;</span>
<span class="token function">register_callback</span><span class="token punctuation">(</span>my_callback<span class="token punctuation">,</span>
                  <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// hopefully this doesn't lose information...</span>

</code></pre></div><h2 id="type-punning-conversion"><a href="#type-punning-conversion" class="header-anchor">#</a> Type punning conversion</h2> <p>A pointer (resp. reference) to an object type can be converted to a pointer (resp. reference) to any other object type using <code>reinterpret_cast</code>. This does not call any constructors or conversion functions.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">char</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// error: static_cast cannot perform this conversion</span>
<span class="token keyword">char</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK</span>
<span class="token operator">*</span>p <span class="token operator">=</span> <span class="token string">'z'</span><span class="token punctuation">;</span>                              <span class="token comment">// maybe this modifies x (see below)</span>

</code></pre></div><p>The result of <code>reinterpret_cast</code> represents the same address as the operand, provided that the address is appropriately aligned for the destination type. Otherwise, the result is unspecified.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">char</span><span class="token operator">&amp;</span> r <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> px <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> pr <span class="token operator">=</span> <span class="token operator">&amp;</span>r<span class="token punctuation">;</span>
<span class="token function">assert</span><span class="token punctuation">(</span>px <span class="token operator">==</span> pr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// should never fire</span>

</code></pre></div><p>The result of <code>reinterpret_cast</code> is unspecified, except that a pointer (resp. reference) will survive a round trip from the source type to the destination type and back, as long as the destination type's alignment requirement is not stricter than that of the source type.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> r1 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> r2 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>r1<span class="token punctuation">)</span><span class="token punctuation">;</span>
r2 <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span> <span class="token comment">// sets x to 456</span>

</code></pre></div><p>On most implementations, <code>reinterpret_cast</code> does not change the address, but this requirement was not standardized until C++11.</p> <p><code>reinterpret_cast</code> can also be used to convert from one pointer-to-data-member type to another, or one pointer-to-member-function type to another.</p> <p>Use of <code>reinterpret_cast</code> is considered dangerous because reading or writing through a pointer or reference obtained using <code>reinterpret_cast</code> may trigger undefined behaviour when the source and destination types are unrelated.</p> <h2 id="conversion-by-explicit-constructor-or-explicit-conversion-function"><a href="#conversion-by-explicit-constructor-or-explicit-conversion-function" class="header-anchor">#</a> Conversion by explicit constructor or explicit conversion function</h2> <p>A conversion that involves calling an <a href="http://stackoverflow.com/documentation/c%2b%2b/4891/keywords/18568/explicit" target="_blank" rel="noopener noreferrer">explicit<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> constructor or conversion function can't be done implicitly. We can request that the conversion be done explicitly using <code>static_cast</code>. The meaning is the same as that of a direct initialization, except that the result is a temporary.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> p<span class="token punctuation">;</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">explicit</span> <span class="token function">C</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">p</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>C c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">f</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// error: C::C(int*) is explicit</span>
    <span class="token function">f</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>C<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
    <span class="token function">f</span><span class="token punctuation">(</span><span class="token function">C</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// equivalent to previous line</span>
    C <span class="token function">c</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token function">f</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// error: C is not copyable</span>
<span class="token punctuation">}</span>

</code></pre></div><h2 id="implicit-conversion"><a href="#implicit-conversion" class="header-anchor">#</a> Implicit conversion</h2> <p><code>static_cast</code> can perform any implicit conversion. This use of <code>static_cast</code> can occasionally be useful, such as in the following examples:</p> <li>
When passing arguments to an ellipsis, the &quot;expected&quot; argument type is not statically known, so no implicit conversion will occur.
<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">double</span> x <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d\n&quot;</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// prints 3</span>
<span class="token comment">// printf(&quot;%d\n&quot;, x); // undefined behaviour; printf is expecting an int here</span>
<span class="token comment">// alternative:</span>
<span class="token comment">// const int y = x; printf(&quot;%d\n&quot;, y);</span>

</code></pre></div><p>Without the explicit type conversion, a <code>double</code> object would be passed to the ellipsis, and undefined behaviour would occur.
</p></li> <li>
A derived class assignment operator can call a base class assignment operator like so:<p></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
    Derived<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Derived<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Base<span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">=</span> other<span class="token punctuation">;</span>
        <span class="token comment">// alternative:</span>
        <span class="token comment">// Base&amp; this_base_ref = *this; this_base_ref = other;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div></li> <h2 id="enum-conversions"><a href="#enum-conversions" class="header-anchor">#</a> Enum conversions</h2> <p><code>static_cast</code> can convert from an integer or floating point type to an enumeration type (whether scoped or unscoped), and <strong>vice versa.</strong> It can also convert between enumeration types.</p> <ul><li>The conversion from an unscoped enumeration type to an arithmetic type is an implicit conversion; it is possible, but not necessary, to use <code>static_cast</code>.</li></ul> <li>
When a scoped enumeration type is converted to an arithmetic type:
<ul>
- If the enum's value can be represented exactly in the destination type, the result is that value.
- Otherwise, if the destination type is an integer type, the result is unspecified.
- Otherwise, if the destination type is a floating point type, the result is the same as that of converting to the underlying type and then to the floating point type.
<p>Example:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">Format</span> <span class="token punctuation">{</span>
    TEXT <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    PDF <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">,</span>
    OTHER <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Format f <span class="token operator">=</span> Format<span class="token double-colon punctuation">::</span>PDF<span class="token punctuation">;</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> f<span class="token punctuation">;</span>                         <span class="token comment">// error</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// ok; b is 1000</span>
<span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// unspecified, if 1000 doesn't fit into char</span>
<span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// d is 1000.0... probably</span>

</code></pre></div><li>
When an integer or enumeration type is converted to an enumeration type:
<ul>
- If the original value is within the destination enum's range, the result is that value. Note that this value might be unequal to all enumerators.
- Otherwise, the result is unspecified (&lt;= C++14) or undefined (&gt;= C++17).
<p>Example:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">enum</span> <span class="token class-name">Scale</span> <span class="token punctuation">{</span>
    SINGLE <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
    DOUBLE <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span>
    QUAD <span class="token operator">=</span> <span class="token number">4</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Scale s1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                     <span class="token comment">// error</span>
Scale s2 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Scale<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s2 is DOUBLE</span>
Scale s3 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Scale<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s3 has value 3, and is not equal to any enumerator</span>
Scale s9 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Scale<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// unspecified value in C++14; UB in C++17</span>

</code></pre></div><li>
When a floating point type is converted to an enumeration type, the result is the same as converting to the enum's underlying type and then to the enum type.
<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">enum</span> <span class="token class-name">Direction</span> <span class="token punctuation">{</span>
    UP <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
    LEFT <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span>
    DOWN <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span>
    RIGHT <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Direction d <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Direction<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// d is RIGHT</span>

</code></pre></div></li> <h2 id="derived-to-base-conversion-for-pointers-to-members"><a href="#derived-to-base-conversion-for-pointers-to-members" class="header-anchor">#</a> Derived to base conversion for pointers to members</h2> <p>A pointer to member of derived class can be converted to a pointer to member of base class using <code>static_cast</code>. The types pointed to must match.</p> <p>If the operand is a null pointer to member value, the result is also a null pointer to member value.</p> <p>Otherwise, the conversion is only valid if the member pointed to by the operand actually exists in the destination class, or if the destination class is a base or derived class of the class containing the member pointed to by the operand. <code>static_cast</code> does not check for validity. If the conversion is not valid, the behaviour is undefined.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">C</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token class-name">B</span></span> <span class="token punctuation">{</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span> <span class="token keyword">double</span> z<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> B<span class="token double-colon punctuation">::</span><span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>B<span class="token double-colon punctuation">::</span>x<span class="token punctuation">;</span>
<span class="token keyword">int</span> C<span class="token double-colon punctuation">::</span><span class="token operator">*</span>p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span>                              <span class="token comment">// ok; implicit conversion</span>
<span class="token keyword">int</span> B<span class="token double-colon punctuation">::</span><span class="token operator">*</span>p3 <span class="token operator">=</span> p2<span class="token punctuation">;</span>                              <span class="token comment">// error</span>
<span class="token keyword">int</span> B<span class="token double-colon punctuation">::</span><span class="token operator">*</span>p4 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span> B<span class="token double-colon punctuation">::</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// ok; p4 is equal to p1</span>
<span class="token keyword">int</span> A<span class="token double-colon punctuation">::</span><span class="token operator">*</span>p5 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span> A<span class="token double-colon punctuation">::</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>p2<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// undefined; p2 points to x, which is a member</span>
                                              <span class="token comment">// of the unrelated class B</span>
<span class="token keyword">double</span> C<span class="token double-colon punctuation">::</span><span class="token operator">*</span>p6 <span class="token operator">=</span> <span class="token operator">&amp;</span>C<span class="token double-colon punctuation">::</span>z<span class="token punctuation">;</span>
<span class="token keyword">double</span> A<span class="token double-colon punctuation">::</span><span class="token operator">*</span>p7 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span> A<span class="token double-colon punctuation">::</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>p6<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok, even though A doesn't contain z</span>
<span class="token keyword">int</span> A<span class="token double-colon punctuation">::</span><span class="token operator">*</span>p8 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span> A<span class="token double-colon punctuation">::</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>p6<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// error: types don't match</span>

</code></pre></div><h2 id="void-to-t"><a href="#void-to-t" class="header-anchor">#</a> void* to T*</h2> <p>In C++, <code>void*</code> cannot be implicitly converted to <code>T*</code> where <code>T</code> is an object type. Instead, <code>static_cast</code> should be used to perform the conversion explicitly. If the operand actually points to a <code>T</code> object, the result points to that object. Otherwise, the result is unspecified.</p> <p>Even if the operand does not point to a <code>T</code> object, as long as the operand points to a byte whose address is properly aligned for the type <code>T</code>, the result of the conversion points to the same byte.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// allocating an array of 100 ints, the hard way</span>
<span class="token keyword">int</span><span class="token operator">*</span> a <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// error; malloc returns void*</span>
<span class="token keyword">int</span><span class="token operator">*</span> a <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
<span class="token comment">// int* a = new int[100];                           // no cast needed</span>
<span class="token comment">// std::vector&lt;int&gt; a(100);                         // better</span>

<span class="token keyword">const</span> <span class="token keyword">char</span> c <span class="token operator">=</span> <span class="token string">'!'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">void</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>c<span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> p2 <span class="token operator">=</span> p1<span class="token punctuation">;</span>                           <span class="token comment">// error</span>
<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> p3 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok; p3 points to c</span>
<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> p4 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// unspecified in C++03;</span>
                                               <span class="token comment">// possibly unspecified in C++11 if</span>
                                               <span class="token comment">// alignof(int) &gt; alignof(char)</span>
<span class="token keyword">char</span><span class="token operator">*</span> p5 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// error: casting away constness</span>

</code></pre></div><h4 id="syntax"><a href="#syntax" class="header-anchor">#</a> Syntax</h4> <ul><li><strong>simple-type-specifier</strong> <code>(</code> <code>)</code></li> <li><strong>simple-type-specifier</strong> <code>(</code> <strong>expression-list</strong> <code>)</code></li> <li><strong>simple-type-specifier</strong> <strong>braced-init-list</strong></li> <li><strong>typename-specifier</strong> <code>(</code> <code>)</code></li> <li><strong>typename-specifier</strong> <code>(</code> <strong>expression-list</strong> <code>)</code></li> <li><strong>typename-specifier</strong> <strong>braced-init-list</strong></li> <li><code>dynamic_cast</code> <code>&lt;</code> <strong>type-id</strong> <code>&gt;</code> <code>(</code> <strong>expression</strong> <code>)</code></li> <li><code>static_cast</code> <code>&lt;</code> <strong>type-id</strong> <code>&gt;</code> <code>(</code> <strong>expression</strong> <code>)</code></li> <li><code>reinterpret_cast</code> <code>&lt;</code> <strong>type-id</strong> <code>&gt;</code> <code>(</code> <strong>expression</strong> <code>)</code></li> <li><code>const_cast</code> <code>&lt;</code> <strong>type-id</strong> <code>&gt;</code> <code>(</code> <strong>expression</strong> <code>)</code></li> <li><code>(</code> <strong>type-id</strong> <code>)</code> <strong>cast-expression</strong></li></ul> <h4 id="remarks"><a href="#remarks" class="header-anchor">#</a> Remarks</h4> <p>All six cast notations have one thing in common:</p> <ul><li>Casting to an lvalue reference type, as in <code>dynamic_cast&lt;Derived&amp;&gt;(base)</code>, yields an lvalue. Therefore, when you want to do something with the same object but treat it as a different type, you would cast to an lvalue reference type.</li> <li>Casting to an rvalue reference type, as in <code>static_cast&lt;string&amp;&amp;&gt;(s)</code>, yields an rvalue.</li> <li>Casting to a non-reference type, as in <code>(int)x</code>, yields a prvalue, which may be thought of as a <strong>copy</strong> of the value being cast, but with a different type from the original.</li></ul> <p>The <code>reinterpret_cast</code> keyword is responsible for performing two different kinds of &quot;unsafe&quot; conversions:</p> <ul><li>The <a href="http://stackoverflow.com/documentation/c%2b%2b/3090/explicit-type-conversions/12169/type-punning-conversion" target="_blank" rel="noopener noreferrer">&quot;type punning&quot;<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> conversions, which can be used to access memory of one type as though it is of a different type.</li> <li>Conversions <a href="http://stackoverflow.com/documentation/c%2b%2b/3090/explicit-type-conversions/13555/conversion-between-pointer-and-integer" target="_blank" rel="noopener noreferrer">between integer types and pointer types<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, in either direction.</li></ul> <p>The <code>static_cast</code> keyword can perform a variety of different conversions:</p> <li>
[Base to derived](http://stackoverflow.com/documentation/c%2b%2b/3090/explicit-type-conversions/10518/base-to-derived-conversion) conversions
</li> <li>
Any conversion that can be done by a direct initialization, including both implicit conversions and conversions that call an explicit constructor or conversion function. See [here](http://stackoverflow.com/documentation/c%2b%2b/3090/explicit-type-conversions/18732/implicit-conversion) and [here](http://stackoverflow.com/documentation/c%2b%2b/3090/explicit-type-conversions/18731/conversion-by-explicit-constructor-or-explicit-conversion-function) for more details.
</li> <li>
To `void`, which discards the value of the expression.
<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// on some compilers, suppresses warning about x being unused</span>
<span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div></li> <li>
Between arithmetic and enumeration types, and between different enumeration types. See [enum conversions](http://stackoverflow.com/documentation/c%2b%2b/3090/explicit-type-conversions/18751/enum-conversions)
</li> <li>
From pointer to member of derived class, to pointer to member of base class. The types pointed to must match. See [derived to base conversion for pointers to members](http://stackoverflow.com/documentation/c%2b%2b/3090/explicit-type-conversions/18752/derived-to-base-conversion-for-pointers-to-members)
</li> <li>
[`void*` to `T*`](http://stackoverflow.com/documentation/c%2b%2b/3090/explicit-type-conversions/18753/void-to-t).
</li> <ul><li>From an lvalue to an xvalue, as in <code>std::move</code>. See <a href="http://stackoverflow.com/documentation/c%2b%2b/2129/move-semantics" target="_blank" rel="noopener noreferrer">move semantics<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</li></ul></ul></li></ul></li></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/devtut/generate/edit/master/docs/cpp/explicit-type-conversions.md" target="_blank" rel="noopener noreferrer">Edit this page on GitHub</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      
      <a href="/cpp/type-erasure.html" class="prev">
        Type Erasure
      </a></span> <span class="next"><a href="/cpp/unnamed-types.html">
        Unnamed types
      </a>
      
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.1779e102.js" defer></script><script src="/assets/js/3.2cfa8016.js" defer></script><script src="/assets/js/650.bef042b9.js" defer></script>
  </body>
</html>
