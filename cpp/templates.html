<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C++ | Templates</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="description" content="Function Templates, Basic Class Template, Variadic template data structures, Argument forwarding, Template Specialization, Partial template specialization, Alias template, Template template parameters, Declaring non-type template arguments with auto, Non-type template parameter, Explicit instantiation, Default template parameter value">
    <meta property="og:site_name" content="DevTut">
    <meta property="og:title" content="C++ | Templates">
    <meta property="og:description" content="Function Templates, Basic Class Template, Variadic template data structures, Argument forwarding, Template Specialization, Partial template specialization, Alias template, Template template parameters, Declaring non-type template arguments with auto, Non-type template parameter, Explicit instantiation, Default template parameter value">
    <meta property="og:type" content="article">
    <meta property="og:url" content="/cpp/templates.html">
    <meta property="og:image" content="/logo.png">
    <meta name="twitter:title" content="C++ | Templates">
    <meta name="twitter:description" content="Function Templates, Basic Class Template, Variadic template data structures, Argument forwarding, Template Specialization, Partial template specialization, Alias template, Template template parameters, Declaring non-type template arguments with auto, Non-type template parameter, Explicit instantiation, Default template parameter value">
    <meta name="twitter:url" content="/cpp/templates.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="/logo.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/mstile-150x150.png">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="google-site-verification" content="76_rKXgwMVIjd-axJC_1zPV9OS4mEjvtgjYOWVkAdnQ">
    
    <link rel="preload" href="/assets/css/0.styles.60619e34.css" as="style"><link rel="preload" href="/assets/js/app.1779e102.js" as="script"><link rel="preload" href="/assets/js/3.2cfa8016.js" as="script"><link rel="preload" href="/assets/js/733.70af0de2.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.60619e34.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">DevTut</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>C++</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/cpp/" aria-current="page" class="sidebar-link">Disclaimer</a></li><li><a href="/cpp/getting-started-with-cpp.html" class="sidebar-link">Getting started with C++</a></li><li><a href="/cpp/literals.html" class="sidebar-link">Literals</a></li><li><a href="/cpp/operator-precedence.html" class="sidebar-link">operator precedence</a></li><li><a href="/cpp/floating-point-arithmetic.html" class="sidebar-link">Floating Point Arithmetic</a></li><li><a href="/cpp/bit-operators.html" class="sidebar-link">Bit Operators</a></li><li><a href="/cpp/bit-manipulation.html" class="sidebar-link">Bit Manipulation</a></li><li><a href="/cpp/bit-fields.html" class="sidebar-link">Bit fields</a></li><li><a href="/cpp/arrays.html" class="sidebar-link">Arrays</a></li><li><a href="/cpp/iterators.html" class="sidebar-link">Iterators</a></li><li><a href="/cpp/basic-input-output-in-c.html" class="sidebar-link">Basic input/output in c++</a></li><li><a href="/cpp/loops.html" class="sidebar-link">Loops</a></li><li><a href="/cpp/file-i-o.html" class="sidebar-link">File I/O</a></li><li><a href="/cpp/cpp-streams.html" class="sidebar-link">C++ Streams</a></li><li><a href="/cpp/stream-manipulators.html" class="sidebar-link">Stream manipulators</a></li><li><a href="/cpp/flow-control.html" class="sidebar-link">Flow Control</a></li><li><a href="/cpp/metaprogramming.html" class="sidebar-link">Metaprogramming</a></li><li><a href="/cpp/const-keyword.html" class="sidebar-link">const keyword</a></li><li><a href="/cpp/mutable-keyword.html" class="sidebar-link">mutable keyword</a></li><li><a href="/cpp/friend-keyword.html" class="sidebar-link">Friend keyword</a></li><li><a href="/cpp/type-keywords.html" class="sidebar-link">Type Keywords</a></li><li><a href="/cpp/basic-type-keywords.html" class="sidebar-link">Basic Type Keywords</a></li><li><a href="/cpp/variable-declaration-keywords.html" class="sidebar-link">Variable Declaration Keywords</a></li><li><a href="/cpp/keywords.html" class="sidebar-link">Keywords</a></li><li><a href="/cpp/returning-several-values-from-a-function.html" class="sidebar-link">Returning several values from a function</a></li><li><a href="/cpp/polymorphism.html" class="sidebar-link">Polymorphism</a></li><li><a href="/cpp/references.html" class="sidebar-link">References</a></li><li><a href="/cpp/value-and-reference-semantics.html" class="sidebar-link">Value and Reference Semantics</a></li><li><a href="/cpp/c-function-call-by-value-vs-call-by-reference.html" class="sidebar-link">C++ function &quot;call by value&quot; vs. &quot;call by reference&quot;</a></li><li><a href="/cpp/copying-vs-assignment.html" class="sidebar-link">Copying vs Assignment</a></li><li><a href="/cpp/pointers.html" class="sidebar-link">Pointers</a></li><li><a href="/cpp/pointers-to-members.html" class="sidebar-link">Pointers to members</a></li><li><a href="/cpp/the-this-pointer.html" class="sidebar-link">The This Pointer</a></li><li><a href="/cpp/smart-pointers.html" class="sidebar-link">Smart Pointers</a></li><li><a href="/cpp/classes-structures.html" class="sidebar-link">Classes/Structures</a></li><li><a href="/cpp/function-overloading.html" class="sidebar-link">Function Overloading</a></li><li><a href="/cpp/operator-overloading.html" class="sidebar-link">Operator Overloading</a></li><li><a href="/cpp/function-template-overloading.html" class="sidebar-link">Function Template Overloading</a></li><li><a href="/cpp/virtual-member-functions.html" class="sidebar-link">Virtual Member Functions</a></li><li><a href="/cpp/inline-functions.html" class="sidebar-link">Inline functions</a></li><li><a href="/cpp/special-member-functions.html" class="sidebar-link">Special Member Functions</a></li><li><a href="/cpp/non-static-member-functions.html" class="sidebar-link">Non-Static Member Functions</a></li><li><a href="/cpp/constant-class-member-functions.html" class="sidebar-link">Constant class member functions</a></li><li><a href="/cpp/c-containers.html" class="sidebar-link">C++ Containers</a></li><li><a href="/cpp/namespaces.html" class="sidebar-link">Namespaces</a></li><li><a href="/cpp/header-files.html" class="sidebar-link">Header Files</a></li><li><a href="/cpp/using-declaration.html" class="sidebar-link">Using declaration</a></li><li><a href="/cpp/std-string.html" class="sidebar-link">std::string</a></li><li><a href="/cpp/std-array.html" class="sidebar-link">std::array</a></li><li><a href="/cpp/std-vector.html" class="sidebar-link">std::vector</a></li><li><a href="/cpp/std-map.html" class="sidebar-link">std::map</a></li><li><a href="/cpp/std-optional.html" class="sidebar-link">std::optional</a></li><li><a href="/cpp/std-function-to-wrap-any-element-that-is-callable.html" class="sidebar-link">std::function: To wrap any element that is callable</a></li><li><a href="/cpp/std-forward-list.html" class="sidebar-link">std::forward_list</a></li><li><a href="/cpp/std-pair.html" class="sidebar-link">std::pair</a></li><li><a href="/cpp/std-atomics.html" class="sidebar-link">std::atomics</a></li><li><a href="/cpp/std-variant.html" class="sidebar-link">std::variant</a></li><li><a href="/cpp/std-iomanip.html" class="sidebar-link">std::iomanip</a></li><li><a href="/cpp/std-any.html" class="sidebar-link">std::any</a></li><li><a href="/cpp/std-set-and-std-multiset.html" class="sidebar-link">std::set and std::multiset</a></li><li><a href="/cpp/std-integer-sequence.html" class="sidebar-link">std::integer_sequence</a></li><li><a href="/cpp/using-std-unordered-map.html" class="sidebar-link">Using std::unordered_map</a></li><li><a href="/cpp/standard-library-algorithms.html" class="sidebar-link">Standard Library Algorithms</a></li><li><a href="/cpp/the-iso-c-standard.html" class="sidebar-link">The ISO C++ Standard</a></li><li><a href="/cpp/inline-variables.html" class="sidebar-link">Inline variables</a></li><li><a href="/cpp/random-number-generation.html" class="sidebar-link">Random number generation</a></li><li><a href="/cpp/date-and-time-using-chrono-header.html" class="sidebar-link">Date and time using  header</a></li><li><a href="/cpp/sorting.html" class="sidebar-link">Sorting</a></li><li><a href="/cpp/enumeration.html" class="sidebar-link">Enumeration</a></li><li><a href="/cpp/iteration.html" class="sidebar-link">Iteration</a></li><li><a href="/cpp/regular-expressions.html" class="sidebar-link">Regular expressions</a></li><li><a href="/cpp/implementation-defined-behavior.html" class="sidebar-link">Implementation-defined behavior</a></li><li><a href="/cpp/exceptions.html" class="sidebar-link">Exceptions</a></li><li><a href="/cpp/lambdas.html" class="sidebar-link">Lambdas</a></li><li><a href="/cpp/value-categories.html" class="sidebar-link">Value Categories</a></li><li><a href="/cpp/preprocessor.html" class="sidebar-link">Preprocessor</a></li><li><a href="/cpp/data-structures-in-c.html" class="sidebar-link">Data Structures in C++</a></li><li><a href="/cpp/templates.html" aria-current="page" class="active sidebar-link">Templates</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cpp/templates.html#function-templates" class="sidebar-link">Function Templates</a></li><li class="sidebar-sub-header"><a href="/cpp/templates.html#basic-class-template" class="sidebar-link">Basic Class Template</a></li><li class="sidebar-sub-header"><a href="/cpp/templates.html#variadic-template-data-structures" class="sidebar-link">Variadic template data structures</a></li><li class="sidebar-sub-header"><a href="/cpp/templates.html#argument-forwarding" class="sidebar-link">Argument forwarding</a></li><li class="sidebar-sub-header"><a href="/cpp/templates.html#template-specialization" class="sidebar-link">Template Specialization</a></li><li class="sidebar-sub-header"><a href="/cpp/templates.html#partial-template-specialization" class="sidebar-link">Partial template specialization</a></li><li class="sidebar-sub-header"><a href="/cpp/templates.html#alias-template" class="sidebar-link">Alias template</a></li><li class="sidebar-sub-header"><a href="/cpp/templates.html#template-template-parameters" class="sidebar-link">Template template parameters</a></li><li class="sidebar-sub-header"><a href="/cpp/templates.html#declaring-non-type-template-arguments-with-auto" class="sidebar-link">Declaring non-type template arguments with auto</a></li><li class="sidebar-sub-header"><a href="/cpp/templates.html#non-type-template-parameter" class="sidebar-link">Non-type template parameter</a></li><li class="sidebar-sub-header"><a href="/cpp/templates.html#explicit-instantiation" class="sidebar-link">Explicit instantiation</a></li><li class="sidebar-sub-header"><a href="/cpp/templates.html#default-template-parameter-value" class="sidebar-link">Default template parameter value</a></li></ul></li><li><a href="/cpp/expression-templates.html" class="sidebar-link">Expression templates</a></li><li><a href="/cpp/curiously-recurring-template-pattern-crtp.html" class="sidebar-link">Curiously Recurring Template Pattern (CRTP)</a></li><li><a href="/cpp/threading.html" class="sidebar-link">Threading</a></li><li><a href="/cpp/thread-synchronization-structures.html" class="sidebar-link">Thread synchronization structures</a></li><li><a href="/cpp/the-rule-of-three-five-and-zero.html" class="sidebar-link">The Rule of Three, Five, And Zero</a></li><li><a href="/cpp/raii-resource-acquisition-is-initialization.html" class="sidebar-link">RAII: Resource Acquisition Is Initialization</a></li><li><a href="/cpp/rtti-run-time-type-information.html" class="sidebar-link">RTTI: Run-Time Type Information</a></li><li><a href="/cpp/mutexes.html" class="sidebar-link">Mutexes</a></li><li><a href="/cpp/recursive-mutex.html" class="sidebar-link">Recursive Mutex</a></li><li><a href="/cpp/semaphore.html" class="sidebar-link">Semaphore</a></li><li><a href="/cpp/futures-and-promises.html" class="sidebar-link">Futures and Promises</a></li><li><a href="/cpp/atomic-types.html" class="sidebar-link">Atomic Types</a></li><li><a href="/cpp/type-erasure.html" class="sidebar-link">Type Erasure</a></li><li><a href="/cpp/explicit-type-conversions.html" class="sidebar-link">Explicit type conversions</a></li><li><a href="/cpp/unnamed-types.html" class="sidebar-link">Unnamed types</a></li><li><a href="/cpp/type-traits.html" class="sidebar-link">Type Traits</a></li><li><a href="/cpp/return-type-covariance.html" class="sidebar-link">Return Type Covariance</a></li><li><a href="/cpp/layout-of-object-types.html" class="sidebar-link">Layout of object types</a></li><li><a href="/cpp/type-inference.html" class="sidebar-link">Type Inference</a></li><li><a href="/cpp/typedef-and-type-aliases.html" class="sidebar-link">Typedef and type aliases</a></li><li><a href="/cpp/type-deduction.html" class="sidebar-link">type deduction</a></li><li><a href="/cpp/trailing-return-type.html" class="sidebar-link">Trailing return type</a></li><li><a href="/cpp/alignment.html" class="sidebar-link">Alignment</a></li><li><a href="/cpp/perfect-forwarding.html" class="sidebar-link">Perfect Forwarding</a></li><li><a href="/cpp/decltype.html" class="sidebar-link">decltype</a></li><li><a href="/cpp/sfinae-substitution-failure-is-not-an-error.html" class="sidebar-link">SFINAE (Substitution Failure Is Not An Error)</a></li><li><a href="/cpp/undefined-behavior.html" class="sidebar-link">Undefined Behavior</a></li><li><a href="/cpp/overload-resolution.html" class="sidebar-link">Overload resolution</a></li><li><a href="/cpp/move-semantics.html" class="sidebar-link">Move Semantics</a></li><li><a href="/cpp/pimpl-idiom.html" class="sidebar-link">Pimpl Idiom</a></li><li><a href="/cpp/auto.html" class="sidebar-link">auto</a></li><li><a href="/cpp/copy-elision.html" class="sidebar-link">Copy Elision</a></li><li><a href="/cpp/fold-expressions.html" class="sidebar-link">Fold Expressions</a></li><li><a href="/cpp/unions.html" class="sidebar-link">Unions</a></li><li><a href="/cpp/design-pattern-implementation-in-c.html" class="sidebar-link">Design pattern implementation in C++</a></li><li><a href="/cpp/singleton-design-pattern.html" class="sidebar-link">Singleton Design Pattern</a></li><li><a href="/cpp/user-defined-literals.html" class="sidebar-link">User-Defined Literals</a></li><li><a href="/cpp/memory-management.html" class="sidebar-link">Memory management</a></li><li><a href="/cpp/c-11-memory-model.html" class="sidebar-link">C++11 Memory Model</a></li><li><a href="/cpp/scopes.html" class="sidebar-link">Scopes</a></li><li><a href="/cpp/static-assert.html" class="sidebar-link">static_assert</a></li><li><a href="/cpp/constexpr.html" class="sidebar-link">constexpr</a></li><li><a href="/cpp/one-definition-rule-odr.html" class="sidebar-link">One Definition Rule (ODR)</a></li><li><a href="/cpp/unspecified-behavior.html" class="sidebar-link">Unspecified behavior</a></li><li><a href="/cpp/argument-dependent-name-lookup.html" class="sidebar-link">Argument Dependent Name Lookup</a></li><li><a href="/cpp/attributes.html" class="sidebar-link">Attributes</a></li><li><a href="/cpp/recursion-in-c.html" class="sidebar-link">Recursion in C++</a></li><li><a href="/cpp/arithmitic-metaprogramming.html" class="sidebar-link">Arithmitic Metaprogramming</a></li><li><a href="/cpp/callable-objects.html" class="sidebar-link">Callable Objects</a></li><li><a href="/cpp/client-server-examples.html" class="sidebar-link">Client server examples</a></li><li><a href="/cpp/const-correctness.html" class="sidebar-link">Const Correctness</a></li><li><a href="/cpp/parameter-packs.html" class="sidebar-link">Parameter packs</a></li><li><a href="/cpp/build-systems.html" class="sidebar-link">Build Systems</a></li><li><a href="/cpp/concurrency-with-openmp.html" class="sidebar-link">Concurrency With OpenMP</a></li><li><a href="/cpp/resource-management.html" class="sidebar-link">Resource Management</a></li><li><a href="/cpp/storage-class-specifiers.html" class="sidebar-link">Storage class specifiers</a></li><li><a href="/cpp/linkage-specifications.html" class="sidebar-link">Linkage specifications</a></li><li><a href="/cpp/digit-separators.html" class="sidebar-link">Digit separators</a></li><li><a href="/cpp/c-incompatibilities.html" class="sidebar-link">C incompatibilities</a></li><li><a href="/cpp/side-by-side-comparisons-of-classic-c-examples-solved-via-c-vs-c-11-vs-c-14-vs-c-17.html" class="sidebar-link">Side by Side Comparisons of classic C++ examples solved via C++ vs C++11 vs C++14 vs C++17</a></li><li><a href="/cpp/compiling-and-building.html" class="sidebar-link">Compiling and Building</a></li><li><a href="/cpp/common-compile-linker-errors-gcc.html" class="sidebar-link">Common compile/linker errors (GCC)</a></li><li><a href="/cpp/more-undefined-behaviors-in-c.html" class="sidebar-link">More undefined behaviors in C++</a></li><li><a href="/cpp/unit-testing-in-c.html" class="sidebar-link">Unit Testing in C++</a></li><li><a href="/cpp/c-debugging-and-debug-prevention-tools-techniques.html" class="sidebar-link">C++ Debugging and Debug-prevention Tools &amp; Techniques</a></li><li><a href="/cpp/optimization-in-c.html" class="sidebar-link">Optimization in C++</a></li><li><a href="/cpp/optimization.html" class="sidebar-link">Optimization</a></li><li><a href="/cpp/profiling.html" class="sidebar-link">Profiling</a></li><li><a href="/cpp/refactoring-techniques.html" class="sidebar-link">Refactoring Techniques</a></li><li><a href="/cpp/internationalization-in-c.html" class="sidebar-link">Internationalization in C++</a></li><li><a href="/cpp/contributors.html" class="sidebar-link">The Contributors</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="templates"><a href="#templates" class="header-anchor">#</a> Templates</h1> <p>Classes, functions, and (since C++14) variables can be templated. A template is a piece of code with some free parameters that will become a concrete class, function, or variable when all parameters are specified. Parameters can be types, values, or themselves templates. A well-known template is <code>std::vector</code>, which becomes a concrete container type when the element type is specified, <strong>e.g.,</strong> <code>std::vector&lt;int&gt;</code>.</p> <h2 id="function-templates"><a href="#function-templates" class="header-anchor">#</a> Function Templates</h2> <p>Templating can also be applied to functions (as well as the more traditional structures) with the same effect.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 'T' stands for the unknown type</span>
<span class="token comment">// Both of our arguments will be of the same type.</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">printSum</span><span class="token punctuation">(</span>T add1<span class="token punctuation">,</span> T add2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>add1 <span class="token operator">+</span> add2<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>This can then be used in the same way as structure templates.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token generic-function"><span class="token function">printSum</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token generic-function"><span class="token function">printSum</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">4.5f</span><span class="token punctuation">,</span> <span class="token number">8.9f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>In both these case the template argument is used to replace the types of the parameters; the result works just like a normal C++ function (if the parameters don't match the template type the compiler applies the standard conversions).</p> <p>One additional property of template functions (unlike template classes) is that the compiler can infer the template parameters based on the parameters passed to the function.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token function">printSum</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// Both parameters are int.</span>
                    <span class="token comment">// This allows the compiler deduce that the type</span>
                    <span class="token comment">// T is also int.</span>

<span class="token function">printSum</span><span class="token punctuation">(</span><span class="token number">5.0</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// In this case the parameters are two different types.</span>
                    <span class="token comment">// The compiler is unable to deduce the type of T</span>
                    <span class="token comment">// because there are contradictions. As a result</span>
                    <span class="token comment">// this is a compile time error.</span>

</code></pre></div><p>This feature allows us to simplify code when we combine template structures and functions. There is a common pattern in the standard library that allows us to make <code>template structure X</code> using a helper function <code>make_X()</code>.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// The make_X pattern looks like this.</span>
<span class="token comment">// 1) A template structure with 1 or more template types.</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T2</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">MyPair</span>
<span class="token punctuation">{</span>
    T1      first<span class="token punctuation">;</span>
    T2      second<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 2) A make function that has a parameter type for</span>
<span class="token comment">//    each template parameter in the template structure.</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T1</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T2</span><span class="token operator">&gt;</span>
MyPair<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token operator">&gt;</span> <span class="token function">make_MyPair</span><span class="token punctuation">(</span>T1 t1<span class="token punctuation">,</span> T2 t2<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> MyPair<span class="token operator">&lt;</span>T1<span class="token punctuation">,</span> T2<span class="token operator">&gt;</span><span class="token punctuation">{</span>t1<span class="token punctuation">,</span> t2<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>How does this help?</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">auto</span> val1 <span class="token operator">=</span> MyPair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8.7</span><span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token comment">// Create object explicitly defining the types</span>
<span class="token keyword">auto</span> val2 <span class="token operator">=</span> <span class="token function">make_MyPair</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">8.7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// Create object using the types of the paramters.</span>
                                            <span class="token comment">// In this code both val1 and val2 are the same</span>
                                            <span class="token comment">// type.</span>

</code></pre></div><p>Note: This is not designed to shorten the code. This is designed to make the code more robust. It allows the types to be changed by changing the code in a single place rather than in multiple locations.</p> <h2 id="basic-class-template"><a href="#basic-class-template" class="header-anchor">#</a> Basic Class Template</h2> <p>The basic idea of a class template is that the template parameter gets substituted by a type at compile time. The result is that the same class can be reused for multiple types. The user specifies which type will be used when a variable of the class is declared. Three examples of this are shown in <code>main()</code>:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>         <span class="token comment">// A simple class to hold one number of any type</span>
<span class="token keyword">class</span> <span class="token class-name">Number</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">setNum</span><span class="token punctuation">(</span>T n<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// Sets the class field to the given number</span>
    T <span class="token function">plus1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>          <span class="token comment">// returns class field's &quot;follower&quot;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    T num<span class="token punctuation">;</span>                    <span class="token comment">// Class field</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>         <span class="token comment">// Set the class field to the given number</span>
<span class="token keyword">void</span> <span class="token class-name">Number</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">setNum</span><span class="token punctuation">(</span>T n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    num <span class="token operator">=</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>         <span class="token comment">// returns class field's &quot;follower&quot;</span>
T <span class="token class-name">Number</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">plus1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Number<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> anInt<span class="token punctuation">;</span>        <span class="token comment">// Test with an integer (int replaces T in the class)</span>
    anInt<span class="token punctuation">.</span><span class="token function">setNum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;My integer + 1 is &quot;</span> <span class="token operator">&lt;&lt;</span> anInt<span class="token punctuation">.</span><span class="token function">plus1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;\n&quot;</span><span class="token punctuation">;</span>     <span class="token comment">// Prints 2</span>

    Number<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">&gt;</span> aDouble<span class="token punctuation">;</span>   <span class="token comment">// Test with a double</span>
    aDouble<span class="token punctuation">.</span><span class="token function">setNum</span><span class="token punctuation">(</span><span class="token number">3.1415926535897</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;My double + 1 is &quot;</span> <span class="token operator">&lt;&lt;</span> aDouble<span class="token punctuation">.</span><span class="token function">plus1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;\n&quot;</span><span class="token punctuation">;</span>    <span class="token comment">// Prints 4.14159</span>

    Number<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span> aFloat<span class="token punctuation">;</span>     <span class="token comment">// Test with a float</span>
    aFloat<span class="token punctuation">.</span><span class="token function">setNum</span><span class="token punctuation">(</span><span class="token number">1.4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;My float + 1 is &quot;</span> <span class="token operator">&lt;&lt;</span> aFloat<span class="token punctuation">.</span><span class="token function">plus1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;\n&quot;</span><span class="token punctuation">;</span>      <span class="token comment">// Prints 2.4</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// Successful completion</span>
<span class="token punctuation">}</span>

</code></pre></div><h2 id="variadic-template-data-structures"><a href="#variadic-template-data-structures" class="header-anchor">#</a> Variadic template data structures</h2> <p>It is often useful to define classes or structures that have a variable number and type of data members which are defined at compile time. The canonical example is <code>std::tuple</code>, but sometimes is it is necessary to define your own custom structures. Here is an example that defines the structure using compounding (rather than inheritance as with <code>std::tuple</code>. Start with the general (empty) definition, which also serves as the base-case for recrusion termination in the later specialisation:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> T<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">DataStructure</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>This already allows us to define an empty structure, <code>DataStructure&lt;&gt; data</code>, albeit that isn't very useful yet.</p> <p>Next comes the recursive case specialisation:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Rest<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">DataStructure</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Rest <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
    <span class="token function">DataStructure</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> first<span class="token punctuation">,</span> <span class="token keyword">const</span> Rest<span class="token operator">&amp;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> rest<span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token function">first</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span>
        <span class="token punctuation">,</span> <span class="token function">rest</span><span class="token punctuation">(</span>rest<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span><span class="token punctuation">}</span>
    
    T first<span class="token punctuation">;</span>                                
    DataStructure<span class="token operator">&lt;</span>Rest <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">&gt;</span> rest<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>This is now sufficient for us to create arbitrary data structures, like <code>DataStructure&lt;int, float, std::string&gt; data(1, 2.1, &quot;hello&quot;)</code>.</p> <p>So what's going on? First, note that this is a specialisation whose requirement is that at least one variadic template parameter (namely <code>T</code> above) exists, whilst not caring about the specific makeup of the pack <code>Rest</code>. Knowing that <code>T</code> exists allows the definition of its data member, <code>first</code>. The rest of the data is recursively packaged as <code>DataStructure&lt;Rest ... &gt; rest</code>. The constructor initiates both of those members, including a recursive constructor call to the <code>rest</code> member.</p> <p>To understand this better, we can work through an example: suppose you have a declaration <code>DataStructure&lt;int, float&gt; data</code>. The declaration first matches against the specialisation, yielding a structure with <code>int first</code> and <code>DataStructure&lt;float&gt; rest</code> data members. The <code>rest</code> definition again matches this specialisation, creating its own <code>float first</code> and <code>DataStructure&lt;&gt; rest</code> members. Finally this last <code>rest</code> matches against the base-case defintion, producing an empty structure.</p> <p>You can visualise this as follows:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>DataStructure<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">&gt;</span>
   <span class="token operator">-&gt;</span> <span class="token keyword">int</span> first
   <span class="token operator">-&gt;</span> DataStructure<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span> rest
         <span class="token operator">-&gt;</span> <span class="token keyword">float</span> first
         <span class="token operator">-&gt;</span> DataStructure<span class="token operator">&lt;</span><span class="token operator">&gt;</span> rest
              <span class="token operator">-&gt;</span> <span class="token punctuation">(</span>empty<span class="token punctuation">)</span>

</code></pre></div><p>Now we have the data structure, but its not terribly useful yet as we cannot easily access the individual data elements (for example to access the last member of <code>DataStructure&lt;int, float, std::string&gt; data</code> we would have to use <code>data.rest.rest.first</code>, which is not exactly user-friendly). So we add a <code>get</code> method to it (only needed in the specialisation as the base-case structure has no data to <code>get</code>):</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Rest<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">DataStructure</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Rest <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span>size_t idx<span class="token operator">&gt;</span>
    <span class="token keyword">auto</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">GetHelper</span><span class="token operator">&lt;</span>idx<span class="token punctuation">,</span> DataStructure<span class="token operator">&lt;</span>T<span class="token punctuation">,</span>Rest<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>As you can see this <code>get</code> member function is itself templated - this time on the index of the member that is needed (so usage can be things like <code>data.get&lt;1&gt;()</code>, similar to <code>std::tuple</code>). The actual work is done by a static function in a helper class, <code>GetHelper</code>. The reason we can't define the required functionality directly in <code>DataStructure</code>'s <code>get</code> is because (as we will shortly see) we would need to specialise on <code>idx</code> - but it isn't possible to specialise a template member function without specialising the containing class template. Note also the use of a C++14-style <code>auto</code> here makes our lives significantly simpler as otherwise we would need quite a complicated expression for the return type.</p> <p>So on to the helper class. This time we will need an empty forward declaration and two specialisations. First the declaration:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span>size_t idx<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">GetHelper</span><span class="token punctuation">;</span>

</code></pre></div><p>Now the base-case (when <code>idx==0</code>). In this case we just return the <code>first</code> member:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Rest<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">GetHelper</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">,</span> DataStructure<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Rest <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">&gt;&gt;</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> T <span class="token function">get</span><span class="token punctuation">(</span>DataStructure<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Rest<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> data<span class="token punctuation">.</span>first<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>In the recursive case, we decrement <code>idx</code> and invoke the <code>GetHelper</code> for the <code>rest</code> member:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span>size_t idx<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Rest<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">GetHelper</span><span class="token operator">&lt;</span>idx<span class="token punctuation">,</span> DataStructure<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Rest <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">&gt;&gt;</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">auto</span> <span class="token function">get</span><span class="token punctuation">(</span>DataStructure<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Rest<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">GetHelper</span><span class="token operator">&lt;</span>idx<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> DataStructure<span class="token operator">&lt;</span>Rest <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">get</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>rest<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>To work through an example, suppose we have <code>DataStructure&lt;int, float&gt; data</code> and we need <code>data.get&lt;1&gt;()</code>. This invokes <code>GetHelper&lt;1, DataStructure&lt;int, float&gt;&gt;::get(data)</code> (the 2nd specialisation), which in turn invokes <code>GetHelper&lt;0, DataStructure&lt;float&gt;&gt;::get(data.rest)</code>, which finally returns (by the 1st specialisation as now <code>idx</code> is 0) <code>data.rest.first</code>.</p> <p>So that's it! Here is the whole functioning code, with some example use in the <code>main</code> function:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">template</span><span class="token operator">&lt;</span>size_t idx<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">GetHelper</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> T<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">DataStructure</span>
<span class="token punctuation">{</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Rest<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">DataStructure</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Rest <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
    <span class="token function">DataStructure</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> first<span class="token punctuation">,</span> <span class="token keyword">const</span> Rest<span class="token operator">&amp;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> rest<span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token function">first</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span>
        <span class="token punctuation">,</span> <span class="token function">rest</span><span class="token punctuation">(</span>rest<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span><span class="token punctuation">}</span>
    
    T first<span class="token punctuation">;</span>
    DataStructure<span class="token operator">&lt;</span>Rest <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">&gt;</span> rest<span class="token punctuation">;</span>
    
    <span class="token keyword">template</span><span class="token operator">&lt;</span>size_t idx<span class="token operator">&gt;</span>
    <span class="token keyword">auto</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">GetHelper</span><span class="token operator">&lt;</span>idx<span class="token punctuation">,</span> DataStructure<span class="token operator">&lt;</span>T<span class="token punctuation">,</span>Rest<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Rest<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">GetHelper</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">,</span> DataStructure<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Rest <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">&gt;&gt;</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> T <span class="token function">get</span><span class="token punctuation">(</span>DataStructure<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Rest<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> data<span class="token punctuation">.</span>first<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span>size_t idx<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Rest<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">GetHelper</span><span class="token operator">&lt;</span>idx<span class="token punctuation">,</span> DataStructure<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Rest <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token operator">&gt;&gt;</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">auto</span> <span class="token function">get</span><span class="token punctuation">(</span>DataStructure<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Rest<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">GetHelper</span><span class="token operator">&lt;</span>idx<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> DataStructure<span class="token operator">&lt;</span>Rest <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">get</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>rest<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    DataStructure<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> <span class="token function">data</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2.1</span><span class="token punctuation">,</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> data<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> data<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> data<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">get</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token number">2</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h2 id="argument-forwarding"><a href="#argument-forwarding" class="header-anchor">#</a> Argument forwarding</h2> <p>Template may accept both lvalue and rvalue references using <strong>forwarding reference</strong>:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T <span class="token operator">&amp;&amp;</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>In this case, the real type of <code>t</code> will be deduced depending on the context:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">X</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

X x<span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// calls f&lt;X&amp;&gt;(x)</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token function">X</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// calls f&lt;X&gt;(x)</span>

</code></pre></div><p>In the first case, the type <code>T</code> is deduced as <strong>reference to <code>X</code></strong> (<code>X&amp;</code>), and the type of <code>t</code> is <strong>lvalue reference to <code>X</code></strong>, while in the second case the type of <code>T</code> is deduced as <code>X</code> and the type of <code>t</code> as <strong>rvalue reference to <code>X</code></strong> (<code>X&amp;&amp;</code>).</p> <p><strong>Note:</strong> It is worth noticing that in the first case, <code>decltype(t)</code> is the same as <code>T</code>, but not in the second.</p> <p>In order to perfectly forward <code>t</code> to another function ,whether it is an lvalue or rvalue reference, one must use <code>std::forward</code>:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>T <span class="token operator">&amp;&amp;</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">g</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Forwarding references may be used with variadic templates:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">g</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>Args<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p><strong>Note:</strong> Forwarding references can only be used for template parameters, for instance, in the following code, <code>v</code> is a rvalue reference, not a forwarding reference:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token operator">&amp;&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><h2 id="template-specialization"><a href="#template-specialization" class="header-anchor">#</a> Template Specialization</h2> <p>You can define implementation for specific instantiations of a template class/method.</p> <p>For example if you have:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
T <span class="token function">sqrt</span><span class="token punctuation">(</span>T t<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* Some generic implementation */</span> <span class="token punctuation">}</span>

</code></pre></div><p>You can then write:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>
<span class="token keyword">int</span> <span class="token generic-function"><span class="token function">sqrt</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* Highly optimized integer implementation */</span> <span class="token punctuation">}</span>

</code></pre></div><p>Then a user that writes <code>sqrt(4.0)</code> will get the generic implementation whereas <code>sqrt(4)</code> will get the specialized implementation.</p> <h2 id="partial-template-specialization"><a href="#partial-template-specialization" class="header-anchor">#</a> Partial template specialization</h2> <p>In contrast of a full template specialization partial template specialization allows to introduce template with some of the arguments of existing template fixed. Partial template specialization is only available for template class/structs:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// Common case:</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">S</span> <span class="token punctuation">{</span>
    T t_val<span class="token punctuation">;</span>
    U u_val<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Special case when the first template argument is fixed to int</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">V</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">S</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> V<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">double</span> another_value<span class="token punctuation">;</span>
    <span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">double</span> arg<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// Do something}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>As shown above, partial template specializations may introduce completely different sets of data and function members.</p> <p>When a partially specialized template is instantiated, the most suitable specialization is selected. For example, let's define a template and two partial specializations:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">V</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">S</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;General case\n&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">V</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">S</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> U<span class="token punctuation">,</span> V<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;T = int\n&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">V</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">S</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">,</span> V<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;T = int, U = double\n&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>Now the following calls:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token class-name">S</span><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">S</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">S</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>will print</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>General <span class="token keyword">case</span>
T <span class="token operator">=</span> <span class="token keyword">int</span>
T <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">,</span> U <span class="token operator">=</span> <span class="token keyword">double</span>

</code></pre></div><p>Function templates may only be fully specialized:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>T t<span class="token punctuation">,</span> U u<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;General case: &quot;</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> u <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// OK.</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token generic-function"><span class="token function">foo</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">int</span> a1<span class="token punctuation">,</span> <span class="token keyword">int</span> a2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Two ints: &quot;</span> <span class="token operator">&lt;&lt;</span> a1 <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> a2 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">invoke_foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2.1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Prints &quot;General case: 1 2.1&quot;</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Prints &quot;Two ints: 1 2&quot;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Compilation error: partial function specialization is not allowed.</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token generic-function"><span class="token function">foo</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token punctuation">,</span> U<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string t<span class="token punctuation">,</span> U u<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;General case: &quot;</span> <span class="token operator">&lt;&lt;</span> t <span class="token operator">&lt;&lt;</span> <span class="token string">&quot; &quot;</span> <span class="token operator">&lt;&lt;</span> u <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h2 id="alias-template"><a href="#alias-template" class="header-anchor">#</a> Alias template</h2> <p>Basic example:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">using</span> pointer <span class="token operator">=</span> T<span class="token operator">*</span><span class="token punctuation">;</span>

</code></pre></div><p>This definition makes <code>pointer&lt;T&gt;</code> an alias of <code>T*</code>. For example:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>pointer<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span> <span class="token comment">// equivalent to: int* p = new int;</span>

</code></pre></div><p>Alias templates cannot be specialized. However, that functionality can be obtained indirectly by having them refer to a nested type in a struct:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
 <span class="token keyword">struct</span> <span class="token class-name">nonconst_pointer_helper</span> <span class="token punctuation">{</span> <span class="token keyword">typedef</span> T<span class="token operator">*</span> type<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
 <span class="token keyword">struct</span> <span class="token class-name">nonconst_pointer_helper</span><span class="token operator">&lt;</span>T <span class="token keyword">const</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">typedef</span> T<span class="token operator">*</span> type<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">using</span> nonconst_pointer <span class="token operator">=</span> nonconst_pointer_helper<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token punctuation">;</span>

</code></pre></div><h2 id="template-template-parameters"><a href="#template-template-parameters" class="header-anchor">#</a> Template template parameters</h2> <p>Sometimes we would like to pass into the template a template type without fixing its values. This is what template template parameters are created for. Very simple template template parameter examples:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">Tag1</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">Tag2</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">Tag</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">IntTag</span> <span class="token punctuation">{</span>
   <span class="token keyword">typedef</span> Tag<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> type<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   IntTag<span class="token operator">&lt;</span>Tag1<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type t<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">C</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
C<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">cast_all</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&lt;</span>U<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   C<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">result</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span> vf <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token number">2.6</span><span class="token punctuation">,</span> <span class="token number">3.7</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
   <span class="token keyword">auto</span> vi <span class="token operator">=</span> <span class="token generic-function"><span class="token function">cast_all</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>vf<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;&amp;</span>i<span class="token operator">:</span> vi<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><h2 id="declaring-non-type-template-arguments-with-auto"><a href="#declaring-non-type-template-arguments-with-auto" class="header-anchor">#</a> Declaring non-type template arguments with auto</h2> <p>Prior to C++17, when writing a template non-type parameter, you had to specify its type first. So a common pattern became writing something like:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> T N<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">integral_constant</span> <span class="token punctuation">{</span>
    <span class="token keyword">using</span> type <span class="token operator">=</span> T<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> T value <span class="token operator">=</span> N<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">using</span> five <span class="token operator">=</span> integral_constant<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

</code></pre></div><p>But for complicated expressions, using something like this involves having to write <code>decltype(expr), expr</code> when instantiating templates. The solution is to simplify this idiom and simply allow <code>auto</code>:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">auto</span> N<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">integral_constant</span> <span class="token punctuation">{</span>
    <span class="token keyword">using</span> type <span class="token operator">=</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">static</span> <span class="token keyword">constexpr</span> type value <span class="token operator">=</span> N<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">using</span> five <span class="token operator">=</span> integral_constant<span class="token operator">&lt;</span><span class="token number">5</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

</code></pre></div><h3 id="empty-custom-deleter-for-unique-ptr"><a href="#empty-custom-deleter-for-unique-ptr" class="header-anchor">#</a> Empty custom deleter for unique_ptr</h3> <p>A nice motivating example can come from trying to combine the empty base optimization with a custom deleter for <code>unique_ptr</code>. Different C API deleters have different return types, but we don't care - we just want something to work for any function:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">auto</span> DeleteFn<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">FunctionDeleter</span> <span class="token punctuation">{</span>
    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
        <span class="token function">DeleteFn</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token keyword">auto</span> DeleteFn<span class="token operator">&gt;</span>
<span class="token keyword">using</span> unique_ptr_deleter <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> FunctionDeleter<span class="token operator">&lt;</span>DeleteFn<span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>

</code></pre></div><p>And now you can simply use any function pointer that can take an argument of type <code>T</code> as a template non-type parameter, regardless of return type, and get a no-size overhead <code>unique_ptr</code> out of it:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>unique_ptr_deleter<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>FILE<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>fclose<span class="token operator">&gt;</span> p<span class="token punctuation">;</span>

</code></pre></div><h2 id="non-type-template-parameter"><a href="#non-type-template-parameter" class="header-anchor">#</a> Non-type template parameter</h2> <p>Apart from types as a template parameter we are allowed to declare
values of constant expressions meeting one of the following criteria:</p> <ul><li>integral or enumeration type,</li> <li>pointer to object  or pointer to function,</li> <li>lvalue reference to object or lvalue  reference to function,</li> <li>pointer to member,</li> <li><code>std::nullptr_t</code>.</li></ul> <p>Like all template parameters, non-type template parameters can be explicitly specified, defaulted, or derived implicitly via Template Argument Deduction.</p> <p>Example of non-type template parameter usage:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t size<span class="token operator">&gt;</span>
std<span class="token double-colon punctuation">::</span>size_t <span class="token function">size_of</span><span class="token punctuation">(</span><span class="token function">T</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>anArray<span class="token punctuation">)</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">// Pass array by reference. Requires.</span>
<span class="token punctuation">{</span>                                        <span class="token comment">// an exact size. We allow all sizes</span>
    <span class="token keyword">return</span> size<span class="token punctuation">;</span>                         <span class="token comment">// by using a template &quot;size&quot;.</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">char</span> anArrayOfChar<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;anArrayOfChar: &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token function">size_of</span><span class="token punctuation">(</span>anArrayOfChar<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;\n&quot;</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span>  anArrayOfData<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;anArrayOfData: &quot;</span> <span class="token operator">&lt;&lt;</span> <span class="token function">size_of</span><span class="token punctuation">(</span>anArrayOfData<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;\n&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Example of explicitly specifying both type and non-type template parameters:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;array&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token operator">&gt;</span> foo<span class="token punctuation">;</span> <span class="token comment">// int is a type parameter, 5 is non-type</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Non-type template parameters are one of the ways to achieve template
recurrence and enables to do <a href="http://stackoverflow.com/documentation/c%2b%2b/462/metaprogramming" target="_blank" rel="noopener noreferrer">Metaprogramming<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <h2 id="explicit-instantiation"><a href="#explicit-instantiation" class="header-anchor">#</a> Explicit instantiation</h2> <p>An explicit instantiation definition creates and declares a concrete class, function, or variable from a template, without using it just yet. An explicit instantiation can be referenced from other translation units. This can be used to avoid defining a template in a header file, if it will only be instantiated with a finite set of arguments. For example:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// print_string.h</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">print_string</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">*</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// print_string.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;print_string.h&quot;</span></span>
<span class="token keyword">template</span> <span class="token keyword">void</span> <span class="token function">print_string</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token keyword">void</span> <span class="token function">print_string</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">wchar_t</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>Because <code>print_string&lt;char&gt;</code> and <code>print_string&lt;wchar_t&gt;</code> are explicitly instantiated in <code>print_string.cpp</code>, the linker will be able to find them even though the <code>print_string</code> template is not defined in the header. If these explicit instantiation declarations were not present, a linker error would likely occur. See <a href="http://stackoverflow.com/questions/495021/why-can-templates-only-be-implemented-in-the-header-file" target="_blank" rel="noopener noreferrer">Why can templates only be implemented in the header file?<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>If an explicit instantiation definition is preceded by the <code>extern</code> <a href="http://stackoverflow.com/documentation/c%2b%2b/4891/keywords" target="_blank" rel="noopener noreferrer">keyword<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, it becomes an explicit instantiation <strong>declaration</strong> instead. The presence of an explicit instantiation declaration for a given specialization  prevents the implicit instantiation of the given specialization within the current translation unit. Instead, a reference to that specialization that would otherwise cause an implicit instantiation can refer to an explicit instantiation definition in the same or another TU.</p> <p><code>foo.h</code></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">FOO_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FOO_H</span></span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>T x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// complicated implementation</span>
<span class="token punctuation">}</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

</code></pre></div><p><code>foo.cpp</code></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;foo.h&quot;</span></span>
<span class="token comment">// explicit instantiation definitions for common cases</span>
<span class="token keyword">template</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">template</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p><code>main.cpp</code></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;foo.h&quot;</span></span>
<span class="token comment">// we already know foo.cpp has explicit instantiation definitions for these</span>
<span class="token keyword">extern</span> <span class="token keyword">template</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// instantiates foo&lt;int&gt; here;</span>
               <span class="token comment">// wasteful since foo.cpp provides an explicit instantiation already!</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// does not instantiate foo&lt;double&gt; here;</span>
               <span class="token comment">// uses instantiation of foo&lt;double&gt; in foo.cpp instead</span>
<span class="token punctuation">}</span>

</code></pre></div><h2 id="default-template-parameter-value"><a href="#default-template-parameter-value" class="header-anchor">#</a> Default template parameter value</h2> <p>Just like in case of the function arguments, template parameters can have their default values. All template parameters with a default value have to be declared at the end of the template parameter list. The basic idea is that the template parameters with default value can be omitted while template instantiation.</p> <p>Simple example of default template parameter value usage:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> size_t N <span class="token operator">=</span> <span class="token number">10</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">my_array</span> <span class="token punctuation">{</span>
    T arr<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* Default parameter is ignored, N = 5 */</span>
    my_array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token operator">&gt;</span> a<span class="token punctuation">;</span>

    <span class="token comment">/* Print the length of a.arr: 5 */</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    <span class="token comment">/* Last parameter is omitted, N = 10 */</span>
    my_array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> b<span class="token punctuation">;</span>

    <span class="token comment">/* Print the length of a.arr: 10 */</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>arr<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h4 id="syntax"><a href="#syntax" class="header-anchor">#</a> Syntax</h4> <ul><li>template &lt; <strong>template-parameter-list</strong> &gt; <strong>declaration</strong></li> <li>export template &lt; <strong>template-parameter-list</strong> &gt; <strong>declaration</strong> /* until C++11 */</li> <li>template &lt;&gt; <strong>declaration</strong></li> <li>template <strong>declaration</strong></li> <li>extern template <strong>declaration</strong> /* since C++11 */</li> <li>template &lt; <strong>template-parameter-list</strong> &gt; class ...(<strong>opt</strong>) <strong>identifier</strong>(<strong>opt</strong>)</li> <li>template &lt; <strong>template-parameter-list</strong> &gt; class <strong>identifier</strong>(<strong>opt</strong>) = <strong>id-expression</strong></li> <li>template &lt; <strong>template-parameter-list</strong> &gt; typename ...(<strong>opt</strong>) <strong>identifier</strong>(<strong>opt</strong>) /* since C++17 */</li> <li>template &lt; <strong>template-parameter-list</strong> &gt; typename <strong>identifier</strong>(<strong>opt</strong>) = <strong>id-expression</strong> /* since C++17 */</li> <li><strong>postfix-expression</strong> . template <strong>id-expression</strong></li> <li><strong>postfix-expression</strong> -&gt; template <strong>id-expression</strong></li> <li><strong>nested-name-specifier</strong> <code>template</code> <strong>simple-template-id</strong> <code>::</code></li></ul> <h4 id="remarks"><a href="#remarks" class="header-anchor">#</a> Remarks</h4> <p>The word <code>template</code> is a <a href="http://stackoverflow.com/documentation/c%2b%2b/4891/keywords" target="_blank" rel="noopener noreferrer">keyword<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> with five different meanings in the C++ language, depending on the context.</p> <li>
When followed by a list of template parameters enclosed in `&lt;&gt;`, it declares a template such as a [class template](http://stackoverflow.com/documentation/c%2b%2b/460/templates/3999/basic-class-template), a [function template](http://stackoverflow.com/documentation/c%2b%2b/460/templates/1517/function-templates), or a [partial specialization](http://stackoverflow.com/documentation/c%2b%2b/460/templates/6253/partial-template-specialization) of an existing template.
<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">++</span>x<span class="token punctuation">;</span> <span class="token punctuation">}</span>

</code></pre></div></li> <li>
When followed by an **empty** `&lt;&gt;`, it declares a an [explicit (full) specialization](http://stackoverflow.com/documentation/c%2b%2b/460/templates/5054/template-specialization).
<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>T x<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span> <span class="token comment">// &lt;-- keyword used in this sense here</span>
<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// output the content of the string</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%s\n&quot;</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div></li> <li>
When followed by a declaration without `&lt;&gt;`, it forms an [explicit instantiation](http://stackoverflow.com/documentation/c%2b%2b/460/templates/28734/explicit-instantiation) declaration or definition.
<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
std<span class="token double-colon punctuation">::</span>set<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">make_singleton</span><span class="token punctuation">(</span>T x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">set</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">template</span> std<span class="token double-colon punctuation">::</span>set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">make_singleton</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &lt;-- keyword used in this sense here</span>

</code></pre></div></li> <li>
Within a template parameter list, it introduces a [template template parameter](http://stackoverflow.com/documentation/c%2b%2b/460/templates/10838/template-template-parameters).
<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">U</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">Alloc</span><span class="token operator">&gt;</span>
<span class="token comment">//                 ^^^^^^^^ keyword used in this sense here</span>
<span class="token keyword">class</span> <span class="token class-name">List</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>
        T value<span class="token punctuation">;</span>
        Node<span class="token operator">*</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    Alloc<span class="token operator">&lt;</span>Node<span class="token operator">&gt;</span> allocator<span class="token punctuation">;</span>
    Node<span class="token operator">*</span> <span class="token function">allocate_node</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> allocator<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div></li> <li>
After the scope resolution operator `::` and the class member access operators `.` and `-&gt;`, it specifies that the following name is a template.
<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Allocator</span> <span class="token punctuation">{</span>
    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
    T<span class="token operator">*</span> <span class="token function">allocate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Alloc</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">List</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>
        T value<span class="token punctuation">;</span>
        Node<span class="token operator">*</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    Alloc allocator<span class="token punctuation">;</span>
    Node<span class="token operator">*</span> <span class="token function">allocate_node</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// return allocator.allocate&lt;Node&gt;();       // error: &lt; and &gt; are interpreted as</span>
                                                    <span class="token comment">// comparison operators</span>
        <span class="token keyword">return</span> allocator<span class="token punctuation">.</span><span class="token keyword">template</span> <span class="token generic-function"><span class="token function">allocate</span><span class="token generic class-name"><span class="token operator">&lt;</span>Node<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok; allocate is a template</span>
        <span class="token comment">//               ^^^^^^^^ keyword used in this sense here</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div></li> <p>Before C++11, a template could be declared with the <code>export</code> <a href="http://stackoverflow.com/documentation/c%2b%2b/4891/keywords" target="_blank" rel="noopener noreferrer">keyword<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, making it into an <strong>exported</strong> template. An exported template's definition does not need to be present in every translation unit in which the template is instantiated. For example, the following was supposed to work:</p> <p><code>foo.h</code>:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">FOO_H</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">FOO_H</span></span>
<span class="token keyword">export</span> <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> T <span class="token function">identity</span><span class="token punctuation">(</span>T x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

</code></pre></div><p><code>foo.cpp</code>:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;foo.h&quot;</span></span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> T <span class="token function">identity</span><span class="token punctuation">(</span>T x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span>

</code></pre></div><p><code>main.cpp</code>:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;foo.h&quot;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token function">identity</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// x is 42</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Due to difficulty of implementation, the <code>export</code> keyword was not supported by most major compilers. It was removed in C++11; now, it is illegal to use the <code>export</code> keyword at all. Instead, it is usually necessary to define templates in headers (in contrast to non-template functions, which are usually <strong>not</strong> defined in headers). See <a href="http://stackoverflow.com/questions/495021/why-can-templates-only-be-implemented-in-the-header-file" target="_blank" rel="noopener noreferrer">Why can templates only be implemented in the header file?<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/devtut/generate/edit/master/docs/cpp/templates.md" target="_blank" rel="noopener noreferrer">Edit this page on GitHub</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/cpp/data-structures-in-c.html" class="prev">
        Data Structures in C++
      </a></span> <span class="next"><a href="/cpp/expression-templates.html">
        Expression templates
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.1779e102.js" defer></script><script src="/assets/js/3.2cfa8016.js" defer></script><script src="/assets/js/733.70af0de2.js" defer></script>
  </body>
</html>
