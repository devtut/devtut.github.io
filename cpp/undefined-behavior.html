<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C++ | Undefined Behavior</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="description" content="Reading or writing through a null pointer, Using an uninitialized local variable, Accessing an out-of-bounds index, Deleting a derived object via a pointer to a base class that doesn't have a virtual destructor., Extending the `std` or `posix` Namespace, No return statement for a function with a non-void return type, Integer division by zero, Accessing a dangling reference, Invalid pointer arithmetic, Signed Integer Overflow, Incorrect pairing of memory allocation and deallocation, Shifting by an invalid number of positions, Multiple non-identical definitions (the One Definition Rule), Modifying a const object, Modifying a string literal, Accessing an object as the wrong type, Overflow during conversion to or from floating point type, Returning from a [[noreturn]] function, Infinite template recursion, Floating point overflow, Calling (Pure) Virtual Members From Constructor Or Destructor, Invalid base-to-derived static cast, Function call through mismatched function pointer type, Access to nonexistent member through pointer to member, Invalid derived-to-base conversion for pointers to members, Destroying an object that has already been destroyed">
    <meta property="og:site_name" content="DevTut">
    <meta property="og:title" content="C++ | Undefined Behavior">
    <meta property="og:description" content="Reading or writing through a null pointer, Using an uninitialized local variable, Accessing an out-of-bounds index, Deleting a derived object via a pointer to a base class that doesn't have a virtual destructor., Extending the `std` or `posix` Namespace, No return statement for a function with a non-void return type, Integer division by zero, Accessing a dangling reference, Invalid pointer arithmetic, Signed Integer Overflow, Incorrect pairing of memory allocation and deallocation, Shifting by an invalid number of positions, Multiple non-identical definitions (the One Definition Rule), Modifying a const object, Modifying a string literal, Accessing an object as the wrong type, Overflow during conversion to or from floating point type, Returning from a [[noreturn]] function, Infinite template recursion, Floating point overflow, Calling (Pure) Virtual Members From Constructor Or Destructor, Invalid base-to-derived static cast, Function call through mismatched function pointer type, Access to nonexistent member through pointer to member, Invalid derived-to-base conversion for pointers to members, Destroying an object that has already been destroyed">
    <meta property="og:type" content="article">
    <meta property="og:url" content="/cpp/undefined-behavior.html">
    <meta property="og:image" content="/logo.png">
    <meta name="twitter:title" content="C++ | Undefined Behavior">
    <meta name="twitter:description" content="Reading or writing through a null pointer, Using an uninitialized local variable, Accessing an out-of-bounds index, Deleting a derived object via a pointer to a base class that doesn't have a virtual destructor., Extending the `std` or `posix` Namespace, No return statement for a function with a non-void return type, Integer division by zero, Accessing a dangling reference, Invalid pointer arithmetic, Signed Integer Overflow, Incorrect pairing of memory allocation and deallocation, Shifting by an invalid number of positions, Multiple non-identical definitions (the One Definition Rule), Modifying a const object, Modifying a string literal, Accessing an object as the wrong type, Overflow during conversion to or from floating point type, Returning from a [[noreturn]] function, Infinite template recursion, Floating point overflow, Calling (Pure) Virtual Members From Constructor Or Destructor, Invalid base-to-derived static cast, Function call through mismatched function pointer type, Access to nonexistent member through pointer to member, Invalid derived-to-base conversion for pointers to members, Destroying an object that has already been destroyed">
    <meta name="twitter:url" content="/cpp/undefined-behavior.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="/logo.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/mstile-150x150.png">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="google-site-verification" content="76_rKXgwMVIjd-axJC_1zPV9OS4mEjvtgjYOWVkAdnQ">
    
    <link rel="preload" href="/assets/css/0.styles.60619e34.css" as="style"><link rel="preload" href="/assets/js/app.1779e102.js" as="script"><link rel="preload" href="/assets/js/3.2cfa8016.js" as="script"><link rel="preload" href="/assets/js/746.bd36588e.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.60619e34.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">DevTut</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>C++</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/cpp/" aria-current="page" class="sidebar-link">Disclaimer</a></li><li><a href="/cpp/getting-started-with-cpp.html" class="sidebar-link">Getting started with C++</a></li><li><a href="/cpp/literals.html" class="sidebar-link">Literals</a></li><li><a href="/cpp/operator-precedence.html" class="sidebar-link">operator precedence</a></li><li><a href="/cpp/floating-point-arithmetic.html" class="sidebar-link">Floating Point Arithmetic</a></li><li><a href="/cpp/bit-operators.html" class="sidebar-link">Bit Operators</a></li><li><a href="/cpp/bit-manipulation.html" class="sidebar-link">Bit Manipulation</a></li><li><a href="/cpp/bit-fields.html" class="sidebar-link">Bit fields</a></li><li><a href="/cpp/arrays.html" class="sidebar-link">Arrays</a></li><li><a href="/cpp/iterators.html" class="sidebar-link">Iterators</a></li><li><a href="/cpp/basic-input-output-in-c.html" class="sidebar-link">Basic input/output in c++</a></li><li><a href="/cpp/loops.html" class="sidebar-link">Loops</a></li><li><a href="/cpp/file-i-o.html" class="sidebar-link">File I/O</a></li><li><a href="/cpp/cpp-streams.html" class="sidebar-link">C++ Streams</a></li><li><a href="/cpp/stream-manipulators.html" class="sidebar-link">Stream manipulators</a></li><li><a href="/cpp/flow-control.html" class="sidebar-link">Flow Control</a></li><li><a href="/cpp/metaprogramming.html" class="sidebar-link">Metaprogramming</a></li><li><a href="/cpp/const-keyword.html" class="sidebar-link">const keyword</a></li><li><a href="/cpp/mutable-keyword.html" class="sidebar-link">mutable keyword</a></li><li><a href="/cpp/friend-keyword.html" class="sidebar-link">Friend keyword</a></li><li><a href="/cpp/type-keywords.html" class="sidebar-link">Type Keywords</a></li><li><a href="/cpp/basic-type-keywords.html" class="sidebar-link">Basic Type Keywords</a></li><li><a href="/cpp/variable-declaration-keywords.html" class="sidebar-link">Variable Declaration Keywords</a></li><li><a href="/cpp/keywords.html" class="sidebar-link">Keywords</a></li><li><a href="/cpp/returning-several-values-from-a-function.html" class="sidebar-link">Returning several values from a function</a></li><li><a href="/cpp/polymorphism.html" class="sidebar-link">Polymorphism</a></li><li><a href="/cpp/references.html" class="sidebar-link">References</a></li><li><a href="/cpp/value-and-reference-semantics.html" class="sidebar-link">Value and Reference Semantics</a></li><li><a href="/cpp/c-function-call-by-value-vs-call-by-reference.html" class="sidebar-link">C++ function &quot;call by value&quot; vs. &quot;call by reference&quot;</a></li><li><a href="/cpp/copying-vs-assignment.html" class="sidebar-link">Copying vs Assignment</a></li><li><a href="/cpp/pointers.html" class="sidebar-link">Pointers</a></li><li><a href="/cpp/pointers-to-members.html" class="sidebar-link">Pointers to members</a></li><li><a href="/cpp/the-this-pointer.html" class="sidebar-link">The This Pointer</a></li><li><a href="/cpp/smart-pointers.html" class="sidebar-link">Smart Pointers</a></li><li><a href="/cpp/classes-structures.html" class="sidebar-link">Classes/Structures</a></li><li><a href="/cpp/function-overloading.html" class="sidebar-link">Function Overloading</a></li><li><a href="/cpp/operator-overloading.html" class="sidebar-link">Operator Overloading</a></li><li><a href="/cpp/function-template-overloading.html" class="sidebar-link">Function Template Overloading</a></li><li><a href="/cpp/virtual-member-functions.html" class="sidebar-link">Virtual Member Functions</a></li><li><a href="/cpp/inline-functions.html" class="sidebar-link">Inline functions</a></li><li><a href="/cpp/special-member-functions.html" class="sidebar-link">Special Member Functions</a></li><li><a href="/cpp/non-static-member-functions.html" class="sidebar-link">Non-Static Member Functions</a></li><li><a href="/cpp/constant-class-member-functions.html" class="sidebar-link">Constant class member functions</a></li><li><a href="/cpp/c-containers.html" class="sidebar-link">C++ Containers</a></li><li><a href="/cpp/namespaces.html" class="sidebar-link">Namespaces</a></li><li><a href="/cpp/header-files.html" class="sidebar-link">Header Files</a></li><li><a href="/cpp/using-declaration.html" class="sidebar-link">Using declaration</a></li><li><a href="/cpp/std-string.html" class="sidebar-link">std::string</a></li><li><a href="/cpp/std-array.html" class="sidebar-link">std::array</a></li><li><a href="/cpp/std-vector.html" class="sidebar-link">std::vector</a></li><li><a href="/cpp/std-map.html" class="sidebar-link">std::map</a></li><li><a href="/cpp/std-optional.html" class="sidebar-link">std::optional</a></li><li><a href="/cpp/std-function-to-wrap-any-element-that-is-callable.html" class="sidebar-link">std::function: To wrap any element that is callable</a></li><li><a href="/cpp/std-forward-list.html" class="sidebar-link">std::forward_list</a></li><li><a href="/cpp/std-pair.html" class="sidebar-link">std::pair</a></li><li><a href="/cpp/std-atomics.html" class="sidebar-link">std::atomics</a></li><li><a href="/cpp/std-variant.html" class="sidebar-link">std::variant</a></li><li><a href="/cpp/std-iomanip.html" class="sidebar-link">std::iomanip</a></li><li><a href="/cpp/std-any.html" class="sidebar-link">std::any</a></li><li><a href="/cpp/std-set-and-std-multiset.html" class="sidebar-link">std::set and std::multiset</a></li><li><a href="/cpp/std-integer-sequence.html" class="sidebar-link">std::integer_sequence</a></li><li><a href="/cpp/using-std-unordered-map.html" class="sidebar-link">Using std::unordered_map</a></li><li><a href="/cpp/standard-library-algorithms.html" class="sidebar-link">Standard Library Algorithms</a></li><li><a href="/cpp/the-iso-c-standard.html" class="sidebar-link">The ISO C++ Standard</a></li><li><a href="/cpp/inline-variables.html" class="sidebar-link">Inline variables</a></li><li><a href="/cpp/random-number-generation.html" class="sidebar-link">Random number generation</a></li><li><a href="/cpp/date-and-time-using-chrono-header.html" class="sidebar-link">Date and time using  header</a></li><li><a href="/cpp/sorting.html" class="sidebar-link">Sorting</a></li><li><a href="/cpp/enumeration.html" class="sidebar-link">Enumeration</a></li><li><a href="/cpp/iteration.html" class="sidebar-link">Iteration</a></li><li><a href="/cpp/regular-expressions.html" class="sidebar-link">Regular expressions</a></li><li><a href="/cpp/implementation-defined-behavior.html" class="sidebar-link">Implementation-defined behavior</a></li><li><a href="/cpp/exceptions.html" class="sidebar-link">Exceptions</a></li><li><a href="/cpp/lambdas.html" class="sidebar-link">Lambdas</a></li><li><a href="/cpp/value-categories.html" class="sidebar-link">Value Categories</a></li><li><a href="/cpp/preprocessor.html" class="sidebar-link">Preprocessor</a></li><li><a href="/cpp/data-structures-in-c.html" class="sidebar-link">Data Structures in C++</a></li><li><a href="/cpp/templates.html" class="sidebar-link">Templates</a></li><li><a href="/cpp/expression-templates.html" class="sidebar-link">Expression templates</a></li><li><a href="/cpp/curiously-recurring-template-pattern-crtp.html" class="sidebar-link">Curiously Recurring Template Pattern (CRTP)</a></li><li><a href="/cpp/threading.html" class="sidebar-link">Threading</a></li><li><a href="/cpp/thread-synchronization-structures.html" class="sidebar-link">Thread synchronization structures</a></li><li><a href="/cpp/the-rule-of-three-five-and-zero.html" class="sidebar-link">The Rule of Three, Five, And Zero</a></li><li><a href="/cpp/raii-resource-acquisition-is-initialization.html" class="sidebar-link">RAII: Resource Acquisition Is Initialization</a></li><li><a href="/cpp/rtti-run-time-type-information.html" class="sidebar-link">RTTI: Run-Time Type Information</a></li><li><a href="/cpp/mutexes.html" class="sidebar-link">Mutexes</a></li><li><a href="/cpp/recursive-mutex.html" class="sidebar-link">Recursive Mutex</a></li><li><a href="/cpp/semaphore.html" class="sidebar-link">Semaphore</a></li><li><a href="/cpp/futures-and-promises.html" class="sidebar-link">Futures and Promises</a></li><li><a href="/cpp/atomic-types.html" class="sidebar-link">Atomic Types</a></li><li><a href="/cpp/type-erasure.html" class="sidebar-link">Type Erasure</a></li><li><a href="/cpp/explicit-type-conversions.html" class="sidebar-link">Explicit type conversions</a></li><li><a href="/cpp/unnamed-types.html" class="sidebar-link">Unnamed types</a></li><li><a href="/cpp/type-traits.html" class="sidebar-link">Type Traits</a></li><li><a href="/cpp/return-type-covariance.html" class="sidebar-link">Return Type Covariance</a></li><li><a href="/cpp/layout-of-object-types.html" class="sidebar-link">Layout of object types</a></li><li><a href="/cpp/type-inference.html" class="sidebar-link">Type Inference</a></li><li><a href="/cpp/typedef-and-type-aliases.html" class="sidebar-link">Typedef and type aliases</a></li><li><a href="/cpp/type-deduction.html" class="sidebar-link">type deduction</a></li><li><a href="/cpp/trailing-return-type.html" class="sidebar-link">Trailing return type</a></li><li><a href="/cpp/alignment.html" class="sidebar-link">Alignment</a></li><li><a href="/cpp/perfect-forwarding.html" class="sidebar-link">Perfect Forwarding</a></li><li><a href="/cpp/decltype.html" class="sidebar-link">decltype</a></li><li><a href="/cpp/sfinae-substitution-failure-is-not-an-error.html" class="sidebar-link">SFINAE (Substitution Failure Is Not An Error)</a></li><li><a href="/cpp/undefined-behavior.html" aria-current="page" class="active sidebar-link">Undefined Behavior</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cpp/undefined-behavior.html#reading-or-writing-through-a-null-pointer" class="sidebar-link">Reading or writing through a null pointer</a></li><li class="sidebar-sub-header"><a href="/cpp/undefined-behavior.html#using-an-uninitialized-local-variable" class="sidebar-link">Using an uninitialized local variable</a></li><li class="sidebar-sub-header"><a href="/cpp/undefined-behavior.html#accessing-an-out-of-bounds-index" class="sidebar-link">Accessing an out-of-bounds index</a></li><li class="sidebar-sub-header"><a href="/cpp/undefined-behavior.html#deleting-a-derived-object-via-a-pointer-to-a-base-class-that-doesn-t-have-a-virtual-destructor" class="sidebar-link">Deleting a derived object via a pointer to a base class that doesn't have a virtual destructor.</a></li><li class="sidebar-sub-header"><a href="/cpp/undefined-behavior.html#extending-the-std-or-posix-namespace" class="sidebar-link">Extending the std or posix Namespace</a></li><li class="sidebar-sub-header"><a href="/cpp/undefined-behavior.html#no-return-statement-for-a-function-with-a-non-void-return-type" class="sidebar-link">No return statement for a function with a non-void return type</a></li><li class="sidebar-sub-header"><a href="/cpp/undefined-behavior.html#integer-division-by-zero" class="sidebar-link">Integer division by zero</a></li><li class="sidebar-sub-header"><a href="/cpp/undefined-behavior.html#accessing-a-dangling-reference" class="sidebar-link">Accessing a dangling reference</a></li><li class="sidebar-sub-header"><a href="/cpp/undefined-behavior.html#invalid-pointer-arithmetic" class="sidebar-link">Invalid pointer arithmetic</a></li><li class="sidebar-sub-header"><a href="/cpp/undefined-behavior.html#signed-integer-overflow" class="sidebar-link">Signed Integer Overflow</a></li><li class="sidebar-sub-header"><a href="/cpp/undefined-behavior.html#incorrect-pairing-of-memory-allocation-and-deallocation" class="sidebar-link">Incorrect pairing of memory allocation and deallocation</a></li><li class="sidebar-sub-header"><a href="/cpp/undefined-behavior.html#shifting-by-an-invalid-number-of-positions" class="sidebar-link">Shifting by an invalid number of positions</a></li><li class="sidebar-sub-header"><a href="/cpp/undefined-behavior.html#multiple-non-identical-definitions-the-one-definition-rule" class="sidebar-link">Multiple non-identical definitions (the One Definition Rule)</a></li><li class="sidebar-sub-header"><a href="/cpp/undefined-behavior.html#modifying-a-const-object" class="sidebar-link">Modifying a const object</a></li><li class="sidebar-sub-header"><a href="/cpp/undefined-behavior.html#modifying-a-string-literal" class="sidebar-link">Modifying a string literal</a></li><li class="sidebar-sub-header"><a href="/cpp/undefined-behavior.html#accessing-an-object-as-the-wrong-type" class="sidebar-link">Accessing an object as the wrong type</a></li><li class="sidebar-sub-header"><a href="/cpp/undefined-behavior.html#overflow-during-conversion-to-or-from-floating-point-type" class="sidebar-link">Overflow during conversion to or from floating point type</a></li><li class="sidebar-sub-header"><a href="/cpp/undefined-behavior.html#returning-from-a-noreturn-function" class="sidebar-link">Returning from a [[noreturn]] function</a></li><li class="sidebar-sub-header"><a href="/cpp/undefined-behavior.html#infinite-template-recursion" class="sidebar-link">Infinite template recursion</a></li><li class="sidebar-sub-header"><a href="/cpp/undefined-behavior.html#floating-point-overflow" class="sidebar-link">Floating point overflow</a></li><li class="sidebar-sub-header"><a href="/cpp/undefined-behavior.html#calling-pure-virtual-members-from-constructor-or-destructor" class="sidebar-link">Calling (Pure) Virtual Members From Constructor Or Destructor</a></li><li class="sidebar-sub-header"><a href="/cpp/undefined-behavior.html#invalid-base-to-derived-static-cast" class="sidebar-link">Invalid base-to-derived static cast</a></li><li class="sidebar-sub-header"><a href="/cpp/undefined-behavior.html#function-call-through-mismatched-function-pointer-type" class="sidebar-link">Function call through mismatched function pointer type</a></li><li class="sidebar-sub-header"><a href="/cpp/undefined-behavior.html#access-to-nonexistent-member-through-pointer-to-member" class="sidebar-link">Access to nonexistent member through pointer to member</a></li><li class="sidebar-sub-header"><a href="/cpp/undefined-behavior.html#invalid-derived-to-base-conversion-for-pointers-to-members" class="sidebar-link">Invalid derived-to-base conversion for pointers to members</a></li><li class="sidebar-sub-header"><a href="/cpp/undefined-behavior.html#destroying-an-object-that-has-already-been-destroyed" class="sidebar-link">Destroying an object that has already been destroyed</a></li></ul></li><li><a href="/cpp/overload-resolution.html" class="sidebar-link">Overload resolution</a></li><li><a href="/cpp/move-semantics.html" class="sidebar-link">Move Semantics</a></li><li><a href="/cpp/pimpl-idiom.html" class="sidebar-link">Pimpl Idiom</a></li><li><a href="/cpp/auto.html" class="sidebar-link">auto</a></li><li><a href="/cpp/copy-elision.html" class="sidebar-link">Copy Elision</a></li><li><a href="/cpp/fold-expressions.html" class="sidebar-link">Fold Expressions</a></li><li><a href="/cpp/unions.html" class="sidebar-link">Unions</a></li><li><a href="/cpp/design-pattern-implementation-in-c.html" class="sidebar-link">Design pattern implementation in C++</a></li><li><a href="/cpp/singleton-design-pattern.html" class="sidebar-link">Singleton Design Pattern</a></li><li><a href="/cpp/user-defined-literals.html" class="sidebar-link">User-Defined Literals</a></li><li><a href="/cpp/memory-management.html" class="sidebar-link">Memory management</a></li><li><a href="/cpp/c-11-memory-model.html" class="sidebar-link">C++11 Memory Model</a></li><li><a href="/cpp/scopes.html" class="sidebar-link">Scopes</a></li><li><a href="/cpp/static-assert.html" class="sidebar-link">static_assert</a></li><li><a href="/cpp/constexpr.html" class="sidebar-link">constexpr</a></li><li><a href="/cpp/one-definition-rule-odr.html" class="sidebar-link">One Definition Rule (ODR)</a></li><li><a href="/cpp/unspecified-behavior.html" class="sidebar-link">Unspecified behavior</a></li><li><a href="/cpp/argument-dependent-name-lookup.html" class="sidebar-link">Argument Dependent Name Lookup</a></li><li><a href="/cpp/attributes.html" class="sidebar-link">Attributes</a></li><li><a href="/cpp/recursion-in-c.html" class="sidebar-link">Recursion in C++</a></li><li><a href="/cpp/arithmitic-metaprogramming.html" class="sidebar-link">Arithmitic Metaprogramming</a></li><li><a href="/cpp/callable-objects.html" class="sidebar-link">Callable Objects</a></li><li><a href="/cpp/client-server-examples.html" class="sidebar-link">Client server examples</a></li><li><a href="/cpp/const-correctness.html" class="sidebar-link">Const Correctness</a></li><li><a href="/cpp/parameter-packs.html" class="sidebar-link">Parameter packs</a></li><li><a href="/cpp/build-systems.html" class="sidebar-link">Build Systems</a></li><li><a href="/cpp/concurrency-with-openmp.html" class="sidebar-link">Concurrency With OpenMP</a></li><li><a href="/cpp/resource-management.html" class="sidebar-link">Resource Management</a></li><li><a href="/cpp/storage-class-specifiers.html" class="sidebar-link">Storage class specifiers</a></li><li><a href="/cpp/linkage-specifications.html" class="sidebar-link">Linkage specifications</a></li><li><a href="/cpp/digit-separators.html" class="sidebar-link">Digit separators</a></li><li><a href="/cpp/c-incompatibilities.html" class="sidebar-link">C incompatibilities</a></li><li><a href="/cpp/side-by-side-comparisons-of-classic-c-examples-solved-via-c-vs-c-11-vs-c-14-vs-c-17.html" class="sidebar-link">Side by Side Comparisons of classic C++ examples solved via C++ vs C++11 vs C++14 vs C++17</a></li><li><a href="/cpp/compiling-and-building.html" class="sidebar-link">Compiling and Building</a></li><li><a href="/cpp/common-compile-linker-errors-gcc.html" class="sidebar-link">Common compile/linker errors (GCC)</a></li><li><a href="/cpp/more-undefined-behaviors-in-c.html" class="sidebar-link">More undefined behaviors in C++</a></li><li><a href="/cpp/unit-testing-in-c.html" class="sidebar-link">Unit Testing in C++</a></li><li><a href="/cpp/c-debugging-and-debug-prevention-tools-techniques.html" class="sidebar-link">C++ Debugging and Debug-prevention Tools &amp; Techniques</a></li><li><a href="/cpp/optimization-in-c.html" class="sidebar-link">Optimization in C++</a></li><li><a href="/cpp/optimization.html" class="sidebar-link">Optimization</a></li><li><a href="/cpp/profiling.html" class="sidebar-link">Profiling</a></li><li><a href="/cpp/refactoring-techniques.html" class="sidebar-link">Refactoring Techniques</a></li><li><a href="/cpp/internationalization-in-c.html" class="sidebar-link">Internationalization in C++</a></li><li><a href="/cpp/contributors.html" class="sidebar-link">The Contributors</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="undefined-behavior"><a href="#undefined-behavior" class="header-anchor">#</a> Undefined Behavior</h1> <p>What is undefined behavior (UB)? According to the ISO C++ Standard (ยง1.3.24, N4296), it is &quot;behavior for which this International Standard imposes no requirements.&quot;</p> <p>This means that when a program encounters UB, it is allowed to do whatever it wants. This often means a crash, but it may simply do nothing, <a href="http://catb.org/jargon/html/N/nasal-demons.html" target="_blank" rel="noopener noreferrer">make demons fly out of your nose<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, or even <strong>appear</strong> to work properly!</p> <p>Needless to say, you should avoid writing code that invokes UB.</p> <h2 id="reading-or-writing-through-a-null-pointer"><a href="#reading-or-writing-through-a-null-pointer" class="header-anchor">#</a> Reading or writing through a null pointer</h2> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// Undefined behavior</span>

</code></pre></div><p>This is <strong>undefined behavior</strong>, because a null pointer does not point to any valid object, so there is no object at <code>*ptr</code> to write to.</p> <p>Although this most often causes a segmentation fault, it is undefined and anything can happen.</p> <h2 id="using-an-uninitialized-local-variable"><a href="#using-an-uninitialized-local-variable" class="header-anchor">#</a> Using an uninitialized local variable</h2> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> a<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">;</span> <span class="token comment">// Undefined behavior!</span>

</code></pre></div><p>This results in <strong>undefined behavior</strong>, because <code>a</code> is uninitialised.</p> <p>It is often, incorrectly, claimed that this is because the value is &quot;indeterminate&quot;, or &quot;whatever value was in that memory location before&quot;.  However, it is the act of accessing the value of <code>a</code> in the above example that gives undefined behaviour.  In practice, printing a &quot;garbage value&quot; is a common symptom in this case, but that is only one possible form of undefined behaviour.</p> <p>Although highly unlikely in practice (since it is reliant on specific hardware support) the compiler could equally well electrocute the programmer when compiling the code sample above.   With such a compiler and hardware support, such a response to undefined behaviour would markedly increase average (living) programmer understanding of the true meaning of undefined behaviour - which is that the standard places no constraint on the resultant behaviour.</p> <p>Using an indeterminate value of <code>unsigned char</code> type does not produce undefined behavior if the value is used as:</p> <ul><li>the second or third operand of the ternary conditional operator;</li> <li>the right operand of the built-in comma operator;</li> <li>the operand of a conversion to <code>unsigned char</code>;</li> <li>the right operand of the assignment operator, if the left operand is also of type <code>unsigned char</code>;</li> <li>the initializer for an <code>unsigned char</code> object;</li></ul> <p>or if the value is discarded. In such cases, the indeterminate value simply propagates to the result of the expression, if applicable.</p> <p>Note that a <code>static</code> variable is <strong>always</strong> zero-initialized (if possible):</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">static</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">;</span> <span class="token comment">// Defined behavior, 'a' is 0</span>

</code></pre></div><h2 id="accessing-an-out-of-bounds-index"><a href="#accessing-an-out-of-bounds-index" class="header-anchor">#</a> Accessing an out-of-bounds index</h2> <p>It is <strong>undefined behavior</strong> to access an index that is out of bounds for an array (or standard library container for that matter, as they are all implemented using a <strong>raw</strong> array):</p> <div class="language- extra-class"><pre class="language-text"><code>
int array[] = {1, 2, 3, 4, 5};
 array[5] = 0;  // Undefined behavior

</code></pre></div><p>It is <strong>allowed</strong> to have a pointer pointing to the end of the array (in this case <code>array + 5</code>), you just can't dereference it, as it is not a valid element.</p> <div class="language- extra-class"><pre class="language-text"><code>
const int *end = array + 5;  // Pointer to one past the last index
 for (int *p = array; p != end; ++p)
   // Do something with `p`

</code></pre></div><p>In general, you're not allowed to create an out-of-bounds pointer. A pointer must point to an element within the array, or one past the end.</p> <h2 id="deleting-a-derived-object-via-a-pointer-to-a-base-class-that-doesn-t-have-a-virtual-destructor"><a href="#deleting-a-derived-object-via-a-pointer-to-a-base-class-that-doesn-t-have-a-virtual-destructor" class="header-anchor">#</a> Deleting a derived object via a pointer to a base class that doesn't have a virtual destructor.</h2> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">base</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">base</span></span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> 

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    base<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token comment">// The is undefined behavior!</span>
<span class="token punctuation">}</span>

</code></pre></div><p>In section [expr.delete] ยง5.3.5/3 the standard says that if <code>delete</code> is called on an object whose static type does not have a <code>virtual</code> destructor:</p> <blockquote></blockquote> <p>if the static type of the object to be deleted is different from its
dynamic type, the static type shall be a base class of the dynamic type of the object to be deleted and the
static type shall have a virtual destructor or the behavior is undefined.</p> <p>This is the case regardless of the question whether the derived class added any data members to the base class.</p> <h2 id="extending-the-std-or-posix-namespace"><a href="#extending-the-std-or-posix-namespace" class="header-anchor">#</a> Extending the <code>std</code> or <code>posix</code> Namespace</h2> <p><a href="https://isocpp.org/files/papers/N3690.pdf" target="_blank" rel="noopener noreferrer">The standard (17.6.4.2.1/1)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> generally forbids extending the <code>std</code> namespace:</p> <blockquote></blockquote> <p>The behavior of a C++ program is undefined if it adds declarations or definitions to namespace std or to a namespace within namespace std unless otherwise specified.</p> <p>The same goes for <code>posix</code> (17.6.4.2.2/1):</p> <blockquote></blockquote> <p>The behavior of a C++ program is undefined if it adds declarations or definitions to namespace posix or to a namespace within namespace posix unless otherwise specified.</p> <p>Consider the following:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>

<span class="token keyword">namespace</span> std
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Nothing in the standard forbids <code>algorithm</code> (or one of the headers it includes) defining the same definition, and so this code would violate the <a href="https://en.wikipedia.org/wiki/One_Definition_Rule" target="_blank" rel="noopener noreferrer">One Definition Rule<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <p>So, in general, this is forbidden. There are <a href="http://en.cppreference.com/w/cpp/language/extending_std" target="_blank" rel="noopener noreferrer">specific exceptions allowed<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, though. Perhaps most usefully, it is allowed to add specializations for user defined types. So, for example, suppose your code has</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">foo</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Stuff</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>Then the following is fine</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">namespace</span> std
<span class="token punctuation">{</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>
    <span class="token keyword">struct</span> <span class="token class-name">hash</span><span class="token operator">&lt;</span>foo<span class="token operator">&gt;</span>
    <span class="token punctuation">{</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        size_t <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> foo <span class="token operator">&amp;</span>f<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h2 id="no-return-statement-for-a-function-with-a-non-void-return-type"><a href="#no-return-statement-for-a-function-with-a-non-void-return-type" class="header-anchor">#</a> No return statement for a function with a non-void return type</h2> <p>Omitting the <code>return</code> statement in a function which is has a return type that is not <code>void</code> is <strong>undefined behavior</strong>.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
    <span class="token comment">// Missing return statement</span>
<span class="token punctuation">}</span> 

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//Undefined Behavior</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Most modern day compilers emit a warning at compile time for this kind of undefined behavior.</p> <p><strong>Note:</strong> <code>main</code> is the only exception to the rule. If <code>main</code> doesn't have a <code>return</code> statement, the compiler automatically inserts <code>return 0;</code> for you, so it can be safely left out.</p> <h2 id="integer-division-by-zero"><a href="#integer-division-by-zero" class="header-anchor">#</a> Integer division by zero</h2> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// Undefined behavior</span>

</code></pre></div><p>Division by <code>0</code> is mathematically undefined, and as such it makes sense that this is undefined behavior.</p> <p>However:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">float</span> x <span class="token operator">=</span> <span class="token number">5.0f</span> <span class="token operator">/</span> <span class="token number">0.0f</span><span class="token punctuation">;</span>   <span class="token comment">// x is +infinity</span>

</code></pre></div><p>Most implementation implement IEEE-754, which defines floating point division by zero to return <code>NaN</code> (if numerator is <code>0.0f</code>), <code>infinity</code> (if numerator is positive) or <code>-infinity</code> (if numerator is negative).</p> <h2 id="accessing-a-dangling-reference"><a href="#accessing-a-dangling-reference" class="header-anchor">#</a> Accessing a dangling reference</h2> <p>It is illegal to access a reference to an object that has gone out of scope or been otherwise destroyed. Such a reference is said to be <strong>dangling</strong> since it no longer refers to a valid object.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span><span class="token operator">&amp;</span> r <span class="token operator">=</span> <span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> r <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;\n&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>In this example, the local variable <code>x</code> goes out of scope when <code>getX</code> returns. (Note that <strong>lifetime extension</strong> cannot extend the lifetime of a local variable past the scope of the block in which it is defined.) Therefore <code>r</code> is a dangling reference. This program has undefined behavior, although it may appear to work and print <code>42</code> in some cases.</p> <h2 id="invalid-pointer-arithmetic"><a href="#invalid-pointer-arithmetic" class="header-anchor">#</a> Invalid pointer arithmetic</h2> <p>The following uses of pointer arithmetic cause undefined behavior:</p> <li>
Addition or subtraction of an integer, if the result does not belong to the same array object as the pointer operand. (Here, the element one past the end is considered to still belong to the array.)
<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">*</span> p2 <span class="token operator">=</span> p1 <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// ok; p2 points to a[9]</span>
<span class="token keyword">int</span><span class="token operator">*</span> p3 <span class="token operator">=</span> p1 <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// ok; p2 points to one past the end of a</span>
<span class="token keyword">int</span><span class="token operator">*</span> p4 <span class="token operator">=</span> p1 <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token comment">// UB</span>
<span class="token keyword">int</span><span class="token operator">*</span> p5 <span class="token operator">=</span> p1 <span class="token operator">-</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// ok; p2 points to a[0]</span>
<span class="token keyword">int</span><span class="token operator">*</span> p6 <span class="token operator">=</span> p1 <span class="token operator">-</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token comment">// UB</span>
<span class="token keyword">int</span><span class="token operator">*</span> p7 <span class="token operator">=</span> p3 <span class="token operator">-</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// ok; p7 points to a[5]</span>

</code></pre></div></li> <li>
Subtraction of two pointers if they do not both belong to the same array object. (Again, the element one past the end is considered to belong to the array.) The exception is that two null pointers may be subtracted, yielding 0.
<div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">*</span>p2 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> d1 <span class="token operator">=</span> p1 <span class="token operator">-</span> p2<span class="token punctuation">;</span> <span class="token comment">// yields 5</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p3 <span class="token operator">=</span> p1 <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// ok; p3 points to one past the end of a</span>
<span class="token keyword">int</span> d2 <span class="token operator">=</span> p3 <span class="token operator">-</span> p2<span class="token punctuation">;</span> <span class="token comment">// yields 7</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p4 <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> d3 <span class="token operator">=</span> p4 <span class="token operator">-</span> p1<span class="token punctuation">;</span> <span class="token comment">// UB</span>

</code></pre></div></li> <li>
Subtraction of two pointers if the result overflows `std::ptrdiff_t`.
</li> <li><p>Any pointer arithmetic where either operand's pointee type does not match the dynamic type of the object pointed to (ignoring cv-qualification). According to the standard, &quot;[in] particular, a pointer to a base
class cannot be used for pointer arithmetic when the array contains objects of a derived class type.&quot;</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">Base</span></span> <span class="token punctuation">{</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
Derived a<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
Base<span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token comment">// ok</span>
Base<span class="token operator">*</span> p2 <span class="token operator">=</span> p1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token comment">// UB; p1 points to Derived</span>
Base<span class="token operator">*</span> p3 <span class="token operator">=</span> p1 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token comment">// likewise</span>
Base<span class="token operator">*</span> p4 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token comment">// ok</span>
<span class="token keyword">auto</span> p5 <span class="token operator">=</span> p4 <span class="token operator">-</span> p1<span class="token punctuation">;</span>          <span class="token comment">// UB; p4 and p1 point to Derived</span>
<span class="token keyword">const</span> Derived<span class="token operator">*</span> p6 <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> Derived<span class="token operator">*</span> p7 <span class="token operator">=</span> p6 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// ok; cv-qualifiers don't matter</span>

</code></pre></div></li> <h2 id="signed-integer-overflow"><a href="#signed-integer-overflow" class="header-anchor">#</a> Signed Integer Overflow</h2> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> x <span class="token operator">=</span> INT_MAX <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">// x can be anything -&gt; Undefined behavior</span>

</code></pre></div><blockquote></blockquote> <p>If during the evaluation of an expression, the result is not mathematically defined or not in the range of representable values for its type, the behavior is undefined.</p> <p><sup>(C++11 Standard paragraph 5/4)</sup></p> <p>This is one of the more nasty ones, as it usually yields reproducible, non-crashing behavior so developers may be tempted to rely heavily on the observed behavior.</p> <p>On the other hand:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">unsigned</span> <span class="token keyword">int</span> x <span class="token operator">=</span> UINT_MAX <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">// x is 0</span>

</code></pre></div><p>is well defined since:</p> <blockquote></blockquote> <p>Unsigned integers, declared unsigned, shall obey the laws of arithmetic modulo <code>2^n</code> where <code>n</code> is the number of bits in the value representation of that particular size of integer.</p> <p><sup>(C++11 Standard paragraph 3.9.1/4)</sup></p> <p>Sometimes compilers may exploit an undefined behavior and optimize</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">signed</span> <span class="token keyword">int</span> x <span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">&gt;</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">//do something</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Here since a signed integer overflow is not defined, compiler is free to assume
that it may never happen and hence it can optimize away the &quot;if&quot; block</p> <h2 id="incorrect-pairing-of-memory-allocation-and-deallocation"><a href="#incorrect-pairing-of-memory-allocation-and-deallocation" class="header-anchor">#</a> Incorrect pairing of memory allocation and deallocation</h2> <p>An object can only be deallocated by <code>delete</code> if it was allocated by <code>new</code> and is not an array. If the argument to <code>delete</code> was not returned by <code>new</code> or is an array, the behavior is undefined.</p> <p>An object can only be deallocated by <code>delete[]</code> if it was allocated by <code>new</code> and is an array. If the argument to <code>delete[]</code> was not returned by <code>new</code> or is not an array, the behavior is undefined.</p> <p>If the argument to <code>free</code> was not returned by <code>malloc</code>, the behavior is undefined.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">;</span>
<span class="token keyword">delete</span> p1<span class="token punctuation">;</span>      <span class="token comment">// correct</span>
<span class="token comment">// delete[] p1; // undefined</span>
<span class="token comment">// free(p1);    // undefined</span>

<span class="token keyword">int</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p2<span class="token punctuation">;</span>    <span class="token comment">// correct</span>
<span class="token comment">// delete p2;   // undefined</span>
<span class="token comment">// free(p2);    // undefined</span>

<span class="token keyword">int</span><span class="token operator">*</span> p3 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">free</span><span class="token punctuation">(</span>p3<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// correct</span>
<span class="token comment">// delete p3;   // undefined</span>
<span class="token comment">// delete[] p3; // undefined</span>

</code></pre></div><p>Such issues can be avoided by completely avoiding <code>malloc</code> and <code>free</code> in C++ programs, preferring the standard library smart pointers over raw <code>new</code> and <code>delete</code>, and preferring <code>std::vector</code> and <code>std::string</code> over raw <code>new</code> and <code>delete[]</code>.</p> <h2 id="shifting-by-an-invalid-number-of-positions"><a href="#shifting-by-an-invalid-number-of-positions" class="header-anchor">#</a> Shifting by an invalid number of positions</h2> <p>For the built-in shift operator, the right operand must be nonnegative and strictly less than the bit width of the promoted left operand. Otherwise, the behavior is undefined.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> b <span class="token operator">=</span> a <span class="token operator">&lt;&lt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// UB</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> c <span class="token operator">=</span> a <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// ok</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> d <span class="token operator">=</span> a <span class="token operator">&lt;&lt;</span> <span class="token number">32</span><span class="token punctuation">;</span> <span class="token comment">// UB if int is 32 bits or less</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> e <span class="token operator">=</span> a <span class="token operator">&gt;&gt;</span> <span class="token number">32</span><span class="token punctuation">;</span> <span class="token comment">// also UB if int is 32 bits or less</span>
<span class="token keyword">const</span> <span class="token keyword">signed</span> <span class="token keyword">char</span> f <span class="token operator">=</span> <span class="token string">'x'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> g <span class="token operator">=</span> f <span class="token operator">&lt;&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// ok even if signed char is 10 bits or less;</span>
                       <span class="token comment">// int must be at least 16 bits</span>

</code></pre></div><h2 id="multiple-non-identical-definitions-the-one-definition-rule"><a href="#multiple-non-identical-definitions-the-one-definition-rule" class="header-anchor">#</a> Multiple non-identical definitions (the One Definition Rule)</h2> <p>If a class, enum, inline function, template, or member of a template has external linkage and is defined in multiple translation units, all definitions must be identical or the behavior is undefined according to the <a href="https://en.wikipedia.org/wiki/One_Definition_Rule" target="_blank" rel="noopener noreferrer">One Definition Rule (ODR)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <p><code>foo.h</code>:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">double</span> x<span class="token punctuation">;</span>
  <span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Foo <span class="token function">get_foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p><code>foo.cpp</code>:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&quot;foo.h&quot;</span></span>
Foo <span class="token function">get_foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* implementation */</span> <span class="token punctuation">}</span>

</code></pre></div><p><code>main.cpp</code>:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// I want access to the private member, so I am going to replace Foo with my own type</span>
<span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">double</span> x<span class="token punctuation">;</span>
    <span class="token keyword">int</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Foo <span class="token function">get_foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// declare this function ourselves since we aren't including foo.h</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Foo foo <span class="token operator">=</span> <span class="token function">get_foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// do something with foo.y</span>
<span class="token punctuation">}</span>

</code></pre></div><p>The above program exhibits undefined behavior because it contains two definitions of the class <code>::Foo</code>, which has external linkage, in different translation units, but the two definitions are not identical. Unlike redefinition of a class within the <strong>same</strong> translation unit, this problem is not required to be diagnosed by the compiler.</p> <h2 id="modifying-a-const-object"><a href="#modifying-a-const-object" class="header-anchor">#</a> Modifying a const object</h2> <p>Any attempt to modify a <code>const</code> object results in undefined behavior. This applies to <code>const</code> variables, members of <code>const</code> objects, and class members declared <code>const</code>. (However, a <code>mutable</code> member of a <code>const</code> object is not <code>const</code>.)</p> <p>Such an attempt can be made through <code>const_cast</code>:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">456</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>

</code></pre></div><p>A compiler will usually inline the value of a <code>const int</code> object, so it's possible that this code compiles and prints <code>123</code>. Compilers can also place <code>const</code> objects' values in read-only memory, so a segmentation fault may occur. In any case, the behavior is undefined and the program might do anything.</p> <p>The following program conceals a far more subtle error:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token operator">*</span> instance<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">get_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> m_x<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">set_x</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> m_x <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> Foo<span class="token operator">*</span><span class="token operator">&amp;</span> this_ref<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">m_x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        this_ref <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">int</span> m_x<span class="token punctuation">;</span>
    <span class="token keyword">friend</span> <span class="token keyword">const</span> Foo<span class="token operator">&amp;</span> <span class="token function">getFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> Foo<span class="token operator">&amp;</span> <span class="token function">getFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> Foo <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span> instance<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> foo<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">do_evil</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    instance<span class="token operator">-&gt;</span><span class="token function">set_x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> Foo<span class="token operator">&amp;</span> foo <span class="token operator">=</span> <span class="token function">getFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">do_evil</span><span class="token punctuation">(</span><span class="token number">456</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> foo<span class="token punctuation">.</span><span class="token function">get_x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>In this code, <code>getFoo</code> creates a singleton of type <code>const Foo</code> and its member <code>m_x</code> is initialized to <code>123</code>. Then <code>do_evil</code> is called and the value of <code>foo.m_x</code> is apparently changed to 456. What went wrong?</p> <p>Despite its name, <code>do_evil</code> does nothing particularly evil; all it does is call a setter through a <code>Foo*</code>. But that pointer points to a <code>const Foo</code> object even though <code>const_cast</code> was not used. This pointer was obtained through <code>Foo</code>'s constructor. A <code>const</code> object does not become <code>const</code> until its initialization is complete, so <code>this</code> has type <code>Foo*</code>, not <code>const Foo*</code>, within the constructor.</p> <p>Therefore, undefined behavior occurs even though there are no obviously dangerous constructs in this program.</p> <h2 id="modifying-a-string-literal"><a href="#modifying-a-string-literal" class="header-anchor">#</a> Modifying a string literal</h2> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> <span class="token string">&quot;hello world&quot;</span><span class="token punctuation">;</span>
str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'H'</span><span class="token punctuation">;</span>

</code></pre></div><p><code>&quot;hello world&quot;</code> is a string literal, so modifying it gives undefined behaviour.</p> <p>The initialisation of <code>str</code> in the above example was formally deprecated (scheduled for removal from a future version of the standard) in C++03.  A number of compilers before 2003 might issue a warning about this (e.g. a suspicious conversion).  After 2003, compilers typically warn about a deprecated conversion.</p> <p>The above example is illegal, and results in a compiler diagnostic, in C++11 and later.   A similar example may be constructed to exhibit undefined behaviour by explicitly permitting the type conversion, such as:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'H'</span><span class="token punctuation">;</span> 

</code></pre></div><h2 id="accessing-an-object-as-the-wrong-type"><a href="#accessing-an-object-as-the-wrong-type" class="header-anchor">#</a> Accessing an object as the wrong type</h2> <p>In most cases, it is illegal to access an object of one type as though it were a different type (disregarding cv-qualifiers). Example:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">float</span> x <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>The result is undefined behavior.</p> <p>There are some exceptions to  this <strong>strict aliasing</strong> rule:</p> <ul><li>An object of class type can be accessed as though it were of a type that is a base class of the actual class type.</li> <li>Any type can be accessed as a <code>char</code> or <code>unsigned char</code>, but the reverse is not true: a char array cannot be accessed as though it were an arbitrary type.</li> <li>A signed integer type can be accessed as the corresponding unsigned type and <strong>vice versa</strong>.</li></ul> <p>A related rule is that if a non-static member function is called on an object that does not actually have the same type as the defining class of the function, or a derived class, then undefined behavior occurs. This is true even if the function does not access the object.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">Unrelated</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Unrelated u<span class="token punctuation">;</span>
Derived<span class="token operator">&amp;</span> r1 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Derived<span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
r1<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                      <span class="token comment">// UB</span>
Base b<span class="token punctuation">;</span>
Derived<span class="token operator">&amp;</span> r2 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Derived<span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
r2<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                      <span class="token comment">// UB</span>

</code></pre></div><h2 id="overflow-during-conversion-to-or-from-floating-point-type"><a href="#overflow-during-conversion-to-or-from-floating-point-type" class="header-anchor">#</a> Overflow during conversion to or from floating point type</h2> <p>If, during the conversion of:</p> <ul><li>an integer type to a floating point type,</li> <li>a floating point type to an integer type, or</li> <li>a floating point type to a shorter floating point type,</li></ul> <p>the source value is outside the range of values that can be represented in the destination type, the result is undefined behavior. Example:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">double</span> x <span class="token operator">=</span> <span class="token number">1e100</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> y <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// int probably cannot hold numbers that large, so this is UB</span>

</code></pre></div><h2 id="returning-from-a-noreturn-function"><a href="#returning-from-a-noreturn-function" class="header-anchor">#</a> Returning from a [[noreturn]] function</h2> <p>Example from the Standard, [dcl.attr.noreturn]:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token punctuation">[</span><span class="token punctuation">[</span> noreturn <span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token string">&quot;error&quot;</span><span class="token punctuation">;</span> <span class="token comment">// OK</span>
<span class="token punctuation">}</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span> noreturn <span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token keyword">void</span> <span class="token function">q</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// behavior is undefined if called with an argument &lt;= 0</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">throw</span> <span class="token string">&quot;positive&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h2 id="infinite-template-recursion"><a href="#infinite-template-recursion" class="header-anchor">#</a> Infinite template recursion</h2> <p>Example from the Standard, [temp.inst]/17:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">X</span> <span class="token punctuation">{</span>
    X<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> p<span class="token punctuation">;</span> <span class="token comment">// OK</span>
    X<span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token operator">&gt;</span> a<span class="token punctuation">;</span> <span class="token comment">// implicit generation of X&lt;T&gt; requires</span>
             <span class="token comment">// the implicit instantiation of X&lt;T*&gt; which requires</span>
             <span class="token comment">// the implicit instantiation of X&lt;T**&gt; which ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><h2 id="floating-point-overflow"><a href="#floating-point-overflow" class="header-anchor">#</a> Floating point overflow</h2> <p>If an arithmetic operation that yields a floating point type produces a value that is not in the range of representable values of the result type, the behavior is undefined according to the C++ standard, but may be defined by other standards the machine might conform to, such as IEEE 754.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">float</span> x <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x <span class="token operator">*=</span> <span class="token number">10.0</span><span class="token punctuation">;</span> <span class="token comment">// will probably overflow eventually; undefined behavior</span>
<span class="token punctuation">}</span>

</code></pre></div><h2 id="calling-pure-virtual-members-from-constructor-or-destructor"><a href="#calling-pure-virtual-members-from-constructor-or-destructor" class="header-anchor">#</a> Calling (Pure) Virtual Members From Constructor Or Destructor</h2> <p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4527.pdf" target="_blank" rel="noopener noreferrer">The Standard (10.4)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> states:</p> <blockquote></blockquote> <p>Member functions can be called from a constructor (or destructor) of an abstract class; the effect of making a virtual call (10.3) to a pure virtual function directly or indirectly for the object being created (or destroyed) from such a constructor (or destructor) is undefined.</p> <p>More generally, some C++ authorities, e.g. Scott Meyers, <a href="http://www.artima.com/cppsource/nevercall.html" target="_blank" rel="noopener noreferrer">suggest<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> never calling virtual functions (even non-pure ones) from constructors and dstructors.</p> <p>Consider the following example, modified from the above link:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">transaction</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">transaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">log_it</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">log_it</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">sell_transaction</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">transaction</span></span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">log_it</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token comment">/* Do something */</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>Suppose we create a <code>sell_transaction</code> object:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>sell_transaction s<span class="token punctuation">;</span>

</code></pre></div><p>This implicitly calls the constructor of <code>sell_transaction</code>, which first calls the constructor of <code>transaction</code>. When the constructor of <code>transaction</code> is called though, the object is not yet of the type <code>sell_transaction</code>, but rather only of the type <code>transaction</code>.</p> <p>Consequently, the call in <code>transaction::transaction()</code> to <code>log_it</code>, won't do what might seem to be the intuitive thing - namely call <code>sell_transaction::log_it</code>.</p> <li>
If `log_it` is pure virtual, as in this example, the behaviour is undefined.
</li> <li>
If `log_it` is non-pure virtual, `transaction::log_it` will be called.
</li> <h2 id="invalid-base-to-derived-static-cast"><a href="#invalid-base-to-derived-static-cast" class="header-anchor">#</a> Invalid base-to-derived static cast</h2> <p>If <code>static_cast</code> is used to convert a pointer (resp. reference) to base class to a pointer (resp. reference) to derived class, but the operand does not point (resp. refer) to an object of the derived class type, the behavior is undefined. See <a href="http://stackoverflow.com/documentation/c%2b%2b/3090/explicit-type-conversions/10518/base-to-derived-conversion#t=201608021020103102096" target="_blank" rel="noopener noreferrer">Base to derived conversion<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <h2 id="function-call-through-mismatched-function-pointer-type"><a href="#function-call-through-mismatched-function-pointer-type" class="header-anchor">#</a> Function call through mismatched function pointer type</h2> <p>In order to call a function through a function pointer, the function pointer's type must exactly match the function's type. Otherwise, the behaviour is undefined. Example:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">p</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undefined</span>

</code></pre></div><h2 id="access-to-nonexistent-member-through-pointer-to-member"><a href="#access-to-nonexistent-member-through-pointer-to-member" class="header-anchor">#</a> Access to nonexistent member through pointer to member</h2> <p>When accessing a non-static member of an object through a pointer to member, if the object does not actually contain the member denoted by the pointer, the behavior is undefined. (Such a pointer to member can be obtained through <code>static_cast</code>.)</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">Base</span></span> <span class="token punctuation">{</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> Derived<span class="token double-colon punctuation">::</span><span class="token operator">*</span>pdy <span class="token operator">=</span> <span class="token operator">&amp;</span>Derived<span class="token double-colon punctuation">::</span>y<span class="token punctuation">;</span>
<span class="token keyword">int</span> Base<span class="token double-colon punctuation">::</span><span class="token operator">*</span>pby <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span> Base<span class="token double-colon punctuation">::</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>pdy<span class="token punctuation">)</span><span class="token punctuation">;</span>

Base<span class="token operator">*</span> b1 <span class="token operator">=</span> <span class="token keyword">new</span> Derived<span class="token punctuation">;</span>
b1<span class="token operator">-&gt;</span><span class="token operator">*</span>pby <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// ok; sets y in Derived object to 42</span>
Base<span class="token operator">*</span> b2 <span class="token operator">=</span> <span class="token keyword">new</span> Base<span class="token punctuation">;</span>
b2<span class="token operator">-&gt;</span><span class="token operator">*</span>pby <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token comment">// undefined; there is no y member in Base</span>

</code></pre></div><h2 id="invalid-derived-to-base-conversion-for-pointers-to-members"><a href="#invalid-derived-to-base-conversion-for-pointers-to-members" class="header-anchor">#</a> Invalid derived-to-base conversion for pointers to members</h2> <p>When <code>static_cast</code> is used to convert <code>T D::*</code> to <code>T B::*</code>, the member pointed to must belong to a class that is a base class or derived class of <code>B</code>. Otherwise the behavior is undefined.     See <a href="http://stackoverflow.com/documentation/c%2b%2b/3090/explicit-type-conversions/18752/derived-to-base-conversion-for-pointers-to-members" target="_blank" rel="noopener noreferrer">Derived to base conversion for pointers to members<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h2 id="destroying-an-object-that-has-already-been-destroyed"><a href="#destroying-an-object-that-has-already-been-destroyed" class="header-anchor">#</a> Destroying an object that has already been destroyed</h2> <p>In this example, a destructor is explicitly invoked for an object that will later be automatically destroyed.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">S</span> <span class="token punctuation">{</span>
    <span class="token operator">~</span><span class="token function">S</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;destroying S\n&quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    S s<span class="token punctuation">;</span>
    s<span class="token punctuation">.</span><span class="token operator">~</span><span class="token function">S</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// UB: s destroyed a second time here</span>

</code></pre></div><p>A similar issue occurs when a <code>std::unique_ptr&lt;T&gt;</code> is made to point at a <code>T</code> with automatic or static storage duration.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>S<span class="token operator">&gt;</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    S s<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>S<span class="token operator">&gt;</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s destroyed upon return from f</span>
<span class="token punctuation">}</span>                    <span class="token comment">// UB: s destroyed</span>

</code></pre></div><p>Another way to destroy an object twice is by having two <code>shared_ptr</code>s both manage the object without sharing ownership with each other.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>S<span class="token operator">&gt;</span> p1<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>S<span class="token operator">&gt;</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    S<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> S<span class="token punctuation">;</span>
    <span class="token comment">// I want to pass the same object twice...</span>
    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>S<span class="token operator">&gt;</span> <span class="token function">sp1</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>S<span class="token operator">&gt;</span> <span class="token function">sp2</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">f</span><span class="token punctuation">(</span>sp1<span class="token punctuation">,</span> sp2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// UB: both sp1 and sp2 will destroy s separately</span>
<span class="token comment">// NB: this is correct:</span>
<span class="token comment">// std::shared_ptr&lt;S&gt; sp(p);</span>
<span class="token comment">// f(sp, sp);</span>

</code></pre></div><h4 id="remarks"><a href="#remarks" class="header-anchor">#</a> Remarks</h4> <p>If a program contains undefined behavior, the C++ standard places no constraints on its behavior.</p> <ul><li>It may appear to work as the developer intended, but it may also crash or produce strange results.</li> <li>The behavior may vary between runs of the same program.</li> <li>Any part of the program may malfunction, including lines that come before the line that contains undefined behavior.</li> <li>The implementation is not required to document the result of undefined behavior.</li></ul> <p>An implementation <strong>may</strong> document the result of an operation that produces undefined behavior according to the standard, but a program that depends on such documented behavior is not portable.</p> <p><strong>Why undefined behavior exists</strong></p> <p>Intuitively, undefined behavior is considered a bad thing as such errors can't be handled graciously through, say, exception handlers.</p> <p>But leaving some behavior undefined is actually an integral part of C++'s promise &quot;you don't pay for what you don't use&quot;.
Undefined behavior allows a compiler to assume the developer knows what he's doing and not introduce code to check for the mistakes highlighted in the above examples.</p> <p><strong>Finding and avoiding undefined behavior</strong></p> <p>Some tools can be used to discover undefined behavior during development:</p> <ul><li>Most compilers have warning flags to warn about some cases of undefined behavior at compile time.</li> <li>Newer versions of gcc and clang include a so-called &quot;Undefined Behavior Sanitizer&quot; flag (<code>-fsanitize=undefined</code>) that will check for undefined behavior at runtime, at a performance cost.</li> <li><code>lint</code>-like tools may perform more thorough undefined behavior analysis.</li></ul> <p><strong>Undefined, unspecified and <a href="http://stackoverflow.com/documentation/c%2B%2B/1363/implementation-defined-behavior" target="_blank" rel="noopener noreferrer">implementation-defined<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> behavior</strong></p> <p>From C++14 standard (ISO/IEC 14882:2014) section 1.9 (Program Execution):</p> <blockquote></blockquote> <ol><li>
The semantic descriptions in this International Standard define a parameterized nondeterministic abstract machine. [CUT]
</li> <li>
Certain aspects and operations of the abstract machine are described in this International Standard as **implementation-defined** (for example, `sizeof(int)`). These constitute **the parameters of the abstract machine**. Each implementation shall include documentation describing its characteristics and behavior in these respects. [CUT]
</li> <li>
Certain other aspects and operations of the abstract machine are described in this International Standard as **unspecified** (for example, evaluation of expressions in a **new-initializer** if the allocation function fails to allocate memory). Where possible, this International Standard defines a set of allowable behaviors. These define the nondeterministic aspects of the abstract machine. An instance of the abstract machine can thus have more than one possible execution for a given program and a given input.
</li> <li>
Certain other operations are described in this International Standard as **undefined** (or example, the effect of attempting to modify a `const` object). [ **Note**: this International Standard imposes no requirements on the behavior of programs that contain undefined behavior. โ**end note** ]
</li></ol></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/devtut/generate/edit/master/docs/cpp/undefined-behavior.md" target="_blank" rel="noopener noreferrer">Edit this page on GitHub</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      โ
      <a href="/cpp/sfinae-substitution-failure-is-not-an-error.html" class="prev">
        SFINAE (Substitution Failure Is Not An Error)
      </a></span> <span class="next"><a href="/cpp/overload-resolution.html">
        Overload resolution
      </a>
      โ
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.1779e102.js" defer></script><script src="/assets/js/3.2cfa8016.js" defer></script><script src="/assets/js/746.bd36588e.js" defer></script>
  </body>
</html>
