<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C++ | Smart Pointers</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="description" content="Unique ownership (std::unique_ptr), Sharing ownership (std::shared_ptr), Sharing with temporary ownership (std::weak_ptr), Using custom deleters to create a wrapper to a C interface, Unique ownership without move semantics (auto_ptr), Casting std::shared_ptr pointers, Writing a smart pointer: value_ptr, Getting a shared_ptr referring to this">
    <meta property="og:site_name" content="DevTut">
    <meta property="og:title" content="C++ | Smart Pointers">
    <meta property="og:description" content="Unique ownership (std::unique_ptr), Sharing ownership (std::shared_ptr), Sharing with temporary ownership (std::weak_ptr), Using custom deleters to create a wrapper to a C interface, Unique ownership without move semantics (auto_ptr), Casting std::shared_ptr pointers, Writing a smart pointer: value_ptr, Getting a shared_ptr referring to this">
    <meta property="og:type" content="article">
    <meta property="og:url" content="/cpp/smart-pointers.html">
    <meta property="og:image" content="/logo.png">
    <meta name="twitter:title" content="C++ | Smart Pointers">
    <meta name="twitter:description" content="Unique ownership (std::unique_ptr), Sharing ownership (std::shared_ptr), Sharing with temporary ownership (std::weak_ptr), Using custom deleters to create a wrapper to a C interface, Unique ownership without move semantics (auto_ptr), Casting std::shared_ptr pointers, Writing a smart pointer: value_ptr, Getting a shared_ptr referring to this">
    <meta name="twitter:url" content="/cpp/smart-pointers.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="/logo.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/mstile-150x150.png">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="google-site-verification" content="76_rKXgwMVIjd-axJC_1zPV9OS4mEjvtgjYOWVkAdnQ">
    <link rel="preload" href="/assets/css/0.styles.8b877eb8.css" as="style"><link rel="preload" href="/assets/js/app.ced448ab.js" as="script"><link rel="preload" href="/assets/js/3.f1d73125.js" as="script"><link rel="preload" href="/assets/js/710.0d41aedb.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.8b877eb8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">DevTut</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>C++</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/cpp/" class="sidebar-link">Disclaimer</a></li><li><a href="/cpp/getting-started-with-cpp.html" class="sidebar-link">Getting started with C++</a></li><li><a href="/cpp/literals.html" class="sidebar-link">Literals</a></li><li><a href="/cpp/operator-precedence.html" class="sidebar-link">operator precedence</a></li><li><a href="/cpp/floating-point-arithmetic.html" class="sidebar-link">Floating Point Arithmetic</a></li><li><a href="/cpp/bit-operators.html" class="sidebar-link">Bit Operators</a></li><li><a href="/cpp/bit-manipulation.html" class="sidebar-link">Bit Manipulation</a></li><li><a href="/cpp/bit-fields.html" class="sidebar-link">Bit fields</a></li><li><a href="/cpp/arrays.html" class="sidebar-link">Arrays</a></li><li><a href="/cpp/iterators.html" class="sidebar-link">Iterators</a></li><li><a href="/cpp/basic-input-output-in-c.html" class="sidebar-link">Basic input/output in c++</a></li><li><a href="/cpp/loops.html" class="sidebar-link">Loops</a></li><li><a href="/cpp/file-i-o.html" class="sidebar-link">File I/O</a></li><li><a href="/cpp/cpp-streams.html" class="sidebar-link">C++ Streams</a></li><li><a href="/cpp/stream-manipulators.html" class="sidebar-link">Stream manipulators</a></li><li><a href="/cpp/flow-control.html" class="sidebar-link">Flow Control</a></li><li><a href="/cpp/metaprogramming.html" class="sidebar-link">Metaprogramming</a></li><li><a href="/cpp/const-keyword.html" class="sidebar-link">const keyword</a></li><li><a href="/cpp/mutable-keyword.html" class="sidebar-link">mutable keyword</a></li><li><a href="/cpp/friend-keyword.html" class="sidebar-link">Friend keyword</a></li><li><a href="/cpp/type-keywords.html" class="sidebar-link">Type Keywords</a></li><li><a href="/cpp/basic-type-keywords.html" class="sidebar-link">Basic Type Keywords</a></li><li><a href="/cpp/variable-declaration-keywords.html" class="sidebar-link">Variable Declaration Keywords</a></li><li><a href="/cpp/keywords.html" class="sidebar-link">Keywords</a></li><li><a href="/cpp/returning-several-values-from-a-function.html" class="sidebar-link">Returning several values from a function</a></li><li><a href="/cpp/polymorphism.html" class="sidebar-link">Polymorphism</a></li><li><a href="/cpp/references.html" class="sidebar-link">References</a></li><li><a href="/cpp/value-and-reference-semantics.html" class="sidebar-link">Value and Reference Semantics</a></li><li><a href="/cpp/c-function-call-by-value-vs-call-by-reference.html" class="sidebar-link">C++ function &quot;call by value&quot; vs. &quot;call by reference&quot;</a></li><li><a href="/cpp/copying-vs-assignment.html" class="sidebar-link">Copying vs Assignment</a></li><li><a href="/cpp/pointers.html" class="sidebar-link">Pointers</a></li><li><a href="/cpp/pointers-to-members.html" class="sidebar-link">Pointers to members</a></li><li><a href="/cpp/the-this-pointer.html" class="sidebar-link">The This Pointer</a></li><li><a href="/cpp/smart-pointers.html" class="active sidebar-link">Smart Pointers</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cpp/smart-pointers.html#unique-ownership-std-unique-ptr" class="sidebar-link">Unique ownership (std::unique_ptr)</a></li><li class="sidebar-sub-header"><a href="/cpp/smart-pointers.html#sharing-ownership-std-shared-ptr" class="sidebar-link">Sharing ownership (std::shared_ptr)</a></li><li class="sidebar-sub-header"><a href="/cpp/smart-pointers.html#sharing-with-temporary-ownership-std-weak-ptr" class="sidebar-link">Sharing with temporary ownership (std::weak_ptr)</a></li><li class="sidebar-sub-header"><a href="/cpp/smart-pointers.html#using-custom-deleters-to-create-a-wrapper-to-a-c-interface" class="sidebar-link">Using custom deleters to create a wrapper to a C interface</a></li><li class="sidebar-sub-header"><a href="/cpp/smart-pointers.html#unique-ownership-without-move-semantics-auto-ptr" class="sidebar-link">Unique ownership without move semantics (auto_ptr)</a></li><li class="sidebar-sub-header"><a href="/cpp/smart-pointers.html#casting-std-shared-ptr-pointers" class="sidebar-link">Casting std::shared_ptr pointers</a></li><li class="sidebar-sub-header"><a href="/cpp/smart-pointers.html#writing-a-smart-pointer-value-ptr" class="sidebar-link">Writing a smart pointer: value_ptr</a></li><li class="sidebar-sub-header"><a href="/cpp/smart-pointers.html#getting-a-shared-ptr-referring-to-this" class="sidebar-link">Getting a shared_ptr referring to this</a></li></ul></li><li><a href="/cpp/classes-structures.html" class="sidebar-link">Classes/Structures</a></li><li><a href="/cpp/function-overloading.html" class="sidebar-link">Function Overloading</a></li><li><a href="/cpp/operator-overloading.html" class="sidebar-link">Operator Overloading</a></li><li><a href="/cpp/function-template-overloading.html" class="sidebar-link">Function Template Overloading</a></li><li><a href="/cpp/virtual-member-functions.html" class="sidebar-link">Virtual Member Functions</a></li><li><a href="/cpp/inline-functions.html" class="sidebar-link">Inline functions</a></li><li><a href="/cpp/special-member-functions.html" class="sidebar-link">Special Member Functions</a></li><li><a href="/cpp/non-static-member-functions.html" class="sidebar-link">Non-Static Member Functions</a></li><li><a href="/cpp/constant-class-member-functions.html" class="sidebar-link">Constant class member functions</a></li><li><a href="/cpp/c-containers.html" class="sidebar-link">C++ Containers</a></li><li><a href="/cpp/namespaces.html" class="sidebar-link">Namespaces</a></li><li><a href="/cpp/header-files.html" class="sidebar-link">Header Files</a></li><li><a href="/cpp/using-declaration.html" class="sidebar-link">Using declaration</a></li><li><a href="/cpp/std-string.html" class="sidebar-link">std::string</a></li><li><a href="/cpp/std-array.html" class="sidebar-link">std::array</a></li><li><a href="/cpp/std-vector.html" class="sidebar-link">std::vector</a></li><li><a href="/cpp/std-map.html" class="sidebar-link">std::map</a></li><li><a href="/cpp/std-optional.html" class="sidebar-link">std::optional</a></li><li><a href="/cpp/std-function-to-wrap-any-element-that-is-callable.html" class="sidebar-link">std::function: To wrap any element that is callable</a></li><li><a href="/cpp/std-forward-list.html" class="sidebar-link">std::forward_list</a></li><li><a href="/cpp/std-pair.html" class="sidebar-link">std::pair</a></li><li><a href="/cpp/std-atomics.html" class="sidebar-link">std::atomics</a></li><li><a href="/cpp/std-variant.html" class="sidebar-link">std::variant</a></li><li><a href="/cpp/std-iomanip.html" class="sidebar-link">std::iomanip</a></li><li><a href="/cpp/std-any.html" class="sidebar-link">std::any</a></li><li><a href="/cpp/std-set-and-std-multiset.html" class="sidebar-link">std::set and std::multiset</a></li><li><a href="/cpp/std-integer-sequence.html" class="sidebar-link">std::integer_sequence</a></li><li><a href="/cpp/using-std-unordered-map.html" class="sidebar-link">Using std::unordered_map</a></li><li><a href="/cpp/standard-library-algorithms.html" class="sidebar-link">Standard Library Algorithms</a></li><li><a href="/cpp/the-iso-c-standard.html" class="sidebar-link">The ISO C++ Standard</a></li><li><a href="/cpp/inline-variables.html" class="sidebar-link">Inline variables</a></li><li><a href="/cpp/random-number-generation.html" class="sidebar-link">Random number generation</a></li><li><a href="/cpp/date-and-time-using-chrono-header.html" class="sidebar-link">Date and time using  header</a></li><li><a href="/cpp/sorting.html" class="sidebar-link">Sorting</a></li><li><a href="/cpp/enumeration.html" class="sidebar-link">Enumeration</a></li><li><a href="/cpp/iteration.html" class="sidebar-link">Iteration</a></li><li><a href="/cpp/regular-expressions.html" class="sidebar-link">Regular expressions</a></li><li><a href="/cpp/implementation-defined-behavior.html" class="sidebar-link">Implementation-defined behavior</a></li><li><a href="/cpp/exceptions.html" class="sidebar-link">Exceptions</a></li><li><a href="/cpp/lambdas.html" class="sidebar-link">Lambdas</a></li><li><a href="/cpp/value-categories.html" class="sidebar-link">Value Categories</a></li><li><a href="/cpp/preprocessor.html" class="sidebar-link">Preprocessor</a></li><li><a href="/cpp/data-structures-in-c.html" class="sidebar-link">Data Structures in C++</a></li><li><a href="/cpp/templates.html" class="sidebar-link">Templates</a></li><li><a href="/cpp/expression-templates.html" class="sidebar-link">Expression templates</a></li><li><a href="/cpp/curiously-recurring-template-pattern-crtp.html" class="sidebar-link">Curiously Recurring Template Pattern (CRTP)</a></li><li><a href="/cpp/threading.html" class="sidebar-link">Threading</a></li><li><a href="/cpp/thread-synchronization-structures.html" class="sidebar-link">Thread synchronization structures</a></li><li><a href="/cpp/the-rule-of-three-five-and-zero.html" class="sidebar-link">The Rule of Three, Five, And Zero</a></li><li><a href="/cpp/raii-resource-acquisition-is-initialization.html" class="sidebar-link">RAII: Resource Acquisition Is Initialization</a></li><li><a href="/cpp/rtti-run-time-type-information.html" class="sidebar-link">RTTI: Run-Time Type Information</a></li><li><a href="/cpp/mutexes.html" class="sidebar-link">Mutexes</a></li><li><a href="/cpp/recursive-mutex.html" class="sidebar-link">Recursive Mutex</a></li><li><a href="/cpp/semaphore.html" class="sidebar-link">Semaphore</a></li><li><a href="/cpp/futures-and-promises.html" class="sidebar-link">Futures and Promises</a></li><li><a href="/cpp/atomic-types.html" class="sidebar-link">Atomic Types</a></li><li><a href="/cpp/type-erasure.html" class="sidebar-link">Type Erasure</a></li><li><a href="/cpp/explicit-type-conversions.html" class="sidebar-link">Explicit type conversions</a></li><li><a href="/cpp/unnamed-types.html" class="sidebar-link">Unnamed types</a></li><li><a href="/cpp/type-traits.html" class="sidebar-link">Type Traits</a></li><li><a href="/cpp/return-type-covariance.html" class="sidebar-link">Return Type Covariance</a></li><li><a href="/cpp/layout-of-object-types.html" class="sidebar-link">Layout of object types</a></li><li><a href="/cpp/type-inference.html" class="sidebar-link">Type Inference</a></li><li><a href="/cpp/typedef-and-type-aliases.html" class="sidebar-link">Typedef and type aliases</a></li><li><a href="/cpp/type-deduction.html" class="sidebar-link">type deduction</a></li><li><a href="/cpp/trailing-return-type.html" class="sidebar-link">Trailing return type</a></li><li><a href="/cpp/alignment.html" class="sidebar-link">Alignment</a></li><li><a href="/cpp/perfect-forwarding.html" class="sidebar-link">Perfect Forwarding</a></li><li><a href="/cpp/decltype.html" class="sidebar-link">decltype</a></li><li><a href="/cpp/sfinae-substitution-failure-is-not-an-error.html" class="sidebar-link">SFINAE (Substitution Failure Is Not An Error)</a></li><li><a href="/cpp/undefined-behavior.html" class="sidebar-link">Undefined Behavior</a></li><li><a href="/cpp/overload-resolution.html" class="sidebar-link">Overload resolution</a></li><li><a href="/cpp/move-semantics.html" class="sidebar-link">Move Semantics</a></li><li><a href="/cpp/pimpl-idiom.html" class="sidebar-link">Pimpl Idiom</a></li><li><a href="/cpp/auto.html" class="sidebar-link">auto</a></li><li><a href="/cpp/copy-elision.html" class="sidebar-link">Copy Elision</a></li><li><a href="/cpp/fold-expressions.html" class="sidebar-link">Fold Expressions</a></li><li><a href="/cpp/unions.html" class="sidebar-link">Unions</a></li><li><a href="/cpp/design-pattern-implementation-in-c.html" class="sidebar-link">Design pattern implementation in C++</a></li><li><a href="/cpp/singleton-design-pattern.html" class="sidebar-link">Singleton Design Pattern</a></li><li><a href="/cpp/user-defined-literals.html" class="sidebar-link">User-Defined Literals</a></li><li><a href="/cpp/memory-management.html" class="sidebar-link">Memory management</a></li><li><a href="/cpp/c-11-memory-model.html" class="sidebar-link">C++11 Memory Model</a></li><li><a href="/cpp/scopes.html" class="sidebar-link">Scopes</a></li><li><a href="/cpp/static-assert.html" class="sidebar-link">static_assert</a></li><li><a href="/cpp/constexpr.html" class="sidebar-link">constexpr</a></li><li><a href="/cpp/one-definition-rule-odr.html" class="sidebar-link">One Definition Rule (ODR)</a></li><li><a href="/cpp/unspecified-behavior.html" class="sidebar-link">Unspecified behavior</a></li><li><a href="/cpp/argument-dependent-name-lookup.html" class="sidebar-link">Argument Dependent Name Lookup</a></li><li><a href="/cpp/attributes.html" class="sidebar-link">Attributes</a></li><li><a href="/cpp/recursion-in-c.html" class="sidebar-link">Recursion in C++</a></li><li><a href="/cpp/arithmitic-metaprogramming.html" class="sidebar-link">Arithmitic Metaprogramming</a></li><li><a href="/cpp/callable-objects.html" class="sidebar-link">Callable Objects</a></li><li><a href="/cpp/client-server-examples.html" class="sidebar-link">Client server examples</a></li><li><a href="/cpp/const-correctness.html" class="sidebar-link">Const Correctness</a></li><li><a href="/cpp/parameter-packs.html" class="sidebar-link">Parameter packs</a></li><li><a href="/cpp/build-systems.html" class="sidebar-link">Build Systems</a></li><li><a href="/cpp/concurrency-with-openmp.html" class="sidebar-link">Concurrency With OpenMP</a></li><li><a href="/cpp/resource-management.html" class="sidebar-link">Resource Management</a></li><li><a href="/cpp/storage-class-specifiers.html" class="sidebar-link">Storage class specifiers</a></li><li><a href="/cpp/linkage-specifications.html" class="sidebar-link">Linkage specifications</a></li><li><a href="/cpp/digit-separators.html" class="sidebar-link">Digit separators</a></li><li><a href="/cpp/c-incompatibilities.html" class="sidebar-link">C incompatibilities</a></li><li><a href="/cpp/side-by-side-comparisons-of-classic-c-examples-solved-via-c-vs-c-11-vs-c-14-vs-c-17.html" class="sidebar-link">Side by Side Comparisons of classic C++ examples solved via C++ vs C++11 vs C++14 vs C++17</a></li><li><a href="/cpp/compiling-and-building.html" class="sidebar-link">Compiling and Building</a></li><li><a href="/cpp/common-compile-linker-errors-gcc.html" class="sidebar-link">Common compile/linker errors (GCC)</a></li><li><a href="/cpp/more-undefined-behaviors-in-c.html" class="sidebar-link">More undefined behaviors in C++</a></li><li><a href="/cpp/unit-testing-in-c.html" class="sidebar-link">Unit Testing in C++</a></li><li><a href="/cpp/c-debugging-and-debug-prevention-tools-techniques.html" class="sidebar-link">C++ Debugging and Debug-prevention Tools &amp; Techniques</a></li><li><a href="/cpp/optimization-in-c.html" class="sidebar-link">Optimization in C++</a></li><li><a href="/cpp/optimization.html" class="sidebar-link">Optimization</a></li><li><a href="/cpp/profiling.html" class="sidebar-link">Profiling</a></li><li><a href="/cpp/refactoring-techniques.html" class="sidebar-link">Refactoring Techniques</a></li><li><a href="/cpp/internationalization-in-c.html" class="sidebar-link">Internationalization in C++</a></li><li><a href="/cpp/contributors.html" class="sidebar-link">The Contributors</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="smart-pointers"><a href="#smart-pointers" class="header-anchor">#</a> Smart Pointers</h1> <h2 id="unique-ownership-std-unique-ptr"><a href="#unique-ownership-std-unique-ptr" class="header-anchor">#</a> Unique ownership (std::unique_ptr)</h2> <p>A <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr" target="_blank" rel="noopener noreferrer"><code>std::unique_ptr</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> is a class template that manages the lifetime of a dynamically stored object. Unlike for <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr" target="_blank" rel="noopener noreferrer"><code>std::shared_ptr</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>, the dynamic object is owned by only <strong>one instance</strong> of a <code>std::unique_ptr</code> at any time,</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// Creates a dynamic int with value of 20 owned by a unique pointer</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ptr <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>(Note: <code>std::unique_ptr</code> is available since C++11 and <code>std::make_unique</code> since C++14.)</p> <p>Only the variable <code>ptr</code> holds a pointer to a dynamically allocated <code>int</code>. When a unique pointer that owns an object goes out of scope, the owned object is deleted, i.e. its destructor is called if the object is of class type, and the memory for that object is released.</p> <p>To use <code>std::unique_ptr</code> and <code>std::make_unique</code> with array-types, use their array specializations:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// Creates a unique_ptr to an int with value 59</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ptr <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">59</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Creates a unique_ptr to an array of 15 ints</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> ptr <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>You can access the <code>std::unique_ptr</code> just like a raw pointer, because it overloads those operators.</p> <p>You can transfer ownership of the contents of a smart pointer to another pointer by using <code>std::move</code>, which will cause the original smart pointer to point to <code>nullptr</code>.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// 1. std::unique_ptr</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ptr <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Change value to 1</span>
<span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">// 2. std::unique_ptr (by moving 'ptr' to 'ptr2', 'ptr' doesn't own the object anymore)</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ptr2 <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token operator">*</span>ptr2<span class="token punctuation">;</span> <span class="token comment">// 'a' is 1</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>  <span class="token comment">// undefined behavior! 'ptr' is 'nullptr'</span>
               <span class="token comment">// (because of the move command above)</span>

</code></pre></div><p>Passing <code>unique_ptr</code> to functions as parameter:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ptr<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// Your code goes here</span>
<span class="token punctuation">}</span>

std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ptr <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">59</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span>

</code></pre></div><p>Returning <code>unique_ptr</code> from functions. This is the preferred C++11 way of writing factory functions, as it clearly conveys the ownership semantics of the return: the caller owns the resulting <code>unique_ptr</code> and is responsible for it.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ptr <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">59</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ptr <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>Compare this to:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span><span class="token operator">*</span> <span class="token function">foo_cpp03</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token function">foo_cpp03</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// do I own p? do I have to delete it at some point?</span>
                      <span class="token comment">// it's not readily apparent what the answer is.</span>

</code></pre></div><p>The class template <code>make_unique</code> is provided since C++14. It's easy to add it manually to C++11 code:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token punctuation">,</span> <span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">&gt;</span>
<span class="token keyword">typename</span> std<span class="token operator">::</span>enable_if<span class="token operator">&lt;</span><span class="token operator">!</span>std<span class="token operator">::</span>is_array<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">::</span>value<span class="token punctuation">,</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span><span class="token operator">::</span>type
<span class="token function">make_unique</span><span class="token punctuation">(</span>Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span>
<span class="token punctuation">{</span> <span class="token keyword">return</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">T</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Args<span class="token operator">&gt;</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token comment">// Use make_unique for arrays</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">&gt;</span>
<span class="token keyword">typename</span> std<span class="token operator">::</span>enable_if<span class="token operator">&lt;</span>std<span class="token operator">::</span>is_array<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">::</span>value<span class="token punctuation">,</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;&gt;</span><span class="token operator">::</span>type
<span class="token function">make_unique</span><span class="token punctuation">(</span>size_t n<span class="token punctuation">)</span>
<span class="token punctuation">{</span> <span class="token keyword">return</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">typename</span> std<span class="token operator">::</span>remove_extent<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">::</span>type<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

</code></pre></div><p>Unlike the <strong>dumb</strong> smart pointer (<code>std::auto_ptr</code>), <code>unique_ptr</code> can also be instantiated with vector allocation (<strong>not</strong> <code>std::vector</code>). Earlier examples were for <strong>scalar</strong> allocations. For example to have a dynamically allocated integer array for 10 elements, you would specify <code>int[]</code> as the template type (and not just <code>int</code>):</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> arr_ptr <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>Which can be simplified with:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">auto</span> arr_ptr <span class="token operator">=</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>Now, you use <code>arr_ptr</code> as if it is an array:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>arr_ptr<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span>  <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// Modify third element</span>

</code></pre></div><p>You need not to worry about de-allocation. This template specialized version calls constructors and destructors appropriately. Using vectored version of <code>unique_ptr</code> or a <code>vector</code> itself - is a personal choice.</p> <p>In versions prior to C++11, <code>std::auto_ptr</code> was available. Unlike <code>unique_ptr</code> it is allowed to copy <code>auto_ptr</code>s, upon which the source <code>ptr</code> will lose the ownership of the contained pointer and the target receives it.</p> <h2 id="sharing-ownership-std-shared-ptr"><a href="#sharing-ownership-std-shared-ptr" class="header-anchor">#</a> Sharing ownership (std::shared_ptr)</h2> <p>The class template <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr" target="_blank" rel="noopener noreferrer"><code>std::shared_ptr</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> defines a shared pointer that is able to share ownership of an object with other shared pointers. This contrasts to <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr" target="_blank" rel="noopener noreferrer"><code>std::unique_ptr</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> which represents exclusive ownership.</p> <p>The sharing behavior is implemented through a technique known as reference counting, where the number of shared pointers that point to the object is stored alongside it. When this count reaches zero, either through the destruction or reassignment of the last <code>std::shared_ptr</code> instance, the object is automatically destroyed.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// Creation: 'firstShared' is a shared pointer for a new instance of 'Foo'</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span> firstShared <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token comment">/*args*/</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>To create multiple smart pointers that share the same object, we need to create another <code>shared_ptr</code> that aliases the first shared pointer. Here are 2 ways of doing it:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span> <span class="token function">secondShared</span><span class="token punctuation">(</span>firstShared<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 1st way: Copy constructing</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span> secondShared<span class="token punctuation">;</span>
secondShared <span class="token operator">=</span> firstShared<span class="token punctuation">;</span>                      <span class="token comment">// 2nd way: Assigning</span>

</code></pre></div><p>Either of the above ways makes <code>secondShared</code> a shared pointer that shares ownership of our instance of <code>Foo</code> with <code>firstShared</code>.</p> <p>The smart pointer works just like a raw pointer. This means, you can use <code>*</code> to dereference them. The regular <code>-&gt;</code> operator works as well:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>secondShared<span class="token operator">-&gt;</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Calls Foo::test()</span>

</code></pre></div><p>Finally, when the last aliased <code>shared_ptr</code> goes out of scope, the destructor of our <code>Foo</code> instance is called.</p> <p><strong>Warning:</strong> Constructing a <code>shared_ptr</code> might throw a <code>bad_alloc</code> exception when extra data for shared ownership semantics needs to be allocated. If the constructor is passed a regular pointer it assumes to own the object pointed to and calls the deleter if an exception is thrown. This means <code>shared_ptr&lt;T&gt;(new T(args))</code> will not leak a <code>T</code> object if allocation of <code>shared_ptr&lt;T&gt;</code> fails. However, it is advisable to use <code>make_shared&lt;T&gt;(args)</code> or <code>allocate_shared&lt;T&gt;(alloc, args)</code>, which enable the implementation to optimize the memory allocation.</p> <p><strong>Allocating Arrays([]) using shared_ptr</strong></p> <p>Unfortunately, there is no direct way to allocate Arrays using <code>make_shared&lt;&gt;</code>.</p> <p>It is possible to create arrays for <code>shared_ptr&lt;&gt;</code> using <code>new</code> and <code>std::default_delete</code>.</p> <p>For example, to allocate an array of 10 integers, we can write the code as</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">sh</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> std<span class="token operator">::</span>default_delete<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


</code></pre></div><p>Specifying <code>std::default_delete</code> is mandatory here to make sure that the allocated memory is correctly cleaned up using <code>delete[]</code>.</p> <p>If we know the size at compile time, we can do it this way:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Arr</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">shared_array_maker</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> std<span class="token operator">::</span>size_t N<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">shared_array_maker</span><span class="token operator">&lt;</span>T<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span><span class="token punctuation">{</span>
    <span class="token keyword">auto</span> r <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>std<span class="token operator">::</span>array<span class="token operator">&lt;</span>T<span class="token punctuation">,</span>N<span class="token operator">&gt;&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>r<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>r<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> r<span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Arr</span><span class="token operator">&gt;</span>
<span class="token keyword">auto</span> <span class="token function">make_shared_array</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token operator">-&gt;</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> shared_array_maker<span class="token operator">&lt;</span>Arr<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>
<span class="token punctuation">{</span> <span class="token keyword">return</span> shared_array_maker<span class="token operator">&lt;</span>Arr<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

</code></pre></div><p>then <code>make_shared_array&lt;int[10]&gt;</code> returns a <code>shared_ptr&lt;int&gt;</code> pointing to 10 ints all default constructed.</p> <p>With C++17, <code>shared_ptr</code> <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0414r2.html" target="_blank" rel="noopener noreferrer">gained special support<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> for array types. It is no longer necessary to specify the array-deleter explicitly, and the shared pointer can be dereferenced using the <code>[]</code> array index operator:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> <span class="token function">sh</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
sh<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>

</code></pre></div><p>Shared pointers can point to a sub-object of the object it owns:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span> p1 <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p2</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>p1<span class="token operator">-&gt;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>Both <code>p2</code> and <code>p1</code> own the object of type <code>Foo</code>, but <code>p2</code> points to its <code>int</code> member <code>x</code>. This means that if <code>p1</code> goes out of scope or is reassigned, the underlying <code>Foo</code> object will still be alive, ensuring that <code>p2</code> does not dangle.</p> <p><strong>Important:</strong> A <code>shared_ptr</code> only knows about itself and all other <code>shared_ptr</code> that were created with the alias constructor. It does not know about any other pointers, including all other <code>shared_ptr</code>s created with a reference to the same <code>Foo</code> instance:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>Foo <span class="token operator">*</span>foo <span class="token operator">=</span> <span class="token keyword">new</span> Foo<span class="token punctuation">;</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span> <span class="token function">shared1</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>Foo<span class="token operator">&gt;</span> <span class="token function">shared2</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// don't do this</span>

shared1<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// this will delete foo, since shared1</span>
                 <span class="token comment">// was the only shared_ptr that owned it</span>

shared2<span class="token operator">-&gt;</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// UNDEFINED BEHAVIOR: shared2's foo has been</span>
                 <span class="token comment">// deleted already!!</span>

</code></pre></div><p><strong>Ownership Transfer of shared_ptr</strong></p> <p>By default, <code>shared_ptr</code> increments the reference count and doesn't transfer the ownership. However, it can be made to transfer the ownership using <code>std::move</code>:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> up <span class="token operator">=</span> make_shared<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Transferring the ownership</span>
shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> up2 <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>up<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// At this point, the reference count of up = 0 and the</span>
<span class="token comment">// ownership of the pointer is solely with up2 with reference count = 1</span>


</code></pre></div><h2 id="sharing-with-temporary-ownership-std-weak-ptr"><a href="#sharing-with-temporary-ownership-std-weak-ptr" class="header-anchor">#</a> Sharing with temporary ownership (std::weak_ptr)</h2> <p>Instances of <a href="http://en.cppreference.com/w/cpp/memory/weak_ptr" target="_blank" rel="noopener noreferrer"><code>std::weak_ptr</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> can point to objects owned by instances of <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr" target="_blank" rel="noopener noreferrer"><code>std::shared_ptr</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> while only becoming temporary owners themselves. This means that weak pointers do not alter the object's reference count and therefore do not prevent an object's deletion if all of the object's shared pointers are reassigned or destroyed.</p> <p>In the following example instances of <code>std::weak_ptr</code> are used so that the destruction of a tree object is not inhibited:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>
    std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span>TreeNode<span class="token operator">&gt;</span> parent<span class="token punctuation">;</span>
    std<span class="token operator">::</span>vector<span class="token operator">&lt;</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>TreeNode<span class="token operator">&gt;</span> <span class="token operator">&gt;</span> children<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Create a TreeNode to serve as the root/parent.</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>TreeNode<span class="token operator">&gt;</span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token keyword">new</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Give the parent 100 child nodes.</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>TreeNode<span class="token operator">&gt;</span> <span class="token function">child</span><span class="token punctuation">(</span><span class="token keyword">new</span> TreeNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
        root<span class="token operator">-&gt;</span>children<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">;</span>
        child<span class="token operator">-&gt;</span>parent <span class="token operator">=</span> root<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// Reset the root shared pointer, destroying the root object, and</span>
    <span class="token comment">// subsequently its child nodes.</span>
    root<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>As child nodes are added to the root node's children, their <code>std::weak_ptr</code> member <code>parent</code> is set to the root node. The member <code>parent</code> is declared as a weak pointer as opposed to a shared pointer such that the root node's reference count is not incremented. When the root node is reset at the end of <code>main()</code>, the root is destroyed. Since the only remaining <code>std::shared_ptr</code> references to the child nodes were contained in the root's collection <code>children</code>, all child nodes are subsequently destroyed as well.</p> <p>Due to control block implementation details, shared_ptr allocated memory may not be released until <code>shared_ptr</code> reference counter and <code>weak_ptr</code> reference counter both reach zero.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
         std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> wk<span class="token punctuation">;</span>
         <span class="token punctuation">{</span>
             <span class="token comment">// std::make_shared is optimized by allocating only once </span>
             <span class="token comment">// while std::shared_ptr&lt;int&gt;(new int(42)) allocates twice.</span>
             <span class="token comment">// Drawback of std::make_shared is that control block is tied to our integer</span>
             std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> sh <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             wk <span class="token operator">=</span> sh<span class="token punctuation">;</span>
             <span class="token comment">// sh memory should be released at this point...</span>
         <span class="token punctuation">}</span>
         <span class="token comment">// ... but wk is still alive and needs access to control block</span>
     <span class="token punctuation">}</span>
     <span class="token comment">// now memory is released (sh and wk)</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Since <code>std::weak_ptr</code> does not keep its referenced object alive, direct data access through a <code>std::weak_ptr</code> is not possible. Instead it provides a <code>lock()</code> member function that attempts to retrieve a <code>std::shared_ptr</code> to the referenced object:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cassert&gt;</span></span>
<span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">{</span>
         std<span class="token operator">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> wk<span class="token punctuation">;</span>
         std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> sp<span class="token punctuation">;</span>
         <span class="token punctuation">{</span>
             std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> sh <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             wk <span class="token operator">=</span> sh<span class="token punctuation">;</span>
             <span class="token comment">// calling lock will create a shared_ptr to the object referenced by wk</span>
             sp <span class="token operator">=</span> wk<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token comment">// sh will be destroyed after this point, but sp is still alive</span>
         <span class="token punctuation">}</span>
         <span class="token comment">// sp still keeps the data alive.</span>
         <span class="token comment">// At this point we could even call lock() again </span>
         <span class="token comment">// to retrieve another shared_ptr to the same data from wk</span>
         <span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">*</span>sp <span class="token operator">==</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">!</span>wk<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token comment">// resetting sp will delete the data,</span>
         <span class="token comment">// as it is currently the last shared_ptr with ownership</span>
         sp<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token comment">// attempting to lock wk now will return an empty shared_ptr,</span>
         <span class="token comment">// as the data has already been deleted</span>
         sp <span class="token operator">=</span> wk<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">!</span>sp<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token function">assert</span><span class="token punctuation">(</span>wk<span class="token punctuation">.</span><span class="token function">expired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><h2 id="using-custom-deleters-to-create-a-wrapper-to-a-c-interface"><a href="#using-custom-deleters-to-create-a-wrapper-to-a-c-interface" class="header-anchor">#</a> Using custom deleters to create a wrapper to a C interface</h2> <p>Many C interfaces such as <a href="https://www.libsdl.org/" target="_blank" rel="noopener noreferrer">SDL2<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> have their own deletion functions. This means that you cannot use smart pointers directly:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>SDL_Surface<span class="token operator">&gt;</span> a<span class="token punctuation">;</span> <span class="token comment">// won't work, UNSAFE!</span>

</code></pre></div><p>Instead, you need to define your own deleter. The examples here use the <a href="https://wiki.libsdl.org/SDL_Surface" target="_blank" rel="noopener noreferrer"><code>SDL_Surface</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> structure which should be freed using the <a href="https://wiki.libsdl.org/SDL_FreeSurface" target="_blank" rel="noopener noreferrer"><code>SDL_FreeSurface()</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> function, but they should be adaptable to many other C interfaces.</p> <p>The deleter must be callable with a pointer argument, and therefore can be e.g. a simple function pointer:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>SDL_Surface<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>SDL_Surface<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">a</span><span class="token punctuation">(</span>pointer<span class="token punctuation">,</span> SDL_FreeSurface<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>Any other callable object will work, too, for example a class with an <code>operator()</code>:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">SurfaceDeleter</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>SDL_Surface<span class="token operator">*</span> surf<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">SDL_FreeSurface</span><span class="token punctuation">(</span>surf<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>SDL_Surface<span class="token punctuation">,</span> SurfaceDeleter<span class="token operator">&gt;</span> <span class="token function">a</span><span class="token punctuation">(</span>pointer<span class="token punctuation">,</span> SurfaceDeleter<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// safe</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>SDL_Surface<span class="token punctuation">,</span> SurfaceDeleter<span class="token operator">&gt;</span> <span class="token function">b</span><span class="token punctuation">(</span>pointer<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// equivalent to the above</span>
                                                         <span class="token comment">// as the deleter is value-initialized</span>

</code></pre></div><p>This not only provides you with safe, zero overhead (if you use <a href="http://en.cppreference.com/w/cpp/memory/unique_ptr" target="_blank" rel="noopener noreferrer"><code>unique_ptr</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>) automatic memory management, you also get exception safety.</p> <p>Note that the deleter is part of the type for <code>unique_ptr</code>, and the implementation can use the <a href="http://stackoverflow.com/documentation/c%2b%2b/3944/empty-base-optimization#t=201607261453124463486" target="_blank" rel="noopener noreferrer">empty base optimization<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> to avoid any change in size for empty custom deleters. So while <code>std::unique_ptr&lt;SDL_Surface, SurfaceDeleter&gt;</code> and <code>std::unique_ptr&lt;SDL_Surface, void(*)(SDL_Surface*)&gt;</code> solve the same problem in a similar way, the former type is still only the size of a pointer while the latter type has to hold <strong>two</strong> pointers: both the <code>SDL_Surface*</code> and the function pointer! When having free function custom deleters, it is preferable to wrap the function in an empty type.</p> <p>In cases where reference counting is important, one could use a <a href="http://en.cppreference.com/w/cpp/memory/shared_ptr" target="_blank" rel="noopener noreferrer"><code>shared_ptr</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> instead of an <code>unique_ptr</code>. The <code>shared_ptr</code> always stores a deleter, this erases the type of the deleter, which might be useful in APIs. The disadvantages of using <code>shared_ptr</code> over <code>unique_ptr</code> include a higher memory cost for storing the deleter and a performance cost for maintaining the reference count.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// deleter required at construction time and is part of the type</span>
std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>SDL_Surface<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>SDL_Surface<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">a</span><span class="token punctuation">(</span>pointer<span class="token punctuation">,</span> SDL_FreeSurface<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// deleter is only required at construction time, not part of the type</span>
std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>SDL_Surface<span class="token operator">&gt;</span> <span class="token function">b</span><span class="token punctuation">(</span>pointer<span class="token punctuation">,</span> SDL_FreeSurface<span class="token punctuation">)</span><span class="token punctuation">;</span> 

</code></pre></div><p>With <code>template auto</code>, we can make it even easier to wrap our custom deleters:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">auto</span> DeleteFn<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">FunctionDeleter</span> <span class="token punctuation">{</span>
    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">DeleteFn</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">auto</span> DeleteFn<span class="token operator">&gt;</span>
<span class="token keyword">using</span> unique_ptr_deleter <span class="token operator">=</span> std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> FunctionDeleter<span class="token operator">&lt;</span>DeleteFn<span class="token operator">&gt;&gt;</span><span class="token punctuation">;</span>

</code></pre></div><p>With which the above example is simply:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>unique_ptr_deleter<span class="token operator">&lt;</span>SDL_Surface<span class="token punctuation">,</span> SDL_FreeSurface<span class="token operator">&gt;</span> <span class="token function">c</span><span class="token punctuation">(</span>pointer<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>Here, the purpose of <code>auto</code> is to handle all free functions, whether they return <code>void</code> (e.g. <code>SDL_FreeSurface</code>) or not (e.g. <code>fclose</code>).</p> <h2 id="unique-ownership-without-move-semantics-auto-ptr"><a href="#unique-ownership-without-move-semantics-auto-ptr" class="header-anchor">#</a> Unique ownership without move semantics (auto_ptr)</h2> <p><strong>NOTE:</strong> <code>std::auto_ptr</code> has been deprecated in C++11 and will be removed in C++17. You should only use this if you are forced to use C++03 or earlier and are willing to be careful. It is recommended to move to unique_ptr in combination with <code>std::move</code> to replace <code>std::auto_ptr</code> behavior.</p> <p>Before we had <code>std::unique_ptr</code>, before we had move semantics, we had <code>std::auto_ptr</code>. <code>std::auto_ptr</code> provides unique ownership but transfers ownership upon copy.</p> <p>As with all smart pointers, <code>std::auto_ptr</code> automatically cleans up resources (see <a href="http://stackoverflow.com/documentation/c%2B%2B/1320/raii-resource-acquisition-is-initialization#t=201607231428426338521" target="_blank" rel="noopener noreferrer">RAII<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>):</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token punctuation">{</span>
    std<span class="token operator">::</span>auto_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// p is deleted here, no memory leaked</span>

</code></pre></div><p>but allows only one owner:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token operator">::</span>auto_ptr<span class="token operator">&lt;</span>X<span class="token operator">&gt;</span> px <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
std<span class="token operator">::</span>auto_ptr<span class="token operator">&lt;</span>X<span class="token operator">&gt;</span> py <span class="token operator">=</span> px<span class="token punctuation">;</span> 
  <span class="token comment">// px is now empty </span>

</code></pre></div><p>This allows to use std::auto_ptr to keep ownership explicit and unique at the danger of losing ownership unintended:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>std<span class="token operator">::</span>auto_ptr<span class="token operator">&lt;</span>X<span class="token operator">&gt;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// assumes ownership of X</span>
    <span class="token comment">// deletes it at end of scope</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token operator">::</span>auto_ptr<span class="token operator">&lt;</span>X<span class="token operator">&gt;</span> px <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>px<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// f acquires ownership of underlying X</span>
       <span class="token comment">// px is now empty</span>
px<span class="token operator">-&gt;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// NPE!</span>
<span class="token comment">// px.~auto_ptr() does NOT delete</span>

</code></pre></div><p>The transfer of ownership happened in the &quot;copy&quot; constructor. <code>auto_ptr</code>'s copy constructor and copy assignment operator take their operands by non-<code>const</code> reference so that they could be modified. An example implementation might be:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> T<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">auto_ptr</span> <span class="token punctuation">{</span>
    T<span class="token operator">*</span> ptr<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">auto_ptr</span><span class="token punctuation">(</span>auto_ptr<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token function">ptr</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span> <span class="token punctuation">}</span>

    auto_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>auto_ptr<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">reset</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    T<span class="token operator">*</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        T<span class="token operator">*</span> tmp <span class="token operator">=</span> ptr<span class="token punctuation">;</span>
        ptr <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> tmp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span>T<span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">!=</span> tmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">delete</span> ptr<span class="token punctuation">;</span>
            ptr <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* other functions ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>This breaks copy semantics, which require that copying an object leaves you with two equivalent versions of it. For any copyable type, <code>T</code>, I should be able to write:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>T a <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
T <span class="token function">b</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">assert</span><span class="token punctuation">(</span>b <span class="token operator">==</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>But for <code>auto_ptr</code>, this is not the case. As a result, it is not safe to put <code>auto_ptr</code>s in containers.</p> <h2 id="casting-std-shared-ptr-pointers"><a href="#casting-std-shared-ptr-pointers" class="header-anchor">#</a> Casting std::shared_ptr pointers</h2> <p>It is not possible to directly use <code>static_cast</code>, <code>const_cast</code>, <code>dynamic_cast</code> and <code>reinterpret_cast</code> on <code>std::shared_ptr</code> to retrieve a pointer sharing ownership with the pointer being passed as argument. Instead, the functions <code>std::static_pointer_cast</code>, <code>std::const_pointer_cast</code>, <code>std::dynamic_pointer_cast</code> and <code>std::reinterpret_pointer_cast</code> should be used:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span> <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">Derived</span><span class="token operator">:</span> Base <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> <span class="token function">derivedPtr</span><span class="token punctuation">(</span>std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span>Derived<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> <span class="token function">basePtr</span><span class="token punctuation">(</span>std<span class="token operator">::</span>static_pointer_cast<span class="token operator">&lt;</span>Base<span class="token operator">&gt;</span><span class="token punctuation">(</span>derivedPtr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> <span class="token function">constBasePtr</span><span class="token punctuation">(</span>std<span class="token operator">::</span>const_pointer_cast<span class="token operator">&lt;</span>Base <span class="token keyword">const</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>basePtr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> <span class="token function">constDerivedPtr</span><span class="token punctuation">(</span>std<span class="token operator">::</span>dynamic_pointer_cast<span class="token operator">&lt;</span>Derived <span class="token keyword">const</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>constBasePtr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>Note that <code>std::reinterpret_pointer_cast</code> is not available in C++11 and C++14, as it was only proposed by <a href="https://isocpp.org/files/papers/N3920.html" target="_blank" rel="noopener noreferrer">N3920<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> and adopted into Library Fundamentals TS <a href="https://isocpp.org/blog/2014/02/trip-report" target="_blank" rel="noopener noreferrer">in February 2014<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>. However, it can be implemented as follows:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> To<span class="token punctuation">,</span> <span class="token keyword">typename</span> From<span class="token operator">&gt;</span>
<span class="token keyword">inline</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>To<span class="token operator">&gt;</span> <span class="token function">reinterpret_pointer_cast</span><span class="token punctuation">(</span>
    std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>From<span class="token operator">&gt;</span> <span class="token keyword">const</span> <span class="token operator">&amp;</span> ptr<span class="token punctuation">)</span> <span class="token keyword">noexcept</span>
<span class="token punctuation">{</span> <span class="token keyword">return</span> std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span>To<span class="token operator">&gt;</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> <span class="token keyword">reinterpret_cast</span><span class="token operator">&lt;</span>To <span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>ptr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

</code></pre></div><h2 id="writing-a-smart-pointer-value-ptr"><a href="#writing-a-smart-pointer-value-ptr" class="header-anchor">#</a> Writing a smart pointer: value_ptr</h2> <p>A <code>value_ptr</code> is a smart pointer that behaves like a value.  When copied, it copies its contents.  When created, it creates its contents.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// Like std::default_delete:</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">default_copier</span> <span class="token punctuation">{</span>
  <span class="token comment">// a copier must handle a null T const* in and return null:</span>
  T<span class="token operator">*</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span>T <span class="token keyword">const</span><span class="token operator">*</span> tin<span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tin<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token operator">*</span>tin<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> dest<span class="token punctuation">,</span> T <span class="token keyword">const</span><span class="token operator">*</span> tin<span class="token punctuation">)</span><span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tin<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span><span class="token punctuation">(</span>dest<span class="token punctuation">)</span> <span class="token function">T</span><span class="token punctuation">(</span><span class="token operator">*</span>tin<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// tag class to handle empty case:</span>
<span class="token keyword">struct</span> <span class="token class-name">empty_ptr_t</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">constexpr</span> empty_ptr_t empty_ptr<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// the value pointer type itself:</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Copier</span><span class="token operator">=</span>default_copier<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Deleter</span><span class="token operator">=</span>std<span class="token operator">::</span>default_delete<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">,</span>
  <span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token operator">=</span>std<span class="token operator">::</span>unique_ptr<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> Deleter<span class="token operator">&gt;</span>
<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">value_ptr</span><span class="token operator">:</span>Base<span class="token punctuation">,</span> <span class="token keyword">private</span> Copier <span class="token punctuation">{</span>
  <span class="token keyword">using</span> copier_type<span class="token operator">=</span>Copier<span class="token punctuation">;</span>
  <span class="token comment">// also typedefs from unique_ptr</span>

  <span class="token keyword">using</span> Base<span class="token operator">::</span>Base<span class="token punctuation">;</span>

  <span class="token function">value_ptr</span><span class="token punctuation">(</span> T <span class="token keyword">const</span><span class="token operator">&amp;</span> t <span class="token punctuation">)</span><span class="token operator">:</span>
    <span class="token function">Base</span><span class="token punctuation">(</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">Copier</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">value_ptr</span><span class="token punctuation">(</span> T <span class="token operator">&amp;&amp;</span> t <span class="token punctuation">)</span><span class="token operator">:</span>
    <span class="token function">Base</span><span class="token punctuation">(</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">Copier</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">// almost-never-empty:</span>
      <span class="token function">value_ptr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>
    <span class="token function">Base</span><span class="token punctuation">(</span> std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">Copier</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">value_ptr</span><span class="token punctuation">(</span> empty_ptr_t <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token function">value_ptr</span><span class="token punctuation">(</span> Base b<span class="token punctuation">,</span> Copier c<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token operator">:</span>
    <span class="token function">Base</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">Copier</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span><span class="token punctuation">}</span>

  Copier <span class="token keyword">const</span><span class="token operator">&amp;</span> <span class="token function">get_copier</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  value_ptr <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token function">Base</span><span class="token punctuation">(</span>
        <span class="token function">get_copier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">get_deleter</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token function">get_copier</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">value_ptr</span><span class="token punctuation">(</span>value_ptr<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">default</span><span class="token punctuation">;</span>
  value_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>value_ptr<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">default</span><span class="token punctuation">;</span>

  <span class="token function">value_ptr</span><span class="token punctuation">(</span>value_ptr <span class="token keyword">const</span><span class="token operator">&amp;</span> o<span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">value_ptr</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  value_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>value_ptr <span class="token keyword">const</span><span class="token operator">&amp;</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// if we are both non-null, assign contents:</span>
      <span class="token operator">*</span><span class="token operator">*</span><span class="token keyword">this</span> <span class="token operator">=</span> <span class="token operator">*</span>o<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// otherwise, assign a clone (which could itself be null):</span>
      <span class="token operator">*</span><span class="token keyword">this</span> <span class="token operator">=</span> o<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  value_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span> T <span class="token keyword">const</span><span class="token operator">&amp;</span> t <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token operator">*</span><span class="token operator">*</span><span class="token keyword">this</span> <span class="token operator">=</span> t<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token operator">*</span><span class="token keyword">this</span> <span class="token operator">=</span> <span class="token function">value_ptr</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  value_ptr<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span> T <span class="token operator">&amp;&amp;</span> t <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token operator">*</span><span class="token operator">*</span><span class="token keyword">this</span> <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token operator">*</span><span class="token keyword">this</span> <span class="token operator">=</span> <span class="token function">value_ptr</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  T<span class="token operator">&amp;</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  T <span class="token keyword">const</span><span class="token operator">&amp;</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  T<span class="token operator">*</span> <span class="token function">get_pointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">addressof</span><span class="token punctuation">(</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  T <span class="token keyword">const</span><span class="token operator">*</span> <span class="token function">get_pointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> std<span class="token operator">::</span><span class="token function">addressof</span><span class="token punctuation">(</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// operator-&gt; from unique_ptr</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">&gt;</span>
value_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">make_value_ptr</span><span class="token punctuation">(</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args <span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>std<span class="token operator">::</span>make_unique<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">(</span>std<span class="token operator">::</span>forward<span class="token operator">&lt;</span>Args<span class="token operator">&gt;</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>This particular value_ptr is only empty if you construct it with <code>empty_ptr_t</code> or if you move from it.  It exposes the fact it is a <code>unique_ptr</code>, so <code>explicit operator bool() const</code> works on it.  <code>.get()</code> has been changed to return a reference (as it is almost never empty), and <code>.get_pointer()</code> returns a pointer instead.</p> <p>This smart pointer can be useful for <code>pImpl</code> cases, where we want value-semantics but we also don't want to expose the contents of the <code>pImpl</code> outside of the implementation file.</p> <p>With a non-default <code>Copier</code>, it can even handle virtual base classes that know how to produce instances of their derived and turn them into value-types.</p> <h2 id="getting-a-shared-ptr-referring-to-this"><a href="#getting-a-shared-ptr-referring-to-this" class="header-anchor">#</a> Getting a shared_ptr referring to this</h2> <p><code>enable_shared_from_this</code> enables you to get a valid <code>shared_ptr</code> instance to <code>this</code>.</p> <p>By deriving your class from the class template <code>enable_shared_from_this</code>, you inherit a method <code>shared_from_this</code> that returns a <code>shared_ptr</code> instance to <code>this</code>.</p> <p><strong>Note</strong> that the object must be created as a <code>shared_ptr</code> in first place:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>
<span class="token keyword">class</span> <span class="token class-name">A</span><span class="token operator">:</span> <span class="token keyword">public</span> enable_shared_from_this<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
A<span class="token operator">*</span> ap1 <span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> <span class="token function">ap2</span><span class="token punctuation">(</span>ap1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// First prepare a shared pointer to the object and hold it!</span>
<span class="token comment">// Then get a shared pointer to the object from the object itself</span>
shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> ap3 <span class="token operator">=</span> ap1<span class="token operator">-&gt;</span><span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">int</span> c3 <span class="token operator">=</span>ap3<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// =2: pointing to the same object</span>

</code></pre></div><p><strong>Note</strong>(2) you cannot call <code>enable_shared_from_this</code> inside the constructor.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span> </span><span class="token comment">// enable_shared_from_this</span>

<span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token operator">:</span> <span class="token keyword">public</span> std<span class="token operator">::</span>enable_shared_from_this<span class="token operator">&lt;</span> Widget <span class="token operator">&gt;</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">DoSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        std<span class="token operator">::</span>shared_ptr<span class="token operator">&lt;</span> Widget <span class="token operator">&gt;</span> self <span class="token operator">=</span> <span class="token function">shared_from_this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        someEvent <span class="token operator">-&gt;</span> <span class="token function">Register</span><span class="token punctuation">(</span> self <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">auto</span> w <span class="token operator">=</span> std<span class="token operator">::</span>make_shared<span class="token operator">&lt;</span> Widget <span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    w <span class="token operator">-&gt;</span> <span class="token function">DoSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

</code></pre></div><p>If you use <code>shared_from_this()</code> on an object not owned by a <code>shared_ptr</code>, such as a local automatic object or a global object, then the behavior is undefined. Since C++17 it throws <code>std::bad_alloc</code> instead.</p> <p>Using <code>shared_from_this()</code> from a constructor is equivalent to using it on an object not owned by a <code>shared_ptr</code>, because the objects is possessed by the <code>shared_ptr</code> after the constructor returns.</p> <h4 id="syntax"><a href="#syntax" class="header-anchor">#</a> Syntax</h4> <ul><li><code>std::shared_ptr&lt;ClassType&gt; variableName = std::make_shared&lt;ClassType&gt;(arg1, arg2, ...);</code></li> <li><code>std::shared_ptr&lt;ClassType&gt; variableName (new ClassType(arg1, arg2, ...));</code></li> <li><code>std::unique_ptr&lt;ClassType&gt; variableName = std::make_unique&lt;ClassType&gt;(arg1, arg2, ...);</code> // C++14</li> <li><code>std::unique_ptr&lt;ClassType&gt; variableName (new ClassType(arg1, arg2, ...));</code></li></ul> <h4 id="remarks"><a href="#remarks" class="header-anchor">#</a> Remarks</h4> <p>C++ is not a memory-managed language. Dynamically allocated memory (i.e. objects created with <code>new</code>) will be &quot;leaked&quot; if it is not explicitly deallocated (with <code>delete</code>). It is the programmer's responsibility to ensure that the dynamically allocated memory is freed before discarding the last pointer to that object.</p> <p>Smart pointers can be used to automatically manage the scope of dynamically allocated memory (i.e. when the last pointer reference goes out of scope it is deleted).</p> <p>Smart pointers are preferred over &quot;raw&quot; pointers in most cases. They make the ownership semantics of dynamically allocated memory explicit, by communicating in their names whether an object is intended to be shared or uniquely owned.</p> <p>Use <code>#include &lt;memory&gt;</code> to be able to use smart pointers.</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/devtut/generate/edit/master/docs/cpp/smart-pointers.md" target="_blank" rel="noopener noreferrer">Edit this page on GitHub</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      
      <a href="/cpp/the-this-pointer.html" class="prev">
        The This Pointer
      </a></span> <span class="next"><a href="/cpp/classes-structures.html">
        Classes/Structures
      </a>
      
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.ced448ab.js" defer></script><script src="/assets/js/3.f1d73125.js" defer></script><script src="/assets/js/710.0d41aedb.js" defer></script>
  </body>
</html>
