<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C++ | std::string</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="description" content="Tokenize, Conversion to (const) char*, Using the std::string_view class, Conversion to std::wstring, Trimming characters at start/end, Lexicographical comparison, String replacement, Converting to std::string, Splitting, Accessing a character, Looping through each character, Checking if a string is a prefix of another, Concatenation, Conversion to integers/floating point types, Converting between character encodings, Finding character(s) in a string">
    <meta property="og:site_name" content="DevTut">
    <meta property="og:title" content="C++ | std::string">
    <meta property="og:description" content="Tokenize, Conversion to (const) char*, Using the std::string_view class, Conversion to std::wstring, Trimming characters at start/end, Lexicographical comparison, String replacement, Converting to std::string, Splitting, Accessing a character, Looping through each character, Checking if a string is a prefix of another, Concatenation, Conversion to integers/floating point types, Converting between character encodings, Finding character(s) in a string">
    <meta property="og:type" content="article">
    <meta property="og:url" content="/cpp/std-string.html">
    <meta property="og:image" content="/logo.png">
    <meta name="twitter:title" content="C++ | std::string">
    <meta name="twitter:description" content="Tokenize, Conversion to (const) char*, Using the std::string_view class, Conversion to std::wstring, Trimming characters at start/end, Lexicographical comparison, String replacement, Converting to std::string, Splitting, Accessing a character, Looping through each character, Checking if a string is a prefix of another, Concatenation, Conversion to integers/floating point types, Converting between character encodings, Finding character(s) in a string">
    <meta name="twitter:url" content="/cpp/std-string.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="/logo.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/mstile-150x150.png">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="google-site-verification" content="76_rKXgwMVIjd-axJC_1zPV9OS4mEjvtgjYOWVkAdnQ">
    
    <link rel="preload" href="/assets/css/0.styles.60619e34.css" as="style"><link rel="preload" href="/assets/js/app.1779e102.js" as="script"><link rel="preload" href="/assets/js/3.2cfa8016.js" as="script"><link rel="preload" href="/assets/js/728.94442c29.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.60619e34.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">DevTut</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>C++</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/cpp/" aria-current="page" class="sidebar-link">Disclaimer</a></li><li><a href="/cpp/getting-started-with-cpp.html" class="sidebar-link">Getting started with C++</a></li><li><a href="/cpp/literals.html" class="sidebar-link">Literals</a></li><li><a href="/cpp/operator-precedence.html" class="sidebar-link">operator precedence</a></li><li><a href="/cpp/floating-point-arithmetic.html" class="sidebar-link">Floating Point Arithmetic</a></li><li><a href="/cpp/bit-operators.html" class="sidebar-link">Bit Operators</a></li><li><a href="/cpp/bit-manipulation.html" class="sidebar-link">Bit Manipulation</a></li><li><a href="/cpp/bit-fields.html" class="sidebar-link">Bit fields</a></li><li><a href="/cpp/arrays.html" class="sidebar-link">Arrays</a></li><li><a href="/cpp/iterators.html" class="sidebar-link">Iterators</a></li><li><a href="/cpp/basic-input-output-in-c.html" class="sidebar-link">Basic input/output in c++</a></li><li><a href="/cpp/loops.html" class="sidebar-link">Loops</a></li><li><a href="/cpp/file-i-o.html" class="sidebar-link">File I/O</a></li><li><a href="/cpp/cpp-streams.html" class="sidebar-link">C++ Streams</a></li><li><a href="/cpp/stream-manipulators.html" class="sidebar-link">Stream manipulators</a></li><li><a href="/cpp/flow-control.html" class="sidebar-link">Flow Control</a></li><li><a href="/cpp/metaprogramming.html" class="sidebar-link">Metaprogramming</a></li><li><a href="/cpp/const-keyword.html" class="sidebar-link">const keyword</a></li><li><a href="/cpp/mutable-keyword.html" class="sidebar-link">mutable keyword</a></li><li><a href="/cpp/friend-keyword.html" class="sidebar-link">Friend keyword</a></li><li><a href="/cpp/type-keywords.html" class="sidebar-link">Type Keywords</a></li><li><a href="/cpp/basic-type-keywords.html" class="sidebar-link">Basic Type Keywords</a></li><li><a href="/cpp/variable-declaration-keywords.html" class="sidebar-link">Variable Declaration Keywords</a></li><li><a href="/cpp/keywords.html" class="sidebar-link">Keywords</a></li><li><a href="/cpp/returning-several-values-from-a-function.html" class="sidebar-link">Returning several values from a function</a></li><li><a href="/cpp/polymorphism.html" class="sidebar-link">Polymorphism</a></li><li><a href="/cpp/references.html" class="sidebar-link">References</a></li><li><a href="/cpp/value-and-reference-semantics.html" class="sidebar-link">Value and Reference Semantics</a></li><li><a href="/cpp/c-function-call-by-value-vs-call-by-reference.html" class="sidebar-link">C++ function &quot;call by value&quot; vs. &quot;call by reference&quot;</a></li><li><a href="/cpp/copying-vs-assignment.html" class="sidebar-link">Copying vs Assignment</a></li><li><a href="/cpp/pointers.html" class="sidebar-link">Pointers</a></li><li><a href="/cpp/pointers-to-members.html" class="sidebar-link">Pointers to members</a></li><li><a href="/cpp/the-this-pointer.html" class="sidebar-link">The This Pointer</a></li><li><a href="/cpp/smart-pointers.html" class="sidebar-link">Smart Pointers</a></li><li><a href="/cpp/classes-structures.html" class="sidebar-link">Classes/Structures</a></li><li><a href="/cpp/function-overloading.html" class="sidebar-link">Function Overloading</a></li><li><a href="/cpp/operator-overloading.html" class="sidebar-link">Operator Overloading</a></li><li><a href="/cpp/function-template-overloading.html" class="sidebar-link">Function Template Overloading</a></li><li><a href="/cpp/virtual-member-functions.html" class="sidebar-link">Virtual Member Functions</a></li><li><a href="/cpp/inline-functions.html" class="sidebar-link">Inline functions</a></li><li><a href="/cpp/special-member-functions.html" class="sidebar-link">Special Member Functions</a></li><li><a href="/cpp/non-static-member-functions.html" class="sidebar-link">Non-Static Member Functions</a></li><li><a href="/cpp/constant-class-member-functions.html" class="sidebar-link">Constant class member functions</a></li><li><a href="/cpp/c-containers.html" class="sidebar-link">C++ Containers</a></li><li><a href="/cpp/namespaces.html" class="sidebar-link">Namespaces</a></li><li><a href="/cpp/header-files.html" class="sidebar-link">Header Files</a></li><li><a href="/cpp/using-declaration.html" class="sidebar-link">Using declaration</a></li><li><a href="/cpp/std-string.html" aria-current="page" class="active sidebar-link">std::string</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cpp/std-string.html#tokenize" class="sidebar-link">Tokenize</a></li><li class="sidebar-sub-header"><a href="/cpp/std-string.html#conversion-to-const-char" class="sidebar-link">Conversion to (const) char*</a></li><li class="sidebar-sub-header"><a href="/cpp/std-string.html#using-the-std-string-view-class" class="sidebar-link">Using the std::string_view class</a></li><li class="sidebar-sub-header"><a href="/cpp/std-string.html#conversion-to-std-wstring" class="sidebar-link">Conversion to std::wstring</a></li><li class="sidebar-sub-header"><a href="/cpp/std-string.html#trimming-characters-at-start-end" class="sidebar-link">Trimming characters at start/end</a></li><li class="sidebar-sub-header"><a href="/cpp/std-string.html#lexicographical-comparison" class="sidebar-link">Lexicographical comparison</a></li><li class="sidebar-sub-header"><a href="/cpp/std-string.html#string-replacement" class="sidebar-link">String replacement</a></li><li class="sidebar-sub-header"><a href="/cpp/std-string.html#converting-to-std-string" class="sidebar-link">Converting to std::string</a></li><li class="sidebar-sub-header"><a href="/cpp/std-string.html#splitting" class="sidebar-link">Splitting</a></li><li class="sidebar-sub-header"><a href="/cpp/std-string.html#accessing-a-character" class="sidebar-link">Accessing a character</a></li><li class="sidebar-sub-header"><a href="/cpp/std-string.html#looping-through-each-character" class="sidebar-link">Looping through each character</a></li><li class="sidebar-sub-header"><a href="/cpp/std-string.html#checking-if-a-string-is-a-prefix-of-another" class="sidebar-link">Checking if a string is a prefix of another</a></li><li class="sidebar-sub-header"><a href="/cpp/std-string.html#concatenation" class="sidebar-link">Concatenation</a></li><li class="sidebar-sub-header"><a href="/cpp/std-string.html#conversion-to-integers-floating-point-types" class="sidebar-link">Conversion to integers/floating point types</a></li><li class="sidebar-sub-header"><a href="/cpp/std-string.html#converting-between-character-encodings" class="sidebar-link">Converting between character encodings</a></li><li class="sidebar-sub-header"><a href="/cpp/std-string.html#finding-character-s-in-a-string" class="sidebar-link">Finding character(s) in a string</a></li></ul></li><li><a href="/cpp/std-array.html" class="sidebar-link">std::array</a></li><li><a href="/cpp/std-vector.html" class="sidebar-link">std::vector</a></li><li><a href="/cpp/std-map.html" class="sidebar-link">std::map</a></li><li><a href="/cpp/std-optional.html" class="sidebar-link">std::optional</a></li><li><a href="/cpp/std-function-to-wrap-any-element-that-is-callable.html" class="sidebar-link">std::function: To wrap any element that is callable</a></li><li><a href="/cpp/std-forward-list.html" class="sidebar-link">std::forward_list</a></li><li><a href="/cpp/std-pair.html" class="sidebar-link">std::pair</a></li><li><a href="/cpp/std-atomics.html" class="sidebar-link">std::atomics</a></li><li><a href="/cpp/std-variant.html" class="sidebar-link">std::variant</a></li><li><a href="/cpp/std-iomanip.html" class="sidebar-link">std::iomanip</a></li><li><a href="/cpp/std-any.html" class="sidebar-link">std::any</a></li><li><a href="/cpp/std-set-and-std-multiset.html" class="sidebar-link">std::set and std::multiset</a></li><li><a href="/cpp/std-integer-sequence.html" class="sidebar-link">std::integer_sequence</a></li><li><a href="/cpp/using-std-unordered-map.html" class="sidebar-link">Using std::unordered_map</a></li><li><a href="/cpp/standard-library-algorithms.html" class="sidebar-link">Standard Library Algorithms</a></li><li><a href="/cpp/the-iso-c-standard.html" class="sidebar-link">The ISO C++ Standard</a></li><li><a href="/cpp/inline-variables.html" class="sidebar-link">Inline variables</a></li><li><a href="/cpp/random-number-generation.html" class="sidebar-link">Random number generation</a></li><li><a href="/cpp/date-and-time-using-chrono-header.html" class="sidebar-link">Date and time using  header</a></li><li><a href="/cpp/sorting.html" class="sidebar-link">Sorting</a></li><li><a href="/cpp/enumeration.html" class="sidebar-link">Enumeration</a></li><li><a href="/cpp/iteration.html" class="sidebar-link">Iteration</a></li><li><a href="/cpp/regular-expressions.html" class="sidebar-link">Regular expressions</a></li><li><a href="/cpp/implementation-defined-behavior.html" class="sidebar-link">Implementation-defined behavior</a></li><li><a href="/cpp/exceptions.html" class="sidebar-link">Exceptions</a></li><li><a href="/cpp/lambdas.html" class="sidebar-link">Lambdas</a></li><li><a href="/cpp/value-categories.html" class="sidebar-link">Value Categories</a></li><li><a href="/cpp/preprocessor.html" class="sidebar-link">Preprocessor</a></li><li><a href="/cpp/data-structures-in-c.html" class="sidebar-link">Data Structures in C++</a></li><li><a href="/cpp/templates.html" class="sidebar-link">Templates</a></li><li><a href="/cpp/expression-templates.html" class="sidebar-link">Expression templates</a></li><li><a href="/cpp/curiously-recurring-template-pattern-crtp.html" class="sidebar-link">Curiously Recurring Template Pattern (CRTP)</a></li><li><a href="/cpp/threading.html" class="sidebar-link">Threading</a></li><li><a href="/cpp/thread-synchronization-structures.html" class="sidebar-link">Thread synchronization structures</a></li><li><a href="/cpp/the-rule-of-three-five-and-zero.html" class="sidebar-link">The Rule of Three, Five, And Zero</a></li><li><a href="/cpp/raii-resource-acquisition-is-initialization.html" class="sidebar-link">RAII: Resource Acquisition Is Initialization</a></li><li><a href="/cpp/rtti-run-time-type-information.html" class="sidebar-link">RTTI: Run-Time Type Information</a></li><li><a href="/cpp/mutexes.html" class="sidebar-link">Mutexes</a></li><li><a href="/cpp/recursive-mutex.html" class="sidebar-link">Recursive Mutex</a></li><li><a href="/cpp/semaphore.html" class="sidebar-link">Semaphore</a></li><li><a href="/cpp/futures-and-promises.html" class="sidebar-link">Futures and Promises</a></li><li><a href="/cpp/atomic-types.html" class="sidebar-link">Atomic Types</a></li><li><a href="/cpp/type-erasure.html" class="sidebar-link">Type Erasure</a></li><li><a href="/cpp/explicit-type-conversions.html" class="sidebar-link">Explicit type conversions</a></li><li><a href="/cpp/unnamed-types.html" class="sidebar-link">Unnamed types</a></li><li><a href="/cpp/type-traits.html" class="sidebar-link">Type Traits</a></li><li><a href="/cpp/return-type-covariance.html" class="sidebar-link">Return Type Covariance</a></li><li><a href="/cpp/layout-of-object-types.html" class="sidebar-link">Layout of object types</a></li><li><a href="/cpp/type-inference.html" class="sidebar-link">Type Inference</a></li><li><a href="/cpp/typedef-and-type-aliases.html" class="sidebar-link">Typedef and type aliases</a></li><li><a href="/cpp/type-deduction.html" class="sidebar-link">type deduction</a></li><li><a href="/cpp/trailing-return-type.html" class="sidebar-link">Trailing return type</a></li><li><a href="/cpp/alignment.html" class="sidebar-link">Alignment</a></li><li><a href="/cpp/perfect-forwarding.html" class="sidebar-link">Perfect Forwarding</a></li><li><a href="/cpp/decltype.html" class="sidebar-link">decltype</a></li><li><a href="/cpp/sfinae-substitution-failure-is-not-an-error.html" class="sidebar-link">SFINAE (Substitution Failure Is Not An Error)</a></li><li><a href="/cpp/undefined-behavior.html" class="sidebar-link">Undefined Behavior</a></li><li><a href="/cpp/overload-resolution.html" class="sidebar-link">Overload resolution</a></li><li><a href="/cpp/move-semantics.html" class="sidebar-link">Move Semantics</a></li><li><a href="/cpp/pimpl-idiom.html" class="sidebar-link">Pimpl Idiom</a></li><li><a href="/cpp/auto.html" class="sidebar-link">auto</a></li><li><a href="/cpp/copy-elision.html" class="sidebar-link">Copy Elision</a></li><li><a href="/cpp/fold-expressions.html" class="sidebar-link">Fold Expressions</a></li><li><a href="/cpp/unions.html" class="sidebar-link">Unions</a></li><li><a href="/cpp/design-pattern-implementation-in-c.html" class="sidebar-link">Design pattern implementation in C++</a></li><li><a href="/cpp/singleton-design-pattern.html" class="sidebar-link">Singleton Design Pattern</a></li><li><a href="/cpp/user-defined-literals.html" class="sidebar-link">User-Defined Literals</a></li><li><a href="/cpp/memory-management.html" class="sidebar-link">Memory management</a></li><li><a href="/cpp/c-11-memory-model.html" class="sidebar-link">C++11 Memory Model</a></li><li><a href="/cpp/scopes.html" class="sidebar-link">Scopes</a></li><li><a href="/cpp/static-assert.html" class="sidebar-link">static_assert</a></li><li><a href="/cpp/constexpr.html" class="sidebar-link">constexpr</a></li><li><a href="/cpp/one-definition-rule-odr.html" class="sidebar-link">One Definition Rule (ODR)</a></li><li><a href="/cpp/unspecified-behavior.html" class="sidebar-link">Unspecified behavior</a></li><li><a href="/cpp/argument-dependent-name-lookup.html" class="sidebar-link">Argument Dependent Name Lookup</a></li><li><a href="/cpp/attributes.html" class="sidebar-link">Attributes</a></li><li><a href="/cpp/recursion-in-c.html" class="sidebar-link">Recursion in C++</a></li><li><a href="/cpp/arithmitic-metaprogramming.html" class="sidebar-link">Arithmitic Metaprogramming</a></li><li><a href="/cpp/callable-objects.html" class="sidebar-link">Callable Objects</a></li><li><a href="/cpp/client-server-examples.html" class="sidebar-link">Client server examples</a></li><li><a href="/cpp/const-correctness.html" class="sidebar-link">Const Correctness</a></li><li><a href="/cpp/parameter-packs.html" class="sidebar-link">Parameter packs</a></li><li><a href="/cpp/build-systems.html" class="sidebar-link">Build Systems</a></li><li><a href="/cpp/concurrency-with-openmp.html" class="sidebar-link">Concurrency With OpenMP</a></li><li><a href="/cpp/resource-management.html" class="sidebar-link">Resource Management</a></li><li><a href="/cpp/storage-class-specifiers.html" class="sidebar-link">Storage class specifiers</a></li><li><a href="/cpp/linkage-specifications.html" class="sidebar-link">Linkage specifications</a></li><li><a href="/cpp/digit-separators.html" class="sidebar-link">Digit separators</a></li><li><a href="/cpp/c-incompatibilities.html" class="sidebar-link">C incompatibilities</a></li><li><a href="/cpp/side-by-side-comparisons-of-classic-c-examples-solved-via-c-vs-c-11-vs-c-14-vs-c-17.html" class="sidebar-link">Side by Side Comparisons of classic C++ examples solved via C++ vs C++11 vs C++14 vs C++17</a></li><li><a href="/cpp/compiling-and-building.html" class="sidebar-link">Compiling and Building</a></li><li><a href="/cpp/common-compile-linker-errors-gcc.html" class="sidebar-link">Common compile/linker errors (GCC)</a></li><li><a href="/cpp/more-undefined-behaviors-in-c.html" class="sidebar-link">More undefined behaviors in C++</a></li><li><a href="/cpp/unit-testing-in-c.html" class="sidebar-link">Unit Testing in C++</a></li><li><a href="/cpp/c-debugging-and-debug-prevention-tools-techniques.html" class="sidebar-link">C++ Debugging and Debug-prevention Tools &amp; Techniques</a></li><li><a href="/cpp/optimization-in-c.html" class="sidebar-link">Optimization in C++</a></li><li><a href="/cpp/optimization.html" class="sidebar-link">Optimization</a></li><li><a href="/cpp/profiling.html" class="sidebar-link">Profiling</a></li><li><a href="/cpp/refactoring-techniques.html" class="sidebar-link">Refactoring Techniques</a></li><li><a href="/cpp/internationalization-in-c.html" class="sidebar-link">Internationalization in C++</a></li><li><a href="/cpp/contributors.html" class="sidebar-link">The Contributors</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="std-string"><a href="#std-string" class="header-anchor">#</a> std::string</h1> <p>Strings are objects that represent sequences of characters. The standard <code>string</code> class provides a simple, safe and versatile alternative to using explicit arrays of <code>char</code>s when dealing with text and other sequences of characters. The C++ <code>string</code> class is part of the <code>std</code> namespace and was standardized in 1998.</p> <h2 id="tokenize"><a href="#tokenize" class="header-anchor">#</a> Tokenize</h2> <p>Listed from least expensive to most expensive at run-time:</p> <li>
`str::strtok` is the cheapest standard provided tokenization method, it also allows the delimiter to be modified between tokens, but it incurs 3 difficulties with modern C++:
<ul>
1. `std::strtok` cannot be used on multiple `strings` at the same time (though some implementations do extend to support this, such as: [`strtok_s`](https://msdn.microsoft.com/en-us/library/ftsafwz3.aspx))
1. For the same reason `std::strtok` cannot be used on multiple threads simultaneously (this may however be implementation defined, for example: [Visual Studio's implementation is thread safe](https://msdn.microsoft.com/en-us/library/2c8d19sb.aspx#Anchor_3))
1. Calling `std::strtok` modifies the `std::string` it is operating on, so it cannot be used on `const string`s, `const char*`s, or literal strings, to tokenize any of these with `std::strtok` or to operate on a `std::string` who's contents need to be preserved, the input would have to be copied, then the copy could be operated on
</ul>
Generally any of these options cost will be hidden in the allocation cost of the tokens, but if the cheapest algorithm is required and `std::strtok`'s difficulties are not overcomable consider a [hand-spun solution](http://stackoverflow.com/a/38595708/2642059).
</li> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// String to tokenize</span>
std<span class="token double-colon punctuation">::</span>string str<span class="token punctuation">{</span> <span class="token string">&quot;The quick brown fox&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// Vector to store tokens</span>
vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> tokens<span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> i <span class="token operator">=</span> <span class="token function">strtok</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> i <span class="token operator">=</span> <span class="token function">strtok</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    tokens<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p><a href="http://ideone.com/8kAGoa" target="_blank" rel="noopener noreferrer">Live Example<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ol><li>The <code>std::istream_iterator</code> uses the stream's extraction operator iteratively. If the input <code>std::string</code> is white-space delimited this is able to expand on the <code>std::strtok</code> option by eliminating its difficulties, allowing inline tokenization thereby supporting the generation of a <code>const vector&lt;string&gt;</code>, and by adding support for multiple delimiting white-space character:</li></ol> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// String to tokenize</span>
<span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token function">str</span><span class="token punctuation">(</span><span class="token string">&quot;The  quick \tbrown \nfox&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>istringstream <span class="token function">is</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Vector to store tokens</span>
<span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> tokens <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>
                                        std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">istream_iterator</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>is<span class="token punctuation">)</span><span class="token punctuation">,</span>
                                        std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">istream_iterator</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p><a href="http://ideone.com/gWmfV9" target="_blank" rel="noopener noreferrer">Live Example<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ol><li>The <code>std::regex_token_iterator</code> uses a <code>std::regex</code> to iteratively tokenize. It provides for a more flexible delimiter definition. For example, non-delimited commas and white-space:</li></ol> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// String to tokenize</span>
<span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string str<span class="token punctuation">{</span> <span class="token string">&quot;The ,qu\\,ick ,\tbrown, fox&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>regex re<span class="token punctuation">{</span> <span class="token string">&quot;\\s*((?:[^\\\\,]|\\\\.)*?)\\s*(?:,|$)&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// Vector to store tokens</span>
<span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> tokens<span class="token punctuation">{</span> 
    std<span class="token double-colon punctuation">::</span><span class="token function">sregex_token_iterator</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> str<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> re<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
    std<span class="token double-colon punctuation">::</span><span class="token function">sregex_token_iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p><a href="http://ideone.com/q58zoX" target="_blank" rel="noopener noreferrer">Live Example<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>See the <a href="http://stackoverflow.com/documentation/c%2b%2b/1681/regular-expressions/5425/regex-token-iterator-example" target="_blank" rel="noopener noreferrer"><code>regex_token_iterator</code> Example<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> for more details.</p> <h2 id="conversion-to-const-char"><a href="#conversion-to-const-char" class="header-anchor">#</a> Conversion to (const) char*</h2> <p>In order to get <code>const char*</code> access to the data of a <code>std::string</code> you can use the string's <code>c_str()</code> member function. Keep in mind that the pointer is only valid as long as the <code>std::string</code> object is within scope and remains unchanged, that means that only <code>const</code> methods may be called on the object.</p> <p>The <code>data()</code> member function can be used to obtain a modifiable <code>char*</code>, which can be used to manipulate the <code>std::string</code> object's data.</p> <p>A modifiable <code>char*</code> can also be obtained by taking the address of the first character: <code>&amp;s[0]</code>. Within C++11, this is guaranteed to yield a well-formed, null-terminated string. Note that <code>&amp;s[0]</code> is well-formed even if <code>s</code> is empty, whereas <code>&amp;s.front()</code> is undefined if <code>s</code> is empty.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string <span class="token function">str</span><span class="token punctuation">(</span><span class="token string">&quot;This is a string.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> cstr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// cstr points to: &quot;This is a string.\0&quot;</span>
<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> data <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// data points to: &quot;This is a string.\0&quot;</span>

</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string <span class="token function">str</span><span class="token punctuation">(</span><span class="token string">&quot;This is a string.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Copy the contents of str to untie lifetime from the std::string object</span>
std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">char</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> cstr <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Alternative to the line above (no exception safety):</span>
<span class="token comment">// char* cstr_unsafe = new char[str.size() + 1];</span>

std<span class="token double-colon punctuation">::</span><span class="token function">copy</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> str<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cstr<span class="token punctuation">)</span><span class="token punctuation">;</span>
cstr<span class="token punctuation">[</span>str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span> <span class="token comment">// A null-terminator needs to be added</span>

<span class="token comment">// delete[] cstr_unsafe;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> cstr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><h2 id="using-the-std-string-view-class"><a href="#using-the-std-string-view-class" class="header-anchor">#</a> Using the std::string_view class</h2> <p>C++17 introduces <code>std::string_view</code>, which is simply a non-owning range of <code>const char</code>s, implementable as either a pair of pointers or a pointer and a length. It is a superior parameter type for functions that requires non-modifiable string data. Before C++17, there were three options for this:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string <span class="token keyword">const</span><span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// pre-C++17, single argument, could incur</span>
                                     <span class="token comment">// allocation if caller's data was not in a string</span>
                                     <span class="token comment">// (e.g. string literal or vector&lt;char&gt; )</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">,</span> size_t len<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// pre-C++17, two arguments, have to pass them</span>
                                     <span class="token comment">// both everywhere</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// pre-C++17, single argument, but need to call</span>
                                     <span class="token comment">// strlen()</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">StringT</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>StringT <span class="token keyword">const</span><span class="token operator">&amp;</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// pre-C++17, caller can pass arbitrary char data</span>
                                     <span class="token comment">// provider, but now foo() has to live in a header</span>

</code></pre></div><p>All of these can be replaced with:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string_view s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// post-C++17, single argument, tighter coupling</span>
                                     <span class="token comment">// zero copies regardless of how caller is storing</span>
                                     <span class="token comment">// the data</span>

</code></pre></div><p><strong>Note that <code>std::string_view</code> <strong>cannot</strong> modify its underlying data</strong>.</p> <p><code>string_view</code> is useful when you want to avoid unnecessary copies.</p> <p>It offers a useful subset of the functionality that <code>std::string</code> does, although some of the functions behave differently:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string str <span class="token operator">=</span> <span class="token string">&quot;lllloooonnnngggg sssstttrrriiinnnggg&quot;</span><span class="token punctuation">;</span> <span class="token comment">//A really long string</span>

<span class="token comment">//Bad way - 'string::substr' returns a new string (expensive if the string is long)</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>

<span class="token comment">//Good way - No copies are created!</span>
std<span class="token double-colon punctuation">::</span>string_view view <span class="token operator">=</span> str<span class="token punctuation">;</span>

<span class="token comment">// string_view::substr returns a new string_view</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> view<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>

</code></pre></div><h2 id="conversion-to-std-wstring"><a href="#conversion-to-std-wstring" class="header-anchor">#</a> Conversion to std::wstring</h2> <p>In C++, sequences of characters are represented by specializing the <code>std::basic_string</code> class with a native character type. The two major collections defined by the standard library are <code>std::string</code> and <code>std::wstring</code>:</p> <li>
`std::string` is built with elements of type `char`
</li> <li>
`std::wstring` is built with elements of type `wchar_t`
</li> <p>To convert between the two types, use <code>wstring_convert</code>:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;codecvt&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;locale&gt;</span></span>

std<span class="token double-colon punctuation">::</span>string input_str <span class="token operator">=</span> <span class="token string">&quot;this is a -string-, which is a sequence based on the -char- type.&quot;</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>wstring input_wstr <span class="token operator">=</span> L<span class="token string">&quot;this is a -wide- string, which is based on the -wchar_t- type.&quot;</span><span class="token punctuation">;</span>

<span class="token comment">// conversion</span>
std<span class="token double-colon punctuation">::</span>wstring str_turned_to_wstr <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">wstring_convert</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>codecvt_utf8<span class="token operator">&lt;</span><span class="token keyword">wchar_t</span><span class="token operator">&gt;&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">from_bytes</span><span class="token punctuation">(</span>input_str<span class="token punctuation">)</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>string wstr_turned_to_str <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">wstring_convert</span><span class="token generic class-name"><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>codecvt_utf8<span class="token operator">&lt;</span><span class="token keyword">wchar_t</span><span class="token operator">&gt;&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">to_bytes</span><span class="token punctuation">(</span>input_wstr<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>In order to improve usability and/or readability, you can define functions to perform the conversion:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;codecvt&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;locale&gt;</span></span>

<span class="token keyword">using</span> convert_t <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>codecvt_utf8<span class="token operator">&lt;</span><span class="token keyword">wchar_t</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>wstring_convert<span class="token operator">&lt;</span>convert_t<span class="token punctuation">,</span> <span class="token keyword">wchar_t</span><span class="token operator">&gt;</span> strconverter<span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>string <span class="token function">to_string</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>wstring wstr<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> strconverter<span class="token punctuation">.</span><span class="token function">to_bytes</span><span class="token punctuation">(</span>wstr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

std<span class="token double-colon punctuation">::</span>wstring <span class="token function">to_wstring</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string str<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> strconverter<span class="token punctuation">.</span><span class="token function">from_bytes</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Sample usage:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>wstring a_wide_string <span class="token operator">=</span> <span class="token function">to_wstring</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>That's certainly more readable than <code>std::wstring_convert&lt;std::codecvt_utf8&lt;wchar_t&gt;&gt;().from_bytes(&quot;Hello World!&quot;)</code>.</p> <p>Please note that <code>char</code> and <code>wchar_t</code> do not imply encoding, and gives no indication of size in bytes. For instance, <code>wchar_t</code> is commonly implemented as a 2-bytes data type and typically contains UTF-16 encoded data under Windows (or UCS-2 in versions prior to Windows 2000) and as a 4-bytes data type encoded using UTF-32 under Linux. This is in contrast with the newer types <code>char16_t</code> and <code>char32_t</code>, which were introduced in C++11 and are guaranteed to be large enough to hold any UTF16 or UTF32 &quot;character&quot; (or more precisely, <strong>code point</strong>) respectively.</p> <h2 id="trimming-characters-at-start-end"><a href="#trimming-characters-at-start-end" class="header-anchor">#</a> Trimming characters at start/end</h2> <p>This example requires the headers <a href="http://en.cppreference.com/w/cpp/header/algorithm" target="_blank" rel="noopener noreferrer"><code>&lt;algorithm&gt;</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, <a href="http://en.cppreference.com/w/cpp/header/locale" target="_blank" rel="noopener noreferrer"><code>&lt;locale&gt;</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, and <a href="http://en.cppreference.com/w/cpp/header/utility" target="_blank" rel="noopener noreferrer"><code>&lt;utility&gt;</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <p>To <strong>trim</strong> a sequence or string means to remove all leading and trailing elements (or characters) matching a certain predicate. We first trim the trailing elements, because it doesn't involve moving any elements, and then trim the leading elements. Note that the generalizations below work for all types of <code>std::basic_string</code> (e.g. <code>std::string</code> and <code>std::wstring</code>), and accidentally also for sequence containers (e.g. <code>std::vector</code> and <code>std::list</code>).</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Sequence</span><span class="token punctuation">,</span> <span class="token comment">// any basic_string, vector, list etc.</span>
          <span class="token keyword">typename</span> <span class="token class-name">Pred</span><span class="token operator">&gt;</span>     <span class="token comment">// a predicate on the element (character) type</span>
Sequence<span class="token operator">&amp;</span> <span class="token function">trim</span><span class="token punctuation">(</span>Sequence<span class="token operator">&amp;</span> seq<span class="token punctuation">,</span> Pred pred<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">trim_start</span><span class="token punctuation">(</span><span class="token function">trim_end</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> pred<span class="token punctuation">)</span><span class="token punctuation">,</span> pred<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Trimming the trailing elements involves finding the <strong>last</strong> element not matching the predicate, and erasing from there on:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Sequence</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">Pred</span><span class="token operator">&gt;</span>
Sequence<span class="token operator">&amp;</span> <span class="token function">trim_end</span><span class="token punctuation">(</span>Sequence<span class="token operator">&amp;</span> seq<span class="token punctuation">,</span> Pred pred<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> last <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">find_if_not</span><span class="token punctuation">(</span>seq<span class="token punctuation">.</span><span class="token function">rbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                 seq<span class="token punctuation">.</span><span class="token function">rend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                 pred<span class="token punctuation">)</span><span class="token punctuation">;</span>
    seq<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>last<span class="token punctuation">.</span><span class="token function">base</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> seq<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> seq<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Trimming the leading elements involves finding the <strong>first</strong> element not matching the predicate and erasing up to there:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Sequence</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">Pred</span><span class="token operator">&gt;</span>
Sequence<span class="token operator">&amp;</span> <span class="token function">trim_start</span><span class="token punctuation">(</span>Sequence<span class="token operator">&amp;</span> seq<span class="token punctuation">,</span> Pred pred<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> first <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">find_if_not</span><span class="token punctuation">(</span>seq<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                  seq<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                                  pred<span class="token punctuation">)</span><span class="token punctuation">;</span>
    seq<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>seq<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> first<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> seq<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>To specialize the above for trimming whitespace in a <code>std::string</code> we can use the <a href="http://en.cppreference.com/w/cpp/locale/isspace" target="_blank" rel="noopener noreferrer"><code>std::isspace()</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> function as a predicate:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> <span class="token function">trim</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>locale<span class="token operator">&amp;</span> loc <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">locale</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">trim</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>loc<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> c<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">isspace</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> loc<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> <span class="token function">trim_start</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>locale<span class="token operator">&amp;</span> loc <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">locale</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">trim_start</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>loc<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> c<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">isspace</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> loc<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> <span class="token function">trim_end</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> str<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>locale<span class="token operator">&amp;</span> loc <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">locale</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">trim_end</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>loc<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> c<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">isspace</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> loc<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Similarly, we can use the <a href="http://en.cppreference.com/w/cpp/string/wide/iswspace" target="_blank" rel="noopener noreferrer"><code>std::iswspace()</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> function for <code>std::wstring</code> etc.</p> <p>If you wish to create a <strong>new</strong> sequence that is a trimmed copy, then you can use a separate function:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Sequence</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">Pred</span><span class="token operator">&gt;</span>
Sequence <span class="token function">trim_copy</span><span class="token punctuation">(</span>Sequence seq<span class="token punctuation">,</span> Pred pred<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// NOTE: passing seq by value</span>
    <span class="token function">trim</span><span class="token punctuation">(</span>seq<span class="token punctuation">,</span> pred<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> seq<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h2 id="lexicographical-comparison"><a href="#lexicographical-comparison" class="header-anchor">#</a> Lexicographical comparison</h2> <p>Two <code>std::string</code>s can be  compared lexicographically using the operators <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string str1 <span class="token operator">=</span> <span class="token string">&quot;Foo&quot;</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string str2 <span class="token operator">=</span> <span class="token string">&quot;Bar&quot;</span><span class="token punctuation">;</span>

<span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>str1 <span class="token operator">&lt;</span> str2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">assert</span><span class="token punctuation">(</span>str <span class="token operator">&gt;</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>str1 <span class="token operator">&lt;=</span> str2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">assert</span><span class="token punctuation">(</span>str1 <span class="token operator">&gt;=</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">assert</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">assert</span><span class="token punctuation">(</span>str1 <span class="token operator">!=</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>All these functions use the underlying <code>std::string::compare()</code> method to perform the comparison, and return for convenience boolean values. The operation of these functions may be interpreted as follows, regardless of the actual implementation:</p> <li>
operator`==`:
If `str1.length() == str2.length()` and each character pair matches, then returns `true`, otherwise returns `false`.
</li> <li>
operator`!=`:
If `str1.length() != str2.length()` or one character pair doesn't match, returns `true`, otherwise it returns `false`.
</li> <li>
operator`&lt;` or operator`&gt;`:
Finds the first different character pair, compares them then returns the boolean result.
</li> <li>
operator`&lt;=` or operator`&gt;=`:
Finds the first different character pair, compares them then returns the boolean result.
</li> <p><strong><strong>Note:</strong></strong> The term <strong>character pair</strong> means the corresponding characters in both strings of the same positions. For better understanding, if two example strings are <code>str1</code> and <code>str2</code>, and their lengths are <code>n</code> and <code>m</code> respectively, then character pairs of both strings means each <code>str1[i]</code> and <code>str2[i]</code> pairs where <strong>i = 0, 1, 2, ..., max(n,m)</strong>. If for any <strong>i</strong> where the corresponding character does not exist, that is, when <strong>i</strong> is greater than or equal to <code>n</code> or <code>m</code>, it would be considered as the lowest value.</p> <p>Here is an example of using <code>&lt;</code>:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string str1 <span class="token operator">=</span> <span class="token string">&quot;Barr&quot;</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string str2 <span class="token operator">=</span> <span class="token string">&quot;Bar&quot;</span><span class="token punctuation">;</span>

<span class="token function">assert</span><span class="token punctuation">(</span>str2 <span class="token operator">&lt;</span> str1<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>The steps are as follows:</p> <ol><li>Compare the first characters, <code>'B' == 'B'</code> - move on.</li> <li>Compare the second characters, <code>'a' == 'a'</code> - move on.</li> <li>Compare the third characters, <code>'r' == 'r'</code> - move on.</li> <li>The <code>str2</code> range is now exhausted, while the <code>str1</code> range still has characters. Thus, <code>str2 &lt; str1</code>.</li></ol> <h2 id="string-replacement"><a href="#string-replacement" class="header-anchor">#</a> String replacement</h2> <h3 id="replace-by-position"><a href="#replace-by-position" class="header-anchor">#</a> Replace by position</h3> <p>To replace a portion of a <code>std::string</code> you can use the method <code>replace</code> from <code>std::string</code>.</p> <p><code>replace</code> has a lot of useful overloads:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//Define string</span>
std<span class="token double-colon punctuation">::</span>string str <span class="token operator">=</span> <span class="token string">&quot;Hello foo, bar and world!&quot;</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string alternate <span class="token operator">=</span> <span class="token string">&quot;Hello foobar&quot;</span><span class="token punctuation">;</span>

<span class="token comment">//1)</span>
str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">&quot;bar&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Hello bar, bar and world!&quot;</span>

<span class="token comment">//2)</span>
str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">,</span> str<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;nobody!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Hello nobody!&quot;</span>

<span class="token comment">//3)</span>
str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> alternate<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Hello foo, bar and foobar!&quot;</span>

</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//4)</span>
str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> alternate<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Hello foo, bar and foobar!&quot;</span>

</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//5)</span>
str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> str<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">,</span> str<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">,</span> str<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//&quot;foo foo, bar and world!&quot;</span>

<span class="token comment">//6)</span>
str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'z'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;zzz foo, bar and world!&quot;</span>

<span class="token comment">//7)</span>
str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">6</span><span class="token punctuation">,</span> str<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Hello xxx, bar and world!&quot;</span>

</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">//8)</span>
str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> str<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token string">'x'</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">,</span> <span class="token string">'z'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;xyz foo, bar and world!&quot;</span>

</code></pre></div><h3 id="replace-occurrences-of-a-string-with-another-string"><a href="#replace-occurrences-of-a-string-with-another-string" class="header-anchor">#</a> Replace occurrences of a string with another string</h3> <p>Replace only the first occurrence of <code>replace</code> with <code>with</code> in <code>str</code>:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string <span class="token function">replaceString</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string str<span class="token punctuation">,</span>
                          <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> replace<span class="token punctuation">,</span>
                          <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> with<span class="token punctuation">)</span><span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>size_t pos <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>replace<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>
        str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> replace<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> with<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> str<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Replace all occurrence of <code>replace</code> with <code>with</code> in <code>str</code>:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string <span class="token function">replaceStringAll</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string str<span class="token punctuation">,</span>
                             <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> replace<span class="token punctuation">,</span>
                             <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> with<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>replace<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        std<span class="token double-colon punctuation">::</span>size_t pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pos <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>replace<span class="token punctuation">,</span> pos<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>pos<span class="token punctuation">,</span> replace<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> with<span class="token punctuation">)</span><span class="token punctuation">;</span>
            pos <span class="token operator">+=</span> with<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> str<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h2 id="converting-to-std-string"><a href="#converting-to-std-string" class="header-anchor">#</a> Converting to std::string</h2> <p><a href="http://en.cppreference.com/w/cpp/io/basic_ostringstream" target="_blank" rel="noopener noreferrer"><code>std::ostringstream</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> can be used to convert any streamable type to a string representation, by inserting the object into a <code>std::ostringstream</code> object (with the stream insertion operator <code>&lt;&lt;</code>) and then converting the whole <code>std::ostringstream</code> to a <code>std::string</code>.</p> <p>For <code>int</code> for instance:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>ostringstream str<span class="token punctuation">;</span>
    str <span class="token operator">&lt;&lt;</span> val<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>string converted <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Writing your own conversion function, the simple:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
std<span class="token double-colon punctuation">::</span>string <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>ostringstream ss<span class="token punctuation">;</span>
  ss <span class="token operator">&lt;&lt;</span> x<span class="token punctuation">;</span>
  <span class="token keyword">return</span> ss<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>works but isn't suitable for performance critical code.</p> <p>User-defined classes may implement the stream insertion operator if desired:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>ostream <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span>ostream<span class="token operator">&amp;</span> out<span class="token punctuation">,</span> <span class="token keyword">const</span> A<span class="token operator">&amp;</span> a <span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// write a string representation of a to out</span>
    <span class="token keyword">return</span> out<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

</code></pre></div><p>Aside from streams, since C++11 you can also use the <a href="http://en.cppreference.com/w/cpp/string/basic_string/to_string" target="_blank" rel="noopener noreferrer"><code>std::to_string</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> (and <a href="http://en.cppreference.com/w/cpp/string/basic_string/to_wstring" target="_blank" rel="noopener noreferrer"><code>std::to_wstring</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>) function which is overloaded for all fundamental types and returns the string representation of its parameter.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string s <span class="token operator">=</span> <span class="token function">to_string</span><span class="token punctuation">(</span><span class="token number">0x12f3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// after this the string s contains &quot;4851&quot;</span>

</code></pre></div><h2 id="splitting"><a href="#splitting" class="header-anchor">#</a> Splitting</h2> <p>Use <a href="http://en.cppreference.com/w/cpp/string/basic_string/substr" target="_blank" rel="noopener noreferrer"><code>std::string::substr</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> to split a string. There are two variants of this member function.</p> <p>The first takes a <strong>starting position</strong> from which the returned substring should begin. The starting position must be valid in the range <code>(0, str.length()]</code>:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string str <span class="token operator">=</span> <span class="token string">&quot;Hello foo, bar and world!&quot;</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string newstr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;bar and world!&quot;</span>

</code></pre></div><p>The second takes a starting position and a total <strong>length</strong> of the new substring. Regardless of the <strong>length</strong>, the substring will never go past the end of the source string:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string str <span class="token operator">=</span> <span class="token string">&quot;Hello foo, bar and world!&quot;</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string newstr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;and&quot;</span>

</code></pre></div><p><strong><strong>Note that</strong></strong> you can also call <code>substr</code> with no arguments, in this case an exact copy of the string is returned</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string str <span class="token operator">=</span> <span class="token string">&quot;Hello foo, bar and world!&quot;</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string newstr <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;Hello foo, bar and world!&quot;</span>

</code></pre></div><h2 id="accessing-a-character"><a href="#accessing-a-character" class="header-anchor">#</a> Accessing a character</h2> <p>There are several ways to extract characters from a <code>std::string</code> and each is subtly different.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string <span class="token function">str</span><span class="token punctuation">(</span><span class="token string">&quot;Hello world!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><h3 id="operator"><a href="#operator" class="header-anchor">#</a> operator<a href="n"></a></h3> <p>Returns a reference to the character at index n.</p> <p><code>std::string::operator[]</code> is not bounds-checked and does not throw an exception. The caller is responsible for asserting that the index is within the range of the string:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">char</span> c <span class="token operator">=</span> str<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 'w'</span>

</code></pre></div><h3 id="at-n"><a href="#at-n" class="header-anchor">#</a> at(n)</h3> <p>Returns a reference to the character at index n.</p> <p><code>std::string::at</code> <strong>is</strong> bounds checked, and will throw <code>std::out_of_range</code> if the index is not within the range of the string:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">char</span> c <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'o'</span>

</code></pre></div><p><strong>Note: Both of these examples will result in <a href="http://stackoverflow.com/documentation/c%2B%2B/1812/undefined-behavior#t=201607232040171204946" target="_blank" rel="noopener noreferrer">undefined behavior<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> if the string is empty.</strong></p> <h3 id="front"><a href="#front" class="header-anchor">#</a> front()</h3> <p>Returns a reference to the first character:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">char</span> c <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'H'</span>

</code></pre></div><h3 id="back"><a href="#back" class="header-anchor">#</a> back()</h3> <p>Returns a reference to the last character:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">char</span> c <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// '!'</span>

</code></pre></div><h2 id="looping-through-each-character"><a href="#looping-through-each-character" class="header-anchor">#</a> Looping through each character</h2> <p><code>std::string</code> supports iterators, and so you can use a <strong>ranged based</strong> loop to iterate through each character:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string str <span class="token operator">=</span> <span class="token string">&quot;Hello World!&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> c <span class="token operator">:</span> str<span class="token punctuation">)</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">;</span>

</code></pre></div><p>You can use a &quot;traditional&quot; <code>for</code> loop to loop through every character:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string str <span class="token operator">=</span> <span class="token string">&quot;Hello World!&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>

</code></pre></div><h2 id="checking-if-a-string-is-a-prefix-of-another"><a href="#checking-if-a-string-is-a-prefix-of-another" class="header-anchor">#</a> Checking if a string is a prefix of another</h2> <p>In C++14, this is easily done by <a href="http://en.cppreference.com/w/cpp/algorithm/mismatch" target="_blank" rel="noopener noreferrer"><code>std::mismatch</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> which returns the first mismatching pair from two ranges:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string prefix <span class="token operator">=</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string string <span class="token operator">=</span> <span class="token string">&quot;foobar&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">bool</span> isPrefix <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">mismatch</span><span class="token punctuation">(</span>prefix<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> prefix<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    string<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> string<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first <span class="token operator">==</span> prefix<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>Note that a range-and-a-half version of <code>mismatch()</code> existed prior to C++14, but this is unsafe in the case that the second string is the shorter of the two.</p> <p>We can still use the range-and-a-half version of <code>std::mismatch()</code>, but we need to first check that the first string is at most as big as the second:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">bool</span> isPrefix <span class="token operator">=</span> prefix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> string<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">mismatch</span><span class="token punctuation">(</span>prefix<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> prefix<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        string<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> string<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first <span class="token operator">==</span> prefix<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>With <code>std::string_view</code>, we can write the direct comparison we want without having to worry about allocation overhead or making copies:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">bool</span> <span class="token function">isPrefix</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string_view prefix<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string_view full<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> prefix <span class="token operator">==</span> full<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> prefix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h2 id="concatenation"><a href="#concatenation" class="header-anchor">#</a> Concatenation</h2> <p>You can concatenate <code>std::string</code>s using the overloaded <code>+</code> and <code>+=</code> operators.
Using the <code>+</code> operator:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string hello <span class="token operator">=</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string world <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string helloworld <span class="token operator">=</span> hello <span class="token operator">+</span> world<span class="token punctuation">;</span> <span class="token comment">// &quot;Helloworld&quot;</span>

</code></pre></div><p>Using the <code>+=</code> operator:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string hello <span class="token operator">=</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string world <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">;</span>
hello <span class="token operator">+=</span> world<span class="token punctuation">;</span> <span class="token comment">// &quot;Helloworld&quot;</span>

</code></pre></div><p>You can also append C strings, including string literals:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string hello <span class="token operator">=</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string world <span class="token operator">=</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>comma <span class="token operator">=</span> <span class="token string">&quot;, &quot;</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string newhelloworld <span class="token operator">=</span> hello <span class="token operator">+</span> comma <span class="token operator">+</span> world <span class="token operator">+</span> <span class="token string">&quot;!&quot;</span><span class="token punctuation">;</span> <span class="token comment">// &quot;Hello, world!&quot;</span>

</code></pre></div><p>You can also use <code>push_back()</code> to push back individual <code>char</code>s:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string s <span class="token operator">=</span> <span class="token string">&quot;a, b, &quot;</span><span class="token punctuation">;</span>
s<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;a, b, c&quot;</span>

</code></pre></div><p>There is also <code>append()</code>, which is pretty much like <code>+=</code>:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string app <span class="token operator">=</span> <span class="token string">&quot;test and &quot;</span><span class="token punctuation">;</span>
app<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">&quot;test&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;test and test&quot;</span>

</code></pre></div><h2 id="conversion-to-integers-floating-point-types"><a href="#conversion-to-integers-floating-point-types" class="header-anchor">#</a> Conversion to integers/floating point types</h2> <p>A <code>std::string</code> containing a number can be converted into an integer type, or a floating point type, using conversion functions.</p> <p><strong><strong>Note that</strong></strong> all of these functions stop parsing the input string as soon as they encounter a non-numeric character, so <code>&quot;123abc&quot;</code> will be converted into <code>123</code>.</p> <p>The <code>std::ato*</code> family of functions converts C-style strings (character arrays) to integer or floating-point types:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string ten <span class="token operator">=</span> <span class="token string">&quot;10&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">double</span> num1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">atof</span><span class="token punctuation">(</span>ten<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> num2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">atoi</span><span class="token punctuation">(</span>ten<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">long</span> num3 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">atol</span><span class="token punctuation">(</span>ten<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">long</span> <span class="token keyword">long</span> num4 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">atoll</span><span class="token punctuation">(</span>ten<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>However, use of these functions is discouraged because they return <code>0</code> if they fail to parse the string. This is bad because <code>0</code> could also be a valid result, if for example the input string was &quot;0&quot;, so it is impossible to determine if the conversion actually failed.</p> <p>The newer <code>std::sto*</code> family of functions convert <code>std::string</code>s to integer or floating-point types, and throw exceptions if they could not parse their input. <strong>You should use these functions if possible</strong>:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string ten <span class="token operator">=</span> <span class="token string">&quot;10&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> num1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">stoi</span><span class="token punctuation">(</span>ten<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">long</span> num2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">stol</span><span class="token punctuation">(</span>ten<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">long</span> <span class="token keyword">long</span> num3 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">stoll</span><span class="token punctuation">(</span>ten<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">float</span> num4 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">stof</span><span class="token punctuation">(</span>ten<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> num5 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">stod</span><span class="token punctuation">(</span>ten<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">long</span> <span class="token keyword">double</span> num6 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">stold</span><span class="token punctuation">(</span>ten<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>Furthermore, these functions also handle octal and hex strings unlike the <code>std::ato*</code> family. The second parameter is a pointer to the first unconverted character in the input string (not illustrated here), and the third parameter is the base to use. <code>0</code> is automatic detection of octal (starting with <code>0</code>) and hex (starting with <code>0x</code> or <code>0X</code>), and any other value is the base to use</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string ten <span class="token operator">=</span> <span class="token string">&quot;10&quot;</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string ten_octal <span class="token operator">=</span> <span class="token string">&quot;12&quot;</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string ten_hex <span class="token operator">=</span> <span class="token string">&quot;0xA&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> num1 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">stoi</span><span class="token punctuation">(</span>ten<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Returns 2</span>
<span class="token keyword">int</span> num2 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">stoi</span><span class="token punctuation">(</span>ten_octal<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Returns 10</span>
<span class="token keyword">long</span> num3 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">stol</span><span class="token punctuation">(</span>ten_hex<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Returns 10</span>
<span class="token keyword">long</span> num4 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">stol</span><span class="token punctuation">(</span>ten_hex<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Returns 0</span>
<span class="token keyword">long</span> num5 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">stol</span><span class="token punctuation">(</span>ten_hex<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Returns 10 as it detects the leading 0x</span>

</code></pre></div><h2 id="converting-between-character-encodings"><a href="#converting-between-character-encodings" class="header-anchor">#</a> Converting between character encodings</h2> <p>Converting between encodings is easy with C++11 and most compilers are able to deal with it in a cross-platform manner through <code>&lt;codecvt&gt;</code> and <code>&lt;locale&gt;</code> headers.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;codecvt&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;locale&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// converts between wstring and utf8 string</span>
    wstring_convert<span class="token operator">&lt;</span>codecvt_utf8_utf16<span class="token operator">&lt;</span><span class="token keyword">wchar_t</span><span class="token operator">&gt;&gt;</span> wchar_to_utf8<span class="token punctuation">;</span>
    <span class="token comment">// converts between u16string and utf8 string</span>
    wstring_convert<span class="token operator">&lt;</span>codecvt_utf8_utf16<span class="token operator">&lt;</span><span class="token keyword">char16_t</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token keyword">char16_t</span><span class="token operator">&gt;</span> utf16_to_utf8<span class="token punctuation">;</span>
    
    wstring wstr <span class="token operator">=</span> L<span class="token string">&quot;foobar&quot;</span><span class="token punctuation">;</span>
    string utf8str <span class="token operator">=</span> wchar_to_utf8<span class="token punctuation">.</span><span class="token function">to_bytes</span><span class="token punctuation">(</span>wstr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    wstring wstr2 <span class="token operator">=</span> wchar_to_utf8<span class="token punctuation">.</span><span class="token function">from_bytes</span><span class="token punctuation">(</span>utf8str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    wcout <span class="token operator">&lt;&lt;</span> wstr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> utf8str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    wcout <span class="token operator">&lt;&lt;</span> wstr2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    
    u16string u16str <span class="token operator">=</span> u<span class="token string">&quot;foobar&quot;</span><span class="token punctuation">;</span>
    string utf8str2 <span class="token operator">=</span> utf16_to_utf8<span class="token punctuation">.</span><span class="token function">to_bytes</span><span class="token punctuation">(</span>u16str<span class="token punctuation">)</span><span class="token punctuation">;</span>
    u16string u16str2 <span class="token operator">=</span> utf16_to_utf8<span class="token punctuation">.</span><span class="token function">from_bytes</span><span class="token punctuation">(</span>utf8str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>Mind that Visual Studio 2015 provides supports for these conversion but a <a href="https://social.msdn.microsoft.com/Forums/vstudio/en-US/8f40dcd8-c67f-4eba-9134-a19b9178e481/vs-2015-rc-linker-stdcodecvt-error?forum=vcgeneral" target="_blank" rel="noopener noreferrer">bug<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> in their library implementation requires to use a different template for <code>wstring_convert</code> when dealing with <code>char16_t</code>:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">using</span> utf16_char <span class="token operator">=</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token punctuation">;</span>
wstring_convert<span class="token operator">&lt;</span>codecvt_utf8_utf16<span class="token operator">&lt;</span>utf16_char<span class="token operator">&gt;</span><span class="token punctuation">,</span> utf16_char<span class="token operator">&gt;</span> conv_utf8_utf16<span class="token punctuation">;</span>

<span class="token keyword">void</span> strings<span class="token double-colon punctuation">::</span><span class="token function">utf16_to_utf8</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>u16string<span class="token operator">&amp;</span> utf16<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> utf8<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>basic_string<span class="token operator">&lt;</span>utf16_char<span class="token operator">&gt;</span> tmp<span class="token punctuation">;</span>
  tmp<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>utf16<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span><span class="token function">copy</span><span class="token punctuation">(</span>utf16<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> utf16<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> tmp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  utf8 <span class="token operator">=</span> conv_utf8_utf16<span class="token punctuation">.</span><span class="token function">to_bytes</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> strings<span class="token double-colon punctuation">::</span><span class="token function">utf8_to_utf16</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> utf8<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>u16string<span class="token operator">&amp;</span> utf16<span class="token punctuation">)</span>
<span class="token punctuation">{</span> 
  std<span class="token double-colon punctuation">::</span>basic_string<span class="token operator">&lt;</span>utf16_char<span class="token operator">&gt;</span> tmp <span class="token operator">=</span> conv_utf8_utf16<span class="token punctuation">.</span><span class="token function">from_bytes</span><span class="token punctuation">(</span>utf8<span class="token punctuation">)</span><span class="token punctuation">;</span>
  utf16<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  utf16<span class="token punctuation">.</span><span class="token function">resize</span><span class="token punctuation">(</span>tmp<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span><span class="token function">copy</span><span class="token punctuation">(</span>tmp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> tmp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> utf16<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h2 id="finding-character-s-in-a-string"><a href="#finding-character-s-in-a-string" class="header-anchor">#</a> Finding character(s) in a string</h2> <p>To find a character or another string, you can use <a href="http://en.cppreference.com/w/cpp/string/basic_string/find" target="_blank" rel="noopener noreferrer"><code>std::string::find</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>. It returns the position of the first character of the first match. If no matches were found, the function returns <a href="http://en.cppreference.com/w/cpp/string/basic_string/npos" target="_blank" rel="noopener noreferrer"><code>std::string::npos</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string str <span class="token operator">=</span> <span class="token string">&quot;Curiosity killed the cat&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> it <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">&quot;cat&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> std<span class="token double-colon punctuation">::</span>string<span class="token double-colon punctuation">::</span>npos<span class="token punctuation">)</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Found at position: &quot;</span> <span class="token operator">&lt;&lt;</span> it <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>
<span class="token keyword">else</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Not found!\n&quot;</span><span class="token punctuation">;</span>

</code></pre></div><blockquote></blockquote> <p>Found at position: 21</p> <p>The search opportunities are further expanded by the following functions:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>find_first_of     <span class="token comment">// Find first occurrence of characters </span>
find_first_not_of <span class="token comment">// Find first absence of characters </span>
find_last_of      <span class="token comment">// Find last occurrence of characters </span>
find_last_not_of  <span class="token comment">// Find last absence of characters </span>

</code></pre></div><p>These functions can allow you to search for characters from the end of the string, as well as find the negative case (ie. characters that are not in the string). Here is an example:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string str <span class="token operator">=</span> <span class="token string">&quot;dog dog cat cat&quot;</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;Found at position: &quot;</span> <span class="token operator">&lt;&lt;</span> str<span class="token punctuation">.</span><span class="token function">find_last_of</span><span class="token punctuation">(</span><span class="token string">&quot;gzx&quot;</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'\n'</span><span class="token punctuation">;</span>

</code></pre></div><blockquote></blockquote> <p>Found at position: 6</p> <p><strong><strong>Note:</strong></strong> Be aware that the above functions do not search for substrings, but rather for characters contained in the search string. In this case, the last occurrence of <code>'g'</code> was found at position <code>6</code> (the other characters weren't found).</p> <h4 id="syntax"><a href="#syntax" class="header-anchor">#</a> Syntax</h4> <li>
**// Empty string declaration**
std::string s;
</li> <li>
**// Constructing from const  char* (c-string)**
std::string s(&quot;Hello&quot;);
std::string s = &quot;Hello&quot;;
</li> <li>
**// Constructing using copy constructor**
std::string s1(&quot;Hello&quot;);
std::string s2(s1);
</li> <li>
**// Constructing from substring**
std::string s1(&quot;Hello&quot;);
std::string s2(s1, 0, 4); **// Copy 4 characters from position 0 of s1 into s2**
</li> <li>
**// Constructing from a buffer of characters**
<p>std::string s1(&quot;Hello World&quot;);<br>
std::string s2(s1, 5); **// Copy first 5  characters of s1 into s2**</p></li> <li>
**// Construct using fill constructor (char only)**
std::string s(5, 'a'); **// s contains aaaaa**
</li> <li>
**// Construct using range constructor and iterator**
std::string s1(&quot;Hello World&quot;);
std::string s2(s1.begin(), s1.begin()+5); **// Copy first 5 characters of s1 into s2**
</li> <h4 id="remarks"><a href="#remarks" class="header-anchor">#</a> Remarks</h4> <p>Before using <code>std::string</code>, you should include the header <code>string</code>, as it includes functions/operators/overloads that other headers (for example <code>iostream</code>) do not include.</p> <p>Using const char* constructor with a nullptr leads to undefined behavior.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code>std<span class="token double-colon punctuation">::</span>string <span class="token function">oops</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> oops <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;\n&quot;</span><span class="token punctuation">;</span>

</code></pre></div><p>The method <code>at</code> throws an <code>std::out_of_range</code> exception if <code>index &gt;= size()</code>.</p> <p>The behavior of <code>operator[]</code> is a bit more complicated, in all cases it has undefined behavior if <code>index &gt; size()</code>, but when <code>index == size()</code>:</p> <ol><li><p>On a non-const string, the behavior is <strong>undefined</strong>;</p></li> <li><p>On a const string, a reference to a character with value <code>CharT()</code> (the <strong>null</strong> character) is returned.</p></li> <li><p>A reference to a character with value <code>CharT()</code> (the <strong>null</strong> character) is returned.</p></li> <li><p>Modifying this reference is <strong>undefined behavior</strong>.</p></li></ol> <p>Since C++14, instead of using <code>&quot;foo&quot;</code>, it is recommended to use <code>&quot;foo&quot;s</code>, as <code>s</code> is a <a href="http://stackoverflow.com/documentation/c%2b%2b/2745/user-defined-literals" target="_blank" rel="noopener noreferrer">user-defined literal suffix<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>, which converts the <code>const char*</code> <code>&quot;foo&quot;</code> to <code>std::string</code> <code>&quot;foo&quot;</code>.</p> <p><em>Note: you have to use the namespace <code>std::string_literals</code> or <code>std::literals</code> to get the literal <code>s</code>.</em></p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/devtut/generate/edit/master/docs/cpp/std-string.md" target="_blank" rel="noopener noreferrer">Edit this page on GitHub</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/cpp/using-declaration.html" class="prev">
        Using declaration
      </a></span> <span class="next"><a href="/cpp/std-array.html">
        std::array
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.1779e102.js" defer></script><script src="/assets/js/3.2cfa8016.js" defer></script><script src="/assets/js/728.94442c29.js" defer></script>
  </body>
</html>
