<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C++ | SFINAE (Substitution Failure Is Not An Error)</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="description" content="What is SFINAE, void_t, enable_if, is_detected, Overload resolution with a large number of options, trailing decltype in function templates, enable_if_all / enable_if_any">
    <meta property="og:site_name" content="DevTut">
    <meta property="og:title" content="C++ | SFINAE (Substitution Failure Is Not An Error)">
    <meta property="og:description" content="What is SFINAE, void_t, enable_if, is_detected, Overload resolution with a large number of options, trailing decltype in function templates, enable_if_all / enable_if_any">
    <meta property="og:type" content="article">
    <meta property="og:url" content="/cpp/sfinae-substitution-failure-is-not-an-error.html">
    <meta property="og:image" content="/logo.png">
    <meta name="twitter:title" content="C++ | SFINAE (Substitution Failure Is Not An Error)">
    <meta name="twitter:description" content="What is SFINAE, void_t, enable_if, is_detected, Overload resolution with a large number of options, trailing decltype in function templates, enable_if_all / enable_if_any">
    <meta name="twitter:url" content="/cpp/sfinae-substitution-failure-is-not-an-error.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="/logo.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/mstile-150x150.png">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="google-site-verification" content="76_rKXgwMVIjd-axJC_1zPV9OS4mEjvtgjYOWVkAdnQ">
    
    <link rel="preload" href="/assets/css/0.styles.60619e34.css" as="style"><link rel="preload" href="/assets/js/app.1779e102.js" as="script"><link rel="preload" href="/assets/js/3.2cfa8016.js" as="script"><link rel="preload" href="/assets/js/709.8e0ff1ba.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.60619e34.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">DevTut</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>C++</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/cpp/" aria-current="page" class="sidebar-link">Disclaimer</a></li><li><a href="/cpp/getting-started-with-cpp.html" class="sidebar-link">Getting started with C++</a></li><li><a href="/cpp/literals.html" class="sidebar-link">Literals</a></li><li><a href="/cpp/operator-precedence.html" class="sidebar-link">operator precedence</a></li><li><a href="/cpp/floating-point-arithmetic.html" class="sidebar-link">Floating Point Arithmetic</a></li><li><a href="/cpp/bit-operators.html" class="sidebar-link">Bit Operators</a></li><li><a href="/cpp/bit-manipulation.html" class="sidebar-link">Bit Manipulation</a></li><li><a href="/cpp/bit-fields.html" class="sidebar-link">Bit fields</a></li><li><a href="/cpp/arrays.html" class="sidebar-link">Arrays</a></li><li><a href="/cpp/iterators.html" class="sidebar-link">Iterators</a></li><li><a href="/cpp/basic-input-output-in-c.html" class="sidebar-link">Basic input/output in c++</a></li><li><a href="/cpp/loops.html" class="sidebar-link">Loops</a></li><li><a href="/cpp/file-i-o.html" class="sidebar-link">File I/O</a></li><li><a href="/cpp/cpp-streams.html" class="sidebar-link">C++ Streams</a></li><li><a href="/cpp/stream-manipulators.html" class="sidebar-link">Stream manipulators</a></li><li><a href="/cpp/flow-control.html" class="sidebar-link">Flow Control</a></li><li><a href="/cpp/metaprogramming.html" class="sidebar-link">Metaprogramming</a></li><li><a href="/cpp/const-keyword.html" class="sidebar-link">const keyword</a></li><li><a href="/cpp/mutable-keyword.html" class="sidebar-link">mutable keyword</a></li><li><a href="/cpp/friend-keyword.html" class="sidebar-link">Friend keyword</a></li><li><a href="/cpp/type-keywords.html" class="sidebar-link">Type Keywords</a></li><li><a href="/cpp/basic-type-keywords.html" class="sidebar-link">Basic Type Keywords</a></li><li><a href="/cpp/variable-declaration-keywords.html" class="sidebar-link">Variable Declaration Keywords</a></li><li><a href="/cpp/keywords.html" class="sidebar-link">Keywords</a></li><li><a href="/cpp/returning-several-values-from-a-function.html" class="sidebar-link">Returning several values from a function</a></li><li><a href="/cpp/polymorphism.html" class="sidebar-link">Polymorphism</a></li><li><a href="/cpp/references.html" class="sidebar-link">References</a></li><li><a href="/cpp/value-and-reference-semantics.html" class="sidebar-link">Value and Reference Semantics</a></li><li><a href="/cpp/c-function-call-by-value-vs-call-by-reference.html" class="sidebar-link">C++ function &quot;call by value&quot; vs. &quot;call by reference&quot;</a></li><li><a href="/cpp/copying-vs-assignment.html" class="sidebar-link">Copying vs Assignment</a></li><li><a href="/cpp/pointers.html" class="sidebar-link">Pointers</a></li><li><a href="/cpp/pointers-to-members.html" class="sidebar-link">Pointers to members</a></li><li><a href="/cpp/the-this-pointer.html" class="sidebar-link">The This Pointer</a></li><li><a href="/cpp/smart-pointers.html" class="sidebar-link">Smart Pointers</a></li><li><a href="/cpp/classes-structures.html" class="sidebar-link">Classes/Structures</a></li><li><a href="/cpp/function-overloading.html" class="sidebar-link">Function Overloading</a></li><li><a href="/cpp/operator-overloading.html" class="sidebar-link">Operator Overloading</a></li><li><a href="/cpp/function-template-overloading.html" class="sidebar-link">Function Template Overloading</a></li><li><a href="/cpp/virtual-member-functions.html" class="sidebar-link">Virtual Member Functions</a></li><li><a href="/cpp/inline-functions.html" class="sidebar-link">Inline functions</a></li><li><a href="/cpp/special-member-functions.html" class="sidebar-link">Special Member Functions</a></li><li><a href="/cpp/non-static-member-functions.html" class="sidebar-link">Non-Static Member Functions</a></li><li><a href="/cpp/constant-class-member-functions.html" class="sidebar-link">Constant class member functions</a></li><li><a href="/cpp/c-containers.html" class="sidebar-link">C++ Containers</a></li><li><a href="/cpp/namespaces.html" class="sidebar-link">Namespaces</a></li><li><a href="/cpp/header-files.html" class="sidebar-link">Header Files</a></li><li><a href="/cpp/using-declaration.html" class="sidebar-link">Using declaration</a></li><li><a href="/cpp/std-string.html" class="sidebar-link">std::string</a></li><li><a href="/cpp/std-array.html" class="sidebar-link">std::array</a></li><li><a href="/cpp/std-vector.html" class="sidebar-link">std::vector</a></li><li><a href="/cpp/std-map.html" class="sidebar-link">std::map</a></li><li><a href="/cpp/std-optional.html" class="sidebar-link">std::optional</a></li><li><a href="/cpp/std-function-to-wrap-any-element-that-is-callable.html" class="sidebar-link">std::function: To wrap any element that is callable</a></li><li><a href="/cpp/std-forward-list.html" class="sidebar-link">std::forward_list</a></li><li><a href="/cpp/std-pair.html" class="sidebar-link">std::pair</a></li><li><a href="/cpp/std-atomics.html" class="sidebar-link">std::atomics</a></li><li><a href="/cpp/std-variant.html" class="sidebar-link">std::variant</a></li><li><a href="/cpp/std-iomanip.html" class="sidebar-link">std::iomanip</a></li><li><a href="/cpp/std-any.html" class="sidebar-link">std::any</a></li><li><a href="/cpp/std-set-and-std-multiset.html" class="sidebar-link">std::set and std::multiset</a></li><li><a href="/cpp/std-integer-sequence.html" class="sidebar-link">std::integer_sequence</a></li><li><a href="/cpp/using-std-unordered-map.html" class="sidebar-link">Using std::unordered_map</a></li><li><a href="/cpp/standard-library-algorithms.html" class="sidebar-link">Standard Library Algorithms</a></li><li><a href="/cpp/the-iso-c-standard.html" class="sidebar-link">The ISO C++ Standard</a></li><li><a href="/cpp/inline-variables.html" class="sidebar-link">Inline variables</a></li><li><a href="/cpp/random-number-generation.html" class="sidebar-link">Random number generation</a></li><li><a href="/cpp/date-and-time-using-chrono-header.html" class="sidebar-link">Date and time using  header</a></li><li><a href="/cpp/sorting.html" class="sidebar-link">Sorting</a></li><li><a href="/cpp/enumeration.html" class="sidebar-link">Enumeration</a></li><li><a href="/cpp/iteration.html" class="sidebar-link">Iteration</a></li><li><a href="/cpp/regular-expressions.html" class="sidebar-link">Regular expressions</a></li><li><a href="/cpp/implementation-defined-behavior.html" class="sidebar-link">Implementation-defined behavior</a></li><li><a href="/cpp/exceptions.html" class="sidebar-link">Exceptions</a></li><li><a href="/cpp/lambdas.html" class="sidebar-link">Lambdas</a></li><li><a href="/cpp/value-categories.html" class="sidebar-link">Value Categories</a></li><li><a href="/cpp/preprocessor.html" class="sidebar-link">Preprocessor</a></li><li><a href="/cpp/data-structures-in-c.html" class="sidebar-link">Data Structures in C++</a></li><li><a href="/cpp/templates.html" class="sidebar-link">Templates</a></li><li><a href="/cpp/expression-templates.html" class="sidebar-link">Expression templates</a></li><li><a href="/cpp/curiously-recurring-template-pattern-crtp.html" class="sidebar-link">Curiously Recurring Template Pattern (CRTP)</a></li><li><a href="/cpp/threading.html" class="sidebar-link">Threading</a></li><li><a href="/cpp/thread-synchronization-structures.html" class="sidebar-link">Thread synchronization structures</a></li><li><a href="/cpp/the-rule-of-three-five-and-zero.html" class="sidebar-link">The Rule of Three, Five, And Zero</a></li><li><a href="/cpp/raii-resource-acquisition-is-initialization.html" class="sidebar-link">RAII: Resource Acquisition Is Initialization</a></li><li><a href="/cpp/rtti-run-time-type-information.html" class="sidebar-link">RTTI: Run-Time Type Information</a></li><li><a href="/cpp/mutexes.html" class="sidebar-link">Mutexes</a></li><li><a href="/cpp/recursive-mutex.html" class="sidebar-link">Recursive Mutex</a></li><li><a href="/cpp/semaphore.html" class="sidebar-link">Semaphore</a></li><li><a href="/cpp/futures-and-promises.html" class="sidebar-link">Futures and Promises</a></li><li><a href="/cpp/atomic-types.html" class="sidebar-link">Atomic Types</a></li><li><a href="/cpp/type-erasure.html" class="sidebar-link">Type Erasure</a></li><li><a href="/cpp/explicit-type-conversions.html" class="sidebar-link">Explicit type conversions</a></li><li><a href="/cpp/unnamed-types.html" class="sidebar-link">Unnamed types</a></li><li><a href="/cpp/type-traits.html" class="sidebar-link">Type Traits</a></li><li><a href="/cpp/return-type-covariance.html" class="sidebar-link">Return Type Covariance</a></li><li><a href="/cpp/layout-of-object-types.html" class="sidebar-link">Layout of object types</a></li><li><a href="/cpp/type-inference.html" class="sidebar-link">Type Inference</a></li><li><a href="/cpp/typedef-and-type-aliases.html" class="sidebar-link">Typedef and type aliases</a></li><li><a href="/cpp/type-deduction.html" class="sidebar-link">type deduction</a></li><li><a href="/cpp/trailing-return-type.html" class="sidebar-link">Trailing return type</a></li><li><a href="/cpp/alignment.html" class="sidebar-link">Alignment</a></li><li><a href="/cpp/perfect-forwarding.html" class="sidebar-link">Perfect Forwarding</a></li><li><a href="/cpp/decltype.html" class="sidebar-link">decltype</a></li><li><a href="/cpp/sfinae-substitution-failure-is-not-an-error.html" aria-current="page" class="active sidebar-link">SFINAE (Substitution Failure Is Not An Error)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cpp/sfinae-substitution-failure-is-not-an-error.html#what-is-sfinae" class="sidebar-link">What is SFINAE</a></li><li class="sidebar-sub-header"><a href="/cpp/sfinae-substitution-failure-is-not-an-error.html#void-t" class="sidebar-link">void_t</a></li><li class="sidebar-sub-header"><a href="/cpp/sfinae-substitution-failure-is-not-an-error.html#enable-if" class="sidebar-link">enable_if</a></li><li class="sidebar-sub-header"><a href="/cpp/sfinae-substitution-failure-is-not-an-error.html#is-detected" class="sidebar-link">is_detected</a></li><li class="sidebar-sub-header"><a href="/cpp/sfinae-substitution-failure-is-not-an-error.html#overload-resolution-with-a-large-number-of-options" class="sidebar-link">Overload resolution with a large number of options</a></li><li class="sidebar-sub-header"><a href="/cpp/sfinae-substitution-failure-is-not-an-error.html#trailing-decltype-in-function-templates" class="sidebar-link">trailing decltype in function templates</a></li><li class="sidebar-sub-header"><a href="/cpp/sfinae-substitution-failure-is-not-an-error.html#enable-if-all-enable-if-any" class="sidebar-link">enableifall / enableifany</a></li></ul></li><li><a href="/cpp/undefined-behavior.html" class="sidebar-link">Undefined Behavior</a></li><li><a href="/cpp/overload-resolution.html" class="sidebar-link">Overload resolution</a></li><li><a href="/cpp/move-semantics.html" class="sidebar-link">Move Semantics</a></li><li><a href="/cpp/pimpl-idiom.html" class="sidebar-link">Pimpl Idiom</a></li><li><a href="/cpp/auto.html" class="sidebar-link">auto</a></li><li><a href="/cpp/copy-elision.html" class="sidebar-link">Copy Elision</a></li><li><a href="/cpp/fold-expressions.html" class="sidebar-link">Fold Expressions</a></li><li><a href="/cpp/unions.html" class="sidebar-link">Unions</a></li><li><a href="/cpp/design-pattern-implementation-in-c.html" class="sidebar-link">Design pattern implementation in C++</a></li><li><a href="/cpp/singleton-design-pattern.html" class="sidebar-link">Singleton Design Pattern</a></li><li><a href="/cpp/user-defined-literals.html" class="sidebar-link">User-Defined Literals</a></li><li><a href="/cpp/memory-management.html" class="sidebar-link">Memory management</a></li><li><a href="/cpp/c-11-memory-model.html" class="sidebar-link">C++11 Memory Model</a></li><li><a href="/cpp/scopes.html" class="sidebar-link">Scopes</a></li><li><a href="/cpp/static-assert.html" class="sidebar-link">static_assert</a></li><li><a href="/cpp/constexpr.html" class="sidebar-link">constexpr</a></li><li><a href="/cpp/one-definition-rule-odr.html" class="sidebar-link">One Definition Rule (ODR)</a></li><li><a href="/cpp/unspecified-behavior.html" class="sidebar-link">Unspecified behavior</a></li><li><a href="/cpp/argument-dependent-name-lookup.html" class="sidebar-link">Argument Dependent Name Lookup</a></li><li><a href="/cpp/attributes.html" class="sidebar-link">Attributes</a></li><li><a href="/cpp/recursion-in-c.html" class="sidebar-link">Recursion in C++</a></li><li><a href="/cpp/arithmitic-metaprogramming.html" class="sidebar-link">Arithmitic Metaprogramming</a></li><li><a href="/cpp/callable-objects.html" class="sidebar-link">Callable Objects</a></li><li><a href="/cpp/client-server-examples.html" class="sidebar-link">Client server examples</a></li><li><a href="/cpp/const-correctness.html" class="sidebar-link">Const Correctness</a></li><li><a href="/cpp/parameter-packs.html" class="sidebar-link">Parameter packs</a></li><li><a href="/cpp/build-systems.html" class="sidebar-link">Build Systems</a></li><li><a href="/cpp/concurrency-with-openmp.html" class="sidebar-link">Concurrency With OpenMP</a></li><li><a href="/cpp/resource-management.html" class="sidebar-link">Resource Management</a></li><li><a href="/cpp/storage-class-specifiers.html" class="sidebar-link">Storage class specifiers</a></li><li><a href="/cpp/linkage-specifications.html" class="sidebar-link">Linkage specifications</a></li><li><a href="/cpp/digit-separators.html" class="sidebar-link">Digit separators</a></li><li><a href="/cpp/c-incompatibilities.html" class="sidebar-link">C incompatibilities</a></li><li><a href="/cpp/side-by-side-comparisons-of-classic-c-examples-solved-via-c-vs-c-11-vs-c-14-vs-c-17.html" class="sidebar-link">Side by Side Comparisons of classic C++ examples solved via C++ vs C++11 vs C++14 vs C++17</a></li><li><a href="/cpp/compiling-and-building.html" class="sidebar-link">Compiling and Building</a></li><li><a href="/cpp/common-compile-linker-errors-gcc.html" class="sidebar-link">Common compile/linker errors (GCC)</a></li><li><a href="/cpp/more-undefined-behaviors-in-c.html" class="sidebar-link">More undefined behaviors in C++</a></li><li><a href="/cpp/unit-testing-in-c.html" class="sidebar-link">Unit Testing in C++</a></li><li><a href="/cpp/c-debugging-and-debug-prevention-tools-techniques.html" class="sidebar-link">C++ Debugging and Debug-prevention Tools &amp; Techniques</a></li><li><a href="/cpp/optimization-in-c.html" class="sidebar-link">Optimization in C++</a></li><li><a href="/cpp/optimization.html" class="sidebar-link">Optimization</a></li><li><a href="/cpp/profiling.html" class="sidebar-link">Profiling</a></li><li><a href="/cpp/refactoring-techniques.html" class="sidebar-link">Refactoring Techniques</a></li><li><a href="/cpp/internationalization-in-c.html" class="sidebar-link">Internationalization in C++</a></li><li><a href="/cpp/contributors.html" class="sidebar-link">The Contributors</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="sfinae-substitution-failure-is-not-an-error"><a href="#sfinae-substitution-failure-is-not-an-error" class="header-anchor">#</a> SFINAE (Substitution Failure Is Not An Error)</h1> <h2 id="what-is-sfinae"><a href="#what-is-sfinae" class="header-anchor">#</a> What is SFINAE</h2> <p>SFINAE stands for <strong>S</strong>ubstitution <strong>F</strong>ailure <strong>I</strong>s <strong>N</strong>ot <strong>A</strong>n <strong>E</strong>rror. Ill-formed code that results from substituting types (or values) to instantiate a function template or a class template is <strong>not</strong> a hard compile error, it is only treated as a deduction failure.</p> <p>Deduction failures on instantiating function templates or class template specializations remove that candidate from the set of consideration - as if that failed candidate did not exist to begin with.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">auto</span> <span class="token function">begin</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> c<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> size_t N<span class="token operator">&gt;</span>
T<span class="token operator">*</span> <span class="token function">begin</span><span class="token punctuation">(</span><span class="token function">T</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> arr<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">int</span> vals<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">begin</span><span class="token punctuation">(</span>vals<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK. The first function template substitution fails because</span>
             <span class="token comment">// vals.begin() is ill-formed. This is not an error! That function</span>
             <span class="token comment">// is just removed from consideration as a viable overload candidate,</span>
             <span class="token comment">// leaving us with the array overload. </span>

</code></pre></div><p>Only substitution failures in the <strong>immediate context</strong> are considered deduction failures, all others are considered hard errors.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">add_one</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span> val <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token function">add_one</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>

std<span class="token double-colon punctuation">::</span>string msg <span class="token operator">=</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">;</span>
<span class="token function">add_one</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// error. msg += 1 is ill-formed for std::string, but this</span>
              <span class="token comment">// failure is NOT in the immediate context of substituting T</span>

</code></pre></div><h2 id="void-t"><a href="#void-t" class="header-anchor">#</a> void_t</h2> <p><code>void_t</code> is a meta-function that maps any (number of) types to type <code>void</code>.
The primary purpose of <code>void_t</code> is to facilitate writing of type traits.</p> <p><a href="http://en.cppreference.com/w/cpp/types/void_t" target="_blank" rel="noopener noreferrer"><code>std::void_t</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> will be part of C++17, but until then, it is extremely straightforward to implement:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span> <span class="token keyword">using</span> void_t <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">;</span>

</code></pre></div><p>Some compilers <a href="http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1558" target="_blank" rel="noopener noreferrer">require<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> a slightly different implementation:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">make_void</span> <span class="token punctuation">{</span> <span class="token keyword">using</span> type <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> T<span class="token operator">&gt;</span>
<span class="token keyword">using</span> void_t <span class="token operator">=</span> <span class="token keyword">typename</span> <span class="token class-name">make_void</span><span class="token operator">&lt;</span>T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token punctuation">;</span>

</code></pre></div><p>The primary application of <code>void_t</code> is writing type traits that check validity of a statement. For example, let's check if a type has a member function <code>foo()</code> that takes no arguments:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token keyword">void</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">has_foo</span> <span class="token operator">:</span> <span class="token base-clause">std<span class="token double-colon punctuation">::</span><span class="token class-name">false_type</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">has_foo</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> void_t<span class="token operator">&lt;</span><span class="token keyword">decltype</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">declval</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&gt;&gt;</span> <span class="token operator">:</span> std<span class="token double-colon punctuation">::</span>true_type <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>How does this work? When I try to instantiate <code>has_foo&lt;T&gt;::value</code>, that will cause the compiler to try to look for the best specialization for <code>has_foo&lt;T, void&gt;</code>. We have two options: the primary, and this secondary one which involves having to instantiate that underlying expression:</p> <ul><li>If <code>T</code> <strong>does</strong> have a member function <code>foo()</code>, then whatever type that returns gets converted to <code>void</code>, and the specialization is preferred to the primary  based on the template partial ordering rules. So <code>has_foo&lt;T&gt;::value</code> will be <code>true</code></li> <li>If <code>T</code> <strong>doesn't</strong> have such a member function (or it requires more than one argument), then substitution fails for the specialization and we only have the primary template to fallback on. Hence, <code>has_foo&lt;T&gt;::value</code> is <code>false</code>.</li></ul> <p>A simpler case:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token keyword">void</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">can_reference</span> <span class="token operator">:</span> <span class="token base-clause">std<span class="token double-colon punctuation">::</span><span class="token class-name">false_type</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">can_reference</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>void_t<span class="token operator">&lt;</span>T<span class="token operator">&amp;</span><span class="token operator">&gt;&gt;</span> <span class="token operator">:</span> std<span class="token double-colon punctuation">::</span>true_type <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>this doesn't use <code>std::declval</code> or <code>decltype</code>.</p> <p>You may notice a common pattern of a void argument.  We can factor this out:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">struct</span> <span class="token class-name">details</span> <span class="token punctuation">{</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">Z</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token operator">=</span><span class="token keyword">void</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Ts<span class="token operator">&gt;</span>
  <span class="token keyword">struct</span> <span class="token class-name">can_apply</span><span class="token operator">:</span>
    <span class="token base-clause">std<span class="token double-colon punctuation">::</span><span class="token class-name">false_type</span></span>
  <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">Z</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Ts<span class="token operator">&gt;</span>
  <span class="token keyword">struct</span> <span class="token class-name">can_apply</span><span class="token operator">&lt;</span>Z<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>void_t<span class="token operator">&lt;</span>Z<span class="token operator">&lt;</span>Ts<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">,</span> Ts<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>true_type
  <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token keyword">class</span> <span class="token class-name">Z</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Ts<span class="token operator">&gt;</span>
<span class="token keyword">using</span> can_apply <span class="token operator">=</span> details<span class="token double-colon punctuation">::</span>can_apply<span class="token operator">&lt;</span>Z<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token punctuation">,</span> Ts<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

</code></pre></div><p>which hides the use of <code>std::void_t</code> and makes <code>can_apply</code> act like an indicator whether the type supplied as the first template argument is well-formed after substituting the other types into it. The previous examples may now be rewritten using <code>can_apply</code> as:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">using</span> ref_t <span class="token operator">=</span> T<span class="token operator">&amp;</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">using</span> can_reference <span class="token operator">=</span> can_apply<span class="token operator">&lt;</span>ref_t<span class="token punctuation">,</span> T<span class="token operator">&gt;</span><span class="token punctuation">;</span>    <span class="token comment">// Is T&amp; well formed for T?</span>

</code></pre></div><p>and:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">using</span> dot_foo_r <span class="token operator">=</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">declval</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">using</span> can_dot_foo <span class="token operator">=</span> can_apply<span class="token operator">&lt;</span> dot_foo_r<span class="token punctuation">,</span> T <span class="token operator">&gt;</span><span class="token punctuation">;</span>    <span class="token comment">// Is T.foo() well formed for T?</span>

</code></pre></div><p>which seems simpler than the original versions.</p> <p>There are post-C++17 proposals for <code>std</code> traits similar to <code>can_apply</code>.</p> <p>The utility of <code>void_t</code> was discovered by Walter Brown. He gave a wonderful <a href="https://youtu.be/a0FliKwcwXE?t=1747" target="_blank" rel="noopener noreferrer">presentation<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> on it at CppCon 2016.</p> <h2 id="enable-if"><a href="#enable-if" class="header-anchor">#</a> enable_if</h2> <p><code>std::enable_if</code> is a convenient utility to use boolean conditions to trigger SFINAE. It is defined as:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">bool</span> Cond<span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">Result</span><span class="token operator">=</span><span class="token keyword">void</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">enable_if</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Result</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">enable_if</span><span class="token operator">&lt;</span><span class="token boolean">true</span><span class="token punctuation">,</span> Result<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">using</span> type <span class="token operator">=</span> Result<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><p>That is, <code>enable_if&lt;true, R&gt;::type</code>  is an alias for <code>R</code>, whereas <code>enable_if&lt;false, T&gt;::type</code> is ill-formed as that specialization of <code>enable_if</code> does not have a <code>type</code> member type.</p> <p><code>std::enable_if</code> can be used to constrain templates:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">negate</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">-</span>i<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">F</span><span class="token operator">&gt;</span>
<span class="token keyword">auto</span> <span class="token function">negate</span><span class="token punctuation">(</span>F f<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

</code></pre></div><p>Here, a call to <code>negate(1)</code> would fail due to ambiguity. But the second overload is not intended to be used for integral types, so we can add:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">negate</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">-</span>i<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">F</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token operator">=</span> <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>enable_if<span class="token operator">&lt;</span><span class="token operator">!</span>std<span class="token double-colon punctuation">::</span>is_arithmetic<span class="token operator">&lt;</span>F<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">&gt;</span>
<span class="token keyword">auto</span> <span class="token function">negate</span><span class="token punctuation">(</span>F f<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

</code></pre></div><p>Now, instantiating <code>negate&lt;int&gt;</code> would result in a substitution failure since <code>!std::is_arithmetic&lt;int&gt;::value</code> is <code>false</code>. Due to SFINAE, this is not a hard error, this candidate is simply removed from the overload set. As a result, <code>negate(1)</code> only has one single viable candidate - which is then called.</p> <h3 id="when-to-use-it"><a href="#when-to-use-it" class="header-anchor">#</a> When to use it</h3> <p>It's worth keeping in mind that <code>std::enable_if</code> is a helper <strong>on top</strong> of SFINAE, but it's not what makes SFINAE work in the first place. Let's consider these two alternatives for implementing functionality similar to <code>std::size</code>, i.e. an overload set <code>size(arg)</code> that produces the size of a container or array:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// for containers</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Cont</span><span class="token operator">&gt;</span>
<span class="token keyword">auto</span> <span class="token function">size1</span><span class="token punctuation">(</span>Cont <span class="token keyword">const</span><span class="token operator">&amp;</span> cont<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> cont<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// for arrays</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Elt</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t Size<span class="token operator">&gt;</span>
std<span class="token double-colon punctuation">::</span>size_t <span class="token function">size1</span><span class="token punctuation">(</span>Elt <span class="token keyword">const</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span>Size<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// implementation omitted</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Cont</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">is_sizeable</span><span class="token punctuation">;</span>

<span class="token comment">// for containers</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Cont</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>enable_if_t<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>is_sizeable<span class="token operator">&lt;</span>Cont<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token operator">&gt;</span>
<span class="token keyword">auto</span> <span class="token function">size2</span><span class="token punctuation">(</span>Cont <span class="token keyword">const</span><span class="token operator">&amp;</span> cont<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// for arrays</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Elt</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t Size<span class="token operator">&gt;</span>
std<span class="token double-colon punctuation">::</span>size_t <span class="token function">size2</span><span class="token punctuation">(</span>Elt <span class="token keyword">const</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span>Size<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>Assuming that <code>is_sizeable</code> is written appropriately, these two declarations should be exactly equivalent with respect to SFINAE. Which is the easiest to write, and which is the easiest to review and understand at a glance?</p> <p>Now let's consider how we might want to implement arithmetic helpers that avoid signed integer overflow in favour of wrap around or modular behaviour. Which is to say that e.g. <code>incr(i, 3)</code> would be the same as <code>i += 3</code> save for the fact that the result would always be defined even if <code>i</code> is an <code>int</code> with value <code>INT_MAX</code>. These are two possible alternatives:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// handle signed types</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Int</span><span class="token operator">&gt;</span>
<span class="token keyword">auto</span> <span class="token function">incr1</span><span class="token punctuation">(</span>Int<span class="token operator">&amp;</span> target<span class="token punctuation">,</span> Int amount<span class="token punctuation">)</span>
<span class="token operator">-&gt;</span> std<span class="token double-colon punctuation">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token comment">// handle unsigned types by just doing target += amount</span>
<span class="token comment">// since unsigned arithmetic already behaves as intended</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Int</span><span class="token operator">&gt;</span>
<span class="token keyword">auto</span> <span class="token function">incr1</span><span class="token punctuation">(</span>Int<span class="token operator">&amp;</span> target<span class="token punctuation">,</span> Int amount<span class="token punctuation">)</span>
<span class="token operator">-&gt;</span> std<span class="token double-colon punctuation">::</span>void_t<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
 
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>enable_if_t<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>is_signed<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">incr2</span><span class="token punctuation">(</span>Int<span class="token operator">&amp;</span> target<span class="token punctuation">,</span> Int amount<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Int</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>enable_if_t<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>is_unsigned<span class="token operator">&lt;</span>Int<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">incr2</span><span class="token punctuation">(</span>Int<span class="token operator">&amp;</span> target<span class="token punctuation">,</span> Int amount<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>Once again which is the easiest to write, and which is the easiest to review and understand at a glance?</p> <p>A strength of <code>std::enable_if</code> is how it plays with refactoring and API design. If <code>is_sizeable&lt;Cont&gt;::value</code> is meant to reflect whether <code>cont.size()</code> is valid then just using the expression as it appears for <code>size1</code> can be more concise, although that could depend on whether <code>is_sizeable</code> would be used in several places or not. Contrast that with <code>std::is_signed</code> which reflects its intention much more clearly than when its implementation leaks into the declaration of <code>incr1</code>.</p> <h2 id="is-detected"><a href="#is-detected" class="header-anchor">#</a> is_detected</h2> <p>To generalize type_trait creation:based on SFINAE
there are experimental traits <code>detected_or</code>, <code>detected_t</code>, <code>is_detected</code>.</p> <p>With template parameters <code>typename Default</code>, <code>template &lt;typename...&gt; Op</code> and <code>typename ... Args</code>:</p> <ul><li><code>is_detected</code>: alias of <code>std::true_type</code> or <code>std::false_type</code> depending of the validity of <code>Op&lt;Args...&gt;</code></li> <li><code>detected_t</code>: alias of <code>Op&lt;Args...&gt;</code> or <code>nonesuch</code> depending of validity of <code>Op&lt;Args...&gt;</code>.</li> <li><code>detected_or</code>: alias of a struct with <code>value_t</code> which is <code>is_detected</code>, and <code>type</code> which is <code>Op&lt;Args...&gt;</code> or <code>Default</code> depending of validity of <code>Op&lt;Args...&gt;</code></li></ul> <p>which can be implemented using <code>std::void_t</code> for SFINAE as following:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">namespace</span> detail <span class="token punctuation">{</span>
    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Default</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">AlwaysVoid</span><span class="token punctuation">,</span>
              <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">Op</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">&gt;</span>
    <span class="token keyword">struct</span> <span class="token class-name">detector</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">using</span> value_t <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>false_type<span class="token punctuation">;</span>
        <span class="token keyword">using</span> type <span class="token operator">=</span> Default<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Default</span><span class="token punctuation">,</span> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">Op</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">&gt;</span>
    <span class="token keyword">struct</span> <span class="token class-name">detector</span><span class="token operator">&lt;</span>Default<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>void_t<span class="token operator">&lt;</span>Op<span class="token operator">&lt;</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">,</span> Op<span class="token punctuation">,</span> Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">using</span> value_t <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>true_type<span class="token punctuation">;</span>
        <span class="token keyword">using</span> type <span class="token operator">=</span> Op<span class="token operator">&lt;</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span> <span class="token comment">// namespace detail</span>

<span class="token comment">// special type to indicate detection failure</span>
<span class="token keyword">struct</span> <span class="token class-name">nonesuch</span> <span class="token punctuation">{</span>
    <span class="token function">nonesuch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    <span class="token operator">~</span><span class="token function">nonesuch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    <span class="token function">nonesuch</span><span class="token punctuation">(</span>nonesuch <span class="token keyword">const</span><span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>nonesuch <span class="token keyword">const</span><span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">Op</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">&gt;</span>
<span class="token keyword">using</span> is_detected <span class="token operator">=</span>
    <span class="token keyword">typename</span> <span class="token class-name">detail</span><span class="token double-colon punctuation">::</span>detector<span class="token operator">&lt;</span>nonesuch<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token punctuation">,</span> Op<span class="token punctuation">,</span> Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value_t<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">Op</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">&gt;</span>
<span class="token keyword">using</span> detected_t <span class="token operator">=</span> <span class="token keyword">typename</span> <span class="token class-name">detail</span><span class="token double-colon punctuation">::</span>detector<span class="token operator">&lt;</span>nonesuch<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token punctuation">,</span> Op<span class="token punctuation">,</span> Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Default</span><span class="token punctuation">,</span> <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">Op</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args<span class="token operator">&gt;</span>
<span class="token keyword">using</span> detected_or <span class="token operator">=</span> detail<span class="token double-colon punctuation">::</span>detector<span class="token operator">&lt;</span>Default<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token punctuation">,</span> Op<span class="token punctuation">,</span> Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

</code></pre></div><p>Traits to detect presence of method can then be simply implemented:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">typename</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Ts<span class="token operator">&gt;</span>
<span class="token keyword">using</span> foo_type <span class="token operator">=</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">declval</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">declval</span><span class="token generic class-name"><span class="token operator">&lt;</span>Ts<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">C1</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">C2</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">using</span> has_foo_char <span class="token operator">=</span> is_detected<span class="token operator">&lt;</span>foo_type<span class="token punctuation">,</span> T<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token keyword">static_assert</span><span class="token punctuation">(</span><span class="token operator">!</span>has_foo_char<span class="token operator">&lt;</span>C1<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">,</span> <span class="token string">&quot;Unexpected&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">static_assert</span><span class="token punctuation">(</span>has_foo_char<span class="token operator">&lt;</span>C2<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">,</span> <span class="token string">&quot;Unexpected&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">static_assert</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>is_same<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> detected_t<span class="token operator">&lt;</span>foo_type<span class="token punctuation">,</span> C2<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&gt;&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">,</span>
              <span class="token string">&quot;Unexpected&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">static_assert</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>is_same<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">,</span> <span class="token comment">// Default</span>
                           detected_or<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">,</span> foo_type<span class="token punctuation">,</span> C1<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&gt;&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">,</span>
              <span class="token string">&quot;Unexpected&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">static_assert</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>is_same<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> detected_or<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">,</span> foo_type<span class="token punctuation">,</span> C2<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&gt;&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">,</span>
              <span class="token string">&quot;Unexpected&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><h2 id="overload-resolution-with-a-large-number-of-options"><a href="#overload-resolution-with-a-large-number-of-options" class="header-anchor">#</a> Overload resolution with a large number of options</h2> <p>If you need to select between several options,
enabling just one via <code>enable_if&lt;&gt;</code> can be quite cumbersome,
since several conditions needs to be negated too.</p> <p>The ordering between overloads can instead be selected using
inheritance, i.e. tag dispatch.</p> <p>Instead of testing for the thing that needs to be well-formed, and also
testing the negation of all the other versions conditions, we instead test
just for what we need, preferably in a <code>decltype</code> in a trailing return. <br>
This might leave several option well formed, we differentiate between those
using 'tags', similar to iterator-trait tags (<code>random_access_tag</code> et al).
This works because a direct match is better that a base class, which is better
that a base class of a base class, etc.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;algorithm&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iterator&gt;</span></span>

<span class="token keyword">namespace</span> detail
<span class="token punctuation">{</span>
    <span class="token comment">// this gives us infinite types, that inherit from each other</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>size_t N<span class="token operator">&gt;</span>
    <span class="token keyword">struct</span> <span class="token class-name">pick</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">pick</span><span class="token operator">&lt;</span><span class="token class-name">N</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>
    <span class="token keyword">struct</span> <span class="token class-name">pick</span><span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">// the overload we want to be preferred have a higher N in pick&lt;N&gt;</span>
    <span class="token comment">// this is the first helper template function</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
    <span class="token keyword">auto</span> <span class="token function">stable_sort</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> t<span class="token punctuation">,</span> pick<span class="token operator">&lt;</span><span class="token number">2</span><span class="token operator">&gt;</span><span class="token punctuation">)</span>
        <span class="token operator">-&gt;</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> t<span class="token punctuation">.</span><span class="token function">stable_sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// if the container have a member stable_sort, use that</span>
        t<span class="token punctuation">.</span><span class="token function">stable_sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// this helper will be second best match</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
    <span class="token keyword">auto</span> <span class="token function">stable_sort</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> t<span class="token punctuation">,</span> pick<span class="token operator">&lt;</span><span class="token number">1</span><span class="token operator">&gt;</span><span class="token punctuation">)</span>
        <span class="token operator">-&gt;</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> t<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// if the container have a member sort, but no member stable_sort</span>
        <span class="token comment">// it's customary that the sort member is stable</span>
        t<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// this helper will be picked last</span>
    <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
    <span class="token keyword">auto</span> <span class="token function">stable_sort</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> t<span class="token punctuation">,</span> pick<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">&gt;</span><span class="token punctuation">)</span>
        <span class="token operator">-&gt;</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span><span class="token function">stable_sort</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">begin</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">end</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// the container have neither a member sort, nor member stable_sort</span>
        std<span class="token double-colon punctuation">::</span><span class="token function">stable_sort</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">begin</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">end</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>

<span class="token comment">// this is the function the user calls. it will dispatch the call</span>
<span class="token comment">// to the correct implementation with the help of 'tags'.</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">stable_sort</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// use an N that is higher that any used above.</span>
    <span class="token comment">// this will pick the highest overload that is well formed.</span>
    detail<span class="token double-colon punctuation">::</span><span class="token function">stable_sort</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> detail<span class="token double-colon punctuation">::</span>pick<span class="token operator">&lt;</span><span class="token number">10</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>There are other methods commonly used to differentiate between overloads,
such as exact match being better than conversion, being better than ellipsis.</p> <p>However, tag-dispatch can extend to any number of choices, and is a bit more clear in intent.</p> <h2 id="trailing-decltype-in-function-templates"><a href="#trailing-decltype-in-function-templates" class="header-anchor">#</a> trailing decltype in function templates</h2> <p>One of constraining function is to use trailing <code>decltype</code> to specify the return type:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">namespace</span> details <span class="token punctuation">{</span>
   <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>to_string<span class="token punctuation">;</span>

   <span class="token comment">// this one is constrained on being able to call to_string(T)</span>
   <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
   <span class="token keyword">auto</span> <span class="token function">convert_to_string</span><span class="token punctuation">(</span>T <span class="token keyword">const</span><span class="token operator">&amp;</span> val<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token punctuation">)</span>
       <span class="token operator">-&gt;</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">to_string</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token punctuation">{</span>
       <span class="token keyword">return</span> <span class="token function">to_string</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// this one is unconstrained, but less preferred due to the ellipsis argument</span>
   <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
   std<span class="token double-colon punctuation">::</span>string <span class="token function">convert_to_string</span><span class="token punctuation">(</span>T <span class="token keyword">const</span><span class="token operator">&amp;</span> val<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span>
   <span class="token punctuation">{</span>
       std<span class="token double-colon punctuation">::</span>ostringstream oss<span class="token punctuation">;</span>
       oss <span class="token operator">&lt;&lt;</span> val<span class="token punctuation">;</span>
       <span class="token keyword">return</span> oss<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
std<span class="token double-colon punctuation">::</span>string <span class="token function">convert_to_string</span><span class="token punctuation">(</span>T <span class="token keyword">const</span><span class="token operator">&amp;</span> val<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">return</span> details<span class="token double-colon punctuation">::</span><span class="token function">convert_to_string</span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>If I call <code>convert_to_string()</code> with an argument with which I can invoke <code>to_string()</code>, then I have two viable functions for <code>details::convert_to_string()</code>. The first is preferred since the conversion from <code>0</code> to <code>int</code> is a better implicit conversion sequence than the conversion from <code>0</code> to <code>...</code></p> <p>If I call <code>convert_to_string()</code> with an argument from which I cannot invoke <code>to_string()</code>, then the first function template instantiation leads to substitution failure (there is no <code>decltype(to_string(val))</code>). As a result, that candidate is removed from the overload set. The second function template is unconstrained, so it is selected and we instead go through <code>operator&lt;&lt;(std::ostream&amp;, T)</code>. If that one is undefined, then we have a hard compile error with a template stack on the line <code>oss &lt;&lt; val</code>.</p> <h2 id="enable-if-all-enable-if-any"><a href="#enable-if-all-enable-if-any" class="header-anchor">#</a> enable_if_all / enable_if_any</h2> <p><strong>Motivational example</strong></p> <p>When you have a variadic template pack in the template parameters list, like in the following code snippet:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">&gt;</span> <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>Args <span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//... };</span>

</code></pre></div><p>The standard library (prior to C++17) offers no direct way to write <strong>enable_if</strong> to impose SFINAE constraints on <strong><strong>all of the parameters</strong></strong> in <code>Args</code> or <strong><strong>any of the parameters</strong></strong> in <code>Args</code>. C++17 offers <a href="http://en.cppreference.com/w/cpp/types/conjunction" target="_blank" rel="noopener noreferrer"><code>std::conjunction</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> and <a href="http://en.cppreference.com/w/cpp/types/disjunction" target="_blank" rel="noopener noreferrer"><code>std::disjunction</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> which solve this problem. For example:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">/// C++17: SFINAE constraints on all of the parameters in Args.</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token punctuation">,</span>
         std<span class="token double-colon punctuation">::</span>enable_if_t<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>conjunction_v<span class="token operator">&lt;</span>custom_conditions_v<span class="token operator">&lt;</span>Args<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;&gt;</span><span class="token operator">*</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>Args <span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//... };</span>

<span class="token comment">/// C++17: SFINAE constraints on any of the parameters in Args.</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token punctuation">,</span>
         std<span class="token double-colon punctuation">::</span>enable_if_t<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>disjunction_v<span class="token operator">&lt;</span>custom_conditions_v<span class="token operator">&lt;</span>Args<span class="token operator">&gt;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;&gt;</span><span class="token operator">*</span> <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span>Args <span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//... };</span>

</code></pre></div><p>If you do not have C++17 available, there are several solutions to achieve these. One of them is to use a base-case class and <strong>partial specializations</strong>, as demonstrated in answers of this <a href="http://stackoverflow.com/questions/26421104/how-do-i-enable-if-a-class-with-variadic-template-arguments" target="_blank" rel="noopener noreferrer">question<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <p>Alternatively, one may also implement by hand the behavior of <code>std::conjunction</code> and <code>std::disjunction</code> in a rather straight-forward way. In the following example I'll demonstrate the implementations and combine them with <code>std::enable_if</code> to produce two alias: <code>enable_if_all</code> and <code>enable_if_any</code>, which do exactly what they are supposed to semantically. This may provide a more scalable solution.</p> <p><strong>Implementation of</strong> <code>enable_if_all</code> <strong>and</strong> <code>enable_if_any</code></p> <p>First let's emulate <code>std::conjunction</code> and <code>std::disjunction</code> using customized <code>seq_and</code> and <code>seq_or</code> respectively:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">/// Helper for prior to C++14.</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">bool</span> B<span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">F</span> <span class="token operator">&gt;</span>
<span class="token keyword">using</span> conditional_t <span class="token operator">=</span> <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>conditional<span class="token operator">&lt;</span>B<span class="token punctuation">,</span>T<span class="token punctuation">,</span>F<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token punctuation">;</span>

<span class="token comment">/// Emulate C++17 std::conjunction.</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">seq_or</span><span class="token operator">:</span> <span class="token base-clause">std<span class="token double-colon punctuation">::</span><span class="token class-name">false_type</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span> <span class="token keyword">struct</span> <span class="token class-name">seq_and</span><span class="token operator">:</span> <span class="token base-clause">std<span class="token double-colon punctuation">::</span><span class="token class-name">true_type</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">bool</span> B1<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Bs<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">seq_or</span><span class="token operator">&lt;</span>B1<span class="token punctuation">,</span>Bs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token operator">:</span> 
  conditional_t<span class="token operator">&lt;</span>B1<span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>true_type<span class="token punctuation">,</span>seq_or<span class="token operator">&lt;</span>Bs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">bool</span> B1<span class="token punctuation">,</span> <span class="token keyword">bool</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Bs<span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">seq_and</span><span class="token operator">&lt;</span>B1<span class="token punctuation">,</span>Bs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token operator">:</span>
  conditional_t<span class="token operator">&lt;</span>B1<span class="token punctuation">,</span>seq_and<span class="token operator">&lt;</span>Bs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>std<span class="token double-colon punctuation">::</span>false_type<span class="token operator">&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  

</code></pre></div><p>Then the implementation is quite straight-forward:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Bs<span class="token operator">&gt;</span>
<span class="token keyword">using</span> enable_if_any <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>enable_if<span class="token operator">&lt;</span>seq_or<span class="token operator">&lt;</span>Bs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token operator">&gt;</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Bs<span class="token operator">&gt;</span>
<span class="token keyword">using</span> enable_if_all <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>enable_if<span class="token operator">&lt;</span>seq_and<span class="token operator">&lt;</span>Bs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token operator">&gt;</span><span class="token punctuation">;</span>

</code></pre></div><p>Eventually some helpers:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Bs<span class="token operator">&gt;</span>
<span class="token keyword">using</span> enable_if_any_t <span class="token operator">=</span> <span class="token keyword">typename</span> <span class="token class-name">enable_if_any</span><span class="token operator">&lt;</span>Bs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Bs<span class="token operator">&gt;</span>
<span class="token keyword">using</span> enable_if_all_t <span class="token operator">=</span> <span class="token keyword">typename</span> <span class="token class-name">enable_if_all</span><span class="token operator">&lt;</span>Bs<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token punctuation">;</span>

</code></pre></div><p><strong>Usage</strong></p> <p>The usage is also straight-forward:</p> <div class="language- extra-class"><pre class="language-text"><code>
   /// SFINAE constraints on all of the parameters in Args.
    template&lt;typename ...Args,
             enable_if_all_t&lt;custom_conditions_v&lt;Args&gt;...&gt;* = nullptr&gt;
    void func(Args &amp;&amp;...args) { //... };

    /// SFINAE constraints on any of the parameters in Args.
    template&lt;typename ...Args,
             enable_if_any_t&lt;custom_conditions_v&lt;Args&gt;...&gt;* = nullptr&gt;
    void func(Args &amp;&amp;...args) { //... };

</code></pre></div></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/devtut/generate/edit/master/docs/cpp/sfinae-substitution-failure-is-not-an-error.md" target="_blank" rel="noopener noreferrer">Edit this page on GitHub</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/cpp/decltype.html" class="prev">
        decltype
      </a></span> <span class="next"><a href="/cpp/undefined-behavior.html">
        Undefined Behavior
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.1779e102.js" defer></script><script src="/assets/js/3.2cfa8016.js" defer></script><script src="/assets/js/709.8e0ff1ba.js" defer></script>
  </body>
</html>
