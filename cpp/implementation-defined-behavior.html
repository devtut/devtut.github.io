<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C++ | Implementation-defined behavior</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="description" content="Size of integral types, Char might be unsigned or signed, Number of bits in a byte, Numeric value of a pointer, Ranges of numeric types, Value representation of floating point types, Overflow when converting from integer to signed integer, Underlying type (and hence size) of an enum">
    <meta property="og:site_name" content="DevTut">
    <meta property="og:title" content="C++ | Implementation-defined behavior">
    <meta property="og:description" content="Size of integral types, Char might be unsigned or signed, Number of bits in a byte, Numeric value of a pointer, Ranges of numeric types, Value representation of floating point types, Overflow when converting from integer to signed integer, Underlying type (and hence size) of an enum">
    <meta property="og:type" content="article">
    <meta property="og:url" content="/cpp/implementation-defined-behavior.html">
    <meta property="og:image" content="/logo.png">
    <meta name="twitter:title" content="C++ | Implementation-defined behavior">
    <meta name="twitter:description" content="Size of integral types, Char might be unsigned or signed, Number of bits in a byte, Numeric value of a pointer, Ranges of numeric types, Value representation of floating point types, Overflow when converting from integer to signed integer, Underlying type (and hence size) of an enum">
    <meta name="twitter:url" content="/cpp/implementation-defined-behavior.html">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="/logo.png">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/mstile-150x150.png">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="google-site-verification" content="76_rKXgwMVIjd-axJC_1zPV9OS4mEjvtgjYOWVkAdnQ">
    
    <link rel="preload" href="/assets/css/0.styles.60619e34.css" as="style"><link rel="preload" href="/assets/js/app.1779e102.js" as="script"><link rel="preload" href="/assets/js/3.2cfa8016.js" as="script"><link rel="preload" href="/assets/js/662.44d95c63.js" as="script">
    <link rel="stylesheet" href="/assets/css/0.styles.60619e34.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">DevTut</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"> <a href="https://github.com/devtut/generate" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>C++</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/cpp/" aria-current="page" class="sidebar-link">Disclaimer</a></li><li><a href="/cpp/getting-started-with-cpp.html" class="sidebar-link">Getting started with C++</a></li><li><a href="/cpp/literals.html" class="sidebar-link">Literals</a></li><li><a href="/cpp/operator-precedence.html" class="sidebar-link">operator precedence</a></li><li><a href="/cpp/floating-point-arithmetic.html" class="sidebar-link">Floating Point Arithmetic</a></li><li><a href="/cpp/bit-operators.html" class="sidebar-link">Bit Operators</a></li><li><a href="/cpp/bit-manipulation.html" class="sidebar-link">Bit Manipulation</a></li><li><a href="/cpp/bit-fields.html" class="sidebar-link">Bit fields</a></li><li><a href="/cpp/arrays.html" class="sidebar-link">Arrays</a></li><li><a href="/cpp/iterators.html" class="sidebar-link">Iterators</a></li><li><a href="/cpp/basic-input-output-in-c.html" class="sidebar-link">Basic input/output in c++</a></li><li><a href="/cpp/loops.html" class="sidebar-link">Loops</a></li><li><a href="/cpp/file-i-o.html" class="sidebar-link">File I/O</a></li><li><a href="/cpp/cpp-streams.html" class="sidebar-link">C++ Streams</a></li><li><a href="/cpp/stream-manipulators.html" class="sidebar-link">Stream manipulators</a></li><li><a href="/cpp/flow-control.html" class="sidebar-link">Flow Control</a></li><li><a href="/cpp/metaprogramming.html" class="sidebar-link">Metaprogramming</a></li><li><a href="/cpp/const-keyword.html" class="sidebar-link">const keyword</a></li><li><a href="/cpp/mutable-keyword.html" class="sidebar-link">mutable keyword</a></li><li><a href="/cpp/friend-keyword.html" class="sidebar-link">Friend keyword</a></li><li><a href="/cpp/type-keywords.html" class="sidebar-link">Type Keywords</a></li><li><a href="/cpp/basic-type-keywords.html" class="sidebar-link">Basic Type Keywords</a></li><li><a href="/cpp/variable-declaration-keywords.html" class="sidebar-link">Variable Declaration Keywords</a></li><li><a href="/cpp/keywords.html" class="sidebar-link">Keywords</a></li><li><a href="/cpp/returning-several-values-from-a-function.html" class="sidebar-link">Returning several values from a function</a></li><li><a href="/cpp/polymorphism.html" class="sidebar-link">Polymorphism</a></li><li><a href="/cpp/references.html" class="sidebar-link">References</a></li><li><a href="/cpp/value-and-reference-semantics.html" class="sidebar-link">Value and Reference Semantics</a></li><li><a href="/cpp/c-function-call-by-value-vs-call-by-reference.html" class="sidebar-link">C++ function &quot;call by value&quot; vs. &quot;call by reference&quot;</a></li><li><a href="/cpp/copying-vs-assignment.html" class="sidebar-link">Copying vs Assignment</a></li><li><a href="/cpp/pointers.html" class="sidebar-link">Pointers</a></li><li><a href="/cpp/pointers-to-members.html" class="sidebar-link">Pointers to members</a></li><li><a href="/cpp/the-this-pointer.html" class="sidebar-link">The This Pointer</a></li><li><a href="/cpp/smart-pointers.html" class="sidebar-link">Smart Pointers</a></li><li><a href="/cpp/classes-structures.html" class="sidebar-link">Classes/Structures</a></li><li><a href="/cpp/function-overloading.html" class="sidebar-link">Function Overloading</a></li><li><a href="/cpp/operator-overloading.html" class="sidebar-link">Operator Overloading</a></li><li><a href="/cpp/function-template-overloading.html" class="sidebar-link">Function Template Overloading</a></li><li><a href="/cpp/virtual-member-functions.html" class="sidebar-link">Virtual Member Functions</a></li><li><a href="/cpp/inline-functions.html" class="sidebar-link">Inline functions</a></li><li><a href="/cpp/special-member-functions.html" class="sidebar-link">Special Member Functions</a></li><li><a href="/cpp/non-static-member-functions.html" class="sidebar-link">Non-Static Member Functions</a></li><li><a href="/cpp/constant-class-member-functions.html" class="sidebar-link">Constant class member functions</a></li><li><a href="/cpp/c-containers.html" class="sidebar-link">C++ Containers</a></li><li><a href="/cpp/namespaces.html" class="sidebar-link">Namespaces</a></li><li><a href="/cpp/header-files.html" class="sidebar-link">Header Files</a></li><li><a href="/cpp/using-declaration.html" class="sidebar-link">Using declaration</a></li><li><a href="/cpp/std-string.html" class="sidebar-link">std::string</a></li><li><a href="/cpp/std-array.html" class="sidebar-link">std::array</a></li><li><a href="/cpp/std-vector.html" class="sidebar-link">std::vector</a></li><li><a href="/cpp/std-map.html" class="sidebar-link">std::map</a></li><li><a href="/cpp/std-optional.html" class="sidebar-link">std::optional</a></li><li><a href="/cpp/std-function-to-wrap-any-element-that-is-callable.html" class="sidebar-link">std::function: To wrap any element that is callable</a></li><li><a href="/cpp/std-forward-list.html" class="sidebar-link">std::forward_list</a></li><li><a href="/cpp/std-pair.html" class="sidebar-link">std::pair</a></li><li><a href="/cpp/std-atomics.html" class="sidebar-link">std::atomics</a></li><li><a href="/cpp/std-variant.html" class="sidebar-link">std::variant</a></li><li><a href="/cpp/std-iomanip.html" class="sidebar-link">std::iomanip</a></li><li><a href="/cpp/std-any.html" class="sidebar-link">std::any</a></li><li><a href="/cpp/std-set-and-std-multiset.html" class="sidebar-link">std::set and std::multiset</a></li><li><a href="/cpp/std-integer-sequence.html" class="sidebar-link">std::integer_sequence</a></li><li><a href="/cpp/using-std-unordered-map.html" class="sidebar-link">Using std::unordered_map</a></li><li><a href="/cpp/standard-library-algorithms.html" class="sidebar-link">Standard Library Algorithms</a></li><li><a href="/cpp/the-iso-c-standard.html" class="sidebar-link">The ISO C++ Standard</a></li><li><a href="/cpp/inline-variables.html" class="sidebar-link">Inline variables</a></li><li><a href="/cpp/random-number-generation.html" class="sidebar-link">Random number generation</a></li><li><a href="/cpp/date-and-time-using-chrono-header.html" class="sidebar-link">Date and time using  header</a></li><li><a href="/cpp/sorting.html" class="sidebar-link">Sorting</a></li><li><a href="/cpp/enumeration.html" class="sidebar-link">Enumeration</a></li><li><a href="/cpp/iteration.html" class="sidebar-link">Iteration</a></li><li><a href="/cpp/regular-expressions.html" class="sidebar-link">Regular expressions</a></li><li><a href="/cpp/implementation-defined-behavior.html" aria-current="page" class="active sidebar-link">Implementation-defined behavior</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cpp/implementation-defined-behavior.html#size-of-integral-types" class="sidebar-link">Size of integral types</a></li><li class="sidebar-sub-header"><a href="/cpp/implementation-defined-behavior.html#char-might-be-unsigned-or-signed" class="sidebar-link">Char might be unsigned or signed</a></li><li class="sidebar-sub-header"><a href="/cpp/implementation-defined-behavior.html#number-of-bits-in-a-byte" class="sidebar-link">Number of bits in a byte</a></li><li class="sidebar-sub-header"><a href="/cpp/implementation-defined-behavior.html#numeric-value-of-a-pointer" class="sidebar-link">Numeric value of a pointer</a></li><li class="sidebar-sub-header"><a href="/cpp/implementation-defined-behavior.html#ranges-of-numeric-types" class="sidebar-link">Ranges of numeric types</a></li><li class="sidebar-sub-header"><a href="/cpp/implementation-defined-behavior.html#value-representation-of-floating-point-types" class="sidebar-link">Value representation of floating point types</a></li><li class="sidebar-sub-header"><a href="/cpp/implementation-defined-behavior.html#overflow-when-converting-from-integer-to-signed-integer" class="sidebar-link">Overflow when converting from integer to signed integer</a></li><li class="sidebar-sub-header"><a href="/cpp/implementation-defined-behavior.html#underlying-type-and-hence-size-of-an-enum" class="sidebar-link">Underlying type (and hence size) of an enum</a></li></ul></li><li><a href="/cpp/exceptions.html" class="sidebar-link">Exceptions</a></li><li><a href="/cpp/lambdas.html" class="sidebar-link">Lambdas</a></li><li><a href="/cpp/value-categories.html" class="sidebar-link">Value Categories</a></li><li><a href="/cpp/preprocessor.html" class="sidebar-link">Preprocessor</a></li><li><a href="/cpp/data-structures-in-c.html" class="sidebar-link">Data Structures in C++</a></li><li><a href="/cpp/templates.html" class="sidebar-link">Templates</a></li><li><a href="/cpp/expression-templates.html" class="sidebar-link">Expression templates</a></li><li><a href="/cpp/curiously-recurring-template-pattern-crtp.html" class="sidebar-link">Curiously Recurring Template Pattern (CRTP)</a></li><li><a href="/cpp/threading.html" class="sidebar-link">Threading</a></li><li><a href="/cpp/thread-synchronization-structures.html" class="sidebar-link">Thread synchronization structures</a></li><li><a href="/cpp/the-rule-of-three-five-and-zero.html" class="sidebar-link">The Rule of Three, Five, And Zero</a></li><li><a href="/cpp/raii-resource-acquisition-is-initialization.html" class="sidebar-link">RAII: Resource Acquisition Is Initialization</a></li><li><a href="/cpp/rtti-run-time-type-information.html" class="sidebar-link">RTTI: Run-Time Type Information</a></li><li><a href="/cpp/mutexes.html" class="sidebar-link">Mutexes</a></li><li><a href="/cpp/recursive-mutex.html" class="sidebar-link">Recursive Mutex</a></li><li><a href="/cpp/semaphore.html" class="sidebar-link">Semaphore</a></li><li><a href="/cpp/futures-and-promises.html" class="sidebar-link">Futures and Promises</a></li><li><a href="/cpp/atomic-types.html" class="sidebar-link">Atomic Types</a></li><li><a href="/cpp/type-erasure.html" class="sidebar-link">Type Erasure</a></li><li><a href="/cpp/explicit-type-conversions.html" class="sidebar-link">Explicit type conversions</a></li><li><a href="/cpp/unnamed-types.html" class="sidebar-link">Unnamed types</a></li><li><a href="/cpp/type-traits.html" class="sidebar-link">Type Traits</a></li><li><a href="/cpp/return-type-covariance.html" class="sidebar-link">Return Type Covariance</a></li><li><a href="/cpp/layout-of-object-types.html" class="sidebar-link">Layout of object types</a></li><li><a href="/cpp/type-inference.html" class="sidebar-link">Type Inference</a></li><li><a href="/cpp/typedef-and-type-aliases.html" class="sidebar-link">Typedef and type aliases</a></li><li><a href="/cpp/type-deduction.html" class="sidebar-link">type deduction</a></li><li><a href="/cpp/trailing-return-type.html" class="sidebar-link">Trailing return type</a></li><li><a href="/cpp/alignment.html" class="sidebar-link">Alignment</a></li><li><a href="/cpp/perfect-forwarding.html" class="sidebar-link">Perfect Forwarding</a></li><li><a href="/cpp/decltype.html" class="sidebar-link">decltype</a></li><li><a href="/cpp/sfinae-substitution-failure-is-not-an-error.html" class="sidebar-link">SFINAE (Substitution Failure Is Not An Error)</a></li><li><a href="/cpp/undefined-behavior.html" class="sidebar-link">Undefined Behavior</a></li><li><a href="/cpp/overload-resolution.html" class="sidebar-link">Overload resolution</a></li><li><a href="/cpp/move-semantics.html" class="sidebar-link">Move Semantics</a></li><li><a href="/cpp/pimpl-idiom.html" class="sidebar-link">Pimpl Idiom</a></li><li><a href="/cpp/auto.html" class="sidebar-link">auto</a></li><li><a href="/cpp/copy-elision.html" class="sidebar-link">Copy Elision</a></li><li><a href="/cpp/fold-expressions.html" class="sidebar-link">Fold Expressions</a></li><li><a href="/cpp/unions.html" class="sidebar-link">Unions</a></li><li><a href="/cpp/design-pattern-implementation-in-c.html" class="sidebar-link">Design pattern implementation in C++</a></li><li><a href="/cpp/singleton-design-pattern.html" class="sidebar-link">Singleton Design Pattern</a></li><li><a href="/cpp/user-defined-literals.html" class="sidebar-link">User-Defined Literals</a></li><li><a href="/cpp/memory-management.html" class="sidebar-link">Memory management</a></li><li><a href="/cpp/c-11-memory-model.html" class="sidebar-link">C++11 Memory Model</a></li><li><a href="/cpp/scopes.html" class="sidebar-link">Scopes</a></li><li><a href="/cpp/static-assert.html" class="sidebar-link">static_assert</a></li><li><a href="/cpp/constexpr.html" class="sidebar-link">constexpr</a></li><li><a href="/cpp/one-definition-rule-odr.html" class="sidebar-link">One Definition Rule (ODR)</a></li><li><a href="/cpp/unspecified-behavior.html" class="sidebar-link">Unspecified behavior</a></li><li><a href="/cpp/argument-dependent-name-lookup.html" class="sidebar-link">Argument Dependent Name Lookup</a></li><li><a href="/cpp/attributes.html" class="sidebar-link">Attributes</a></li><li><a href="/cpp/recursion-in-c.html" class="sidebar-link">Recursion in C++</a></li><li><a href="/cpp/arithmitic-metaprogramming.html" class="sidebar-link">Arithmitic Metaprogramming</a></li><li><a href="/cpp/callable-objects.html" class="sidebar-link">Callable Objects</a></li><li><a href="/cpp/client-server-examples.html" class="sidebar-link">Client server examples</a></li><li><a href="/cpp/const-correctness.html" class="sidebar-link">Const Correctness</a></li><li><a href="/cpp/parameter-packs.html" class="sidebar-link">Parameter packs</a></li><li><a href="/cpp/build-systems.html" class="sidebar-link">Build Systems</a></li><li><a href="/cpp/concurrency-with-openmp.html" class="sidebar-link">Concurrency With OpenMP</a></li><li><a href="/cpp/resource-management.html" class="sidebar-link">Resource Management</a></li><li><a href="/cpp/storage-class-specifiers.html" class="sidebar-link">Storage class specifiers</a></li><li><a href="/cpp/linkage-specifications.html" class="sidebar-link">Linkage specifications</a></li><li><a href="/cpp/digit-separators.html" class="sidebar-link">Digit separators</a></li><li><a href="/cpp/c-incompatibilities.html" class="sidebar-link">C incompatibilities</a></li><li><a href="/cpp/side-by-side-comparisons-of-classic-c-examples-solved-via-c-vs-c-11-vs-c-14-vs-c-17.html" class="sidebar-link">Side by Side Comparisons of classic C++ examples solved via C++ vs C++11 vs C++14 vs C++17</a></li><li><a href="/cpp/compiling-and-building.html" class="sidebar-link">Compiling and Building</a></li><li><a href="/cpp/common-compile-linker-errors-gcc.html" class="sidebar-link">Common compile/linker errors (GCC)</a></li><li><a href="/cpp/more-undefined-behaviors-in-c.html" class="sidebar-link">More undefined behaviors in C++</a></li><li><a href="/cpp/unit-testing-in-c.html" class="sidebar-link">Unit Testing in C++</a></li><li><a href="/cpp/c-debugging-and-debug-prevention-tools-techniques.html" class="sidebar-link">C++ Debugging and Debug-prevention Tools &amp; Techniques</a></li><li><a href="/cpp/optimization-in-c.html" class="sidebar-link">Optimization in C++</a></li><li><a href="/cpp/optimization.html" class="sidebar-link">Optimization</a></li><li><a href="/cpp/profiling.html" class="sidebar-link">Profiling</a></li><li><a href="/cpp/refactoring-techniques.html" class="sidebar-link">Refactoring Techniques</a></li><li><a href="/cpp/internationalization-in-c.html" class="sidebar-link">Internationalization in C++</a></li><li><a href="/cpp/contributors.html" class="sidebar-link">The Contributors</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="implementation-defined-behavior"><a href="#implementation-defined-behavior" class="header-anchor">#</a> Implementation-defined behavior</h1> <h2 id="size-of-integral-types"><a href="#size-of-integral-types" class="header-anchor">#</a> Size of integral types</h2> <p>The following types are defined as <strong>integral types</strong>:</p> <ul><li><code>char</code></li> <li>Signed integer types</li> <li>Unsigned integer types</li> <li><code>char16_t</code> and <code>char32_t</code></li> <li><code>bool</code></li> <li><code>wchar_t</code></li></ul> <p>With the exception of <code>sizeof(char)</code> / <code>sizeof(signed char)</code> / <code>sizeof(unsigned char)</code>, which is split between § 3.9.1.1 [basic.fundamental/1] and § 5.3.3.1 [expr.sizeof], and <code>sizeof(bool)</code>, which is entirely implementation-defined and has no minimum size, the minimum size requirements of these types are given in section § 3.9.1 [basic.fundamental] of the standard, and shall be detailed below.</p> <h3 id="size-of-char"><a href="#size-of-char" class="header-anchor">#</a> Size of <code>char</code></h3> <p>All versions of the C++ standard specify, in § 5.3.3.1, that <code>sizeof</code> yields <code>1</code> for <code>unsigned char</code>, <code>signed char</code>, and <code>char</code> (it is implementation defined whether the <code>char</code> type is <code>signed</code> or <code>unsigned</code>).</p> <p><code>char</code> is large enough to represent 256 different values, to be suitable for storing UTF-8 code units.</p> <h3 id="size-of-signed-and-unsigned-integer-types"><a href="#size-of-signed-and-unsigned-integer-types" class="header-anchor">#</a> Size of signed and unsigned integer types</h3> <p>The standard specifies, in § 3.9.1.2, that in the list of <strong>standard signed integer types</strong>, consisting of <code>signed char</code>, <code>short int</code>, <code>int</code>, <code>long int</code>, and <code>long long int</code>, each type will provide at least as much storage as those preceding it in the list.  Furthermore, as specified in § 3.9.1.3, each of these types has a corresponding <strong>standard unsigned integer type</strong>, <code>unsigned char</code>, <code>unsigned short int</code>, <code>unsigned int</code>, <code>unsigned long int</code>, and <code>unsigned long long int</code>, which has the same size and alignment as its corresponding signed type.  Additionally, as specified in § 3.9.1.1, <code>char</code> has the same size and alignment requirements as both <code>signed char</code> and <code>unsigned char</code>.</p> <p>Prior to C++11, <code>long long</code> and <code>unsigned long long</code> were not officially part of the C++ standard.  However, after their introduction to C, in C99, many compilers supported <code>long long</code> as an <strong>extended signed integer type</strong>, and <code>unsigned long long</code> as an <strong>extended unsigned integer type</strong>, with the same rules as the C types.</p> <p>The standard thus guarantees that:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token number">1</span> <span class="token operator">==</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span>  <span class="token operator">==</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">signed</span> <span class="token keyword">char</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token punctuation">)</span>
  <span class="token operator">&lt;=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">short</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token punctuation">)</span>
  <span class="token operator">&lt;=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>   <span class="token operator">==</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span>
  <span class="token operator">&lt;=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>  <span class="token operator">==</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span>

</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code> <span class="token operator">&lt;=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span>

</code></pre></div><p>Specific minimum sizes for each type are not given by the standard.  Instead, each type has a minimum range of values it can support, which is, as specified in § 3.9.1.3, inherited from the C standard, in §5.2.4.2.1.  The minimum size of each type can be roughly inferred from this range, by determining the minimum number of bits required; note that for any given platform, any type's actual supported range may be larger than the minimum.  Note that for signed types, ranges correspond to one's complement, not the more commonly used two's complement; this is to allow a wider range of platforms to comply with the standard.</p> <table><thead><tr><th></th><th align="left">Type</th> <th>Minimum range</th><th align="right">Minimum bits required</th></tr></thead> <tbody><tr><td></td><td align="left"><code>signed char</code></td> <td>-127 to 127 (-(2<sup>7</sup> - 1) to (2<sup>7</sup> - 1))</td><td align="right">8</td></tr> <tr><td></td><td align="left"><code>unsigned char</code></td> <td>0 to 255 (0 to 2<sup>8</sup> - 1)</td><td align="right">8</td></tr> <tr><td></td><td align="left"><code>signed short</code></td> <td>-32,767 to 32,767 (-(2<sup>15</sup> - 1) to (2<sup>15</sup> - 1))</td><td align="right">16</td></tr> <tr><td></td><td align="left"><code>unsigned short</code></td> <td>0 to 65,535 (0 to 2<sup>16</sup> - 1)</td><td align="right">16</td></tr> <tr><td></td><td align="left"><code>signed int</code></td> <td>-32,767 to 32,767 (-(2<sup>15</sup> - 1) to (2<sup>15</sup> - 1))</td><td align="right">16</td></tr> <tr><td></td><td align="left"><code>unsigned int</code></td> <td>0 to 65,535 (0 to 2<sup>16</sup> - 1)</td><td align="right">16</td></tr> <tr><td></td><td align="left"><code>signed long</code></td> <td>-2,147,483,647 to 2,147,483,647 (-(2<sup>31</sup> - 1) to (2<sup>31</sup> - 1))</td><td align="right">32</td></tr> <tr><td></td><td align="left"><code>unsigned long</code></td> <td>0 to 4,294,967,295 (0 to 2<sup>32</sup> - 1)</td><td align="right">32</td></tr></tbody></table> <table><thead><tr><th></th><th align="left">Type</th> <th>Minimum range</th><th align="right">Minimum bits required</th></tr></thead> <tbody><tr><td></td><td align="left"><code>signed long long</code></td> <td>-9,223,372,036,854,775,807 to 9,223,372,036,854,775,807 (-(2<sup>63</sup> - 1) to (2<sup>63</sup> - 1))</td><td align="right">64</td></tr> <tr><td></td><td align="left"><code>unsigned long long</code></td> <td>0 to 18,446,744,073,709,551,615 (0 to 2<sup>64</sup> - 1)</td><td align="right">64</td></tr></tbody></table> <p>As each type is allowed to be greater than its minimum size requirement, types may differ in size between implementations.  The most notable example of this is with the 64-bit data models LP64 and LLP64, where LLP64 systems (such as 64-bit Windows) have 32-bit <code>ints</code> and <code>long</code>s, and LP64 systems (such as 64-bit Linux) have 32-bit <code>int</code>s and 64-bit <code>long</code>s.  Due to this, integer types cannot be assumed to have a fixed width across all platforms.</p> <p>If integer types with fixed width are required, use types from the <a href="http://en.cppreference.com/w/cpp/header/cstdint" target="_blank" rel="noopener noreferrer"><code>&lt;cstdint&gt;</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> header, but note that the standard makes it optional for implementations to support the exact-width types <code>int8_t</code>, <code>int16_t</code>, <code>int32_t</code>, <code>int64_t</code>, <code>intptr_t</code>, <code>uint8_t</code>, <code>uint16_t</code>, <code>uint32_t</code>, <code>uint64_t</code> and <code>uintptr_t</code>.</p> <h3 id="size-of-char16-t-and-char32-t"><a href="#size-of-char16-t-and-char32-t" class="header-anchor">#</a> Size of <code>char16_t</code> and <code>char32_t</code></h3> <p>The sizes of <code>char16_t</code> and <code>char32_t</code> are implementation-defined, as specified in § 5.3.3.1, with the stipulations given in § 3.9.1.5:</p> <li>
`char16_t` is large enough to represent any UTF-16 code unit, and has the same size, signedness, and alignment as [`uint_least16_t`](http://en.cppreference.com/w/cpp/header/cstdint); it is thus required to be at least 16 bits in size.
</li> <li>
`char32_t` is large enough to represent any UTF-32 code unit, and has the same size, signedness, and alignment as [`uint_least32_t`](http://en.cppreference.com/w/cpp/header/cstdint); it is thus required to be at least 32 bits in size.
</li> <h3 id="size-of-bool"><a href="#size-of-bool" class="header-anchor">#</a> Size of <code>bool</code></h3> <p>The size of <code>bool</code> is implementation defined, and may or may not be <code>1</code>.</p> <h3 id="size-of-wchar-t"><a href="#size-of-wchar-t" class="header-anchor">#</a> Size of wchar_t</h3> <p><code>wchar_t</code>, as specified in § 3.9.1.5, is a distinct type, whose range of values can represent every distinct code unit of the largest extended character set among the supported locales.  It has the same size, signedness, and alignment as one of the other integral types, which is known as its <strong>underlying type</strong>.  This type's size is implementation-defined, as specified in § 5.3.3.1, and may be, for example, at least 8, 16, or 32 bits; if a system supports Unicode, for example, <code>wchar_t</code> is required to be at least 32 bits (an exception to this rule is Windows, where <code>wchar_t</code> is 16 bits for compatibility purposes).  It is inherited from the C90 standard, ISO 9899:1990 § 4.1.5, with only minor rewording.</p> <p>Depending on the implementation, the size of <code>wchar_t</code> is often, but not always, 8, 16, or 32 bits.  The most common examples of these are:</p> <ul><li>In Unix and Unix-like systems, <code>wchar_t</code> is 32-bit, and is usually used for UTF-32.</li> <li>In Windows, <code>wchar_t</code> is 16-bit, and is used for UTF-16.</li> <li>On a system which only has 8-bit support, <code>wchar_t</code> is 8 bit.</li></ul> <p>If Unicode support is desired, it is recommended to use <code>char</code> for UTF-8, <code>char16_t</code> for UTF-16, or <code>char32_t</code> for UTF-32, instead of using <code>wchar_t</code>.</p> <h3 id="data-models"><a href="#data-models" class="header-anchor">#</a> Data Models</h3> <p>As mentioned above, the widths of integer types can differ between platforms.  The most common models are as follows, with sizes specified in bits:</p> <table><thead><tr><th>Model</th> <th><code>int</code></th> <th><code>long</code></th> <th>pointer</th></tr></thead> <tbody><tr><td>LP32 (2/4/4)</td> <td>16</td> <td>32</td> <td>32</td></tr> <tr><td>ILP32 (4/4/4)</td> <td>32</td> <td>32</td> <td>32</td></tr> <tr><td>LLP64 (4/4/8)</td> <td>32</td> <td>32</td> <td>64</td></tr> <tr><td>LP64 (4/8/8)</td> <td>32</td> <td>64</td> <td>64</td></tr></tbody></table> <p>Out of these models:</p> <ul><li>16-bit Windows used LP32.</li> <li>32-bit *nix systems (Unix, Linux, Mac OSX, and other Unix-like OSes) and Windows use ILP32.</li> <li>64-bit Windows uses LLP64.</li> <li>64-bit *nix systems use LP64.</li></ul> <p>Note, however, that these models aren't specifically mentioned in the standard itself.</p> <h2 id="char-might-be-unsigned-or-signed"><a href="#char-might-be-unsigned-or-signed" class="header-anchor">#</a> Char might be unsigned or signed</h2> <p>The standard doesn't specify if <code>char</code> should be signed or unsigned. Different compilers implement it differently, or might allow to change it using a command line switch.</p> <h2 id="number-of-bits-in-a-byte"><a href="#number-of-bits-in-a-byte" class="header-anchor">#</a> Number of bits in a byte</h2> <p>In C++, a <strong>byte</strong> is the space occupied by a <code>char</code> object. The number of bits in a byte is given by <code>CHAR_BIT</code>, which is defined in <code>climits</code> and required to be at least 8. While most modern systems have 8-bit bytes, and POSIX requires <code>CHAR_BIT</code> to be exactly 8, there are some systems where <code>CHAR_BIT</code> is greater than 8 i.e a single byte may be comprised of 8, 16, 32 or 64 bits.</p> <h2 id="numeric-value-of-a-pointer"><a href="#numeric-value-of-a-pointer" class="header-anchor">#</a> Numeric value of a pointer</h2> <p>The result of casting a pointer to an integer using <code>reinterpret_cast</code> is implementation-defined, but &quot;... is intended to be unsurprising to those who know the addressing structure of the underlying machine.&quot;</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token operator">&amp;</span>x<span class="token punctuation">;</span>
<span class="token keyword">long</span> addr <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">long</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> addr <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;\n&quot;</span><span class="token punctuation">;</span> <span class="token comment">// prints some numeric address,</span>
                           <span class="token comment">// probably in the architecture's native address format</span>

</code></pre></div><p>Likewise, the pointer obtained by conversion from an integer is also implementation-defined.</p> <p>The right way to store a pointer as an integer is using the <code>uintptr_t</code> or <code>intptr_t</code> types:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// `uintptr_t` was not in C++03. It's in C99, in &lt;stdint.h&gt;, as an optional type</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdint.h&gt;</span></span>

uintptr_t uip<span class="token punctuation">;</span>

</code></pre></div><div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// There is an optional `std::uintptr_t` in C++11</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstdint&gt;</span></span>

std<span class="token double-colon punctuation">::</span>uintptr_t uip<span class="token punctuation">;</span>

</code></pre></div><p>C++11 refers to C99 for the definition <code>uintptr_t</code> (C99 standard, 6.3.2.3):</p> <blockquote></blockquote> <p>an unsigned integer type with the property that any valid pointer to <code>void</code> can be converted to this type, then converted back to pointer to <code>void</code>, and the result will compare equal to the original pointer.</p> <p>While, for the majority of modern platforms, you can assume a flat address space and that arithmetic on <code>uintptr_t</code> is equivalent to arithmetic on <code>char *</code>, it's entirely possible for an implementation to perform any transformation when casting <code>void *</code> to <code>uintptr_t</code> as long the transformation can be reversed when casting back from <code>uintptr_t</code> to <code>void *</code>.</p> <p><strong>Technicalities</strong></p> <li>
On XSI-conformant (X/Open System Interfaces) systems, `intptr_t` and `uintptr_t` types are required, otherwise they are **optional**.
</li> <li>
Within the meaning of the C standard, functions aren't objects; it isn't guaranteed by the C standard that `uintptr_t` can hold a function pointer. Anyway POSIX (2.12.3) conformance requires that:
<blockquote>
All function pointer types shall have the same representation as the type pointer to void. Conversion of a function pointer to void * shall not alter the representation. A void * value resulting from such a conversion can be converted back to the original function pointer type, using an explicit cast, without loss of information.
</blockquote></li> <li>
C99 §7.18.1:
<blockquote>
When typedef names differing only in the absence or presence of the initial u are defined, they shall denote corresponding signed and unsigned types as described in 6.2.5; an implementation providing one of these corresponding types shall also provide the other.
</blockquote>
`uintptr_t` might make sense if you want to do things to the bits of the pointer that you can't do as sensibly with a signed integer.
</li> <blockquote></blockquote> <p>When typedef names differing only in the absence or presence of the initial u are defined, they shall denote corresponding signed and unsigned types as described in 6.2.5; an implementation providing one of these corresponding types shall also provide the other.</p> <h2 id="ranges-of-numeric-types"><a href="#ranges-of-numeric-types" class="header-anchor">#</a> Ranges of numeric types</h2> <p>The ranges of the integer types are implementation-defined. The header <code>&lt;limits&gt;</code> provides the <code>std::numeric_limits&lt;T&gt;</code> template which provides the minimum and maximum values of all fundamental types. The values satisfy guarantees provided by the C standard through the <code>&lt;climits&gt;</code> and (&gt;= C++11) <code>&lt;cinttypes&gt;</code> headers.</p> <ul><li><p><code>std::numeric_limits&lt;signed char&gt;::min()</code> equals <code>SCHAR_MIN</code>, which is less than or equal to -127.</p></li> <li><p><code>std::numeric_limits&lt;signed char&gt;::max()</code> equals <code>SCHAR_MAX</code>, which is greater than or equal to 127.</p></li> <li><p><code>std::numeric_limits&lt;unsigned char&gt;::max()</code> equals <code>UCHAR_MAX</code>, which is greater than or equal to 255.</p></li> <li><p><code>std::numeric_limits&lt;short&gt;::min()</code> equals <code>SHRT_MIN</code>, which is less than or equal to -32767.</p></li> <li><p><code>std::numeric_limits&lt;short&gt;::max()</code> equals <code>SHRT_MAX</code>, which is greater than or equal to 32767.</p></li> <li><p><code>std::numeric_limits&lt;unsigned short&gt;::max()</code> equals <code>USHRT_MAX</code>, which is greater than or equal to 65535.</p></li> <li><p><code>std::numeric_limits&lt;int&gt;::min()</code> equals <code>INT_MIN</code>, which is less than or equal to -32767.</p></li> <li><p><code>std::numeric_limits&lt;int&gt;::max()</code> equals <code>INT_MAX</code>, which is greater than or equal to 32767.</p></li> <li><p><code>std::numeric_limits&lt;unsigned int&gt;::max()</code> equals <code>UINT_MAX</code>, which is greater than or equal to 65535.</p></li> <li><p><code>std::numeric_limits&lt;long&gt;::min()</code> equals <code>LONG_MIN</code>, which is less than or equal to -2147483647.</p></li> <li><p><code>std::numeric_limits&lt;long&gt;::max()</code> equals <code>LONG_MAX</code>, which is greater than or equal to 2147483647.</p></li> <li><p><code>std::numeric_limits&lt;unsigned long&gt;::max()</code> equals <code>ULONG_MAX</code>, which is greater than or equal to 4294967295.</p></li> <li><p><code>std::numeric_limits&lt;long long&gt;::min()</code> equals <code>LLONG_MIN</code>, which is less than or equal to -9223372036854775807.</p></li> <li><p><code>std::numeric_limits&lt;long long&gt;::max()</code> equals <code>LLONG_MAX</code>, which is greater than or equal to 9223372036854775807.</p></li> <li><p><code>std::numeric_limits&lt;unsigned long long&gt;::max()</code> equals <code>ULLONG_MAX</code>, which is greater than or equal to 18446744073709551615.</p></li></ul> <p>For floating-point types <code>T</code>, <code>max()</code> is the maximum finite value while <code>min()</code> is the minimum positive normalized value. Additional members are provided for floating-point types, which are also implementation-defined but satisfy certain guarantees provided by the C standard through the <code>&lt;cfloat&gt;</code> header.</p> <li>The member `digits10` gives the number of decimal digits of precision.
<ul>
- `std::numeric_limits<float>::digits10` equals `FLT_DIG`, which is at least 6.
- `std::numeric_limits<double>::digits10` equals `DBL_DIG`, which is at least 10.
- `std::numeric_limits<long double="">::digits10` equals `LDBL_DIG`, which is at least 10.
<ul><li><p><code>std::numeric_limits&lt;float&gt;::min_exponent10</code> equals <code>FLT_MIN_10_EXP</code>, which is at most -37.
</p></li><li><code>std::numeric_limits&lt;double&gt;::min_exponent10</code> equals <code>DBL_MIN_10_EXP</code>, which is at most -37.
<code>std::numeric_limits&lt;long double&gt;::min_exponent10</code> equals <code>LDBL_MIN_10_EXP</code>, which is at most -37.</li><p></p></ul></long></double></float></ul></li> <li><p><code>std::numeric_limits&lt;float&gt;::max_exponent10</code> equals <code>FLT_MIN_10_EXP</code>, which is at least 37.</p></li> <li><p><code>std::numeric_limits&lt;double&gt;::max_exponent10</code> equals <code>DBL_MIN_10_EXP</code>, which is at least 37.</p></li> <li><p><code>std::numeric_limits&lt;long double&gt;::max_exponent10</code> equals <code>LDBL_MIN_10_EXP</code>, which is at least 37.</p></li> <h2 id="value-representation-of-floating-point-types"><a href="#value-representation-of-floating-point-types" class="header-anchor">#</a> Value representation of floating point types</h2> <p>The standard requires that <code>long double</code> provides at least as much precision as <code>double</code>, which provides at least as much precision as <code>float</code>; and that a <code>long double</code> can represent any value that a <code>double</code> can represent, while a <code>double</code> can represent any value that a <code>float</code> can represent. The details of the representation are, however, implementation-defined.</p> <p>For a floating point type <code>T</code>, <code>std::numeric_limits&lt;T&gt;::radix</code> specifies the radix used by the representation of <code>T</code>.</p> <p>If <code>std::numeric_limits&lt;T&gt;::is_iec559</code> is true, then the representation of <code>T</code> matches one of the formats defined by IEC 559 / IEEE 754.</p> <h2 id="overflow-when-converting-from-integer-to-signed-integer"><a href="#overflow-when-converting-from-integer-to-signed-integer" class="header-anchor">#</a> Overflow when converting from integer to signed integer</h2> <p>When either a signed or unsigned integer is converted to a signed integer type, and its value is not representable in the destination type, the value produced is implementation-defined. Example:</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token comment">// Suppose that on this implementation, the range of signed char is -128 to +127 and</span>
<span class="token comment">// the range of unsigned char is 0 to 255</span>
<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">12345</span><span class="token punctuation">;</span>
<span class="token keyword">signed</span> <span class="token keyword">char</span> sc <span class="token operator">=</span> x<span class="token punctuation">;</span>   <span class="token comment">// sc has an implementation-defined value</span>
<span class="token keyword">unsigned</span> <span class="token keyword">char</span> uc <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment">// uc is initialized to 57 (i.e., 12345 modulo 256)</span>

</code></pre></div><h2 id="underlying-type-and-hence-size-of-an-enum"><a href="#underlying-type-and-hence-size-of-an-enum" class="header-anchor">#</a> Underlying type (and hence size) of an enum</h2> <p>If the underlying type is not explicitly specified for an unscoped enumeration type, it is determined in an implementation-defined manner.</p> <div class="language-cpp extra-class"><pre class="language-cpp"><code><span class="token keyword">enum</span> <span class="token class-name">E</span> <span class="token punctuation">{</span>
    RED<span class="token punctuation">,</span>
    GREEN<span class="token punctuation">,</span>
    BLUE<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> T <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>underlying_type<span class="token operator">&lt;</span>E<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token punctuation">;</span> <span class="token comment">// implementation-defined</span>

</code></pre></div><p>However, the standard does require the underlying type of an enumeration to be no larger than <code>int</code> unless both <code>int</code> and <code>unsigned int</code> are unable to represent all the values of the enumeration. Therefore, in the above code, <code>T</code> could be <code>int</code>, <code>unsigned int</code>, or <code>short</code>, but not <code>long long</code>, to give a few examples.</p> <p>Note that an enum has the same size (as returned by <code>sizeof</code>) as its underlying type.</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/devtut/generate/edit/master/docs/cpp/implementation-defined-behavior.md" target="_blank" rel="noopener noreferrer">Edit this page on GitHub</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/cpp/regular-expressions.html" class="prev">
        Regular expressions
      </a></span> <span class="next"><a href="/cpp/exceptions.html">
        Exceptions
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.1779e102.js" defer></script><script src="/assets/js/3.2cfa8016.js" defer></script><script src="/assets/js/662.44d95c63.js" defer></script>
  </body>
</html>
